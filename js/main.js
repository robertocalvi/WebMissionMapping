/**
* File modificato da Roberto
*/
function t(t, e, n, r) {
    Object.defineProperty(t, e, {
        get: n,
        set: r,
        enumerable: !0,
        configurable: !0
    })
}
function e(t) {
    return t && t.__esModule ? t.default : t
}
var n = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof self ? self : "undefined" != typeof window ? window : "undefined" != typeof global ? global : {},
    r = {},
    i = {},
    o = n.parcelRequire1072;
null == o && ((o = function(t) {
    if (t in r)
        return r[t].exports;
    if (t in i) {
        var e = i[t];
        delete i[t];
        var n = {
            id: t,
            exports: {}
        };
        return r[t] = n, e.call(n.exports, n, n.exports), n.exports
    }
    var o = new Error("Cannot find module '" + t + "'");
    throw o.code = "MODULE_NOT_FOUND", o
}).register = function(t, e) {
    i[t] = e
}, n.parcelRequire1072 = o),
o.register("hEixu", (function(t, e) {
    o("hPtJY");
    t.exports,
    function(t) {
        var e = 6371008.8,
            n = {
                centimeters: 637100880,
                centimetres: 637100880,
                degrees: 57.22891354143274,
                feet: 20902260.511392,
                inches: 39.37 * e,
                kilometers: 6371.0088,
                kilometres: 6371.0088,
                meters: e,
                metres: e,
                miles: 3958.761333810546,
                millimeters: 6371008800,
                millimetres: 6371008800,
                nauticalmiles: e / 1852,
                radians: 1,
                yards: 6967335.223679999
            },
            r = {
                centimeters: 100,
                centimetres: 100,
                degrees: 1 / 111325,
                feet: 3.28084,
                inches: 39.37,
                kilometers: .001,
                kilometres: .001,
                meters: 1,
                metres: 1,
                miles: 1 / 1609.344,
                millimeters: 1e3,
                millimetres: 1e3,
                nauticalmiles: 1 / 1852,
                radians: 1 / e,
                yards: 1.0936133
            },
            i = {
                acres: 247105e-9,
                centimeters: 1e4,
                centimetres: 1e4,
                feet: 10.763910417,
                hectares: 1e-4,
                inches: 1550.003100006,
                kilometers: 1e-6,
                kilometres: 1e-6,
                meters: 1,
                metres: 1,
                miles: 386e-9,
                millimeters: 1e6,
                millimetres: 1e6,
                yards: 1.195990046
            };
        function o(t, e, n) {
            void 0 === n && (n = {});
            var r = {
                type: "Feature"
            };
            return (0 === n.id || n.id) && (r.id = n.id), n.bbox && (r.bbox = n.bbox), r.properties = e || {}, r.geometry = t, r
        }
        function s(t, e, n) {
            switch (t) {
            case "Point":
                return a(e).geometry;
            case "LineString":
                return c(e).geometry;
            case "Polygon":
                return l(e).geometry;
            case "MultiPoint":
                return g(e).geometry;
            case "MultiLineString":
                return d(e).geometry;
            case "MultiPolygon":
                return y(e).geometry;
            default:
                throw new Error(t + " is invalid")
            }
        }
        function a(t, e, n) {
            if (void 0 === n && (n = {}), !t)
                throw new Error("coordinates is required");
            if (!Array.isArray(t))
                throw new Error("coordinates must be an Array");
            if (t.length < 2)
                throw new Error("coordinates must be at least 2 numbers long");
            if (!I(t[0]) || !I(t[1]))
                throw new Error("coordinates must contain numbers");
            return o({
                type: "Point",
                coordinates: t
            }, e, n)
        }
        function u(t, e, n) {
            return void 0 === n && (n = {}), f(t.map((function(t) {
                return a(t, e)
            })), n)
        }
        function l(t, e, n) {
            void 0 === n && (n = {});
            for (var r = 0, i = t; r < i.length; r++) {
                var s = i[r];
                if (s.length < 4)
                    throw new Error("Each LinearRing of a Polygon must have 4 or more Positions.");
                for (var a = 0; a < s[s.length - 1].length; a++)
                    if (s[s.length - 1][a] !== s[0][a])
                        throw new Error("First and last Position are not equivalent.")
            }
            return o({
                type: "Polygon",
                coordinates: t
            }, e, n)
        }
        function h(t, e, n) {
            return void 0 === n && (n = {}), f(t.map((function(t) {
                return l(t, e)
            })), n)
        }
        function c(t, e, n) {
            if (void 0 === n && (n = {}), t.length < 2)
                throw new Error("coordinates must be an array of two or more positions");
            return o({
                type: "LineString",
                coordinates: t
            }, e, n)
        }
        function p(t, e, n) {
            return void 0 === n && (n = {}), f(t.map((function(t) {
                return c(t, e)
            })), n)
        }
        function f(t, e) {
            void 0 === e && (e = {});
            var n = {
                type: "FeatureCollection"
            };
            return e.id && (n.id = e.id), e.bbox && (n.bbox = e.bbox), n.features = t, n
        }
        function d(t, e, n) {
            return void 0 === n && (n = {}), o({
                type: "MultiLineString",
                coordinates: t
            }, e, n)
        }
        function g(t, e, n) {
            return void 0 === n && (n = {}), o({
                type: "MultiPoint",
                coordinates: t
            }, e, n)
        }
        function y(t, e, n) {
            return void 0 === n && (n = {}), o({
                type: "MultiPolygon",
                coordinates: t
            }, e, n)
        }
        function v(t, e, n) {
            return void 0 === n && (n = {}), o({
                type: "GeometryCollection",
                geometries: t
            }, e, n)
        }
        function m(t, e) {
            if (void 0 === e && (e = 0), e && !(e >= 0))
                throw new Error("precision must be a positive number");
            var n = Math.pow(10, e || 0);
            return Math.round(t * n) / n
        }
        function _(t, e) {
            void 0 === e && (e = "kilometers");
            var r = n[e];
            if (!r)
                throw new Error(e + " units is invalid");
            return t * r
        }
        function x(t, e) {
            void 0 === e && (e = "kilometers");
            var r = n[e];
            if (!r)
                throw new Error(e + " units is invalid");
            return t / r
        }
        function E(t, e) {
            return b(x(t, e))
        }
        function w(t) {
            var e = t % 360;
            return e < 0 && (e += 360), e
        }
        function b(t) {
            return t % (2 * Math.PI) * 180 / Math.PI
        }
        function C(t) {
            return t % 360 * Math.PI / 180
        }
        function M(t, e, n) {
            if (void 0 === e && (e = "kilometers"), void 0 === n && (n = "kilometers"), !(t >= 0))
                throw new Error("length must be a positive number");
            return _(x(t, e), n)
        }
        function S(t, e, n) {
            if (void 0 === e && (e = "meters"), void 0 === n && (n = "kilometers"), !(t >= 0))
                throw new Error("area must be a positive number");
            var r = i[e];
            if (!r)
                throw new Error("invalid original units");
            var o = i[n];
            if (!o)
                throw new Error("invalid final units");
            return t / r * o
        }
        function I(t) {
            return !isNaN(t) && null !== t && !Array.isArray(t)
        }
        function T(t) {
            return !!t && t.constructor === Object
        }
        function P(t) {
            if (!t)
                throw new Error("bbox is required");
            if (!Array.isArray(t))
                throw new Error("bbox must be an Array");
            if (4 !== t.length && 6 !== t.length)
                throw new Error("bbox must be an Array of 4 or 6 numbers");
            t.forEach((function(t) {
                if (!I(t))
                    throw new Error("bbox must only contain numbers")
            }))
        }
        function L(t) {
            if (!t)
                throw new Error("id is required");
            if (-1 === ["string", "number"].indexOf(typeof t))
                throw new Error("id must be a number or a string")
        }
        var O = Object.freeze({
            __proto__: null,
            earthRadius: e,
            factors: n,
            unitsFactors: r,
            areaFactors: i,
            feature: o,
            geometry: s,
            point: a,
            points: u,
            polygon: l,
            polygons: h,
            lineString: c,
            lineStrings: p,
            featureCollection: f,
            multiLineString: d,
            multiPoint: g,
            multiPolygon: y,
            geometryCollection: v,
            round: m,
            radiansToLength: _,
            lengthToRadians: x,
            lengthToDegrees: E,
            bearingToAzimuth: w,
            radiansToDegrees: b,
            degreesToRadians: C,
            convertLength: M,
            convertArea: S,
            isNumber: I,
            isObject: T,
            validateBBox: P,
            validateId: L
        });
        function N(t, e, n) {
            if (null !== t)
                for (var r, i, o, s, a, u, l, h, c = 0, p = 0, f = t.type, d = "FeatureCollection" === f, g = "Feature" === f, y = d ? t.features.length : 1, v = 0; v < y; v++) {
                    a = (h = !!(l = d ? t.features[v].geometry : g ? t.geometry : t) && "GeometryCollection" === l.type) ? l.geometries.length : 1;
                    for (var m = 0; m < a; m++) {
                        var _ = 0,
                            x = 0;
                        if (null !== (s = h ? l.geometries[m] : l)) {
                            u = s.coordinates;
                            var E = s.type;
                            switch (c = !n || "Polygon" !== E && "MultiPolygon" !== E ? 0 : 1, E) {
                            case null:
                                break;
                            case "Point":
                                if (!1 === e(u, p, v, _, x))
                                    return !1;
                                p++,
                                _++;
                                break;
                            case "LineString":
                            case "MultiPoint":
                                for (r = 0; r < u.length; r++) {
                                    if (!1 === e(u[r], p, v, _, x))
                                        return !1;
                                    p++,
                                    "MultiPoint" === E && _++
                                }
                                "LineString" === E && _++;
                                break;
                            case "Polygon":
                            case "MultiLineString":
                                for (r = 0; r < u.length; r++) {
                                    for (i = 0; i < u[r].length - c; i++) {
                                        if (!1 === e(u[r][i], p, v, _, x))
                                            return !1;
                                        p++
                                    }
                                    "MultiLineString" === E && _++,
                                    "Polygon" === E && x++
                                }
                                "Polygon" === E && _++;
                                break;
                            case "MultiPolygon":
                                for (r = 0; r < u.length; r++) {
                                    for (x = 0, i = 0; i < u[r].length; i++) {
                                        for (o = 0; o < u[r][i].length - c; o++) {
                                            if (!1 === e(u[r][i][o], p, v, _, x))
                                                return !1;
                                            p++
                                        }
                                        x++
                                    }
                                    _++
                                }
                                break;
                            case "GeometryCollection":
                                for (r = 0; r < s.geometries.length; r++)
                                    if (!1 === N(s.geometries[r], e, n))
                                        return !1;
                                break;
                            default:
                                throw new Error("Unknown Geometry Type")
                            }
                        }
                    }
                }
        }
        function R(t, e, n, r) {
            var i = n;
            return N(t, (function(t, r, o, s, a) {
                i = 0 === r && void 0 === n ? t : e(i, t, r, o, s, a)
            }), r), i
        }
        function A(t, e) {
            var n;
            switch (t.type) {
            case "FeatureCollection":
                for (n = 0; n < t.features.length && !1 !== e(t.features[n].properties, n); n++)
                    ;
                break;
            case "Feature":
                e(t.properties, 0)
            }
        }
        function D(t, e, n) {
            var r = n;
            return A(t, (function(t, i) {
                r = 0 === i && void 0 === n ? t : e(r, t, i)
            })), r
        }
        function F(t, e) {
            if ("Feature" === t.type)
                e(t, 0);
            else if ("FeatureCollection" === t.type)
                for (var n = 0; n < t.features.length && !1 !== e(t.features[n], n); n++)
                    ;
        }
        function k(t, e, n) {
            var r = n;
            return F(t, (function(t, i) {
                r = 0 === i && void 0 === n ? t : e(r, t, i)
            })), r
        }
        function j(t) {
            var e = [];
            return N(t, (function(t) {
                e.push(t)
            })), e
        }
        function G(t, e) {
            var n,
                r,
                i,
                o,
                s,
                a,
                u,
                l,
                h,
                c,
                p = 0,
                f = "FeatureCollection" === t.type,
                d = "Feature" === t.type,
                g = f ? t.features.length : 1;
            for (n = 0; n < g; n++) {
                for (a = f ? t.features[n].geometry : d ? t.geometry : t, l = f ? t.features[n].properties : d ? t.properties : {}, h = f ? t.features[n].bbox : d ? t.bbox : void 0, c = f ? t.features[n].id : d ? t.id : void 0, s = (u = !!a && "GeometryCollection" === a.type) ? a.geometries.length : 1, i = 0; i < s; i++)
                    if (null !== (o = u ? a.geometries[i] : a))
                        switch (o.type) {
                        case "Point":
                        case "LineString":
                        case "MultiPoint":
                        case "Polygon":
                        case "MultiLineString":
                        case "MultiPolygon":
                            if (!1 === e(o, p, l, h, c))
                                return !1;
                            break;
                        case "GeometryCollection":
                            for (r = 0; r < o.geometries.length; r++)
                                if (!1 === e(o.geometries[r], p, l, h, c))
                                    return !1;
                            break;
                        default:
                            throw new Error("Unknown Geometry Type")
                        }
                    else if (!1 === e(null, p, l, h, c))
                        return !1;
                p++
            }
        }
        function B(t, e, n) {
            var r = n;
            return G(t, (function(t, i, o, s, a) {
                r = 0 === i && void 0 === n ? t : e(r, t, i, o, s, a)
            })), r
        }
        function q(t, e) {
            G(t, (function(t, n, r, i, s) {
                var a,
                    u = null === t ? null : t.type;
                switch (u) {
                case null:
                case "Point":
                case "LineString":
                case "Polygon":
                    return !1 !== e(o(t, r, {
                            bbox: i,
                            id: s
                        }), n, 0) && void 0
                }
                switch (u) {
                case "MultiPoint":
                    a = "Point";
                    break;
                case "MultiLineString":
                    a = "LineString";
                    break;
                case "MultiPolygon":
                    a = "Polygon"
                }
                for (var l = 0; l < t.coordinates.length; l++) {
                    var h = t.coordinates[l];
                    if (!1 === e(o({
                        type: a,
                        coordinates: h
                    }, r), n, l))
                        return !1
                }
            }))
        }
        function z(t, e, n) {
            var r = n;
            return q(t, (function(t, i, o) {
                r = 0 === i && 0 === o && void 0 === n ? t : e(r, t, i, o)
            })), r
        }
        function U(t, e) {
            q(t, (function(t, n, r) {
                var i = 0;
                if (t.geometry) {
                    var o = t.geometry.type;
                    if ("Point" !== o && "MultiPoint" !== o) {
                        var s,
                            a = 0,
                            u = 0,
                            l = 0;
                        return !1 !== N(t, (function(o, h, p, f, d) {
                                if (void 0 === s || n > a || f > u || d > l)
                                    return s = o, a = n, u = f, l = d, void (i = 0);
                                var g = c([s, o], t.properties);
                                if (!1 === e(g, n, r, d, i))
                                    return !1;
                                i++,
                                s = o
                            })) && void 0
                    }
                }
            }))
        }
        function V(t, e, n) {
            var r = n,
                i = !1;
            return U(t, (function(t, o, s, a, u) {
                r = !1 === i && void 0 === n ? t : e(r, t, o, s, a, u),
                i = !0
            })), r
        }
        function X(t, e) {
            if (!t)
                throw new Error("geojson is required");
            q(t, (function(t, n, r) {
                if (null !== t.geometry) {
                    var i = t.geometry.type,
                        o = t.geometry.coordinates;
                    switch (i) {
                    case "LineString":
                        if (!1 === e(t, n, r, 0, 0))
                            return !1;
                        break;
                    case "Polygon":
                        for (var s = 0; s < o.length; s++)
                            if (!1 === e(c(o[s], t.properties), n, r, s))
                                return !1
                    }
                }
            }))
        }
        function H(t, e, n) {
            var r = n;
            return X(t, (function(t, i, o, s) {
                r = 0 === i && void 0 === n ? t : e(r, t, i, o, s)
            })), r
        }
        function Y(t, e) {
            if (!T(e = e || {}))
                throw new Error("options is invalid");
            var n,
                r = e.featureIndex || 0,
                i = e.multiFeatureIndex || 0,
                o = e.geometryIndex || 0,
                s = e.segmentIndex || 0,
                a = e.properties;
            switch (t.type) {
            case "FeatureCollection":
                r < 0 && (r = t.features.length + r),
                a = a || t.features[r].properties,
                n = t.features[r].geometry;
                break;
            case "Feature":
                a = a || t.properties,
                n = t.geometry;
                break;
            case "Point":
            case "MultiPoint":
                return null;
            case "LineString":
            case "Polygon":
            case "MultiLineString":
            case "MultiPolygon":
                n = t;
                break;
            default:
                throw new Error("geojson is invalid")
            }
            if (null === n)
                return null;
            var u = n.coordinates;
            switch (n.type) {
            case "Point":
            case "MultiPoint":
                return null;
            case "LineString":
                return s < 0 && (s = u.length + s - 1), c([u[s], u[s + 1]], a, e);
            case "Polygon":
                return o < 0 && (o = u.length + o), s < 0 && (s = u[o].length + s - 1), c([u[o][s], u[o][s + 1]], a, e);
            case "MultiLineString":
                return i < 0 && (i = u.length + i), s < 0 && (s = u[i].length + s - 1), c([u[i][s], u[i][s + 1]], a, e);
            case "MultiPolygon":
                return i < 0 && (i = u.length + i), o < 0 && (o = u[i].length + o), s < 0 && (s = u[i][o].length - s - 1), c([u[i][o][s], u[i][o][s + 1]], a, e)
            }
            throw new Error("geojson is invalid")
        }
        function W(t, e) {
            if (!T(e = e || {}))
                throw new Error("options is invalid");
            var n,
                r = e.featureIndex || 0,
                i = e.multiFeatureIndex || 0,
                o = e.geometryIndex || 0,
                s = e.coordIndex || 0,
                u = e.properties;
            switch (t.type) {
            case "FeatureCollection":
                r < 0 && (r = t.features.length + r),
                u = u || t.features[r].properties,
                n = t.features[r].geometry;
                break;
            case "Feature":
                u = u || t.properties,
                n = t.geometry;
                break;
            case "Point":
            case "MultiPoint":
                return null;
            case "LineString":
            case "Polygon":
            case "MultiLineString":
            case "MultiPolygon":
                n = t;
                break;
            default:
                throw new Error("geojson is invalid")
            }
            if (null === n)
                return null;
            var l = n.coordinates;
            switch (n.type) {
            case "Point":
                return a(l, u, e);
            case "MultiPoint":
                return i < 0 && (i = l.length + i), a(l[i], u, e);
            case "LineString":
                return s < 0 && (s = l.length + s), a(l[s], u, e);
            case "Polygon":
                return o < 0 && (o = l.length + o), s < 0 && (s = l[o].length + s), a(l[o][s], u, e);
            case "MultiLineString":
                return i < 0 && (i = l.length + i), s < 0 && (s = l[i].length + s), a(l[i][s], u, e);
            case "MultiPolygon":
                return i < 0 && (i = l.length + i), o < 0 && (o = l[i].length + o), s < 0 && (s = l[i][o].length - s), a(l[i][o][s], u, e)
            }
            throw new Error("geojson is invalid")
        }
        var $ = Object.freeze({
            __proto__: null,
            coordAll: j,
            coordEach: N,
            coordReduce: R,
            featureEach: F,
            featureReduce: k,
            findPoint: W,
            findSegment: Y,
            flattenEach: q,
            flattenReduce: z,
            geomEach: G,
            geomReduce: B,
            lineEach: X,
            lineReduce: H,
            propEach: A,
            propReduce: D,
            segmentEach: U,
            segmentReduce: V
        });
        function K(t) {
            var e = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
            return N(t, (function(t) {
                e[0] > t[0] && (e[0] = t[0]),
                e[1] > t[1] && (e[1] = t[1]),
                e[2] < t[0] && (e[2] = t[0]),
                e[3] < t[1] && (e[3] = t[1])
            })), e
        }
        function Z(t) {
            if (!t)
                throw new Error("coord is required");
            if (!Array.isArray(t)) {
                if ("Feature" === t.type && null !== t.geometry && "Point" === t.geometry.type)
                    return t.geometry.coordinates;
                if ("Point" === t.type)
                    return t.coordinates
            }
            if (Array.isArray(t) && t.length >= 2 && !Array.isArray(t[0]) && !Array.isArray(t[1]))
                return t;
            throw new Error("coord must be GeoJSON Point or an Array of numbers")
        }
        function J(t) {
            if (Array.isArray(t))
                return t;
            if ("Feature" === t.type) {
                if (null !== t.geometry)
                    return t.geometry.coordinates
            } else if (t.coordinates)
                return t.coordinates;
            throw new Error("coords must be GeoJSON Feature, Geometry Object or an Array")
        }
        function Q(t) {
            if (t.length > 1 && I(t[0]) && I(t[1]))
                return !0;
            if (Array.isArray(t[0]) && t[0].length)
                return Q(t[0]);
            throw new Error("coordinates must only contain numbers")
        }
        function tt(t, e, n) {
            if (!e || !n)
                throw new Error("type and name required");
            if (!t || t.type !== e)
                throw new Error("Invalid input to " + n + ": must be a " + e + ", given " + t.type)
        }
        function et(t, e, n) {
            if (!t)
                throw new Error("No feature passed");
            if (!n)
                throw new Error(".featureOf() requires a name");
            if (!t || "Feature" !== t.type || !t.geometry)
                throw new Error("Invalid input to " + n + ", Feature with geometry required");
            if (!t.geometry || t.geometry.type !== e)
                throw new Error("Invalid input to " + n + ": must be a " + e + ", given " + t.geometry.type)
        }
        function nt(t, e, n) {
            if (!t)
                throw new Error("No featureCollection passed");
            if (!n)
                throw new Error(".collectionOf() requires a name");
            if (!t || "FeatureCollection" !== t.type)
                throw new Error("Invalid input to " + n + ", FeatureCollection required");
            for (var r = 0, i = t.features; r < i.length; r++) {
                var o = i[r];
                if (!o || "Feature" !== o.type || !o.geometry)
                    throw new Error("Invalid input to " + n + ", Feature with geometry required");
                if (!o.geometry || o.geometry.type !== e)
                    throw new Error("Invalid input to " + n + ": must be a " + e + ", given " + o.geometry.type)
            }
        }
        function rt(t) {
            return "Feature" === t.type ? t.geometry : t
        }
        function it(t, e) {
            return "FeatureCollection" === t.type ? "FeatureCollection" : "GeometryCollection" === t.type ? "GeometryCollection" : "Feature" === t.type && null !== t.geometry ? t.geometry.type : t.type
        }
        K.default = K;
        var ot = Object.freeze({
                __proto__: null,
                getCoord: Z,
                getCoords: J,
                containsNumber: Q,
                geojsonType: tt,
                featureOf: et,
                collectionOf: nt,
                getGeom: rt,
                getType: it
            }),
            st = Object.getOwnPropertySymbols,
            at = Object.prototype.hasOwnProperty,
            ut = Object.prototype.propertyIsEnumerable;
        /*
            object-assign
            (c) Sindre Sorhus
            @license MIT
            */
        function lt(t) {
            if (null == t)
                throw new TypeError("Object.assign cannot be called with null or undefined");
            return Object(t)
        }
        var ht = function() {
                try {
                    if (!Object.assign)
                        return !1;
                    var t = new String("abc");
                    if (t[5] = "de", "5" === Object.getOwnPropertyNames(t)[0])
                        return !1;
                    for (var e = {}, n = 0; n < 10; n++)
                        e["_" + String.fromCharCode(n)] = n;
                    if ("0123456789" !== Object.getOwnPropertyNames(e).map((function(t) {
                        return e[t]
                    })).join(""))
                        return !1;
                    var r = {};
                    return "abcdefghijklmnopqrst".split("").forEach((function(t) {
                        r[t] = t
                    })), "abcdefghijklmnopqrst" === Object.keys(Object.assign({}, r)).join("")
                } catch (t) {
                    return !1
                }
            }() ? Object.assign : function(t, e) {
                for (var n, r, i = lt(t), o = 1; o < arguments.length; o++) {
                    for (var s in n = Object(arguments[o]))
                        at.call(n, s) && (i[s] = n[s]);
                    if (st) {
                        r = st(n);
                        for (var a = 0; a < r.length; a++)
                            ut.call(n, r[a]) && (i[r[a]] = n[r[a]])
                    }
                }
                return i
            },
            ct = {
                successCallback: null,
                verbose: !1
            },
            pt = {};
        /**
             * @license GNU Affero General Public License.
             * Copyright (c) 2015, 2015 Ronny Lorenz <ronny@tbi.univie.ac.at>
             * v. 1.2.0
             * https://github.com/RaumZeit/MarchingSquares.js
             *
             * MarchingSquaresJS is free software: you can redistribute it and/or modify
             * it under the terms of the GNU Affero General Public License as published by
             * the Free Software Foundation, either version 3 of the License, or
             * (at your option) any later version.
             *
             * MarchingSquaresJS is distributed in the hope that it will be useful,
             * but WITHOUT ANY WARRANTY; without even the implied warranty of
             * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
             * GNU Affero General Public License for more details.
             *
             * As additional permission under GNU Affero General Public License version 3
             * section 7, third-party projects (personal or commercial) may distribute,
             * include, or link against UNMODIFIED VERSIONS of MarchingSquaresJS without the
             * requirement that said third-party project for that reason alone becomes
             * subject to any requirement of the GNU Affero General Public License version 3.
             * Any modifications to MarchingSquaresJS, however, must be shared with the public
             * and made available.
             *
             * In summary this:
             * - allows you to use MarchingSquaresJS at no cost
             * - allows you to use MarchingSquaresJS for both personal and commercial purposes
             * - allows you to distribute UNMODIFIED VERSIONS of MarchingSquaresJS under any
             *   license as long as this license notice is included
             * - enables you to keep the source code of your program that uses MarchingSquaresJS
             *   undisclosed
             * - forces you to share any modifications you have made to MarchingSquaresJS,
             *   e.g. bug-fixes
             *
             * You should have received a copy of the GNU Affero General Public License
             * along with MarchingSquaresJS.  If not, see <http://www.gnu.org/licenses/>.
             */
        function ft(t, e, n) {
            n = n || {};
            for (var r = Object.keys(ct), i = 0; i < r.length; i++) {
                var o = r[i],
                    s = n[o];
                s = null != s ? s : ct[o],
                pt[o] = s
            }
            pt.verbose && console.log("MarchingSquaresJS-isoContours: computing isocontour for " + e);
            var a = function(t) {
                var e = [],
                    n = 0,
                    r = 1e-7;
                return t.cells.forEach((function(i, o) {
                    i.forEach((function(i, s) {
                        if (void 0 !== i && 5 !== (f = i).cval && 10 !== f.cval && !gt(i)) {
                            var a = function(t, e, n) {
                                    var r,
                                        i,
                                        o = t.length,
                                        s = [],
                                        a = [0, 0, 1, 1, 0, 0, 0, 0, -1, 0, 1, 1, -1, 0, -1, 0],
                                        u = [0, -1, 0, 0, 1, 1, 1, 1, 0, -1, 0, 0, 0, -1, 0, 0],
                                        l = ["none", "left", "bottom", "left", "right", "none", "bottom", "left", "top", "top", "none", "top", "right", "right", "bottom", "none"],
                                        h = ["none", "bottom", "right", "right", "top", "top", "top", "top", "left", "bottom", "right", "right", "left", "bottom", "left", "none"],
                                        c = t[e][n],
                                        p = c.cval,
                                        f = l[p],
                                        d = vt(c, f);
                                    s.push([n + d[0], e + d[1]]),
                                    d = vt(c, f = h[p]),
                                    s.push([n + d[0], e + d[1]]),
                                    yt(c);
                                    for (var g = n + a[p], y = e + u[p], v = p; g >= 0 && y >= 0 && y < o && (g != n || y != e) && void 0 !== (c = t[y][g]);) {
                                        if (0 === (p = c.cval) || 15 === p)
                                            return {
                                                path: s,
                                                info: "mergeable"
                                            };
                                        f = h[p],
                                        r = a[p],
                                        i = u[p],
                                        5 !== p && 10 !== p || (5 === p ? c.flipped ? -1 === u[v] ? (f = "left", r = -1, i = 0) : (f = "right", r = 1, i = 0) : -1 === a[v] && (f = "bottom", r = 0, i = -1) : 10 === p && (c.flipped ? -1 === a[v] ? (f = "top", r = 0, i = 1) : (f = "bottom", r = 0, i = -1) : 1 === u[v] && (f = "left", r = -1, i = 0))),
                                        d = vt(c, f),
                                        s.push([g + d[0], y + d[1]]),
                                        yt(c),
                                        g += r,
                                        y += i,
                                        v = p
                                    }
                                    return {
                                        path: s,
                                        info: "closed"
                                    }
                                }(t.cells, o, s),
                                u = !1;
                            if ("mergeable" === a.info)
                                for (var l = a.path[a.path.length - 1][0], h = a.path[a.path.length - 1][1], c = n - 1; c >= 0; c--)
                                    if (Math.abs(e[c][0][0] - l) <= r && Math.abs(e[c][0][1] - h) <= r) {
                                        for (var p = a.path.length - 2; p >= 0; --p)
                                            e[c].unshift(a.path[p]);
                                        u = !0;
                                        break
                                    }
                            u || (e[n++] = a.path)
                        }
                        var f
                    }))
                })), e
            }(function(t, e) {
                for (var n = t.length - 1, r = t[0].length - 1, i = {
                        rows: n,
                        cols: r,
                        cells: []
                    }, o = 0; o < n; ++o) {
                    i.cells[o] = [];
                    for (var s = 0; s < r; ++s) {
                        var a = 0,
                            u = t[o + 1][s],
                            l = t[o + 1][s + 1],
                            h = t[o][s + 1],
                            c = t[o][s];
                        if (!(isNaN(u) || isNaN(l) || isNaN(h) || isNaN(c))) {
                            a |= u >= e ? 8 : 0,
                            a |= l >= e ? 4 : 0,
                            a |= h >= e ? 2 : 0;
                            var p,
                                f,
                                d,
                                g,
                                y = !1;
                            if (5 == (a |= c >= e ? 1 : 0) || 10 === a) {
                                var v = (u + l + h + c) / 4;
                                5 === a && v < e ? (a = 10, y = !0) : 10 === a && v < e && (a = 5, y = !0)
                            }
                            0 !== a && 15 !== a && (p = f = d = g = .5, 1 === a ? (d = 1 - dt(e, u, c), f = 1 - dt(e, h, c)) : 2 === a ? (f = dt(e, c, h), g = 1 - dt(e, l, h)) : 3 === a ? (d = 1 - dt(e, u, c), g = 1 - dt(e, l, h)) : 4 === a ? (p = dt(e, u, l), g = dt(e, h, l)) : 5 === a ? (p = dt(e, u, l), g = dt(e, h, l), f = 1 - dt(e, h, c), d = 1 - dt(e, u, c)) : 6 === a ? (f = dt(e, c, h), p = dt(e, u, l)) : 7 === a ? (d = 1 - dt(e, u, c), p = dt(e, u, l)) : 8 === a ? (d = dt(e, c, u), p = 1 - dt(e, l, u)) : 9 === a ? (f = 1 - dt(e, h, c), p = 1 - dt(e, l, u)) : 10 === a ? (p = 1 - dt(e, l, u), g = 1 - dt(e, l, h), f = dt(e, c, h), d = dt(e, c, u)) : 11 === a ? (p = 1 - dt(e, l, u), g = 1 - dt(e, l, h)) : 12 === a ? (d = dt(e, c, u), g = dt(e, h, l)) : 13 === a ? (f = 1 - dt(e, h, c), g = dt(e, h, l)) : 14 === a ? (d = dt(e, c, u), f = dt(e, c, h)) : console.log("MarchingSquaresJS-isoContours: Illegal cval detected: " + a), i.cells[o][s] = {
                                cval: a,
                                flipped: y,
                                top: p,
                                right: g,
                                bottom: f,
                                left: d
                            })
                        }
                    }
                }
                return i
            }(t, e));
            return "function" == typeof pt.successCallback && pt.successCallback(a), a
        }
        function dt(t, e, n) {
            return (t - e) / (n - e)
        }
        function gt(t) {
            return 0 === t.cval || 15 === t.cval
        }
        function yt(t) {
            gt(t) || 5 === t.cval || 10 === t.cval || (t.cval = 15)
        }
        function vt(t, e) {
            return "top" === e ? [t.top, 1] : "bottom" === e ? [t.bottom, 0] : "right" === e ? [1, t.right] : "left" === e ? [0, t.left] : void 0
        }
        function mt(t, e) {
            if (!T(e = e || {}))
                throw new Error("options is invalid");
            var n = e.zProperty || "elevation",
                r = e.flip,
                i = e.flags;
            nt(t, "Point", "input must contain Points");
            for (var o = function(t, e) {
                    var n = {};
                    return F(t, (function(t) {
                        var e = J(t)[1];
                        n[e] || (n[e] = []),
                        n[e].push(t)
                    })), Object.keys(n).map((function(t) {
                        return n[t].sort((function(t, e) {
                            return J(t)[0] - J(e)[0]
                        }))
                    })).sort((function(t, n) {
                        return e ? J(t[0])[1] - J(n[0])[1] : J(n[0])[1] - J(t[0])[1]
                    }))
                }(t, r), s = [], a = 0; a < o.length; a++) {
                for (var u = o[a], l = [], h = 0; h < u.length; h++) {
                    var c = u[h];
                    c.properties[n] ? l.push(c.properties[n]) : l.push(0),
                    !0 === i && (c.properties.matrixPosition = [a, h])
                }
                s.push(l)
            }
            return s
        }
        var _t = Et,
            xt = Et;
        function Et(t, e, n, r, i) {
            wt(t, e, n || 0, r || t.length - 1, i || Ct)
        }
        function wt(t, e, n, r, i) {
            for (; r > n;) {
                if (r - n > 600) {
                    var o = r - n + 1,
                        s = e - n + 1,
                        a = Math.log(o),
                        u = .5 * Math.exp(2 * a / 3),
                        l = .5 * Math.sqrt(a * u * (o - u) / o) * (s - o / 2 < 0 ? -1 : 1);
                    wt(t, e, Math.max(n, Math.floor(e - s * u / o + l)), Math.min(r, Math.floor(e + (o - s) * u / o + l)), i)
                }
                var h = t[e],
                    c = n,
                    p = r;
                for (bt(t, n, e), i(t[r], h) > 0 && bt(t, n, r); c < p;) {
                    for (bt(t, c, p), c++, p--; i(t[c], h) < 0;)
                        c++;
                    for (; i(t[p], h) > 0;)
                        p--
                }
                0 === i(t[n], h) ? bt(t, n, p) : bt(t, ++p, r),
                p <= e && (n = p + 1),
                e <= p && (r = p - 1)
            }
        }
        function bt(t, e, n) {
            var r = t[e];
            t[e] = t[n],
            t[n] = r
        }
        function Ct(t, e) {
            return t < e ? -1 : t > e ? 1 : 0
        }
        _t.default = xt;
        var Mt = It,
            St = It;
        function It(t, e) {
            if (!(this instanceof It))
                return new It(t, e);
            this._maxEntries = Math.max(4, t || 9),
            this._minEntries = Math.max(2, Math.ceil(.4 * this._maxEntries)),
            e && this._initFormat(e),
            this.clear()
        }
        function Tt(t, e, n) {
            if (!n)
                return e.indexOf(t);
            for (var r = 0; r < e.length; r++)
                if (n(t, e[r]))
                    return r;
            return -1
        }
        function Pt(t, e) {
            Lt(t, 0, t.children.length, e, t)
        }
        function Lt(t, e, n, r, i) {
            i || (i = jt(null)),
            i.minX = 1 / 0,
            i.minY = 1 / 0,
            i.maxX = -1 / 0,
            i.maxY = -1 / 0;
            for (var o, s = e; s < n; s++)
                o = t.children[s],
                Ot(i, t.leaf ? r(o) : o);
            return i
        }
        function Ot(t, e) {
            return t.minX = Math.min(t.minX, e.minX), t.minY = Math.min(t.minY, e.minY), t.maxX = Math.max(t.maxX, e.maxX), t.maxY = Math.max(t.maxY, e.maxY), t
        }
        function Nt(t, e) {
            return t.minX - e.minX
        }
        function Rt(t, e) {
            return t.minY - e.minY
        }
        function At(t) {
            return (t.maxX - t.minX) * (t.maxY - t.minY)
        }
        function Dt(t) {
            return t.maxX - t.minX + (t.maxY - t.minY)
        }
        function Ft(t, e) {
            return t.minX <= e.minX && t.minY <= e.minY && e.maxX <= t.maxX && e.maxY <= t.maxY
        }
        function kt(t, e) {
            return e.minX <= t.maxX && e.minY <= t.maxY && e.maxX >= t.minX && e.maxY >= t.minY
        }
        function jt(t) {
            return {
                children: t,
                height: 1,
                leaf: !0,
                minX: 1 / 0,
                minY: 1 / 0,
                maxX: -1 / 0,
                maxY: -1 / 0
            }
        }
        function Gt(t, e, n, r, i) {
            for (var o, s = [e, n]; s.length;)
                (n = s.pop()) - (e = s.pop()) <= r || (o = e + Math.ceil((n - e) / r / 2) * r, _t(t, o, e, n, i), s.push(e, o, o, n))
        }
        function Bt(t) {
            var e = {
                exports: {}
            };
            return t(e, e.exports), e.exports
        }
        It.prototype = {
            all: function() {
                return this._all(this.data, [])
            },
            search: function(t) {
                var e = this.data,
                    n = [],
                    r = this.toBBox;
                if (!kt(t, e))
                    return n;
                for (var i, o, s, a, u = []; e;) {
                    for (i = 0, o = e.children.length; i < o; i++)
                        s = e.children[i],
                        kt(t, a = e.leaf ? r(s) : s) && (e.leaf ? n.push(s) : Ft(t, a) ? this._all(s, n) : u.push(s));
                    e = u.pop()
                }
                return n
            },
            collides: function(t) {
                var e = this.data,
                    n = this.toBBox;
                if (!kt(t, e))
                    return !1;
                for (var r, i, o, s, a = []; e;) {
                    for (r = 0, i = e.children.length; r < i; r++)
                        if (o = e.children[r], kt(t, s = e.leaf ? n(o) : o)) {
                            if (e.leaf || Ft(t, s))
                                return !0;
                            a.push(o)
                        }
                    e = a.pop()
                }
                return !1
            },
            load: function(t) {
                if (!t || !t.length)
                    return this;
                if (t.length < this._minEntries) {
                    for (var e = 0, n = t.length; e < n; e++)
                        this.insert(t[e]);
                    return this
                }
                var r = this._build(t.slice(), 0, t.length - 1, 0);
                if (this.data.children.length)
                    if (this.data.height === r.height)
                        this._splitRoot(this.data, r);
                    else {
                        if (this.data.height < r.height) {
                            var i = this.data;
                            this.data = r,
                            r = i
                        }
                        this._insert(r, this.data.height - r.height - 1, !0)
                    }
                else
                    this.data = r;
                return this
            },
            insert: function(t) {
                return t && this._insert(t, this.data.height - 1), this
            },
            clear: function() {
                return this.data = jt([]), this
            },
            remove: function(t, e) {
                if (!t)
                    return this;
                for (var n, r, i, o, s = this.data, a = this.toBBox(t), u = [], l = []; s || u.length;) {
                    if (s || (s = u.pop(), r = u[u.length - 1], n = l.pop(), o = !0), s.leaf && -1 !== (i = Tt(t, s.children, e)))
                        return s.children.splice(i, 1), u.push(s), this._condense(u), this;
                    o || s.leaf || !Ft(s, a) ? r ? (n++, s = r.children[n], o = !1) : s = null : (u.push(s), l.push(n), n = 0, r = s, s = s.children[0])
                }
                return this
            },
            toBBox: function(t) {
                return t
            },
            compareMinX: Nt,
            compareMinY: Rt,
            toJSON: function() {
                return this.data
            },
            fromJSON: function(t) {
                return this.data = t, this
            },
            _all: function(t, e) {
                for (var n = []; t;)
                    t.leaf ? e.push.apply(e, t.children) : n.push.apply(n, t.children),
                    t = n.pop();
                return e
            },
            _build: function(t, e, n, r) {
                var i,
                    o = n - e + 1,
                    s = this._maxEntries;
                if (o <= s)
                    return Pt(i = jt(t.slice(e, n + 1)), this.toBBox), i;
                r || (r = Math.ceil(Math.log(o) / Math.log(s)), s = Math.ceil(o / Math.pow(s, r - 1))),
                (i = jt([])).leaf = !1,
                i.height = r;
                var a,
                    u,
                    l,
                    h,
                    c = Math.ceil(o / s),
                    p = c * Math.ceil(Math.sqrt(s));
                for (Gt(t, e, n, p, this.compareMinX), a = e; a <= n; a += p)
                    for (Gt(t, a, l = Math.min(a + p - 1, n), c, this.compareMinY), u = a; u <= l; u += c)
                        h = Math.min(u + c - 1, l),
                        i.children.push(this._build(t, u, h, r - 1));
                return Pt(i, this.toBBox), i
            },
            _chooseSubtree: function(t, e, n, r) {
                for (var i, o, s, a, u, l, h, c, p, f; r.push(e), !e.leaf && r.length - 1 !== n;) {
                    for (h = c = 1 / 0, i = 0, o = e.children.length; i < o; i++)
                        u = At(s = e.children[i]),
                        p = t,
                        f = s,
                        (l = (Math.max(f.maxX, p.maxX) - Math.min(f.minX, p.minX)) * (Math.max(f.maxY, p.maxY) - Math.min(f.minY, p.minY)) - u) < c ? (c = l, h = u < h ? u : h, a = s) : l === c && u < h && (h = u, a = s);
                    e = a || e.children[0]
                }
                return e
            },
            _insert: function(t, e, n) {
                var r = this.toBBox,
                    i = n ? t : r(t),
                    o = [],
                    s = this._chooseSubtree(i, this.data, e, o);
                for (s.children.push(t), Ot(s, i); e >= 0 && o[e].children.length > this._maxEntries;)
                    this._split(o, e),
                    e--;
                this._adjustParentBBoxes(i, o, e)
            },
            _split: function(t, e) {
                var n = t[e],
                    r = n.children.length,
                    i = this._minEntries;
                this._chooseSplitAxis(n, i, r);
                var o = this._chooseSplitIndex(n, i, r),
                    s = jt(n.children.splice(o, n.children.length - o));
                s.height = n.height,
                s.leaf = n.leaf,
                Pt(n, this.toBBox),
                Pt(s, this.toBBox),
                e ? t[e - 1].children.push(s) : this._splitRoot(n, s)
            },
            _splitRoot: function(t, e) {
                this.data = jt([t, e]),
                this.data.height = t.height + 1,
                this.data.leaf = !1,
                Pt(this.data, this.toBBox)
            },
            _chooseSplitIndex: function(t, e, n) {
                var r,
                    i,
                    o,
                    s,
                    a,
                    u,
                    l,
                    h,
                    c,
                    p,
                    f,
                    d,
                    g,
                    y;
                for (u = l = 1 / 0, r = e; r <= n - e; r++)
                    c = i = Lt(t, 0, r, this.toBBox),
                    p = o = Lt(t, r, n, this.toBBox),
                    f = void 0,
                    d = void 0,
                    g = void 0,
                    y = void 0,
                    f = Math.max(c.minX, p.minX),
                    d = Math.max(c.minY, p.minY),
                    g = Math.min(c.maxX, p.maxX),
                    y = Math.min(c.maxY, p.maxY),
                    s = Math.max(0, g - f) * Math.max(0, y - d),
                    a = At(i) + At(o),
                    s < u ? (u = s, h = r, l = a < l ? a : l) : s === u && a < l && (l = a, h = r);
                return h
            },
            _chooseSplitAxis: function(t, e, n) {
                var r = t.leaf ? this.compareMinX : Nt,
                    i = t.leaf ? this.compareMinY : Rt;
                this._allDistMargin(t, e, n, r) < this._allDistMargin(t, e, n, i) && t.children.sort(r)
            },
            _allDistMargin: function(t, e, n, r) {
                t.children.sort(r);
                var i,
                    o,
                    s = this.toBBox,
                    a = Lt(t, 0, e, s),
                    u = Lt(t, n - e, n, s),
                    l = Dt(a) + Dt(u);
                for (i = e; i < n - e; i++)
                    o = t.children[i],
                    Ot(a, t.leaf ? s(o) : o),
                    l += Dt(a);
                for (i = n - e - 1; i >= e; i--)
                    o = t.children[i],
                    Ot(u, t.leaf ? s(o) : o),
                    l += Dt(u);
                return l
            },
            _adjustParentBBoxes: function(t, e, n) {
                for (var r = n; r >= 0; r--)
                    Ot(e[r], t)
            },
            _condense: function(t) {
                for (var e, n = t.length - 1; n >= 0; n--)
                    0 === t[n].children.length ? n > 0 ? (e = t[n - 1].children).splice(e.indexOf(t[n]), 1) : this.clear() : Pt(t[n], this.toBBox)
            },
            _initFormat: function(t) {
                var e = ["return a", " - b", ";"];
                this.compareMinX = new Function("a", "b", e.join(t[0])),
                this.compareMinY = new Function("a", "b", e.join(t[1])),
                this.toBBox = new Function("a", "return {minX: a" + t[0] + ", minY: a" + t[1] + ", maxX: a" + t[2] + ", maxY: a" + t[3] + "};")
            }
        },
        Mt.default = St;
        var qt = function(t, e, n) {
                var r = t * e,
                    i = zt * t,
                    o = i - (i - t),
                    s = t - o,
                    a = zt * e,
                    u = a - (a - e),
                    l = e - u,
                    h = s * l - (r - o * u - s * u - o * l);
                return n ? (n[0] = h, n[1] = r, n) : [h, r]
            },
            zt = +(Math.pow(2, 27) + 1),
            Ut = function(t, e) {
                var n = 0 | t.length,
                    r = 0 | e.length;
                if (1 === n && 1 === r)
                    return function(t, e) {
                        var n = t + e,
                            r = n - t,
                            i = t - (n - r) + (e - r);
                        return i ? [i, n] : [n]
                    }(t[0], e[0]);
                var i,
                    o,
                    s = new Array(n + r),
                    a = 0,
                    u = 0,
                    l = 0,
                    h = Math.abs,
                    c = t[u],
                    p = h(c),
                    f = e[l],
                    d = h(f);
                p < d ? (o = c, (u += 1) < n && (p = h(c = t[u]))) : (o = f, (l += 1) < r && (d = h(f = e[l]))),
                u < n && p < d || l >= r ? (i = c, (u += 1) < n && (p = h(c = t[u]))) : (i = f, (l += 1) < r && (d = h(f = e[l])));
                for (var g, y, v = i + o, m = v - i, _ = o - m, x = _, E = v; u < n && l < r;)
                    p < d ? (i = c, (u += 1) < n && (p = h(c = t[u]))) : (i = f, (l += 1) < r && (d = h(f = e[l]))),
                    (_ = (o = x) - (m = (v = i + o) - i)) && (s[a++] = _),
                    x = E - ((g = E + v) - (y = g - E)) + (v - y),
                    E = g;
                for (; u < n;)
                    (_ = (o = x) - (m = (v = (i = c) + o) - i)) && (s[a++] = _),
                    x = E - ((g = E + v) - (y = g - E)) + (v - y),
                    E = g,
                    (u += 1) < n && (c = t[u]);
                for (; l < r;)
                    (_ = (o = x) - (m = (v = (i = f) + o) - i)) && (s[a++] = _),
                    x = E - ((g = E + v) - (y = g - E)) + (v - y),
                    E = g,
                    (l += 1) < r && (f = e[l]);
                return x && (s[a++] = x), E && (s[a++] = E), a || (s[a++] = 0), s.length = a, s
            },
            Vt = function(t, e, n) {
                var r = t + e,
                    i = r - t,
                    o = e - i,
                    s = t - (r - i);
                return n ? (n[0] = s + o, n[1] = r, n) : [s + o, r]
            },
            Xt = function(t, e) {
                var n = t.length;
                if (1 === n) {
                    var r = qt(t[0], e);
                    return r[0] ? r : [r[1]]
                }
                var i = new Array(2 * n),
                    o = [.1, .1],
                    s = [.1, .1],
                    a = 0;
                qt(t[0], e, o),
                o[0] && (i[a++] = o[0]);
                for (var u = 1; u < n; ++u) {
                    qt(t[u], e, s);
                    var l = o[1];
                    Vt(l, s[0], o),
                    o[0] && (i[a++] = o[0]);
                    var h = s[1],
                        c = o[1],
                        p = h + c,
                        f = c - (p - h);
                    o[1] = p,
                    f && (i[a++] = f)
                }
                return o[1] && (i[a++] = o[1]), 0 === a && (i[a++] = 0), i.length = a, i
            },
            Ht = function(t, e) {
                var n = 0 | t.length,
                    r = 0 | e.length;
                if (1 === n && 1 === r)
                    return function(t, e) {
                        var n = t + e,
                            r = n - t,
                            i = t - (n - r) + (e - r);
                        return i ? [i, n] : [n]
                    }(t[0], -e[0]);
                var i,
                    o,
                    s = new Array(n + r),
                    a = 0,
                    u = 0,
                    l = 0,
                    h = Math.abs,
                    c = t[u],
                    p = h(c),
                    f = -e[l],
                    d = h(f);
                p < d ? (o = c, (u += 1) < n && (p = h(c = t[u]))) : (o = f, (l += 1) < r && (d = h(f = -e[l]))),
                u < n && p < d || l >= r ? (i = c, (u += 1) < n && (p = h(c = t[u]))) : (i = f, (l += 1) < r && (d = h(f = -e[l])));
                for (var g, y, v = i + o, m = v - i, _ = o - m, x = _, E = v; u < n && l < r;)
                    p < d ? (i = c, (u += 1) < n && (p = h(c = t[u]))) : (i = f, (l += 1) < r && (d = h(f = -e[l]))),
                    (_ = (o = x) - (m = (v = i + o) - i)) && (s[a++] = _),
                    x = E - ((g = E + v) - (y = g - E)) + (v - y),
                    E = g;
                for (; u < n;)
                    (_ = (o = x) - (m = (v = (i = c) + o) - i)) && (s[a++] = _),
                    x = E - ((g = E + v) - (y = g - E)) + (v - y),
                    E = g,
                    (u += 1) < n && (c = t[u]);
                for (; l < r;)
                    (_ = (o = x) - (m = (v = (i = f) + o) - i)) && (s[a++] = _),
                    x = E - ((g = E + v) - (y = g - E)) + (v - y),
                    E = g,
                    (l += 1) < r && (f = -e[l]);
                return x && (s[a++] = x), E && (s[a++] = E), a || (s[a++] = 0), s.length = a, s
            },
            Yt = Bt((function(t) {
                function e(t, e) {
                    for (var n = new Array(t.length - 1), r = 1; r < t.length; ++r)
                        for (var i = n[r - 1] = new Array(t.length - 1), o = 0, s = 0; o < t.length; ++o)
                            o !== e && (i[s++] = t[r][o]);
                    return n
                }
                function n(t) {
                    if (1 === t.length)
                        return t[0];
                    if (2 === t.length)
                        return ["sum(", t[0], ",", t[1], ")"].join("");
                    var e = t.length >> 1;
                    return ["sum(", n(t.slice(0, e)), ",", n(t.slice(e)), ")"].join("")
                }
                function r(t) {
                    if (2 === t.length)
                        return [["sum(prod(", t[0][0], ",", t[1][1], "),prod(-", t[0][1], ",", t[1][0], "))"].join("")];
                    for (var i = [], o = 0; o < t.length; ++o)
                        i.push(["scale(", n(r(e(t, o))), ",", (s = o, 1 & s ? "-" : ""), t[0][o], ")"].join(""));
                    var s;
                    return i
                }
                function i(t) {
                    for (var i = [], o = [], s = function(t) {
                            for (var e = new Array(t), n = 0; n < t; ++n) {
                                e[n] = new Array(t);
                                for (var r = 0; r < t; ++r)
                                    e[n][r] = ["m", r, "[", t - n - 1, "]"].join("")
                            }
                            return e
                        }(t), a = [], u = 0; u < t; ++u)
                        0 == (1 & u) ? i.push.apply(i, r(e(s, u))) : o.push.apply(o, r(e(s, u))),
                        a.push("m" + u);
                    var l = n(i),
                        h = n(o),
                        c = "orientation" + t + "Exact",
                        p = ["function ", c, "(", a.join(), "){var p=", l, ",n=", h, ",d=sub(p,n);return d[d.length-1];};return ", c].join("");
                    return new Function("sum", "prod", "scale", "sub", p)(Ut, qt, Xt, Ht)
                }
                var o = i(3),
                    s = i(4),
                    a = [function() {
                        return 0
                    }, function() {
                        return 0
                    }, function(t, e) {
                        return e[0] - t[0]
                    }, function(t, e, n) {
                        var r,
                            i = (t[1] - n[1]) * (e[0] - n[0]),
                            s = (t[0] - n[0]) * (e[1] - n[1]),
                            a = i - s;
                        if (i > 0) {
                            if (s <= 0)
                                return a;
                            r = i + s
                        } else {
                            if (!(i < 0))
                                return a;
                            if (s >= 0)
                                return a;
                            r = -(i + s)
                        }
                        var u = 33306690738754716e-32 * r;
                        return a >= u || a <= -u ? a : o(t, e, n)
                    }, function(t, e, n, r) {
                        var i = t[0] - r[0],
                            o = e[0] - r[0],
                            a = n[0] - r[0],
                            u = t[1] - r[1],
                            l = e[1] - r[1],
                            h = n[1] - r[1],
                            c = t[2] - r[2],
                            p = e[2] - r[2],
                            f = n[2] - r[2],
                            d = o * h,
                            g = a * l,
                            y = a * u,
                            v = i * h,
                            m = i * l,
                            _ = o * u,
                            x = c * (d - g) + p * (y - v) + f * (m - _),
                            E = 7771561172376103e-31 * ((Math.abs(d) + Math.abs(g)) * Math.abs(c) + (Math.abs(y) + Math.abs(v)) * Math.abs(p) + (Math.abs(m) + Math.abs(_)) * Math.abs(f));
                        return x > E || -x > E ? x : s(t, e, n, r)
                    }];
                function u(t) {
                    var e = a[t.length];
                    return e || (e = a[t.length] = i(t.length)), e.apply(void 0, t)
                }
                !function() {
                    for (; a.length <= 5;)
                        a.push(i(a.length));
                    for (var e = [], n = ["slow"], r = 0; r <= 5; ++r)
                        e.push("a" + r),
                        n.push("o" + r);
                    var o = ["function getOrientation(", e.join(), "){switch(arguments.length){case 0:case 1:return 0;"];
                    for (r = 2; r <= 5; ++r)
                        o.push("case ", r, ":return o", r, "(", e.slice(0, r).join(), ");");
                    o.push("}var s=new Array(arguments.length);for(var i=0;i<arguments.length;++i){s[i]=arguments[i]};return slow(s);}return getOrientation"),
                    n.push(o.join(""));
                    var s = Function.apply(void 0, n);
                    for (t.exports = s.apply(void 0, [u].concat(a)), r = 0; r <= 5; ++r)
                        t.exports[r] = a[r]
                }()
            })),
            Wt = function(t) {
                var e = t.length;
                if (e < 3) {
                    for (var n = new Array(e), r = 0; r < e; ++r)
                        n[r] = r;
                    return 2 === e && t[0][0] === t[1][0] && t[0][1] === t[1][1] ? [0] : n
                }
                var i = new Array(e);
                for (r = 0; r < e; ++r)
                    i[r] = r;
                i.sort((function(e, n) {
                    return t[e][0] - t[n][0] || t[e][1] - t[n][1]
                }));
                var o = [i[0], i[1]],
                    s = [i[0], i[1]];
                for (r = 2; r < e; ++r) {
                    for (var a = i[r], u = t[a], l = o.length; l > 1 && $t(t[o[l - 2]], t[o[l - 1]], u) <= 0;)
                        l -= 1,
                        o.pop();
                    for (o.push(a), l = s.length; l > 1 && $t(t[s[l - 2]], t[s[l - 1]], u) >= 0;)
                        l -= 1,
                        s.pop();
                    s.push(a)
                }
                n = new Array(s.length + o.length - 2);
                for (var h = 0, c = (r = 0, o.length); r < c; ++r)
                    n[h++] = o[r];
                for (var p = s.length - 2; p > 0; --p)
                    n[h++] = s[p];
                return n
            },
            $t = Yt[3],
            Kt = Jt,
            Zt = Jt;
        function Jt(t, e) {
            if (!(this instanceof Jt))
                return new Jt(t, e);
            if (this.data = t || [], this.length = this.data.length, this.compare = e || Qt, this.length > 0)
                for (var n = (this.length >> 1) - 1; n >= 0; n--)
                    this._down(n)
        }
        function Qt(t, e) {
            return t < e ? -1 : t > e ? 1 : 0
        }
        Jt.prototype = {
            push: function(t) {
                this.data.push(t),
                this.length++,
                this._up(this.length - 1)
            },
            pop: function() {
                if (0 !== this.length) {
                    var t = this.data[0];
                    return this.length--, this.length > 0 && (this.data[0] = this.data[this.length], this._down(0)), this.data.pop(), t
                }
            },
            peek: function() {
                return this.data[0]
            },
            _up: function(t) {
                for (var e = this.data, n = this.compare, r = e[t]; t > 0;) {
                    var i = t - 1 >> 1,
                        o = e[i];
                    if (n(r, o) >= 0)
                        break;
                    e[t] = o,
                    t = i
                }
                e[t] = r
            },
            _down: function(t) {
                for (var e = this.data, n = this.compare, r = this.length >> 1, i = e[t]; t < r;) {
                    var o = 1 + (t << 1),
                        s = o + 1,
                        a = e[o];
                    if (s < this.length && n(e[s], a) < 0 && (o = s, a = e[s]), n(a, i) >= 0)
                        break;
                    e[t] = a,
                    t = o
                }
                e[t] = i
            }
        },
        Kt.default = Zt;
        var te = function(t, e) {
                for (var n = t[0], r = t[1], i = !1, o = 0, s = e.length - 1; o < e.length; s = o++) {
                    var a = e[o][0],
                        u = e[o][1],
                        l = e[s][0],
                        h = e[s][1];
                    u > r != h > r && n < (l - a) * (r - u) / (h - u) + a && (i = !i)
                }
                return i
            },
            ee = Yt[3],
            ne = ie,
            re = ie;
        function ie(t, e, n) {
            e = Math.max(0, void 0 === e ? 2 : e),
            n = n || 0;
            for (var r, i = function(t) {
                    for (var e = t[0], n = t[0], r = t[0], i = t[0], o = 0; o < t.length; o++) {
                        var s = t[o];
                        s[0] < e[0] && (e = s),
                        s[0] > r[0] && (r = s),
                        s[1] < n[1] && (n = s),
                        s[1] > i[1] && (i = s)
                    }
                    var a = [e, n, r, i],
                        u = a.slice();
                    for (o = 0; o < t.length; o++)
                        te(t[o], a) || u.push(t[o]);
                    var l = Wt(u),
                        h = [];
                    for (o = 0; o < l.length; o++)
                        h.push(u[l[o]]);
                    return h
                }(t), o = Mt(16, ["[0]", "[1]", "[0]", "[1]"]).load(t), s = [], a = 0; a < i.length; a++) {
                var u = i[a];
                o.remove(u),
                r = ce(u, r),
                s.push(r)
            }
            var l = Mt(16);
            for (a = 0; a < s.length; a++)
                l.insert(he(s[a]));
            for (var h = e * e, c = n * n; s.length;) {
                var p = s.shift(),
                    f = p.p,
                    d = p.next.p,
                    g = pe(f, d);
                if (!(g < c)) {
                    var y = g / h;
                    (u = oe(o, p.prev.p, f, d, p.next.next.p, y, l)) && Math.min(pe(u, f), pe(u, d)) <= y && (s.push(p), s.push(ce(u, p)), o.remove(u), l.remove(p), l.insert(he(p)), l.insert(he(p.next)))
                }
            }
            p = r;
            var v = [];
            do {
                v.push(p.p),
                p = p.next
            } while (p !== r);
            return v.push(p.p), v
        }
        function oe(t, e, n, r, i, o, s) {
            for (var a = new Kt(null, se), u = t.data; u;) {
                for (var l = 0; l < u.children.length; l++) {
                    var h = u.children[l],
                        c = u.leaf ? fe(h, n, r) : ae(n, r, h);
                    c > o || a.push({
                        node: h,
                        dist: c
                    })
                }
                for (; a.length && !a.peek().node.children;) {
                    var p = a.pop(),
                        f = p.node,
                        d = fe(f, e, n),
                        g = fe(f, r, i);
                    if (p.dist < d && p.dist < g && le(n, f, s) && le(r, f, s))
                        return f
                }
                (u = a.pop()) && (u = u.node)
            }
            return null
        }
        function se(t, e) {
            return t.dist - e.dist
        }
        function ae(t, e, n) {
            if (ue(t, n) || ue(e, n))
                return 0;
            var r = de(t[0], t[1], e[0], e[1], n.minX, n.minY, n.maxX, n.minY);
            if (0 === r)
                return 0;
            var i = de(t[0], t[1], e[0], e[1], n.minX, n.minY, n.minX, n.maxY);
            if (0 === i)
                return 0;
            var o = de(t[0], t[1], e[0], e[1], n.maxX, n.minY, n.maxX, n.maxY);
            if (0 === o)
                return 0;
            var s = de(t[0], t[1], e[0], e[1], n.minX, n.maxY, n.maxX, n.maxY);
            return 0 === s ? 0 : Math.min(r, i, o, s)
        }
        function ue(t, e) {
            return t[0] >= e.minX && t[0] <= e.maxX && t[1] >= e.minY && t[1] <= e.maxY
        }
        function le(t, e, n) {
            for (var r, i, o, s, a = Math.min(t[0], e[0]), u = Math.min(t[1], e[1]), l = Math.max(t[0], e[0]), h = Math.max(t[1], e[1]), c = n.search({
                    minX: a,
                    minY: u,
                    maxX: l,
                    maxY: h
                }), p = 0; p < c.length; p++)
                if (r = c[p].p, i = c[p].next.p, o = t, r !== (s = e) && i !== o && ee(r, i, o) > 0 != ee(r, i, s) > 0 && ee(o, s, r) > 0 != ee(o, s, i) > 0)
                    return !1;
            return !0
        }
        function he(t) {
            var e = t.p,
                n = t.next.p;
            return t.minX = Math.min(e[0], n[0]), t.minY = Math.min(e[1], n[1]), t.maxX = Math.max(e[0], n[0]), t.maxY = Math.max(e[1], n[1]), t
        }
        function ce(t, e) {
            var n = {
                p: t,
                prev: null,
                next: null,
                minX: 0,
                minY: 0,
                maxX: 0,
                maxY: 0
            };
            return e ? (n.next = e.next, n.prev = e, e.next.prev = n, e.next = n) : (n.prev = n, n.next = n), n
        }
        function pe(t, e) {
            var n = t[0] - e[0],
                r = t[1] - e[1];
            return n * n + r * r
        }
        function fe(t, e, n) {
            var r = e[0],
                i = e[1],
                o = n[0] - r,
                s = n[1] - i;
            if (0 !== o || 0 !== s) {
                var a = ((t[0] - r) * o + (t[1] - i) * s) / (o * o + s * s);
                a > 1 ? (r = n[0], i = n[1]) : a > 0 && (r += o * a, i += s * a)
            }
            return (o = t[0] - r) * o + (s = t[1] - i) * s
        }
        function de(t, e, n, r, i, o, s, a) {
            var u,
                l,
                h,
                c,
                p = n - t,
                f = r - e,
                d = s - i,
                g = a - o,
                y = t - i,
                v = e - o,
                m = p * p + f * f,
                _ = p * d + f * g,
                x = d * d + g * g,
                E = p * y + f * v,
                w = d * y + g * v,
                b = m * x - _ * _,
                C = b,
                M = b;
            0 === b ? (l = 0, C = 1, c = w, M = x) : (c = m * w - _ * E, (l = _ * w - x * E) < 0 ? (l = 0, c = w, M = x) : l > C && (l = C, c = w + _, M = x)),
            c < 0 ? (c = 0, -E < 0 ? l = 0 : -E > m ? l = C : (l = -E, C = m)) : c > M && (c = M, -E + _ < 0 ? l = 0 : -E + _ > m ? l = C : (l = -E + _, C = m));
            var S = (1 - (h = 0 === c ? 0 : c / M)) * i + h * s - ((1 - (u = 0 === l ? 0 : l / C)) * t + u * n),
                I = (1 - h) * o + h * a - ((1 - u) * e + u * r);
            return S * S + I * I
        }
        function ge(t, e) {
            void 0 === e && (e = {}),
            e.concavity = e.concavity || 1 / 0;
            var n = [];
            if (N(t, (function(t) {
                n.push([t[0], t[1]])
            })), !n.length)
                return null;
            var r = ne(n, e.concavity);
            return r.length > 3 ? l([r]) : null
        }
        function ye(t, e, n) {
            if (void 0 === n && (n = {}), !t)
                throw new Error("point is required");
            if (!e)
                throw new Error("polygon is required");
            var r = Z(t),
                i = rt(e),
                o = i.type,
                s = e.bbox,
                a = i.coordinates;
            if (s && !1 === function(t, e) {
                return e[0] <= t[0] && e[1] <= t[1] && e[2] >= t[0] && e[3] >= t[1]
            }(r, s))
                return !1;
            "Polygon" === o && (a = [a]);
            for (var u = !1, l = 0; l < a.length && !u; l++)
                if (ve(r, a[l][0], n.ignoreBoundary)) {
                    for (var h = !1, c = 1; c < a[l].length && !h;)
                        ve(r, a[l][c], !n.ignoreBoundary) && (h = !0),
                        c++;
                    h || (u = !0)
                }
            return u
        }
        function ve(t, e, n) {
            var r = !1;
            e[0][0] === e[e.length - 1][0] && e[0][1] === e[e.length - 1][1] && (e = e.slice(0, e.length - 1));
            for (var i = 0, o = e.length - 1; i < e.length; o = i++) {
                var s = e[i][0],
                    a = e[i][1],
                    u = e[o][0],
                    l = e[o][1];
                if (t[1] * (s - u) + a * (u - t[0]) + l * (t[0] - s) == 0 && (s - t[0]) * (u - t[0]) <= 0 && (a - t[1]) * (l - t[1]) <= 0)
                    return !n;
                a > t[1] != l > t[1] && t[0] < (u - s) * (t[1] - a) / (l - a) + s && (r = !r)
            }
            return r
        }
        function me(t, e) {
            var n = [];
            return F(t, (function(t) {
                var r = !1;
                if ("Point" === t.geometry.type)
                    G(e, (function(e) {
                        ye(t, e) && (r = !0)
                    })),
                    r && n.push(t);
                else {
                    if ("MultiPoint" !== t.geometry.type)
                        throw new Error("Input geometry must be a Point or MultiPoint");
                    var i = [];
                    G(e, (function(e) {
                        N(t, (function(t) {
                            ye(t, e) && (r = !0, i.push(t))
                        }))
                    })),
                    r && n.push(g(i))
                }
            })), f(n)
        }
        function _e(t, e, n) {
            void 0 === n && (n = {});
            var r = Z(t),
                i = Z(e),
                o = C(i[1] - r[1]),
                s = C(i[0] - r[0]),
                a = C(r[1]),
                u = C(i[1]),
                l = Math.pow(Math.sin(o / 2), 2) + Math.pow(Math.sin(s / 2), 2) * Math.cos(a) * Math.cos(u);
            return _(2 * Math.atan2(Math.sqrt(l), Math.sqrt(1 - l)), n.units)
        }
        function xe(t, e) {
            var n = !1;
            return f(function(t) {
                if (t.length < 3)
                    return [];
                t.sort(we);
                for (var e, n, r, i, o, s, a = t.length - 1, u = t[a].x, l = t[0].x, h = t[a].y, c = h, p = 1e-12; a--;)
                    t[a].y < h && (h = t[a].y),
                    t[a].y > c && (c = t[a].y);
                var f,
                    d = l - u,
                    g = c - h,
                    y = d > g ? d : g,
                    v = .5 * (l + u),
                    m = .5 * (c + h),
                    _ = [new Ee({
                        __sentinel: !0,
                        x: v - 20 * y,
                        y: m - y
                    }, {
                        __sentinel: !0,
                        x: v,
                        y: m + 20 * y
                    }, {
                        __sentinel: !0,
                        x: v + 20 * y,
                        y: m - y
                    })],
                    x = [],
                    E = [];
                for (a = t.length; a--;) {
                    for (E.length = 0, f = _.length; f--;)
                        (d = t[a].x - _[f].x) > 0 && d * d > _[f].r ? (x.push(_[f]), _.splice(f, 1)) : d * d + (g = t[a].y - _[f].y) * g > _[f].r || (E.push(_[f].a, _[f].b, _[f].b, _[f].c, _[f].c, _[f].a), _.splice(f, 1));
                    for (be(E), f = E.length; f;)
                        n = E[--f],
                        e = E[--f],
                        r = t[a],
                        i = n.x - e.x,
                        o = n.y - e.y,
                        s = 2 * (i * (r.y - n.y) - o * (r.x - n.x)),
                        Math.abs(s) > p && _.push(new Ee(e, n, r))
                }
                for (Array.prototype.push.apply(x, _), a = x.length; a--;)
                    (x[a].a.__sentinel || x[a].b.__sentinel || x[a].c.__sentinel) && x.splice(a, 1);
                return x
            }(t.features.map((function(t) {
                var r = {
                    x: t.geometry.coordinates[0],
                    y: t.geometry.coordinates[1]
                };
                return e ? r.z = t.properties[e] : 3 === t.geometry.coordinates.length && (n = !0, r.z = t.geometry.coordinates[2]), r
            }))).map((function(t) {
                var e = [t.a.x, t.a.y],
                    r = [t.b.x, t.b.y],
                    i = [t.c.x, t.c.y],
                    o = {};
                return n ? (e.push(t.a.z), r.push(t.b.z), i.push(t.c.z)) : o = {
                    a: t.a.z,
                    b: t.b.z,
                    c: t.c.z
                }, l([[e, r, i, e]], o)
            })))
        }
        ne.default = re;
        var Ee = function(t, e, n) {
            this.a = t,
            this.b = e,
            this.c = n;
            var r,
                i,
                o = e.x - t.x,
                s = e.y - t.y,
                a = n.x - t.x,
                u = n.y - t.y,
                l = o * (t.x + e.x) + s * (t.y + e.y),
                h = a * (t.x + n.x) + u * (t.y + n.y),
                c = 2 * (o * (n.y - e.y) - s * (n.x - e.x));
            this.x = (u * l - s * h) / c,
            this.y = (o * h - a * l) / c,
            r = this.x - t.x,
            i = this.y - t.y,
            this.r = r * r + i * i
        };
        function we(t, e) {
            return e.x - t.x
        }
        function be(t) {
            var e,
                n,
                r,
                i,
                o,
                s = t.length;
            t:
            for (; s;)
                for (n = t[--s], e = t[--s], r = s; r;)
                    if (o = t[--r], e === (i = t[--r]) && n === o || e === o && n === i) {
                        t.splice(s, 2),
                        t.splice(r, 2),
                        s -= 2;
                        continue t
                    }
        }
        function Ce(t) {
            if (!t)
                throw new Error("geojson is required");
            switch (t.type) {
            case "Feature":
                return Me(t);
            case "FeatureCollection":
                return function(t) {
                    var e = {
                        type: "FeatureCollection"
                    };
                    return Object.keys(t).forEach((function(n) {
                        switch (n) {
                        case "type":
                        case "features":
                            return;
                        default:
                            e[n] = t[n]
                        }
                    })), e.features = t.features.map((function(t) {
                        return Me(t)
                    })), e
                }(t);
            case "Point":
            case "LineString":
            case "Polygon":
            case "MultiPoint":
            case "MultiLineString":
            case "MultiPolygon":
            case "GeometryCollection":
                return Ie(t);
            default:
                throw new Error("unknown GeoJSON type")
            }
        }
        function Me(t) {
            var e = {
                type: "Feature"
            };
            return Object.keys(t).forEach((function(n) {
                switch (n) {
                case "type":
                case "properties":
                case "geometry":
                    return;
                default:
                    e[n] = t[n]
                }
            })), e.properties = Se(t.properties), e.geometry = Ie(t.geometry), e
        }
        function Se(t) {
            var e = {};
            return t ? (Object.keys(t).forEach((function(n) {
                var r = t[n];
                "object" == typeof r ? null === r ? e[n] = null : Array.isArray(r) ? e[n] = r.map((function(t) {
                    return t
                })) : e[n] = Se(r) : e[n] = r
            })), e) : e
        }
        function Ie(t) {
            var e = {
                type: t.type
            };
            return t.bbox && (e.bbox = t.bbox), "GeometryCollection" === t.type ? (e.geometries = t.geometries.map((function(t) {
                return Ie(t)
            })), e) : (e.coordinates = Te(t.coordinates), e)
        }
        function Te(t) {
            var e = t;
            return "object" != typeof e[0] ? e.slice() : e.map((function(t) {
                return Te(t)
            }))
        }
        function Pe(t, e) {
            if (void 0 === e && (e = {}), !T(e = e || {}))
                throw new Error("options is invalid");
            var n = e.mutate;
            if ("FeatureCollection" !== it(t))
                throw new Error("geojson must be a FeatureCollection");
            if (!t.features.length)
                throw new Error("geojson is empty");
            !1 !== n && void 0 !== n || (t = Ce(t));
            var r = [],
                i = H(t, (function(t, e) {
                    var n = function(t, e) {
                        var n,
                            r = t.geometry.coordinates,
                            i = e.geometry.coordinates,
                            o = Le(r[0]),
                            s = Le(r[r.length - 1]),
                            a = Le(i[0]),
                            u = Le(i[i.length - 1]);
                        if (o === u)
                            n = i.concat(r.slice(1));
                        else if (a === s)
                            n = r.concat(i.slice(1));
                        else if (o === a)
                            n = r.slice(1).reverse().concat(i);
                        else {
                            if (s !== u)
                                return null;
                            n = r.concat(i.reverse().slice(1))
                        }
                        return c(n)
                    }(t, e);
                    return n || (r.push(t), e)
                }));
            return i && r.push(i), r.length ? 1 === r.length ? r[0] : d(r.map((function(t) {
                return t.coordinates
            }))) : null
        }
        function Le(t) {
            return t[0].toString() + "," + t[1].toString()
        }
        function Oe(t) {
            return t
        }
        function Ne(t, e) {
            var n = function(t) {
                    if (null == t)
                        return Oe;
                    var e,
                        n,
                        r = t.scale[0],
                        i = t.scale[1],
                        o = t.translate[0],
                        s = t.translate[1];
                    return function(t, a) {
                        a || (e = n = 0);
                        var u = 2,
                            l = t.length,
                            h = new Array(l);
                        for (h[0] = (e += t[0]) * r + o, h[1] = (n += t[1]) * i + s; u < l;)
                            h[u] = t[u],
                            ++u;
                        return h
                    }
                }(t.transform),
                r = t.arcs;
            function i(t, e) {
                e.length && e.pop();
                for (var i = r[t < 0 ? ~t : t], o = 0, s = i.length; o < s; ++o)
                    e.push(n(i[o], o));
                t < 0 && function(t, e) {
                    for (var n, r = t.length, i = r - e; i < --r;)
                        n = t[i],
                        t[i++] = t[r],
                        t[r] = n
                }(e, s)
            }
            function o(t) {
                return n(t)
            }
            function s(t) {
                for (var e = [], n = 0, r = t.length; n < r; ++n)
                    i(t[n], e);
                return e.length < 2 && e.push(e[0]), e
            }
            function a(t) {
                for (var e = s(t); e.length < 4;)
                    e.push(e[0]);
                return e
            }
            function u(t) {
                return t.map(a)
            }
            return function t(e) {
                var n,
                    r = e.type;
                switch (r) {
                case "GeometryCollection":
                    return {
                        type: r,
                        geometries: e.geometries.map(t)
                    };
                case "Point":
                    n = o(e.coordinates);
                    break;
                case "MultiPoint":
                    n = e.coordinates.map(o);
                    break;
                case "LineString":
                    n = s(e.arcs);
                    break;
                case "MultiLineString":
                    n = e.arcs.map(s);
                    break;
                case "Polygon":
                    n = u(e.arcs);
                    break;
                case "MultiPolygon":
                    n = e.arcs.map(u);
                    break;
                default:
                    return null
                }
                return {
                    type: r,
                    coordinates: n
                }
            }(e)
        }
        function Re(t, e) {
            var n = {},
                r = {},
                i = {},
                o = [],
                s = -1;
            function a(t, e) {
                for (var r in t) {
                    var i = t[r];
                    delete e[i.start],
                    delete i.start,
                    delete i.end,
                    i.forEach((function(t) {
                        n[t < 0 ? ~t : t] = 1
                    })),
                    o.push(i)
                }
            }
            return e.forEach((function(n, r) {
                var i,
                    o = t.arcs[n < 0 ? ~n : n];
                o.length < 3 && !o[1][0] && !o[1][1] && (i = e[++s], e[s] = n, e[r] = i)
            })), e.forEach((function(e) {
                var n,
                    o,
                    s = function(e) {
                        var n,
                            r = t.arcs[e < 0 ? ~e : e],
                            i = r[0];
                        return t.transform ? (n = [0, 0], r.forEach((function(t) {
                            n[0] += t[0],
                            n[1] += t[1]
                        }))) : n = r[r.length - 1], e < 0 ? [n, i] : [i, n]
                    }(e),
                    a = s[0],
                    u = s[1];
                if (n = i[a])
                    if (delete i[n.end], n.push(e), n.end = u, o = r[u]) {
                        delete r[o.start];
                        var l = o === n ? n : n.concat(o);
                        r[l.start = n.start] = i[l.end = o.end] = l
                    } else
                        r[n.start] = i[n.end] = n;
                else if (n = r[u])
                    if (delete r[n.start], n.unshift(e), n.start = a, o = i[a]) {
                        delete i[o.end];
                        var h = o === n ? n : o.concat(n);
                        r[h.start = o.start] = i[h.end = n.end] = h
                    } else
                        r[n.start] = i[n.end] = n;
                else
                    r[(n = [e]).start = a] = i[n.end = u] = n
            })), a(i, r), a(r, i), e.forEach((function(t) {
                n[t < 0 ? ~t : t] || o.push([t])
            })), o
        }
        function Ae(t, e) {
            var n = {},
                r = [],
                i = [];
            function o(t) {
                t.forEach((function(e) {
                    e.forEach((function(e) {
                        (n[e = e < 0 ? ~e : e] || (n[e] = [])).push(t)
                    }))
                })),
                r.push(t)
            }
            function s(e) {
                return function(t) {
                    for (var e, n = -1, r = t.length, i = t[r - 1], o = 0; ++n < r;)
                        e = i,
                        i = t[n],
                        o += e[0] * i[1] - e[1] * i[0];
                    return Math.abs(o)
                }(Ne(t, {
                    type: "Polygon",
                    arcs: [e]
                }).coordinates[0])
            }
            return e.forEach((function t(e) {
                switch (e.type) {
                case "GeometryCollection":
                    e.geometries.forEach(t);
                    break;
                case "Polygon":
                    o(e.arcs);
                    break;
                case "MultiPolygon":
                    e.arcs.forEach(o)
                }
            })), r.forEach((function(t) {
                if (!t._) {
                    var e = [],
                        r = [t];
                    for (t._ = 1, i.push(e); t = r.pop();)
                        e.push(t),
                        t.forEach((function(t) {
                            t.forEach((function(t) {
                                n[t < 0 ? ~t : t].forEach((function(t) {
                                    t._ || (t._ = 1, r.push(t))
                                }))
                            }))
                        }))
                }
            })), r.forEach((function(t) {
                delete t._
            })), {
                type: "MultiPolygon",
                arcs: i.map((function(e) {
                    var r,
                        i = [];
                    if (e.forEach((function(t) {
                        t.forEach((function(t) {
                            t.forEach((function(t) {
                                n[t < 0 ? ~t : t].length < 2 && i.push(t)
                            }))
                        }))
                    })), (r = (i = Re(t, i)).length) > 1)
                        for (var o, a, u = 1, l = s(i[0]); u < r; ++u)
                            (o = s(i[u])) > l && (a = i[0], i[0] = i[u], i[u] = a, l = o);
                    return i
                })).filter((function(t) {
                    return t.length > 0
                }))
            }
        }
        var De = Object.prototype.hasOwnProperty;
        function Fe(t, e, n, r, i, o) {
            3 === arguments.length && (r = o = Array, i = null);
            for (var s = new r(t = 1 << Math.max(4, Math.ceil(Math.log(t) / Math.LN2))), a = new o(t), u = t - 1, l = 0; l < t; ++l)
                s[l] = i;
            function h(r, o) {
                for (var l = e(r) & u, h = s[l], c = 0; h != i;) {
                    if (n(h, r))
                        return a[l] = o;
                    if (++c >= t)
                        throw new Error("full hashmap");
                    h = s[l = l + 1 & u]
                }
                return s[l] = r, a[l] = o, o
            }
            function c(r, o) {
                for (var l = e(r) & u, h = s[l], c = 0; h != i;) {
                    if (n(h, r))
                        return a[l];
                    if (++c >= t)
                        throw new Error("full hashmap");
                    h = s[l = l + 1 & u]
                }
                return s[l] = r, a[l] = o, o
            }
            function p(r, o) {
                for (var l = e(r) & u, h = s[l], c = 0; h != i;) {
                    if (n(h, r))
                        return a[l];
                    if (++c >= t)
                        break;
                    h = s[l = l + 1 & u]
                }
                return o
            }
            function f() {
                for (var t = [], e = 0, n = s.length; e < n; ++e) {
                    var r = s[e];
                    r != i && t.push(r)
                }
                return t
            }
            return {
                set: h,
                maybeSet: c,
                get: p,
                keys: f
            }
        }
        function ke(t, e) {
            return t[0] === e[0] && t[1] === e[1]
        }
        var je = new ArrayBuffer(16),
            Ge = new Float64Array(je),
            Be = new Uint32Array(je);
        function qe(t) {
            Ge[0] = t[0],
            Ge[1] = t[1];
            var e = Be[0] ^ Be[1];
            return 2147483647 & (e << 5 ^ e >> 7 ^ Be[2] ^ Be[3])
        }
        function ze(t) {
            var e,
                n,
                r,
                i,
                o = t.coordinates,
                s = t.lines,
                a = t.rings,
                u = function() {
                    for (var t = Fe(1.4 * o.length, E, w, Int32Array, -1, Int32Array), e = new Int32Array(o.length), n = 0, r = o.length; n < r; ++n)
                        e[n] = t.maybeSet(n, n);
                    return e
                }(),
                l = new Int32Array(o.length),
                h = new Int32Array(o.length),
                c = new Int32Array(o.length),
                p = new Int8Array(o.length),
                f = 0;
            for (e = 0, n = o.length; e < n; ++e)
                l[e] = h[e] = c[e] = -1;
            for (e = 0, n = s.length; e < n; ++e) {
                var d = s[e],
                    g = d[0],
                    y = d[1];
                for (r = u[g], i = u[++g], ++f, p[r] = 1; ++g <= y;)
                    x(e, r, r = i, i = u[g]);
                ++f,
                p[i] = 1
            }
            for (e = 0, n = o.length; e < n; ++e)
                l[e] = -1;
            for (e = 0, n = a.length; e < n; ++e) {
                var v = a[e],
                    m = v[0] + 1,
                    _ = v[1];
                for (x(e, u[_ - 1], r = u[m - 1], i = u[m]); ++m <= _;)
                    x(e, r, r = i, i = u[m])
            }
            function x(t, e, n, r) {
                if (l[n] !== t) {
                    l[n] = t;
                    var i = h[n];
                    if (i >= 0) {
                        var o = c[n];
                        i === e && o === r || i === r && o === e || (++f, p[n] = 1)
                    } else
                        h[n] = e,
                        c[n] = r
                }
            }
            function E(t) {
                return qe(o[t])
            }
            function w(t, e) {
                return ke(o[t], o[e])
            }
            l = h = c = null;
            var b,
                C = function(t, e, n, r, i) {
                    3 === arguments.length && (r = Array, i = null);
                    for (var o = new r(t = 1 << Math.max(4, Math.ceil(Math.log(t) / Math.LN2))), s = t - 1, a = 0; a < t; ++a)
                        o[a] = i;
                    function u(r) {
                        for (var a = e(r) & s, u = o[a], l = 0; u != i;) {
                            if (n(u, r))
                                return !0;
                            if (++l >= t)
                                throw new Error("full hashset");
                            u = o[a = a + 1 & s]
                        }
                        return o[a] = r, !0
                    }
                    function l(r) {
                        for (var a = e(r) & s, u = o[a], l = 0; u != i;) {
                            if (n(u, r))
                                return !0;
                            if (++l >= t)
                                break;
                            u = o[a = a + 1 & s]
                        }
                        return !1
                    }
                    function h() {
                        for (var t = [], e = 0, n = o.length; e < n; ++e) {
                            var r = o[e];
                            r != i && t.push(r)
                        }
                        return t
                    }
                    return {
                        add: u,
                        has: l,
                        values: h
                    }
                }(1.4 * f, qe, ke);
            for (e = 0, n = o.length; e < n; ++e)
                p[b = u[e]] && C.add(o[b]);
            return C
        }
        function Ue(t, e, n, r) {
            Ve(t, e, n),
            Ve(t, e, e + r),
            Ve(t, e + r, n)
        }
        function Ve(t, e, n) {
            for (var r, i = e + (n-- - e >> 1); e < i; ++e, --n)
                r = t[e],
                t[e] = t[n],
                t[n] = r
        }
        function Xe(t) {
            var e,
                n,
                r = {};
            for (e in t)
                r[e] = null == (n = t[e]) ? {
                    type: null
                } : ("FeatureCollection" === n.type ? He : "Feature" === n.type ? Ye : We)(n);
            return r
        }
        function He(t) {
            var e = {
                type: "GeometryCollection",
                geometries: t.features.map(Ye)
            };
            return null != t.bbox && (e.bbox = t.bbox), e
        }
        function Ye(t) {
            var e,
                n = We(t.geometry);
            for (e in null != t.id && (n.id = t.id), null != t.bbox && (n.bbox = t.bbox), t.properties) {
                n.properties = t.properties;
                break
            }
            return n
        }
        function We(t) {
            if (null == t)
                return {
                    type: null
                };
            var e = "GeometryCollection" === t.type ? {
                type: "GeometryCollection",
                geometries: t.geometries.map(We)
            } : "Point" === t.type || "MultiPoint" === t.type ? {
                type: t.type,
                coordinates: t.coordinates
            } : {
                type: t.type,
                arcs: t.coordinates
            };
            return null != t.bbox && (e.bbox = t.bbox), e
        }
        function $e(t, e) {
            var n = function(t) {
                    var e = 1 / 0,
                        n = 1 / 0,
                        r = -1 / 0,
                        i = -1 / 0;
                    function o(t) {
                        null != t && De.call(s, t.type) && s[t.type](t)
                    }
                    var s = {
                        GeometryCollection: function(t) {
                            t.geometries.forEach(o)
                        },
                        Point: function(t) {
                            a(t.coordinates)
                        },
                        MultiPoint: function(t) {
                            t.coordinates.forEach(a)
                        },
                        LineString: function(t) {
                            u(t.arcs)
                        },
                        MultiLineString: function(t) {
                            t.arcs.forEach(u)
                        },
                        Polygon: function(t) {
                            t.arcs.forEach(u)
                        },
                        MultiPolygon: function(t) {
                            t.arcs.forEach(l)
                        }
                    };
                    function a(t) {
                        var o = t[0],
                            s = t[1];
                        o < e && (e = o),
                        o > r && (r = o),
                        s < n && (n = s),
                        s > i && (i = s)
                    }
                    function u(t) {
                        t.forEach(a)
                    }
                    function l(t) {
                        t.forEach(u)
                    }
                    for (var h in t)
                        o(t[h]);
                    return r >= e && i >= n ? [e, n, r, i] : void 0
                }(t = Xe(t)),
                r = e > 0 && n && function(t, e, n) {
                    var r = e[0],
                        i = e[1],
                        o = e[2],
                        s = e[3],
                        a = o - r ? (n - 1) / (o - r) : 1,
                        u = s - i ? (n - 1) / (s - i) : 1;
                    function l(t) {
                        return [Math.round((t[0] - r) * a), Math.round((t[1] - i) * u)]
                    }
                    function h(t, e) {
                        for (var n, o, s, l, h, c = -1, p = 0, f = t.length, d = new Array(f); ++c < f;)
                            n = t[c],
                            l = Math.round((n[0] - r) * a),
                            h = Math.round((n[1] - i) * u),
                            l === o && h === s || (d[p++] = [o = l, s = h]);
                        for (d.length = p; p < e;)
                            p = d.push([d[0][0], d[0][1]]);
                        return d
                    }
                    function c(t) {
                        return h(t, 2)
                    }
                    function p(t) {
                        return h(t, 4)
                    }
                    function f(t) {
                        return t.map(p)
                    }
                    function d(t) {
                        null != t && De.call(g, t.type) && g[t.type](t)
                    }
                    var g = {
                        GeometryCollection: function(t) {
                            t.geometries.forEach(d)
                        },
                        Point: function(t) {
                            t.coordinates = l(t.coordinates)
                        },
                        MultiPoint: function(t) {
                            t.coordinates = t.coordinates.map(l)
                        },
                        LineString: function(t) {
                            t.arcs = c(t.arcs)
                        },
                        MultiLineString: function(t) {
                            t.arcs = t.arcs.map(c)
                        },
                        Polygon: function(t) {
                            t.arcs = f(t.arcs)
                        },
                        MultiPolygon: function(t) {
                            t.arcs = t.arcs.map(f)
                        }
                    };
                    for (var y in t)
                        d(t[y]);
                    return {
                        scale: [1 / a, 1 / u],
                        translate: [r, i]
                    }
                }(t, n, e),
                i = function(t) {
                    var e,
                        n,
                        r,
                        i,
                        o = t.coordinates,
                        s = t.lines,
                        a = t.rings,
                        u = s.length + a.length;
                    for (delete t.lines, delete t.rings, r = 0, i = s.length; r < i; ++r)
                        for (e = s[r]; e = e.next;)
                            ++u;
                    for (r = 0, i = a.length; r < i; ++r)
                        for (n = a[r]; n = n.next;)
                            ++u;
                    var l = Fe(2 * u * 1.4, qe, ke),
                        h = t.arcs = [];
                    for (r = 0, i = s.length; r < i; ++r) {
                        e = s[r];
                        do {
                            c(e)
                        } while (e = e.next)
                    }
                    for (r = 0, i = a.length; r < i; ++r)
                        if ((n = a[r]).next)
                            do {
                                c(n)
                            } while (n = n.next);
                        else
                            p(n);
                    function c(t) {
                        var e,
                            n,
                            r,
                            i,
                            s,
                            a,
                            u,
                            c;
                        if (r = l.get(e = o[t[0]]))
                            for (u = 0, c = r.length; u < c; ++u)
                                if (f(i = r[u], t))
                                    return t[0] = i[0], void (t[1] = i[1]);
                        if (s = l.get(n = o[t[1]]))
                            for (u = 0, c = s.length; u < c; ++u)
                                if (d(a = s[u], t))
                                    return t[1] = a[0], void (t[0] = a[1]);
                        r ? r.push(t) : l.set(e, [t]),
                        s ? s.push(t) : l.set(n, [t]),
                        h.push(t)
                    }
                    function p(t) {
                        var e,
                            n,
                            r,
                            i,
                            s;
                        if (n = l.get(o[t[0]]))
                            for (i = 0, s = n.length; i < s; ++i) {
                                if (g(r = n[i], t))
                                    return t[0] = r[0], void (t[1] = r[1]);
                                if (y(r, t))
                                    return t[0] = r[1], void (t[1] = r[0])
                            }
                        if (n = l.get(e = o[t[0] + v(t)]))
                            for (i = 0, s = n.length; i < s; ++i) {
                                if (g(r = n[i], t))
                                    return t[0] = r[0], void (t[1] = r[1]);
                                if (y(r, t))
                                    return t[0] = r[1], void (t[1] = r[0])
                            }
                        n ? n.push(t) : l.set(e, [t]),
                        h.push(t)
                    }
                    function f(t, e) {
                        var n = t[0],
                            r = e[0],
                            i = t[1];
                        if (n - i != r - e[1])
                            return !1;
                        for (; n <= i; ++n, ++r)
                            if (!ke(o[n], o[r]))
                                return !1;
                        return !0
                    }
                    function d(t, e) {
                        var n = t[0],
                            r = e[0],
                            i = t[1],
                            s = e[1];
                        if (n - i != r - s)
                            return !1;
                        for (; n <= i; ++n, --s)
                            if (!ke(o[n], o[s]))
                                return !1;
                        return !0
                    }
                    function g(t, e) {
                        var n = t[0],
                            r = e[0],
                            i = t[1] - n;
                        if (i !== e[1] - r)
                            return !1;
                        for (var s = v(t), a = v(e), u = 0; u < i; ++u)
                            if (!ke(o[n + (u + s) % i], o[r + (u + a) % i]))
                                return !1;
                        return !0
                    }
                    function y(t, e) {
                        var n = t[0],
                            r = e[0],
                            i = t[1],
                            s = e[1],
                            a = i - n;
                        if (a !== s - r)
                            return !1;
                        for (var u = v(t), l = a - v(e), h = 0; h < a; ++h)
                            if (!ke(o[n + (h + u) % a], o[s - (h + l) % a]))
                                return !1;
                        return !0
                    }
                    function v(t) {
                        for (var e = t[0], n = t[1], r = e, i = r, s = o[r]; ++r < n;) {
                            var a = o[r];
                            (a[0] < s[0] || a[0] === s[0] && a[1] < s[1]) && (i = r, s = a)
                        }
                        return i - e
                    }
                    return t
                }(function(t) {
                    var e,
                        n,
                        r,
                        i = ze(t),
                        o = t.coordinates,
                        s = t.lines,
                        a = t.rings;
                    for (n = 0, r = s.length; n < r; ++n)
                        for (var u = s[n], l = u[0], h = u[1]; ++l < h;)
                            i.has(o[l]) && (e = {
                                0: l,
                                1: u[1]
                            }, u[1] = l, u = u.next = e);
                    for (n = 0, r = a.length; n < r; ++n)
                        for (var c = a[n], p = c[0], f = p, d = c[1], g = i.has(o[p]); ++f < d;)
                            i.has(o[f]) && (g ? (e = {
                                0: f,
                                1: c[1]
                            }, c[1] = f, c = c.next = e) : (Ue(o, p, d, d - f), o[d] = o[p], g = !0, f = p));
                    return t
                }(function(t) {
                    var e = -1,
                        n = [],
                        r = [],
                        i = [];
                    function o(t) {
                        t && De.call(s, t.type) && s[t.type](t)
                    }
                    var s = {
                        GeometryCollection: function(t) {
                            t.geometries.forEach(o)
                        },
                        LineString: function(t) {
                            t.arcs = a(t.arcs)
                        },
                        MultiLineString: function(t) {
                            t.arcs = t.arcs.map(a)
                        },
                        Polygon: function(t) {
                            t.arcs = t.arcs.map(u)
                        },
                        MultiPolygon: function(t) {
                            t.arcs = t.arcs.map(l)
                        }
                    };
                    function a(t) {
                        for (var r = 0, o = t.length; r < o; ++r)
                            i[++e] = t[r];
                        var s = {
                            0: e - o + 1,
                            1: e
                        };
                        return n.push(s), s
                    }
                    function u(t) {
                        for (var n = 0, o = t.length; n < o; ++n)
                            i[++e] = t[n];
                        var s = {
                            0: e - o + 1,
                            1: e
                        };
                        return r.push(s), s
                    }
                    function l(t) {
                        return t.map(u)
                    }
                    for (var h in t)
                        o(t[h]);
                    return {
                        type: "Topology",
                        coordinates: i,
                        lines: n,
                        rings: r,
                        objects: t
                    }
                }(t))),
                o = i.coordinates,
                s = Fe(1.4 * i.arcs.length, Ke, Ze);
            function a(t) {
                t && De.call(u, t.type) && u[t.type](t)
            }
            t = i.objects,
            i.bbox = n,
            i.arcs = i.arcs.map((function(t, e) {
                return s.set(t, e), o.slice(t[0], t[1] + 1)
            })),
            delete i.coordinates,
            o = null;
            var u = {
                GeometryCollection: function(t) {
                    t.geometries.forEach(a)
                },
                LineString: function(t) {
                    t.arcs = l(t.arcs)
                },
                MultiLineString: function(t) {
                    t.arcs = t.arcs.map(l)
                },
                Polygon: function(t) {
                    t.arcs = t.arcs.map(l)
                },
                MultiPolygon: function(t) {
                    t.arcs = t.arcs.map(h)
                }
            };
            function l(t) {
                var e = [];
                do {
                    var n = s.get(t);
                    e.push(t[0] < t[1] ? n : ~n)
                } while (t = t.next);
                return e
            }
            function h(t) {
                return t.map(l)
            }
            for (var c in t)
                a(t[c]);
            return r && (i.transform = r, i.arcs = function(t) {
                for (var e = -1, n = t.length; ++e < n;) {
                    for (var r, i, o = t[e], s = 0, a = 1, u = o.length, l = o[0], h = l[0], c = l[1]; ++s < u;)
                        r = (l = o[s])[0],
                        i = l[1],
                        r === h && i === c || (o[a++] = [r - h, i - c], h = r, c = i);
                    1 === a && (o[a++] = [0, 0]),
                    o.length = a
                }
                return t
            }(i.arcs)), i
        }
        function Ke(t) {
            var e,
                n = t[0],
                r = t[1];
            return r < n && (e = n, n = r, r = e), n + 31 * r
        }
        function Ze(t, e) {
            var n,
                r = t[0],
                i = t[1],
                o = e[0],
                s = e[1];
            return i < r && (n = r, r = i, i = n), s < o && (n = o, o = s, s = n), r === o && i === s
        }
        function Je(t, e) {
            if (void 0 === e && (e = {}), "FeatureCollection" !== it(t))
                throw new Error("geojson must be a FeatureCollection");
            if (!t.features.length)
                throw new Error("geojson is empty");
            !1 !== e.mutate && void 0 !== e.mutate || (t = Ce(t));
            var n = [];
            q(t, (function(t) {
                n.push(t.geometry)
            }));
            var r = $e({
                geoms: v(n).geometry
            });
            return function(t) {
                return Ne(t, Ae.apply(this, arguments))
            }(r, r.objects.geoms.geometries)
        }
        function Qe(t, e) {
            if (void 0 === e && (e = {}), !T(e = e || {}))
                throw new Error("options is invalid");
            var n = e.mutate;
            if ("FeatureCollection" !== it(t))
                throw new Error("geojson must be a FeatureCollection");
            if (!t.features.length)
                throw new Error("geojson is empty");
            !1 !== n && void 0 !== n || (t = Ce(t));
            var r = function(t) {
                var e = {};
                q(t, (function(t) {
                    e[t.geometry.type] = !0
                }));
                var n = Object.keys(e);
                return 1 === n.length ? n[0] : null
            }(t);
            if (!r)
                throw new Error("geojson must be homogenous");
            var i = t;
            switch (r) {
            case "LineString":
                return Pe(i, e);
            case "Polygon":
                return Je(i, e);
            default:
                throw new Error(r + " is not supported")
            }
        }
        function tn(t, e) {
            void 0 === e && (e = {});
            var n = "object" == typeof e ? e.mutate : e;
            if (!t)
                throw new Error("geojson is required");
            var r = it(t),
                i = [];
            switch (r) {
            case "LineString":
                i = en(t);
                break;
            case "MultiLineString":
            case "Polygon":
                J(t).forEach((function(t) {
                    i.push(en(t))
                }));
                break;
            case "MultiPolygon":
                J(t).forEach((function(t) {
                    var e = [];
                    t.forEach((function(t) {
                        e.push(en(t))
                    })),
                    i.push(e)
                }));
                break;
            case "Point":
                return t;
            case "MultiPoint":
                var s = {};
                J(t).forEach((function(t) {
                    var e = t.join("-");
                    Object.prototype.hasOwnProperty.call(s, e) || (i.push(t), s[e] = !0)
                }));
                break;
            default:
                throw new Error(r + " geometry not supported")
            }
            return t.coordinates ? !0 === n ? (t.coordinates = i, t) : {
                type: r,
                coordinates: i
            } : !0 === n ? (t.geometry.coordinates = i, t) : o({
                type: r,
                coordinates: i
            }, t.properties, {
                bbox: t.bbox,
                id: t.id
            })
        }
        function en(t) {
            var e = J(t);
            if (2 === e.length && !nn(e[0], e[1]))
                return e;
            var n = [],
                r = e.length - 1,
                i = n.length;
            n.push(e[0]);
            for (var o = 1; o < r; o++) {
                var s = n[n.length - 1];
                e[o][0] === s[0] && e[o][1] === s[1] || (n.push(e[o]), (i = n.length) > 2 && rn(n[i - 3], n[i - 1], n[i - 2]) && n.splice(n.length - 2, 1))
            }
            if (n.push(e[e.length - 1]), i = n.length, nn(e[0], e[e.length - 1]) && i < 4)
                throw new Error("invalid polygon");
            return rn(n[i - 3], n[i - 1], n[i - 2]) && n.splice(n.length - 2, 1), n
        }
        function nn(t, e) {
            return t[0] === e[0] && t[1] === e[1]
        }
        function rn(t, e, n) {
            var r = n[0],
                i = n[1],
                o = t[0],
                s = t[1],
                a = e[0],
                u = e[1],
                l = a - o,
                h = u - s;
            return 0 == (r - o) * h - (i - s) * l && (Math.abs(l) >= Math.abs(h) ? l > 0 ? o <= r && r <= a : a <= r && r <= o : h > 0 ? s <= i && i <= u : u <= i && i <= s)
        }
        function on(t, e, n) {
            var r = e.x,
                i = e.y,
                o = n.x - r,
                s = n.y - i;
            if (0 !== o || 0 !== s) {
                var a = ((t.x - r) * o + (t.y - i) * s) / (o * o + s * s);
                a > 1 ? (r = n.x, i = n.y) : a > 0 && (r += o * a, i += s * a)
            }
            return (o = t.x - r) * o + (s = t.y - i) * s
        }
        function sn(t, e, n, r, i) {
            for (var o, s = r, a = e + 1; a < n; a++) {
                var u = on(t[a], t[e], t[n]);
                u > s && (o = a, s = u)
            }
            s > r && (o - e > 1 && sn(t, e, o, r, i), i.push(t[o]), n - o > 1 && sn(t, o, n, r, i))
        }
        function an(t, e) {
            var n = t.length - 1,
                r = [t[0]];
            return sn(t, 0, n, e, r), r.push(t[n]), r
        }
        function un(t, e, n) {
            if (t.length <= 2)
                return t;
            var r = void 0 !== e ? e * e : 1;
            return an(t = n ? t : function(t, e) {
                for (var n, r, i, o, s, a = t[0], u = [a], l = 1, h = t.length; l < h; l++)
                    i = a,
                    o = void 0,
                    s = void 0,
                    (o = (r = n = t[l]).x - i.x) * o + (s = r.y - i.y) * s > e && (u.push(n), a = n);
                return a !== n && u.push(n), u
            }(t, r), r)
        }
        function ln(t, e, n) {
            return un(t.map((function(t) {
                return {
                    x: t[0],
                    y: t[1],
                    z: t[2]
                }
            })), e, n).map((function(t) {
                return t.z ? [t.x, t.y, t.z] : [t.x, t.y]
            }))
        }
        function hn(t, e, n) {
            return t.map((function(t) {
                var r = t.map((function(t) {
                    return {
                        x: t[0],
                        y: t[1]
                    }
                }));
                if (r.length < 4)
                    throw new Error("invalid polygon");
                for (var i = un(r, e, n).map((function(t) {
                    return [t.x, t.y]
                })); !cn(i);)
                    i = un(r, e -= .01 * e, n).map((function(t) {
                        return [t.x, t.y]
                    }));
                return i[i.length - 1][0] === i[0][0] && i[i.length - 1][1] === i[0][1] || i.push(i[0]), i
            }))
        }
        function cn(t) {
            return !(t.length < 3 || 3 === t.length && t[2][0] === t[0][0] && t[2][1] === t[0][1])
        }
        var pn = function() {
            function t(t) {
                this.points = t.points || [],
                this.duration = t.duration || 1e4,
                this.sharpness = t.sharpness || .85,
                this.centers = [],
                this.controls = [],
                this.stepLength = t.stepLength || 60,
                this.length = this.points.length,
                this.delay = 0;
                for (var e = 0; e < this.length; e++)
                    this.points[e].z = this.points[e].z || 0;
                for (e = 0; e < this.length - 1; e++) {
                    var n = this.points[e],
                        r = this.points[e + 1];
                    this.centers.push({
                        x: (n.x + r.x) / 2,
                        y: (n.y + r.y) / 2,
                        z: (n.z + r.z) / 2
                    })
                }
                for (this.controls.push([this.points[0], this.points[0]]), e = 0; e < this.centers.length - 1; e++) {
                    var i = this.points[e + 1].x - (this.centers[e].x + this.centers[e + 1].x) / 2,
                        o = this.points[e + 1].y - (this.centers[e].y + this.centers[e + 1].y) / 2,
                        s = this.points[e + 1].z - (this.centers[e].y + this.centers[e + 1].z) / 2;
                    this.controls.push([{
                        x: (1 - this.sharpness) * this.points[e + 1].x + this.sharpness * (this.centers[e].x + i),
                        y: (1 - this.sharpness) * this.points[e + 1].y + this.sharpness * (this.centers[e].y + o),
                        z: (1 - this.sharpness) * this.points[e + 1].z + this.sharpness * (this.centers[e].z + s)
                    }, {
                        x: (1 - this.sharpness) * this.points[e + 1].x + this.sharpness * (this.centers[e + 1].x + i),
                        y: (1 - this.sharpness) * this.points[e + 1].y + this.sharpness * (this.centers[e + 1].y + o),
                        z: (1 - this.sharpness) * this.points[e + 1].z + this.sharpness * (this.centers[e + 1].z + s)
                    }])
                }
                return this.controls.push([this.points[this.length - 1], this.points[this.length - 1]]), this.steps = this.cacheSteps(this.stepLength), this
            }
            return t.prototype.cacheSteps = function(t) {
                var e = [],
                    n = this.pos(0);
                e.push(0);
                for (var r = 0; r < this.duration; r += 10) {
                    var i = this.pos(r);
                    Math.sqrt((i.x - n.x) * (i.x - n.x) + (i.y - n.y) * (i.y - n.y) + (i.z - n.z) * (i.z - n.z)) > t && (e.push(r), n = i)
                }
                return e
            }, t.prototype.vector = function(t) {
                var e = this.pos(t + 10),
                    n = this.pos(t - 10);
                return {
                    angle: 180 * Math.atan2(e.y - n.y, e.x - n.x) / 3.14,
                    speed: Math.sqrt((n.x - e.x) * (n.x - e.x) + (n.y - e.y) * (n.y - e.y) + (n.z - e.z) * (n.z - e.z))
                }
            }, t.prototype.pos = function(t) {
                var e = t - this.delay;
                e < 0 && (e = 0),
                e > this.duration && (e = this.duration - 1);
                var n = e / this.duration;
                if (n >= 1)
                    return this.points[this.length - 1];
                var r = Math.floor((this.points.length - 1) * n);
                return function(t, e, n, r, i) {
                    var o = function(t) {
                        var e = t * t;
                        return [e * t, 3 * e * (1 - t), 3 * t * (1 - t) * (1 - t), (1 - t) * (1 - t) * (1 - t)]
                    }(t);
                    return {
                        x: i.x * o[0] + r.x * o[1] + n.x * o[2] + e.x * o[3],
                        y: i.y * o[0] + r.y * o[1] + n.y * o[2] + e.y * o[3],
                        z: i.z * o[0] + r.z * o[1] + n.z * o[2] + e.z * o[3]
                    }
                }((this.length - 1) * n - r, this.points[r], this.controls[r][1], this.controls[r + 1][0], this.points[r + 1])
            }, t
        }();
        function fn(t, e) {
            void 0 === e && (e = {});
            for (var n = e.resolution || 1e4, r = e.sharpness || .85, i = [], o = rt(t).coordinates.map((function(t) {
                    return {
                        x: t[0],
                        y: t[1]
                    }
                })), s = new pn({
                    duration: n,
                    points: o,
                    sharpness: r
                }), a = function(t) {
                    var e = s.pos(t);
                    Math.floor(t / 100) % 2 == 0 && i.push([e.x, e.y])
                }, u = 0; u < s.duration; u += 10)
                a(u);
            return a(s.duration), c(i, e.properties)
        }
        function dn(t, e) {
            void 0 === e && (e = {});
            var n = Number(t[0]),
                r = Number(t[1]),
                i = Number(t[2]),
                o = Number(t[3]);
            if (6 === t.length)
                throw new Error("@turf/bbox-polygon does not support BBox with 6 positions");
            var s = [n, r];
            return l([[s, [i, r], [i, o], [n, o], s]], e.properties, {
                bbox: t,
                id: e.id
            })
        }
        function gn(t) {
            return dn(K(t))
        }
        function yn(t) {
            var e = t[0],
                n = t[1],
                r = t[2],
                i = t[3];
            if (_e(t.slice(0, 2), [r, n]) >= _e(t.slice(0, 2), [e, i])) {
                var o = (n + i) / 2;
                return [e, o - (r - e) / 2, r, o + (r - e) / 2]
            }
            var s = (e + r) / 2;
            return [s - (i - n) / 2, n, s + (i - n) / 2, i]
        }
        function vn(t, e, n, r) {
            void 0 === r && (r = {});
            var i = Z(t),
                o = C(i[0]),
                s = C(i[1]),
                u = C(n),
                l = x(e, r.units),
                h = Math.asin(Math.sin(s) * Math.cos(l) + Math.cos(s) * Math.sin(l) * Math.cos(u));
            return a([b(o + Math.atan2(Math.sin(u) * Math.sin(l) * Math.cos(s), Math.cos(l) - Math.sin(s) * Math.sin(h))), b(h)], r.properties)
        }
        function mn(t, e, n) {
            void 0 === n && (n = {});
            for (var r = n.steps || 64, i = n.properties ? n.properties : !Array.isArray(t) && "Feature" === t.type && t.properties ? t.properties : {}, o = [], s = 0; s < r; s++)
                o.push(vn(t, e, -360 * s / r, n).geometry.coordinates);
            return o.push(o[0]), l([o], i)
        }
        function _n(t, e, n) {
            if (void 0 === n && (n = {}), !0 === n.final)
                return function(t, e) {
                    var n = _n(e, t);
                    return (n + 180) % 360
                }(t, e);
            var r = Z(t),
                i = Z(e),
                o = C(r[0]),
                s = C(i[0]),
                a = C(r[1]),
                u = C(i[1]),
                l = Math.sin(s - o) * Math.cos(u),
                h = Math.cos(a) * Math.sin(u) - Math.sin(a) * Math.cos(u) * Math.cos(s - o);
            return b(Math.atan2(l, h))
        }
        function xn(t, e) {
            void 0 === e && (e = {});
            var n = K(t);
            return a([(n[0] + n[2]) / 2, (n[1] + n[3]) / 2], e.properties, e)
        }
        function En(t, e) {
            void 0 === e && (e = {});
            var n = 0,
                r = 0,
                i = 0;
            return N(t, (function(t) {
                n += t[0],
                r += t[1],
                i++
            }), !0), a([n / i, r / i], e.properties)
        }
        function wn(t) {
            var e = [];
            return "FeatureCollection" === t.type ? F(t, (function(t) {
                N(t, (function(n) {
                    e.push(a(n, t.properties))
                }))
            })) : N(t, (function(n) {
                e.push(a(n, t.properties))
            })), f(e)
        }
        var bn = Mn,
            Cn = Mn;
        function Mn(t, e, n) {
            n = n || 2;
            var r,
                i,
                o,
                s,
                a,
                u,
                l,
                h = e && e.length,
                c = h ? e[0] * n : t.length,
                p = Sn(t, 0, c, n, !0),
                f = [];
            if (!p)
                return f;
            if (h && (p = function(t, e, n, r) {
                var i,
                    o,
                    s,
                    a = [];
                for (i = 0, o = e.length; i < o; i++)
                    (s = Sn(t, e[i] * r, i < o - 1 ? e[i + 1] * r : t.length, r, !1)) === s.next && (s.steiner = !0),
                    a.push(Fn(s));
                for (a.sort(Rn), i = 0; i < a.length; i++)
                    An(a[i], n),
                    n = In(n, n.next);
                return n
            }(t, e, p, n)), t.length > 80 * n) {
                r = o = t[0],
                i = s = t[1];
                for (var d = n; d < c; d += n)
                    (a = t[d]) < r && (r = a),
                    (u = t[d + 1]) < i && (i = u),
                    a > o && (o = a),
                    u > s && (s = u);
                l = 0 !== (l = Math.max(o - r, s - i)) ? 1 / l : 0
            }
            return Tn(p, f, n, r, i, l), f
        }
        function Sn(t, e, n, r, i) {
            var o,
                s;
            if (i === Yn(t, e, n, r) > 0)
                for (o = e; o < n; o += r)
                    s = Vn(o, t[o], t[o + 1], s);
            else
                for (o = n - r; o >= e; o -= r)
                    s = Vn(o, t[o], t[o + 1], s);
            return s && Bn(s, s.next) && (Xn(s), s = s.next), s
        }
        function In(t, e) {
            if (!t)
                return t;
            e || (e = t);
            var n,
                r = t;
            do {
                if (n = !1, r.steiner || !Bn(r, r.next) && 0 !== Gn(r.prev, r, r.next))
                    r = r.next;
                else {
                    if (Xn(r), (r = e = r.prev) === r.next)
                        break;
                    n = !0
                }
            } while (n || r !== e);
            return e
        }
        function Tn(t, e, n, r, i, o, s) {
            if (t) {
                !s && o && function(t, e, n, r) {
                    var i = t;
                    do {
                        null === i.z && (i.z = Dn(i.x, i.y, e, n, r)),
                        i.prevZ = i.prev,
                        i.nextZ = i.next,
                        i = i.next
                    } while (i !== t);
                    i.prevZ.nextZ = null,
                    i.prevZ = null,
                    function(t) {
                        var e,
                            n,
                            r,
                            i,
                            o,
                            s,
                            a,
                            u,
                            l = 1;
                        do {
                            for (n = t, t = null, o = null, s = 0; n;) {
                                for (s++, r = n, a = 0, e = 0; e < l && (a++, r = r.nextZ); e++)
                                    ;
                                for (u = l; a > 0 || u > 0 && r;)
                                    0 !== a && (0 === u || !r || n.z <= r.z) ? (i = n, n = n.nextZ, a--) : (i = r, r = r.nextZ, u--),
                                    o ? o.nextZ = i : t = i,
                                    i.prevZ = o,
                                    o = i;
                                n = r
                            }
                            o.nextZ = null,
                            l *= 2
                        } while (s > 1)
                    }(i)
                }(t, r, i, o);
                for (var a, u, l = t; t.prev !== t.next;)
                    if (a = t.prev, u = t.next, o ? Ln(t, r, i, o) : Pn(t))
                        e.push(a.i / n),
                        e.push(t.i / n),
                        e.push(u.i / n),
                        Xn(t),
                        t = u.next,
                        l = u.next;
                    else if ((t = u) === l) {
                        s ? 1 === s ? Tn(t = On(t, e, n), e, n, r, i, o, 2) : 2 === s && Nn(t, e, n, r, i, o) : Tn(In(t), e, n, r, i, o, 1);
                        break
                    }
            }
        }
        function Pn(t) {
            var e = t.prev,
                n = t,
                r = t.next;
            if (Gn(e, n, r) >= 0)
                return !1;
            for (var i = t.next.next; i !== t.prev;) {
                if (kn(e.x, e.y, n.x, n.y, r.x, r.y, i.x, i.y) && Gn(i.prev, i, i.next) >= 0)
                    return !1;
                i = i.next
            }
            return !0
        }
        function Ln(t, e, n, r) {
            var i = t.prev,
                o = t,
                s = t.next;
            if (Gn(i, o, s) >= 0)
                return !1;
            for (var a = i.x < o.x ? i.x < s.x ? i.x : s.x : o.x < s.x ? o.x : s.x, u = i.y < o.y ? i.y < s.y ? i.y : s.y : o.y < s.y ? o.y : s.y, l = i.x > o.x ? i.x > s.x ? i.x : s.x : o.x > s.x ? o.x : s.x, h = i.y > o.y ? i.y > s.y ? i.y : s.y : o.y > s.y ? o.y : s.y, c = Dn(a, u, e, n, r), p = Dn(l, h, e, n, r), f = t.prevZ, d = t.nextZ; f && f.z >= c && d && d.z <= p;) {
                if (f !== t.prev && f !== t.next && kn(i.x, i.y, o.x, o.y, s.x, s.y, f.x, f.y) && Gn(f.prev, f, f.next) >= 0)
                    return !1;
                if (f = f.prevZ, d !== t.prev && d !== t.next && kn(i.x, i.y, o.x, o.y, s.x, s.y, d.x, d.y) && Gn(d.prev, d, d.next) >= 0)
                    return !1;
                d = d.nextZ
            }
            for (; f && f.z >= c;) {
                if (f !== t.prev && f !== t.next && kn(i.x, i.y, o.x, o.y, s.x, s.y, f.x, f.y) && Gn(f.prev, f, f.next) >= 0)
                    return !1;
                f = f.prevZ
            }
            for (; d && d.z <= p;) {
                if (d !== t.prev && d !== t.next && kn(i.x, i.y, o.x, o.y, s.x, s.y, d.x, d.y) && Gn(d.prev, d, d.next) >= 0)
                    return !1;
                d = d.nextZ
            }
            return !0
        }
        function On(t, e, n) {
            var r = t;
            do {
                var i = r.prev,
                    o = r.next.next;
                !Bn(i, o) && qn(i, r, r.next, o) && zn(i, o) && zn(o, i) && (e.push(i.i / n), e.push(r.i / n), e.push(o.i / n), Xn(r), Xn(r.next), r = t = o),
                r = r.next
            } while (r !== t);
            return r
        }
        function Nn(t, e, n, r, i, o) {
            var s = t;
            do {
                for (var a = s.next.next; a !== s.prev;) {
                    if (s.i !== a.i && jn(s, a)) {
                        var u = Un(s, a);
                        return s = In(s, s.next), u = In(u, u.next), Tn(s, e, n, r, i, o), void Tn(u, e, n, r, i, o)
                    }
                    a = a.next
                }
                s = s.next
            } while (s !== t)
        }
        function Rn(t, e) {
            return t.x - e.x
        }
        function An(t, e) {
            if (e = function(t, e) {
                var n,
                    r = e,
                    i = t.x,
                    o = t.y,
                    s = -1 / 0;
                do {
                    if (o <= r.y && o >= r.next.y && r.next.y !== r.y) {
                        var a = r.x + (o - r.y) * (r.next.x - r.x) / (r.next.y - r.y);
                        if (a <= i && a > s) {
                            if (s = a, a === i) {
                                if (o === r.y)
                                    return r;
                                if (o === r.next.y)
                                    return r.next
                            }
                            n = r.x < r.next.x ? r : r.next
                        }
                    }
                    r = r.next
                } while (r !== e);
                if (!n)
                    return null;
                if (i === s)
                    return n.prev;
                var u,
                    l = n,
                    h = n.x,
                    c = n.y,
                    p = 1 / 0;
                for (r = n.next; r !== l;)
                    i >= r.x && r.x >= h && i !== r.x && kn(o < c ? i : s, o, h, c, o < c ? s : i, o, r.x, r.y) && ((u = Math.abs(o - r.y) / (i - r.x)) < p || u === p && r.x > n.x) && zn(r, t) && (n = r, p = u),
                    r = r.next;
                return n
            }(t, e)) {
                var n = Un(e, t);
                In(n, n.next)
            }
        }
        function Dn(t, e, n, r, i) {
            return (t = 1431655765 & ((t = 858993459 & ((t = 252645135 & ((t = 16711935 & ((t = 32767 * (t - n) * i) | t << 8)) | t << 4)) | t << 2)) | t << 1)) | (e = 1431655765 & ((e = 858993459 & ((e = 252645135 & ((e = 16711935 & ((e = 32767 * (e - r) * i) | e << 8)) | e << 4)) | e << 2)) | e << 1)) << 1
        }
        function Fn(t) {
            var e = t,
                n = t;
            do {
                e.x < n.x && (n = e),
                e = e.next
            } while (e !== t);
            return n
        }
        function kn(t, e, n, r, i, o, s, a) {
            return (i - s) * (e - a) - (t - s) * (o - a) >= 0 && (t - s) * (r - a) - (n - s) * (e - a) >= 0 && (n - s) * (o - a) - (i - s) * (r - a) >= 0
        }
        function jn(t, e) {
            return t.next.i !== e.i && t.prev.i !== e.i && !function(t, e) {
                    var n = t;
                    do {
                        if (n.i !== t.i && n.next.i !== t.i && n.i !== e.i && n.next.i !== e.i && qn(n, n.next, t, e))
                            return !0;
                        n = n.next
                    } while (n !== t);
                    return !1
                }(t, e) && zn(t, e) && zn(e, t) && function(t, e) {
                    var n = t,
                        r = !1,
                        i = (t.x + e.x) / 2,
                        o = (t.y + e.y) / 2;
                    do {
                        n.y > o != n.next.y > o && n.next.y !== n.y && i < (n.next.x - n.x) * (o - n.y) / (n.next.y - n.y) + n.x && (r = !r),
                        n = n.next
                    } while (n !== t);
                    return r
                }(t, e)
        }
        function Gn(t, e, n) {
            return (e.y - t.y) * (n.x - e.x) - (e.x - t.x) * (n.y - e.y)
        }
        function Bn(t, e) {
            return t.x === e.x && t.y === e.y
        }
        function qn(t, e, n, r) {
            return !!(Bn(t, e) && Bn(n, r) || Bn(t, r) && Bn(n, e)) || Gn(t, e, n) > 0 != Gn(t, e, r) > 0 && Gn(n, r, t) > 0 != Gn(n, r, e) > 0
        }
        function zn(t, e) {
            return Gn(t.prev, t, t.next) < 0 ? Gn(t, e, t.next) >= 0 && Gn(t, t.prev, e) >= 0 : Gn(t, e, t.prev) < 0 || Gn(t, t.next, e) < 0
        }
        function Un(t, e) {
            var n = new Hn(t.i, t.x, t.y),
                r = new Hn(e.i, e.x, e.y),
                i = t.next,
                o = e.prev;
            return t.next = e, e.prev = t, n.next = i, i.prev = n, r.next = n, n.prev = r, o.next = r, r.prev = o, r
        }
        function Vn(t, e, n, r) {
            var i = new Hn(t, e, n);
            return r ? (i.next = r.next, i.prev = r, r.next.prev = i, r.next = i) : (i.prev = i, i.next = i), i
        }
        function Xn(t) {
            t.next.prev = t.prev,
            t.prev.next = t.next,
            t.prevZ && (t.prevZ.nextZ = t.nextZ),
            t.nextZ && (t.nextZ.prevZ = t.prevZ)
        }
        function Hn(t, e, n) {
            this.i = t,
            this.x = e,
            this.y = n,
            this.prev = null,
            this.next = null,
            this.z = null,
            this.prevZ = null,
            this.nextZ = null,
            this.steiner = !1
        }
        function Yn(t, e, n, r) {
            for (var i = 0, o = e, s = n - r; o < n; o += r)
                i += (t[s] - t[o]) * (t[o + 1] + t[s + 1]),
                s = o;
            return i
        }
        function Wn(t) {
            var e = function(t) {
                    for (var e = t[0][0].length, n = {
                            vertices: [],
                            holes: [],
                            dimensions: e
                        }, r = 0, i = 0; i < t.length; i++) {
                        for (var o = 0; o < t[i].length; o++)
                            for (var s = 0; s < e; s++)
                                n.vertices.push(t[i][o][s]);
                        i > 0 && (r += t[i - 1].length, n.holes.push(r))
                    }
                    return n
                }(t),
                n = bn(e.vertices, e.holes, 2),
                r = [],
                i = [];
            n.forEach((function(t, r) {
                var o = n[r];
                i.push([e.vertices[2 * o], e.vertices[2 * o + 1]])
            }));
            for (var o = 0; o < i.length; o += 3) {
                var s = i.slice(o, o + 3);
                s.push(i[o]),
                r.push(l([s]))
            }
            return r
        }
        function $n(t, e) {
            if (!t)
                throw new Error("targetPoint is required");
            if (!e)
                throw new Error("points is required");
            var n,
                r = 1 / 0,
                i = 0;
            return F(e, (function(e, n) {
                var o = _e(t, e);
                o < r && (i = n, r = o)
            })), (n = Ce(e.features[i])).properties.featureIndex = i, n.properties.distanceToPoint = r, n
        }
        function Kn(t) {
            if (!t)
                throw new Error("geojson is required");
            var e = [];
            return q(t, (function(t) {
                !function(t, e) {
                    var n = [],
                        r = t.geometry;
                    if (null !== r) {
                        switch (r.type) {
                        case "Polygon":
                            n = J(r);
                            break;
                        case "LineString":
                            n = [J(r)]
                        }
                        n.forEach((function(n) {
                            (function(t, e) {
                                var n = [];
                                return t.reduce((function(t, r) {
                                    var i = c([t, r], e);
                                    return i.bbox = function(t, e) {
                                        var n = t[0],
                                            r = t[1],
                                            i = e[0],
                                            o = e[1];
                                        return [n < i ? n : i, r < o ? r : o, n > i ? n : i, r > o ? r : o]
                                    }(t, r), n.push(i), r
                                })), n
                            })(n, t.properties).forEach((function(t) {
                                t.id = e.length,
                                e.push(t)
                            }))
                        }))
                    }
                }(t, e)
            })), f(e)
        }
        Mn.deviation = function(t, e, n, r) {
            var i = e && e.length,
                o = i ? e[0] * n : t.length,
                s = Math.abs(Yn(t, 0, o, n));
            if (i)
                for (var a = 0, u = e.length; a < u; a++) {
                    var l = e[a] * n,
                        h = a < u - 1 ? e[a + 1] * n : t.length;
                    s -= Math.abs(Yn(t, l, h, n))
                }
            var c = 0;
            for (a = 0; a < r.length; a += 3) {
                var p = r[a] * n,
                    f = r[a + 1] * n,
                    d = r[a + 2] * n;
                c += Math.abs((t[p] - t[d]) * (t[f + 1] - t[p + 1]) - (t[p] - t[f]) * (t[d + 1] - t[p + 1]))
            }
            return 0 === s && 0 === c ? 0 : Math.abs((c - s) / s)
        },
        Mn.flatten = function(t) {
            for (var e = t[0][0].length, n = {
                    vertices: [],
                    holes: [],
                    dimensions: e
                }, r = 0, i = 0; i < t.length; i++) {
                for (var o = 0; o < t[i].length; o++)
                    for (var s = 0; s < e; s++)
                        n.vertices.push(t[i][o][s]);
                i > 0 && (r += t[i - 1].length, n.holes.push(r))
            }
            return n
        },
        bn.default = Cn;
        var Zn = Bt((function(t, e) {
            function n(t, e, n) {
                void 0 === n && (n = {});
                var r = {
                    type: "Feature"
                };
                return (0 === n.id || n.id) && (r.id = n.id), n.bbox && (r.bbox = n.bbox), r.properties = e || {}, r.geometry = t, r
            }
            function r(t, e, r) {
                if (void 0 === r && (r = {}), !t)
                    throw new Error("coordinates is required");
                if (!Array.isArray(t))
                    throw new Error("coordinates must be an Array");
                if (t.length < 2)
                    throw new Error("coordinates must be at least 2 numbers long");
                if (!f(t[0]) || !f(t[1]))
                    throw new Error("coordinates must contain numbers");
                return n({
                    type: "Point",
                    coordinates: t
                }, e, r)
            }
            function i(t, e, r) {
                void 0 === r && (r = {});
                for (var i = 0, o = t; i < o.length; i++) {
                    var s = o[i];
                    if (s.length < 4)
                        throw new Error("Each LinearRing of a Polygon must have 4 or more Positions.");
                    for (var a = 0; a < s[s.length - 1].length; a++)
                        if (s[s.length - 1][a] !== s[0][a])
                            throw new Error("First and last Position are not equivalent.")
                }
                return n({
                    type: "Polygon",
                    coordinates: t
                }, e, r)
            }
            function o(t, e, r) {
                if (void 0 === r && (r = {}), t.length < 2)
                    throw new Error("coordinates must be an array of two or more positions");
                return n({
                    type: "LineString",
                    coordinates: t
                }, e, r)
            }
            function s(t, e) {
                void 0 === e && (e = {});
                var n = {
                    type: "FeatureCollection"
                };
                return e.id && (n.id = e.id), e.bbox && (n.bbox = e.bbox), n.features = t, n
            }
            function a(t, e, r) {
                return void 0 === r && (r = {}), n({
                    type: "MultiLineString",
                    coordinates: t
                }, e, r)
            }
            function u(t, e, r) {
                return void 0 === r && (r = {}), n({
                    type: "MultiPoint",
                    coordinates: t
                }, e, r)
            }
            function l(t, e, r) {
                return void 0 === r && (r = {}), n({
                    type: "MultiPolygon",
                    coordinates: t
                }, e, r)
            }
            function h(t, n) {
                void 0 === n && (n = "kilometers");
                var r = e.factors[n];
                if (!r)
                    throw new Error(n + " units is invalid");
                return t * r
            }
            function c(t, n) {
                void 0 === n && (n = "kilometers");
                var r = e.factors[n];
                if (!r)
                    throw new Error(n + " units is invalid");
                return t / r
            }
            function p(t) {
                return t % (2 * Math.PI) * 180 / Math.PI
            }
            function f(t) {
                return !isNaN(t) && null !== t && !Array.isArray(t)
            }
            Object.defineProperty(e, "__esModule", {
                value: !0
            }),
            e.earthRadius = 6371008.8,
            e.factors = {
                centimeters: 100 * e.earthRadius,
                centimetres: 100 * e.earthRadius,
                degrees: e.earthRadius / 111325,
                feet: 3.28084 * e.earthRadius,
                inches: 39.37 * e.earthRadius,
                kilometers: e.earthRadius / 1e3,
                kilometres: e.earthRadius / 1e3,
                meters: e.earthRadius,
                metres: e.earthRadius,
                miles: e.earthRadius / 1609.344,
                millimeters: 1e3 * e.earthRadius,
                millimetres: 1e3 * e.earthRadius,
                nauticalmiles: e.earthRadius / 1852,
                radians: 1,
                yards: 1.0936 * e.earthRadius
            },
            e.unitsFactors = {
                centimeters: 100,
                centimetres: 100,
                degrees: 1 / 111325,
                feet: 3.28084,
                inches: 39.37,
                kilometers: .001,
                kilometres: .001,
                meters: 1,
                metres: 1,
                miles: 1 / 1609.344,
                millimeters: 1e3,
                millimetres: 1e3,
                nauticalmiles: 1 / 1852,
                radians: 1 / e.earthRadius,
                yards: 1.0936133
            },
            e.areaFactors = {
                acres: 247105e-9,
                centimeters: 1e4,
                centimetres: 1e4,
                feet: 10.763910417,
                hectares: 1e-4,
                inches: 1550.003100006,
                kilometers: 1e-6,
                kilometres: 1e-6,
                meters: 1,
                metres: 1,
                miles: 386e-9,
                millimeters: 1e6,
                millimetres: 1e6,
                yards: 1.195990046
            },
            e.feature = n,
            e.geometry = function(t, e, n) {
                switch (t) {
                case "Point":
                    return r(e).geometry;
                case "LineString":
                    return o(e).geometry;
                case "Polygon":
                    return i(e).geometry;
                case "MultiPoint":
                    return u(e).geometry;
                case "MultiLineString":
                    return a(e).geometry;
                case "MultiPolygon":
                    return l(e).geometry;
                default:
                    throw new Error(t + " is invalid")
                }
            },
            e.point = r,
            e.points = function(t, e, n) {
                return void 0 === n && (n = {}), s(t.map((function(t) {
                    return r(t, e)
                })), n)
            },
            e.polygon = i,
            e.polygons = function(t, e, n) {
                return void 0 === n && (n = {}), s(t.map((function(t) {
                    return i(t, e)
                })), n)
            },
            e.lineString = o,
            e.lineStrings = function(t, e, n) {
                return void 0 === n && (n = {}), s(t.map((function(t) {
                    return o(t, e)
                })), n)
            },
            e.featureCollection = s,
            e.multiLineString = a,
            e.multiPoint = u,
            e.multiPolygon = l,
            e.geometryCollection = function(t, e, r) {
                return void 0 === r && (r = {}), n({
                    type: "GeometryCollection",
                    geometries: t
                }, e, r)
            },
            e.round = function(t, e) {
                if (void 0 === e && (e = 0), e && !(e >= 0))
                    throw new Error("precision must be a positive number");
                var n = Math.pow(10, e || 0);
                return Math.round(t * n) / n
            },
            e.radiansToLength = h,
            e.lengthToRadians = c,
            e.lengthToDegrees = function(t, e) {
                return p(c(t, e))
            },
            e.bearingToAzimuth = function(t) {
                var e = t % 360;
                return e < 0 && (e += 360), e
            },
            e.radiansToDegrees = p,
            e.degreesToRadians = function(t) {
                return t % 360 * Math.PI / 180
            },
            e.convertLength = function(t, e, n) {
                if (void 0 === e && (e = "kilometers"), void 0 === n && (n = "kilometers"), !(t >= 0))
                    throw new Error("length must be a positive number");
                return h(c(t, e), n)
            },
            e.convertArea = function(t, n, r) {
                if (void 0 === n && (n = "meters"), void 0 === r && (r = "kilometers"), !(t >= 0))
                    throw new Error("area must be a positive number");
                var i = e.areaFactors[n];
                if (!i)
                    throw new Error("invalid original units");
                var o = e.areaFactors[r];
                if (!o)
                    throw new Error("invalid final units");
                return t / i * o
            },
            e.isNumber = f,
            e.isObject = function(t) {
                return !!t && t.constructor === Object
            },
            e.validateBBox = function(t) {
                if (!t)
                    throw new Error("bbox is required");
                if (!Array.isArray(t))
                    throw new Error("bbox must be an Array");
                if (4 !== t.length && 6 !== t.length)
                    throw new Error("bbox must be an Array of 4 or 6 numbers");
                t.forEach((function(t) {
                    if (!f(t))
                        throw new Error("bbox must only contain numbers")
                }))
            },
            e.validateId = function(t) {
                if (!t)
                    throw new Error("id is required");
                if (-1 === ["string", "number"].indexOf(typeof t))
                    throw new Error("id must be a number or a string")
            }
        }));
        function Jn(t, e, n) {
            if (null !== t)
                for (var r, i, o, s, a, u, l, h, c = 0, p = 0, f = t.type, d = "FeatureCollection" === f, g = "Feature" === f, y = d ? t.features.length : 1, v = 0; v < y; v++) {
                    a = (h = !!(l = d ? t.features[v].geometry : g ? t.geometry : t) && "GeometryCollection" === l.type) ? l.geometries.length : 1;
                    for (var m = 0; m < a; m++) {
                        var _ = 0,
                            x = 0;
                        if (null !== (s = h ? l.geometries[m] : l)) {
                            u = s.coordinates;
                            var E = s.type;
                            switch (c = !n || "Polygon" !== E && "MultiPolygon" !== E ? 0 : 1, E) {
                            case null:
                                break;
                            case "Point":
                                if (!1 === e(u, p, v, _, x))
                                    return !1;
                                p++,
                                _++;
                                break;
                            case "LineString":
                            case "MultiPoint":
                                for (r = 0; r < u.length; r++) {
                                    if (!1 === e(u[r], p, v, _, x))
                                        return !1;
                                    p++,
                                    "MultiPoint" === E && _++
                                }
                                "LineString" === E && _++;
                                break;
                            case "Polygon":
                            case "MultiLineString":
                                for (r = 0; r < u.length; r++) {
                                    for (i = 0; i < u[r].length - c; i++) {
                                        if (!1 === e(u[r][i], p, v, _, x))
                                            return !1;
                                        p++
                                    }
                                    "MultiLineString" === E && _++,
                                    "Polygon" === E && x++
                                }
                                "Polygon" === E && _++;
                                break;
                            case "MultiPolygon":
                                for (r = 0; r < u.length; r++) {
                                    for (x = 0, i = 0; i < u[r].length; i++) {
                                        for (o = 0; o < u[r][i].length - c; o++) {
                                            if (!1 === e(u[r][i][o], p, v, _, x))
                                                return !1;
                                            p++
                                        }
                                        x++
                                    }
                                    _++
                                }
                                break;
                            case "GeometryCollection":
                                for (r = 0; r < s.geometries.length; r++)
                                    if (!1 === Jn(s.geometries[r], e, n))
                                        return !1;
                                break;
                            default:
                                throw new Error("Unknown Geometry Type")
                            }
                        }
                    }
                }
        }
        function Qn(t, e) {
            var n;
            switch (t.type) {
            case "FeatureCollection":
                for (n = 0; n < t.features.length && !1 !== e(t.features[n].properties, n); n++)
                    ;
                break;
            case "Feature":
                e(t.properties, 0)
            }
        }
        function tr(t, e) {
            if ("Feature" === t.type)
                e(t, 0);
            else if ("FeatureCollection" === t.type)
                for (var n = 0; n < t.features.length && !1 !== e(t.features[n], n); n++)
                    ;
        }
        function er(t, e) {
            var n,
                r,
                i,
                o,
                s,
                a,
                u,
                l,
                h,
                c,
                p = 0,
                f = "FeatureCollection" === t.type,
                d = "Feature" === t.type,
                g = f ? t.features.length : 1;
            for (n = 0; n < g; n++) {
                for (a = f ? t.features[n].geometry : d ? t.geometry : t, l = f ? t.features[n].properties : d ? t.properties : {}, h = f ? t.features[n].bbox : d ? t.bbox : void 0, c = f ? t.features[n].id : d ? t.id : void 0, s = (u = !!a && "GeometryCollection" === a.type) ? a.geometries.length : 1, i = 0; i < s; i++)
                    if (null !== (o = u ? a.geometries[i] : a))
                        switch (o.type) {
                        case "Point":
                        case "LineString":
                        case "MultiPoint":
                        case "Polygon":
                        case "MultiLineString":
                        case "MultiPolygon":
                            if (!1 === e(o, p, l, h, c))
                                return !1;
                            break;
                        case "GeometryCollection":
                            for (r = 0; r < o.geometries.length; r++)
                                if (!1 === e(o.geometries[r], p, l, h, c))
                                    return !1;
                            break;
                        default:
                            throw new Error("Unknown Geometry Type")
                        }
                    else if (!1 === e(null, p, l, h, c))
                        return !1;
                p++
            }
        }
        function nr(t, e) {
            er(t, (function(t, n, r, i, o) {
                var s,
                    a = null === t ? null : t.type;
                switch (a) {
                case null:
                case "Point":
                case "LineString":
                case "Polygon":
                    return !1 !== e(Zn.feature(t, r, {
                            bbox: i,
                            id: o
                        }), n, 0) && void 0
                }
                switch (a) {
                case "MultiPoint":
                    s = "Point";
                    break;
                case "MultiLineString":
                    s = "LineString";
                    break;
                case "MultiPolygon":
                    s = "Polygon"
                }
                for (var u = 0; u < t.coordinates.length; u++) {
                    var l = {
                        type: s,
                        coordinates: t.coordinates[u]
                    };
                    if (!1 === e(Zn.feature(l, r), n, u))
                        return !1
                }
            }))
        }
        function rr(t, e) {
            nr(t, (function(t, n, r) {
                var i = 0;
                if (t.geometry) {
                    var o = t.geometry.type;
                    if ("Point" !== o && "MultiPoint" !== o) {
                        var s,
                            a = 0,
                            u = 0,
                            l = 0;
                        return !1 !== Jn(t, (function(o, h, c, p, f) {
                                if (void 0 === s || n > a || p > u || f > l)
                                    return s = o, a = n, u = p, l = f, void (i = 0);
                                var d = Zn.lineString([s, o], t.properties);
                                if (!1 === e(d, n, r, f, i))
                                    return !1;
                                i++,
                                s = o
                            })) && void 0
                    }
                }
            }))
        }
        function ir(t, e) {
            if (!t)
                throw new Error("geojson is required");
            nr(t, (function(t, n, r) {
                if (null !== t.geometry) {
                    var i = t.geometry.type,
                        o = t.geometry.coordinates;
                    switch (i) {
                    case "LineString":
                        if (!1 === e(t, n, r, 0, 0))
                            return !1;
                        break;
                    case "Polygon":
                        for (var s = 0; s < o.length; s++)
                            if (!1 === e(Zn.lineString(o[s], t.properties), n, r, s))
                                return !1
                    }
                }
            }))
        }
        var or = function(t) {
                var e = [];
                return Jn(t, (function(t) {
                    e.push(t)
                })), e
            },
            sr = Jn,
            ar = function(t, e, n, r) {
                var i = n;
                return Jn(t, (function(t, r, o, s, a) {
                    i = 0 === r && void 0 === n ? t : e(i, t, r, o, s, a)
                }), r), i
            },
            ur = tr,
            lr = function(t, e, n) {
                var r = n;
                return tr(t, (function(t, i) {
                    r = 0 === i && void 0 === n ? t : e(r, t, i)
                })), r
            },
            hr = function(t, e) {
                if (e = e || {}, !Zn.isObject(e))
                    throw new Error("options is invalid");
                var n,
                    r = e.featureIndex || 0,
                    i = e.multiFeatureIndex || 0,
                    o = e.geometryIndex || 0,
                    s = e.coordIndex || 0,
                    a = e.properties;
                switch (t.type) {
                case "FeatureCollection":
                    r < 0 && (r = t.features.length + r),
                    a = a || t.features[r].properties,
                    n = t.features[r].geometry;
                    break;
                case "Feature":
                    a = a || t.properties,
                    n = t.geometry;
                    break;
                case "Point":
                case "MultiPoint":
                    return null;
                case "LineString":
                case "Polygon":
                case "MultiLineString":
                case "MultiPolygon":
                    n = t;
                    break;
                default:
                    throw new Error("geojson is invalid")
                }
                if (null === n)
                    return null;
                var u = n.coordinates;
                switch (n.type) {
                case "Point":
                    return Zn.point(u, a, e);
                case "MultiPoint":
                    return i < 0 && (i = u.length + i), Zn.point(u[i], a, e);
                case "LineString":
                    return s < 0 && (s = u.length + s), Zn.point(u[s], a, e);
                case "Polygon":
                    return o < 0 && (o = u.length + o), s < 0 && (s = u[o].length + s), Zn.point(u[o][s], a, e);
                case "MultiLineString":
                    return i < 0 && (i = u.length + i), s < 0 && (s = u[i].length + s), Zn.point(u[i][s], a, e);
                case "MultiPolygon":
                    return i < 0 && (i = u.length + i), o < 0 && (o = u[i].length + o), s < 0 && (s = u[i][o].length - s), Zn.point(u[i][o][s], a, e)
                }
                throw new Error("geojson is invalid")
            },
            cr = function(t, e) {
                if (e = e || {}, !Zn.isObject(e))
                    throw new Error("options is invalid");
                var n,
                    r = e.featureIndex || 0,
                    i = e.multiFeatureIndex || 0,
                    o = e.geometryIndex || 0,
                    s = e.segmentIndex || 0,
                    a = e.properties;
                switch (t.type) {
                case "FeatureCollection":
                    r < 0 && (r = t.features.length + r),
                    a = a || t.features[r].properties,
                    n = t.features[r].geometry;
                    break;
                case "Feature":
                    a = a || t.properties,
                    n = t.geometry;
                    break;
                case "Point":
                case "MultiPoint":
                    return null;
                case "LineString":
                case "Polygon":
                case "MultiLineString":
                case "MultiPolygon":
                    n = t;
                    break;
                default:
                    throw new Error("geojson is invalid")
                }
                if (null === n)
                    return null;
                var u = n.coordinates;
                switch (n.type) {
                case "Point":
                case "MultiPoint":
                    return null;
                case "LineString":
                    return s < 0 && (s = u.length + s - 1), Zn.lineString([u[s], u[s + 1]], a, e);
                case "Polygon":
                    return o < 0 && (o = u.length + o), s < 0 && (s = u[o].length + s - 1), Zn.lineString([u[o][s], u[o][s + 1]], a, e);
                case "MultiLineString":
                    return i < 0 && (i = u.length + i), s < 0 && (s = u[i].length + s - 1), Zn.lineString([u[i][s], u[i][s + 1]], a, e);
                case "MultiPolygon":
                    return i < 0 && (i = u.length + i), o < 0 && (o = u[i].length + o), s < 0 && (s = u[i][o].length - s - 1), Zn.lineString([u[i][o][s], u[i][o][s + 1]], a, e)
                }
                throw new Error("geojson is invalid")
            },
            pr = nr,
            fr = function(t, e, n) {
                var r = n;
                return nr(t, (function(t, i, o) {
                    r = 0 === i && 0 === o && void 0 === n ? t : e(r, t, i, o)
                })), r
            },
            dr = er,
            gr = function(t, e, n) {
                var r = n;
                return er(t, (function(t, i, o, s, a) {
                    r = 0 === i && void 0 === n ? t : e(r, t, i, o, s, a)
                })), r
            },
            yr = ir,
            vr = function(t, e, n) {
                var r = n;
                return ir(t, (function(t, i, o, s) {
                    r = 0 === i && void 0 === n ? t : e(r, t, i, o, s)
                })), r
            },
            mr = Qn,
            _r = function(t, e, n) {
                var r = n;
                return Qn(t, (function(t, i) {
                    r = 0 === i && void 0 === n ? t : e(r, t, i)
                })), r
            },
            xr = rr,
            Er = function(t, e, n) {
                var r = n,
                    i = !1;
                return rr(t, (function(t, o, s, a, u) {
                    r = !1 === i && void 0 === n ? t : e(r, t, o, s, a, u),
                    i = !0
                })), r
            },
            wr = Object.defineProperty({
                coordAll: or,
                coordEach: sr,
                coordReduce: ar,
                featureEach: ur,
                featureReduce: lr,
                findPoint: hr,
                findSegment: cr,
                flattenEach: pr,
                flattenReduce: fr,
                geomEach: dr,
                geomReduce: gr,
                lineEach: yr,
                lineReduce: vr,
                propEach: mr,
                propReduce: _r,
                segmentEach: xr,
                segmentReduce: Er
            }, "__esModule", {
                value: !0
            });
        function br(t) {
            var e = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
            return wr.coordEach(t, (function(t) {
                e[0] > t[0] && (e[0] = t[0]),
                e[1] > t[1] && (e[1] = t[1]),
                e[2] < t[0] && (e[2] = t[0]),
                e[3] < t[1] && (e[3] = t[1])
            })), e
        }
        br.default = br;
        var Cr = br,
            Mr = Object.defineProperty({
                default: Cr
            }, "__esModule", {
                value: !0
            }).default,
            Sr = wr.featureEach,
            Ir = (wr.coordEach, Zn.polygon, Zn.featureCollection);
        function Tr(t) {
            var e = Mt(t);
            return e.insert = function(t) {
                if ("Feature" !== t.type)
                    throw new Error("invalid feature");
                return t.bbox = t.bbox ? t.bbox : Mr(t), Mt.prototype.insert.call(this, t)
            }, e.load = function(t) {
                var e = [];
                return Array.isArray(t) ? t.forEach((function(t) {
                    if ("Feature" !== t.type)
                        throw new Error("invalid features");
                    t.bbox = t.bbox ? t.bbox : Mr(t),
                    e.push(t)
                })) : Sr(t, (function(t) {
                    if ("Feature" !== t.type)
                        throw new Error("invalid features");
                    t.bbox = t.bbox ? t.bbox : Mr(t),
                    e.push(t)
                })), Mt.prototype.load.call(this, e)
            }, e.remove = function(t, e) {
                if ("Feature" !== t.type)
                    throw new Error("invalid feature");
                return t.bbox = t.bbox ? t.bbox : Mr(t), Mt.prototype.remove.call(this, t, e)
            }, e.clear = function() {
                return Mt.prototype.clear.call(this)
            }, e.search = function(t) {
                var e = Mt.prototype.search.call(this, this.toBBox(t));
                return Ir(e)
            }, e.collides = function(t) {
                return Mt.prototype.collides.call(this, this.toBBox(t))
            }, e.all = function() {
                var t = Mt.prototype.all.call(this);
                return Ir(t)
            }, e.toJSON = function() {
                return Mt.prototype.toJSON.call(this)
            }, e.fromJSON = function(t) {
                return Mt.prototype.fromJSON.call(this, t)
            }, e.toBBox = function(t) {
                var e;
                if (t.bbox)
                    e = t.bbox;
                else if (Array.isArray(t) && 4 === t.length)
                    e = t;
                else if (Array.isArray(t) && 6 === t.length)
                    e = [t[0], t[1], t[3], t[4]];
                else if ("Feature" === t.type)
                    e = Mr(t);
                else {
                    if ("FeatureCollection" !== t.type)
                        throw new Error("invalid geojson");
                    e = Mr(t)
                }
                return {
                    minX: e[0],
                    minY: e[1],
                    maxX: e[2],
                    maxY: e[3]
                }
            }, e
        }
        var Pr = Tr,
            Lr = Tr;
        function Or(t, e) {
            var n = {},
                r = [];
            if ("LineString" === t.type && (t = o(t)), "LineString" === e.type && (e = o(e)), "Feature" === t.type && "Feature" === e.type && null !== t.geometry && null !== e.geometry && "LineString" === t.geometry.type && "LineString" === e.geometry.type && 2 === t.geometry.coordinates.length && 2 === e.geometry.coordinates.length) {
                var i = Nr(t, e);
                return i && r.push(i), f(r)
            }
            var s = Pr();
            return s.load(Kn(e)), F(Kn(t), (function(t) {
                F(s.search(t), (function(e) {
                    var i = Nr(t, e);
                    if (i) {
                        var o = J(i).join(",");
                        n[o] || (n[o] = !0, r.push(i))
                    }
                }))
            })), f(r)
        }
        function Nr(t, e) {
            var n = J(t),
                r = J(e);
            if (2 !== n.length)
                throw new Error("<intersects> line1 must only contain 2 coordinates");
            if (2 !== r.length)
                throw new Error("<intersects> line2 must only contain 2 coordinates");
            var i = n[0][0],
                o = n[0][1],
                s = n[1][0],
                u = n[1][1],
                l = r[0][0],
                h = r[0][1],
                c = r[1][0],
                p = r[1][1],
                f = (p - h) * (s - i) - (c - l) * (u - o);
            if (0 === f)
                return null;
            var d = ((c - l) * (o - h) - (p - h) * (i - l)) / f,
                g = ((s - i) * (o - h) - (u - o) * (i - l)) / f;
            return d >= 0 && d <= 1 && g >= 0 && g <= 1 ? a([i + d * (s - i), o + d * (u - o)]) : null
        }
        function Rr(t, e, n) {
            void 0 === n && (n = {});
            var r = a([1 / 0, 1 / 0], {
                    dist: 1 / 0
                }),
                i = 0;
            return q(t, (function(t) {
                for (var o = J(t), s = 0; s < o.length - 1; s++) {
                    var u = a(o[s]);
                    u.properties.dist = _e(e, u, n);
                    var l = a(o[s + 1]);
                    l.properties.dist = _e(e, l, n);
                    var h = _e(u, l, n),
                        p = Math.max(u.properties.dist, l.properties.dist),
                        f = _n(u, l),
                        d = vn(e, p, f + 90, n),
                        g = vn(e, p, f - 90, n),
                        y = Or(c([d.geometry.coordinates, g.geometry.coordinates]), c([u.geometry.coordinates, l.geometry.coordinates])),
                        v = null;
                    y.features.length > 0 && ((v = y.features[0]).properties.dist = _e(e, v, n), v.properties.location = i + _e(u, v, n)),
                    u.properties.dist < r.properties.dist && ((r = u).properties.index = s, r.properties.location = i),
                    l.properties.dist < r.properties.dist && ((r = l).properties.index = s + 1, r.properties.location = i + h),
                    v && v.properties.dist < r.properties.dist && ((r = v).properties.index = s),
                    i += h
                }
            })), r
        }
        function Ar(t, n, r) {
            void 0 === r && (r = {});
            var i = Z(t),
                o = Z(n);
            return o[0] += o[0] - i[0] > 180 ? -360 : i[0] - o[0] > 180 ? 360 : 0, M(function(t, n, r) {
                var i = r = void 0 === r ? e : Number(r),
                    o = t[1] * Math.PI / 180,
                    s = n[1] * Math.PI / 180,
                    a = s - o,
                    u = Math.abs(n[0] - t[0]) * Math.PI / 180;
                u > Math.PI && (u -= 2 * Math.PI);
                var l = Math.log(Math.tan(s / 2 + Math.PI / 4) / Math.tan(o / 2 + Math.PI / 4)),
                    h = Math.abs(l) > 1e-11 ? a / l : Math.cos(o);
                return Math.sqrt(a * a + h * h * u * u) * i
            }(i, o), "meters", r.units)
        }
        function Dr(t, e, n) {
            if (void 0 === n && (n = {}), n.method || (n.method = "geodesic"), n.units || (n.units = "kilometers"), !t)
                throw new Error("pt is required");
            if (Array.isArray(t) ? t = a(t) : "Point" === t.type ? t = o(t) : et(t, "Point", "point"), !e)
                throw new Error("line is required");
            Array.isArray(e) ? e = c(e) : "LineString" === e.type ? e = o(e) : et(e, "LineString", "line");
            var r = 1 / 0,
                i = t.geometry.coordinates;
            return U(e, (function(t) {
                var e = t.geometry.coordinates[0],
                    o = t.geometry.coordinates[1],
                    s = function(t, e, n, r) {
                        var i = [n[0] - e[0], n[1] - e[1]],
                            o = Fr([t[0] - e[0], t[1] - e[1]], i);
                        if (o <= 0)
                            return kr(t, e, {
                                method: r.method,
                                units: "degrees"
                            });
                        var s = Fr(i, i);
                        if (s <= o)
                            return kr(t, n, {
                                method: r.method,
                                units: "degrees"
                            });
                        var a = o / s;
                        return kr(t, [e[0] + a * i[0], e[1] + a * i[1]], {
                            method: r.method,
                            units: "degrees"
                        })
                    }(i, e, o, n);
                s < r && (r = s)
            })), M(r, "degrees", n.units)
        }
        function Fr(t, e) {
            return t[0] * e[0] + t[1] * e[1]
        }
        function kr(t, e, n) {
            return "planar" === n.method ? Ar(t, e, n) : _e(t, e, n)
        }
        function jr(t, e, n, r, i, o, s, a) {
            var u,
                l,
                h,
                c,
                p = {
                    x: null,
                    y: null,
                    onLine1: !1,
                    onLine2: !1
                };
            return 0 == (u = (a - o) * (n - t) - (s - i) * (r - e)) ? null !== p.x && null !== p.y && p : (c = (n - t) * (l = e - o) - (r - e) * (h = t - i), l = ((s - i) * l - (a - o) * h) / u, h = c / u, p.x = t + l * (n - t), p.y = e + l * (r - e), l >= 0 && l <= 1 && (p.onLine1 = !0), h >= 0 && h <= 1 && (p.onLine2 = !0), !(!p.onLine1 || !p.onLine2) && [p.x, p.y])
        }
        function Gr(t) {
            for (var e = function(t) {
                    return "FeatureCollection" !== t.type ? "Feature" !== t.type ? f([o(t)]) : f([t]) : t
                }(t), n = xn(e), r = !1, i = 0; !r && i < e.features.length;) {
                var s,
                    u = e.features[i].geometry,
                    l = !1;
                if ("Point" === u.type)
                    n.geometry.coordinates[0] === u.coordinates[0] && n.geometry.coordinates[1] === u.coordinates[1] && (r = !0);
                else if ("MultiPoint" === u.type) {
                    var h = !1;
                    for (s = 0; !h && s < u.coordinates.length;)
                        n.geometry.coordinates[0] === u.coordinates[s][0] && n.geometry.coordinates[1] === u.coordinates[s][1] && (r = !0, h = !0),
                        s++
                } else if ("LineString" === u.type)
                    for (s = 0; !l && s < u.coordinates.length - 1;)
                        Br(n.geometry.coordinates[0], n.geometry.coordinates[1], u.coordinates[s][0], u.coordinates[s][1], u.coordinates[s + 1][0], u.coordinates[s + 1][1]) && (l = !0, r = !0),
                        s++;
                else if ("MultiLineString" === u.type)
                    for (var c = 0; c < u.coordinates.length;) {
                        l = !1,
                        s = 0;
                        for (var p = u.coordinates[c]; !l && s < p.length - 1;)
                            Br(n.geometry.coordinates[0], n.geometry.coordinates[1], p[s][0], p[s][1], p[s + 1][0], p[s + 1][1]) && (l = !0, r = !0),
                            s++;
                        c++
                    }
                else
                    "Polygon" !== u.type && "MultiPolygon" !== u.type || ye(n, u) && (r = !0);
                i++
            }
            if (r)
                return n;
            var d = f([]);
            for (i = 0; i < e.features.length; i++)
                d.features = d.features.concat(wn(e.features[i]).features);
            return a($n(n, d).geometry.coordinates)
        }
        function Br(t, e, n, r, i, o) {
            return Math.sqrt((i - n) * (i - n) + (o - r) * (o - r)) === Math.sqrt((t - n) * (t - n) + (e - r) * (e - r)) + Math.sqrt((i - t) * (i - t) + (o - e) * (o - e))
        }
        Pr.default = Lr;
        var qr = 6378137;
        function zr(t) {
            return B(t, (function(t, e) {
                return t + function(t) {
                    var e,
                        n = 0;
                    switch (t.type) {
                    case "Polygon":
                        return Ur(t.coordinates);
                    case "MultiPolygon":
                        for (e = 0; e < t.coordinates.length; e++)
                            n += Ur(t.coordinates[e]);
                        return n;
                    case "Point":
                    case "MultiPoint":
                    case "LineString":
                    case "MultiLineString":
                        return 0
                    }
                    return 0
                }(e)
            }), 0)
        }
        function Ur(t) {
            var e = 0;
            if (t && t.length > 0) {
                e += Math.abs(Vr(t[0]));
                for (var n = 1; n < t.length; n++)
                    e -= Math.abs(Vr(t[n]))
            }
            return e
        }
        function Vr(t) {
            var e,
                n,
                r,
                i,
                o,
                s,
                a = 0,
                u = t.length;
            if (u > 2) {
                for (s = 0; s < u; s++)
                    s === u - 2 ? (r = u - 2, i = u - 1, o = 0) : s === u - 1 ? (r = u - 1, i = 0, o = 1) : (r = s, i = s + 1, o = s + 2),
                    e = t[r],
                    n = t[i],
                    a += (Xr(t[o][0]) - Xr(e[0])) * Math.sin(Xr(n[1]));
                a = a * qr * qr / 2
            }
            return a
        }
        function Xr(t) {
            return t * Math.PI / 180
        }
        function Hr(t, e) {
            return void 0 === e && (e = {}), V(t, (function(t, n) {
                var r = n.geometry.coordinates;
                return t + _e(r[0], r[1], e)
            }), 0)
        }
        function Yr(t, e, n, r) {
            if (!T(r = r || {}))
                throw new Error("options is invalid");
            var i,
                o = [];
            if ("Feature" === t.type)
                i = t.geometry.coordinates;
            else {
                if ("LineString" !== t.type)
                    throw new Error("input must be a LineString Feature or Geometry");
                i = t.coordinates
            }
            for (var s, a, u, l = i.length, h = 0, p = 0; p < i.length && !(e >= h && p === i.length - 1); p++) {
                if (h > e && 0 === o.length) {
                    if (!(s = e - h))
                        return o.push(i[p]), c(o);
                    a = _n(i[p], i[p - 1]) - 180,
                    u = vn(i[p], s, a, r),
                    o.push(u.geometry.coordinates)
                }
                if (h >= n)
                    return (s = n - h) ? (a = _n(i[p], i[p - 1]) - 180, u = vn(i[p], s, a, r), o.push(u.geometry.coordinates), c(o)) : (o.push(i[p]), c(o));
                if (h >= e && o.push(i[p]), p === i.length - 1)
                    return c(o);
                h += _e(i[p], i[p + 1], r)
            }
            if (h < e && i.length === l)
                throw new Error("Start position is beyond line");
            var f = i[i.length - 1];
            return c([f, f])
        }
        function Wr(t, e, n) {
            void 0 === n && (n = {});
            for (var r = Z(t), i = J(e), o = 0; o < i.length - 1; o++) {
                var s = !1;
                if (n.ignoreEndVertices && (0 === o && (s = "start"), o === i.length - 2 && (s = "end"), 0 === o && o + 1 === i.length - 1 && (s = "both")), $r(i[o], i[o + 1], r, s, void 0 === n.epsilon ? null : n.epsilon))
                    return !0
            }
            return !1
        }
        function $r(t, e, n, r, i) {
            var o = n[0],
                s = n[1],
                a = t[0],
                u = t[1],
                l = e[0],
                h = e[1],
                c = l - a,
                p = h - u,
                f = (n[0] - a) * p - (n[1] - u) * c;
            if (null !== i) {
                if (Math.abs(f) > i)
                    return !1
            } else if (0 !== f)
                return !1;
            return r ? "start" === r ? Math.abs(c) >= Math.abs(p) ? c > 0 ? a < o && o <= l : l <= o && o < a : p > 0 ? u < s && s <= h : h <= s && s < u : "end" === r ? Math.abs(c) >= Math.abs(p) ? c > 0 ? a <= o && o < l : l < o && o <= a : p > 0 ? u <= s && s < h : h < s && s <= u : "both" === r && (Math.abs(c) >= Math.abs(p) ? c > 0 ? a < o && o < l : l < o && o < a : p > 0 ? u < s && s < h : h < s && s < u) : Math.abs(c) >= Math.abs(p) ? c > 0 ? a <= o && o <= l : l <= o && o <= a : p > 0 ? u <= s && s <= h : h <= s && s <= u
        }
        function Kr(t, e) {
            var n = rt(t),
                r = rt(e),
                i = n.type,
                o = r.type;
            switch (i) {
            case "Point":
                switch (o) {
                case "MultiPoint":
                    return function(t, e) {
                        var n,
                            r = !1;
                        for (n = 0; n < e.coordinates.length; n++)
                            if (Jr(e.coordinates[n], t.coordinates)) {
                                r = !0;
                                break
                            }
                        return r
                    }(n, r);
                case "LineString":
                    return Wr(n, r, {
                        ignoreEndVertices: !0
                    });
                case "Polygon":
                case "MultiPolygon":
                    return ye(n, r, {
                        ignoreBoundary: !0
                    });
                default:
                    throw new Error("feature2 " + o + " geometry not supported")
                }
            case "MultiPoint":
                switch (o) {
                case "MultiPoint":
                    return function(t, e) {
                        for (var n = 0; n < t.coordinates.length; n++) {
                            for (var r = !1, i = 0; i < e.coordinates.length; i++)
                                Jr(t.coordinates[n], e.coordinates[i]) && (r = !0);
                            if (!r)
                                return !1
                        }
                        return !0
                    }(n, r);
                case "LineString":
                    return function(t, e) {
                        for (var n = !1, r = 0; r < t.coordinates.length; r++) {
                            if (!Wr(t.coordinates[r], e))
                                return !1;
                            n || (n = Wr(t.coordinates[r], e, {
                                ignoreEndVertices: !0
                            }))
                        }
                        return n
                    }(n, r);
                case "Polygon":
                case "MultiPolygon":
                    return function(t, e) {
                        for (var n = !0, r = !1, i = 0; i < t.coordinates.length; i++) {
                            if (!(r = ye(t.coordinates[1], e))) {
                                n = !1;
                                break
                            }
                            r = ye(t.coordinates[1], e, {
                                ignoreBoundary: !0
                            })
                        }
                        return n && r
                    }(n, r);
                default:
                    throw new Error("feature2 " + o + " geometry not supported")
                }
            case "LineString":
                switch (o) {
                case "LineString":
                    return function(t, e) {
                        for (var n = 0; n < t.coordinates.length; n++)
                            if (!Wr(t.coordinates[n], e))
                                return !1;
                        return !0
                    }(n, r);
                case "Polygon":
                case "MultiPolygon":
                    return function(t, e) {
                        if (!Zr(K(e), K(t)))
                            return !1;
                        for (var n = !1, r = 0; r < t.coordinates.length - 1; r++) {
                            if (!ye(t.coordinates[r], e))
                                return !1;
                            n || (n = ye(t.coordinates[r], e, {
                                ignoreBoundary: !0
                            })),
                            n || (n = ye(Qr(t.coordinates[r], t.coordinates[r + 1]), e, {
                                ignoreBoundary: !0
                            }))
                        }
                        return n
                    }(n, r);
                default:
                    throw new Error("feature2 " + o + " geometry not supported")
                }
            case "Polygon":
                switch (o) {
                case "Polygon":
                case "MultiPolygon":
                    return function(t, e) {
                        var n = K(t);
                        if (!Zr(K(e), n))
                            return !1;
                        for (var r = 0; r < t.coordinates[0].length; r++)
                            if (!ye(t.coordinates[0][r], e))
                                return !1;
                        return !0
                    }(n, r);
                default:
                    throw new Error("feature2 " + o + " geometry not supported")
                }
            default:
                throw new Error("feature1 " + i + " geometry not supported")
            }
        }
        function Zr(t, e) {
            return !(t[0] > e[0] || t[2] < e[2] || t[1] > e[1] || t[3] < e[3])
        }
        function Jr(t, e) {
            return t[0] === e[0] && t[1] === e[1]
        }
        function Qr(t, e) {
            return [(t[0] + e[0]) / 2, (t[1] + e[1]) / 2]
        }
        function ti(t, e, n) {
            void 0 === n && (n = {}),
            n.mask && !n.units && (n.units = "kilometers");
            for (var r = [], i = t[0], o = t[1], s = t[2], u = t[3], l = e / _e([i, o], [s, o], n) * (s - i), h = e / _e([i, o], [i, u], n) * (u - o), c = s - i, p = u - o, d = Math.floor(c / l), g = (p - Math.floor(p / h) * h) / 2, y = i + (c - d * l) / 2; y <= s;) {
                for (var v = o + g; v <= u;) {
                    var m = a([y, v], n.properties);
                    n.mask ? Kr(m, n.mask) && r.push(m) : r.push(m),
                    v += h
                }
                y += l
            }
            return f(r)
        }
        function ei(t, e) {
            void 0 === e && (e = {});
            var n = e.precision,
                r = e.coordinates,
                i = e.mutate;
            if (n = null == n || isNaN(n) ? 6 : n, r = null == r || isNaN(r) ? 3 : r, !t)
                throw new Error("<geojson> is required");
            if ("number" != typeof n)
                throw new Error("<precision> must be a number");
            if ("number" != typeof r)
                throw new Error("<coordinates> must be a number");
            !1 !== i && void 0 !== i || (t = JSON.parse(JSON.stringify(t)));
            var o = Math.pow(10, n);
            return N(t, (function(t) {
                !function(t, e, n) {
                    t.length > n && t.splice(n, t.length);
                    for (var r = 0; r < t.length; r++)
                        t[r] = Math.round(t[r] * e) / e
                }(t, o, r)
            })), t
        }
        function ni(t) {
            if (!t)
                throw new Error("geojson is required");
            var e = [];
            return q(t, (function(t) {
                e.push(t)
            })), f(e)
        }
        function ri(t, e, n) {
            if ("Polygon" !== t.geometry.type)
                throw new Error("The input feature must be a Polygon");
            void 0 === n && (n = 1);
            var r = t.geometry.coordinates,
                i = [],
                o = {};
            if (n) {
                for (var s = [], a = 0; a < r.length; a++)
                    for (var u = 0; u < r[a].length - 1; u++)
                        s.push(g(a, u));
                var l = Mt();
                l.load(s)
            }
            for (var h = 0; h < r.length; h++)
                for (var c = 0; c < r[h].length - 1; c++)
                    if (n)
                        l.search(g(h, c)).forEach((function(t) {
                            var e = t.ring,
                                n = t.edge;
                            d(h, c, e, n)
                        }));
                    else
                        for (var p = 0; p < r.length; p++)
                            for (var f = 0; f < r[p].length - 1; f++)
                                d(h, c, p, f);
            return e || (i = {
                type: "Feature",
                geometry: {
                    type: "MultiPoint",
                    coordinates: i
                }
            }), i;
            function d(t, n, s, a) {
                var u,
                    l,
                    h = r[t][n],
                    c = r[t][n + 1],
                    p = r[s][a],
                    f = r[s][a + 1],
                    d = function(t, e, n, r) {
                        if (ii(t, n) || ii(t, r) || ii(e, n) || ii(r, n))
                            return null;
                        var i = t[0],
                            o = t[1],
                            s = e[0],
                            a = e[1],
                            u = n[0],
                            l = n[1],
                            h = r[0],
                            c = r[1],
                            p = (i - s) * (l - c) - (o - a) * (u - h);
                        return 0 === p ? null : [((i * a - o * s) * (u - h) - (i - s) * (u * c - l * h)) / p, ((i * a - o * s) * (l - c) - (o - a) * (u * c - l * h)) / p]
                    }(h, c, p, f);
                if (null !== d && (u = c[0] !== h[0] ? (d[0] - h[0]) / (c[0] - h[0]) : (d[1] - h[1]) / (c[1] - h[1]), l = f[0] !== p[0] ? (d[0] - p[0]) / (f[0] - p[0]) : (d[1] - p[1]) / (f[1] - p[1]), !(u >= 1 || u <= 0 || l >= 1 || l <= 0))) {
                    var g = d,
                        y = !o[g];
                    y && (o[g] = !0),
                    e ? i.push(e(d, t, n, h, c, u, s, a, p, f, l, y)) : i.push(d)
                }
            }
            function g(t, e) {
                var n,
                    i,
                    o,
                    s,
                    a = r[t][e],
                    u = r[t][e + 1];
                return a[0] < u[0] ? (n = a[0], i = u[0]) : (n = u[0], i = a[0]), a[1] < u[1] ? (o = a[1], s = u[1]) : (o = u[1], s = a[1]), {
                    minX: n,
                    minY: o,
                    maxX: i,
                    maxY: s,
                    ring: t,
                    edge: e
                }
            }
        }
        function ii(t, e) {
            if (!t || !e)
                return !1;
            if (t.length !== e.length)
                return !1;
            for (var n = 0, r = t.length; n < r; n++)
                if (t[n] instanceof Array && e[n] instanceof Array) {
                    if (!ii(t[n], e[n]))
                        return !1
                } else if (t[n] !== e[n])
                    return !1;
            return !0
        }
        function oi(t) {
            if ("Feature" != t.type)
                throw new Error("The input must a geojson object of type Feature");
            if (void 0 === t.geometry || null == t.geometry)
                throw new Error("The input must a geojson object with a non-empty geometry");
            if ("Polygon" != t.geometry.type)
                throw new Error("The input must be a geojson Polygon");
            for (var e = t.geometry.coordinates.length, n = [], r = 0; r < e; r++) {
                var i = t.geometry.coordinates[r];
                hi(i[0], i[i.length - 1]) || i.push(i[0]),
                n.push.apply(n, i.slice(0, i.length - 1))
            }
            if (!function(t) {
                for (var e = {}, n = 1, r = 0, i = t.length; r < i; ++r) {
                    if (Object.prototype.hasOwnProperty.call(e, t[r])) {
                        n = 0;
                        break
                    }
                    e[t[r]] = 1
                }
                return n
            }(n))
                throw new Error("The input polygon may not have duplicate vertices (except for the first and last vertex of each ring)");
            var o = n.length,
                s = ri(t, (function(t, e, n, r, i, o, s, a, u, l, h, c) {
                    return [t, e, n, r, i, o, s, a, u, l, h, c]
                })),
                a = s.length;
            if (0 == a) {
                var u = [];
                for (r = 0; r < e; r++)
                    u.push(l([t.geometry.coordinates[r]], {
                        parent: -1,
                        winding: li(t.geometry.coordinates[r])
                    }));
                var h = f(u);
                return j(), G(), h
            }
            var c = [],
                p = [];
            for (r = 0; r < e; r++) {
                c.push([]);
                for (var d = 0; d < t.geometry.coordinates[r].length - 1; d++)
                    c[r].push([new si(t.geometry.coordinates[r][ci(d + 1, t.geometry.coordinates[r].length - 1)], 1, [r, d], [r, ci(d + 1, t.geometry.coordinates[r].length - 1)], void 0)]),
                    p.push(new ai(t.geometry.coordinates[r][d], [r, ci(d - 1, t.geometry.coordinates[r].length - 1)], [r, d], void 0, void 0, !1, !0))
            }
            for (r = 0; r < a; r++)
                c[s[r][1]][s[r][2]].push(new si(s[r][0], s[r][5], [s[r][1], s[r][2]], [s[r][6], s[r][7]], void 0)),
                s[r][11] && p.push(new ai(s[r][0], [s[r][1], s[r][2]], [s[r][6], s[r][7]], void 0, void 0, !0, !0));
            var g = p.length;
            for (r = 0; r < c.length; r++)
                for (d = 0; d < c[r].length; d++)
                    c[r][d].sort((function(t, e) {
                        return t.param < e.param ? -1 : 1
                    }));
            var y = [];
            for (r = 0; r < g; r++)
                y.push({
                    minX: p[r].coord[0],
                    minY: p[r].coord[1],
                    maxX: p[r].coord[0],
                    maxY: p[r].coord[1],
                    index: r
                });
            var v = Mt();
            for (v.load(y), r = 0; r < c.length; r++)
                for (d = 0; d < c[r].length; d++)
                    for (var m = 0; m < c[r][d].length; m++) {
                        x = m == c[r][d].length - 1 ? c[r][ci(d + 1, t.geometry.coordinates[r].length - 1)][0].coord : c[r][d][m + 1].coord;
                        var _ = v.search({
                            minX: x[0],
                            minY: x[1],
                            maxX: x[0],
                            maxY: x[1]
                        })[0];
                        c[r][d][m].nxtIsectAlongEdgeIn = _.index
                    }
            for (r = 0; r < c.length; r++)
                for (d = 0; d < c[r].length; d++)
                    for (m = 0; m < c[r][d].length; m++) {
                        var x = c[r][d][m].coord,
                            E = (_ = v.search({
                                minX: x[0],
                                minY: x[1],
                                maxX: x[0],
                                maxY: x[1]
                            })[0]).index;
                        E < o ? p[E].nxtIsectAlongRingAndEdge2 = c[r][d][m].nxtIsectAlongEdgeIn : hi(p[E].ringAndEdge1, c[r][d][m].ringAndEdgeIn) ? p[E].nxtIsectAlongRingAndEdge1 = c[r][d][m].nxtIsectAlongEdgeIn : p[E].nxtIsectAlongRingAndEdge2 = c[r][d][m].nxtIsectAlongEdgeIn
                    }
            var w = [];
            for (r = 0, d = 0; d < e; d++) {
                var b = r;
                for (m = 0; m < t.geometry.coordinates[d].length - 1; m++)
                    p[r].coord[0] < p[b].coord[0] && (b = r),
                    r++;
                var C = p[b].nxtIsectAlongRingAndEdge2;
                for (m = 0; m < p.length; m++)
                    if (p[m].nxtIsectAlongRingAndEdge1 == b || p[m].nxtIsectAlongRingAndEdge2 == b) {
                        var M = m;
                        break
                    }
                var S = ui([p[M].coord, p[b].coord, p[C].coord], !0) ? 1 : -1;
                w.push({
                    isect: b,
                    parent: -1,
                    winding: S
                })
            }
            for (w.sort((function(t, e) {
                return p[t.isect].coord > p[e.isect].coord ? -1 : 1
            })), u = []; w.length > 0;) {
                var I = w.pop(),
                    T = I.isect,
                    P = I.parent,
                    L = I.winding,
                    O = u.length,
                    N = [p[T].coord],
                    R = T;
                if (p[T].ringAndEdge1Walkable)
                    var A = p[T].ringAndEdge1,
                        D = p[T].nxtIsectAlongRingAndEdge1;
                else
                    A = p[T].ringAndEdge2,
                    D = p[T].nxtIsectAlongRingAndEdge2;
                for (; !hi(p[T].coord, p[D].coord);) {
                    N.push(p[D].coord);
                    var F = void 0;
                    for (r = 0; r < w.length; r++)
                        if (w[r].isect == D) {
                            F = r;
                            break
                        }
                    if (null != F && w.splice(F, 1), hi(A, p[D].ringAndEdge1)) {
                        if (A = p[D].ringAndEdge2, p[D].ringAndEdge2Walkable = !1, p[D].ringAndEdge1Walkable) {
                            var k = {
                                isect: D
                            };
                            ui([p[R].coord, p[D].coord, p[p[D].nxtIsectAlongRingAndEdge2].coord], 1 == L) ? (k.parent = P, k.winding = -L) : (k.parent = O, k.winding = L),
                            w.push(k)
                        }
                        R = D,
                        D = p[D].nxtIsectAlongRingAndEdge2
                    } else
                        A = p[D].ringAndEdge1,
                        p[D].ringAndEdge1Walkable = !1,
                        p[D].ringAndEdge2Walkable && (k = {
                            isect: D
                        }, ui([p[R].coord, p[D].coord, p[p[D].nxtIsectAlongRingAndEdge1].coord], 1 == L) ? (k.parent = P, k.winding = -L) : (k.parent = O, k.winding = L), w.push(k)),
                        R = D,
                        D = p[D].nxtIsectAlongRingAndEdge1
                }
                N.push(p[D].coord),
                u.push(l([N], {
                    index: O,
                    parent: P,
                    winding: L,
                    netWinding: void 0
                }))
            }
            function j() {
                for (var t = [], e = 0; e < h.features.length; e++)
                    -1 == h.features[e].properties.parent && t.push(e);
                if (t.length > 1)
                    for (e = 0; e < t.length; e++) {
                        for (var n = -1, r = 0; r < h.features.length; r++)
                            t[e] != r && ye(h.features[t[e]].geometry.coordinates[0][0], h.features[r], {
                                ignoreBoundary: !0
                            }) && zr(h.features[r]) < 1 / 0 && (n = r);
                        h.features[t[e]].properties.parent = n
                    }
            }
            function G() {
                for (var t = 0; t < h.features.length; t++)
                    if (-1 == h.features[t].properties.parent) {
                        var e = h.features[t].properties.winding;
                        h.features[t].properties.netWinding = e,
                        B(t, e)
                    }
            }
            function B(t, e) {
                for (var n = 0; n < h.features.length; n++)
                    if (h.features[n].properties.parent == t) {
                        var r = e + h.features[n].properties.winding;
                        h.features[n].properties.netWinding = r,
                        B(n, r)
                    }
            }
            return h = f(u), j(), G(), h
        }
        var si = function(t, e, n, r, i) {
                this.coord = t,
                this.param = e,
                this.ringAndEdgeIn = n,
                this.ringAndEdgeOut = r,
                this.nxtIsectAlongEdgeIn = i
            },
            ai = function(t, e, n, r, i, o, s) {
                this.coord = t,
                this.ringAndEdge1 = e,
                this.ringAndEdge2 = n,
                this.nxtIsectAlongRingAndEdge1 = r,
                this.nxtIsectAlongRingAndEdge2 = i,
                this.ringAndEdge1Walkable = o,
                this.ringAndEdge2Walkable = s
            };
        function ui(t, e) {
            if (void 0 === e && (e = !0), 3 != t.length)
                throw new Error("This function requires an array of three points [x,y]");
            return (t[1][0] - t[0][0]) * (t[2][1] - t[0][1]) - (t[1][1] - t[0][1]) * (t[2][0] - t[0][0]) >= 0 == e
        }
        function li(t) {
            for (var e = 0, n = 0; n < t.length - 1; n++)
                t[n][0] < t[e][0] && (e = n);
            if (ui([t[ci(e - 1, t.length - 1)], t[e], t[ci(e + 1, t.length - 1)]], !0))
                var r = 1;
            else
                r = -1;
            return r
        }
        function hi(t, e) {
            if (!t || !e)
                return !1;
            if (t.length != e.length)
                return !1;
            for (var n = 0, r = t.length; n < r; n++)
                if (t[n] instanceof Array && e[n] instanceof Array) {
                    if (!hi(t[n], e[n]))
                        return !1
                } else if (t[n] != e[n])
                    return !1;
            return !0
        }
        function ci(t, e) {
            return (t % e + e) % e
        }
        var pi = Math.PI / 180,
            fi = 180 / Math.PI,
            di = function(t, e) {
                this.lon = t,
                this.lat = e,
                this.x = pi * t,
                this.y = pi * e
            };
        di.prototype.view = function() {
            return String(this.lon).slice(0, 4) + "," + String(this.lat).slice(0, 4)
        },
        di.prototype.antipode = function() {
            var t = -1 * this.lat,
                e = this.lon < 0 ? 180 + this.lon : -1 * (180 - this.lon);
            return new di(e, t)
        };
        var gi = function() {
            this.coords = [],
            this.length = 0
        };
        gi.prototype.move_to = function(t) {
            this.length++,
            this.coords.push(t)
        };
        var yi = function(t) {
            this.properties = t || {},
            this.geometries = []
        };
        yi.prototype.json = function() {
            if (this.geometries.length <= 0)
                return {
                    geometry: {
                        type: "LineString",
                        coordinates: null
                    },
                    type: "Feature",
                    properties: this.properties
                };
            if (1 === this.geometries.length)
                return {
                    geometry: {
                        type: "LineString",
                        coordinates: this.geometries[0].coords
                    },
                    type: "Feature",
                    properties: this.properties
                };
            for (var t = [], e = 0; e < this.geometries.length; e++)
                t.push(this.geometries[e].coords);
            return {
                geometry: {
                    type: "MultiLineString",
                    coordinates: t
                },
                type: "Feature",
                properties: this.properties
            }
        },
        yi.prototype.wkt = function() {
            for (var t = "", e = "LINESTRING(", n = function(t) {
                    e += t[0] + " " + t[1] + ","
                }, r = 0; r < this.geometries.length; r++) {
                if (0 === this.geometries[r].coords.length)
                    return "LINESTRING(empty)";
                this.geometries[r].coords.forEach(n),
                t += e.substring(0, e.length - 1) + ")"
            }
            return t
        };
        var vi = function(t, e, n) {
            if (!t || void 0 === t.x || void 0 === t.y)
                throw new Error("GreatCircle constructor expects two args: start and end objects with x and y properties");
            if (!e || void 0 === e.x || void 0 === e.y)
                throw new Error("GreatCircle constructor expects two args: start and end objects with x and y properties");
            this.start = new di(t.x, t.y),
            this.end = new di(e.x, e.y),
            this.properties = n || {};
            var r = this.start.x - this.end.x,
                i = this.start.y - this.end.y,
                o = Math.pow(Math.sin(i / 2), 2) + Math.cos(this.start.y) * Math.cos(this.end.y) * Math.pow(Math.sin(r / 2), 2);
            if (this.g = 2 * Math.asin(Math.sqrt(o)), this.g === Math.PI)
                throw new Error("it appears " + t.view() + " and " + e.view() + " are 'antipodal', e.g diametrically opposite, thus there is no single route but rather infinite");
            if (isNaN(this.g))
                throw new Error("could not calculate great circle between " + t + " and " + e)
        };
        function mi(t, e) {
            var n = [],
                r = Pr();
            return q(e, (function(e) {
                if (n.forEach((function(t, e) {
                    t.id = e
                })), n.length) {
                    var i = r.search(e);
                    if (i.features.length) {
                        var o = xi(e, i);
                        n = n.filter((function(t) {
                            return t.id !== o.id
                        })),
                        r.remove(o),
                        F(_i(o, e), (function(t) {
                            n.push(t),
                            r.insert(t)
                        }))
                    }
                } else
                    (n = _i(t, e).features).forEach((function(t) {
                        t.bbox || (t.bbox = yn(K(t)))
                    })),
                    r.load(f(n))
            })), f(n)
        }
        function _i(t, e) {
            var n = [],
                r = J(t)[0],
                i = J(t)[t.geometry.coordinates.length - 1];
            if (Ei(r, Z(e)) || Ei(i, Z(e)))
                return f([t]);
            var o = Pr(),
                s = Kn(t);
            o.load(s);
            var a = o.search(e);
            if (!a.features.length)
                return f([t]);
            var u = xi(e, a),
                l = k(s, (function(t, r, i) {
                    var o = J(r)[1],
                        s = Z(e);
                    return i === u.id ? (t.push(s), n.push(c(t)), Ei(s, o) ? [s] : [s, o]) : (t.push(o), t)
                }), [r]);
            return l.length > 1 && n.push(c(l)), f(n)
        }
        function xi(t, e) {
            if (!e.features.length)
                throw new Error("lines must contain features");
            if (1 === e.features.length)
                return e.features[0];
            var n,
                r = 1 / 0;
            return F(e, (function(e) {
                var i = Rr(e, t).properties.dist;
                i < r && (n = e, r = i)
            })), n
        }
        function Ei(t, e) {
            return t[0] === e[0] && t[1] === e[1]
        }
        function wi(t, e, n, r, i) {
            void 0 === i && (i = {});
            var o = i.steps || 64,
                s = bi(n),
                a = bi(r),
                u = Array.isArray(t) || "Feature" !== t.type ? {} : t.properties;
            if (s === a)
                return c(mn(t, e, i).geometry.coordinates[0], u);
            for (var l = s, h = s < a ? a : a + 360, p = l, f = [], d = 0; p < h;)
                f.push(vn(t, e, p, i).geometry.coordinates),
                p = l + 360 * ++d / o;
            return p > h && f.push(vn(t, e, h, i).geometry.coordinates), c(f, u)
        }
        function bi(t) {
            var e = t % 360;
            return e < 0 && (e += 360), e
        }
        function Ci(t, e) {
            void 0 === e && (e = {});
            var n = rt(t);
            switch (e.properties || "Feature" !== t.type || (e.properties = t.properties), n.type) {
            case "Polygon":
                return Mi(n, e);
            case "MultiPolygon":
                return function(t, e) {
                    void 0 === e && (e = {});
                    var n = rt(t).coordinates,
                        r = e.properties ? e.properties : "Feature" === t.type ? t.properties : {},
                        i = [];
                    return n.forEach((function(t) {
                        i.push(Si(t, r))
                    })), f(i)
                }(n, e);
            default:
                throw new Error("invalid poly")
            }
        }
        function Mi(t, e) {
            return void 0 === e && (e = {}), Si(rt(t).coordinates, e.properties ? e.properties : "Feature" === t.type ? t.properties : {})
        }
        function Si(t, e) {
            return t.length > 1 ? d(t, e) : c(t[0], e)
        }
        function Ii(t, e) {
            var n,
                r,
                i;
            void 0 === e && (e = {});
            var o = e.properties,
                s = null === (n = e.autoComplete) || void 0 === n || n,
                a = null === (r = e.orderCoords) || void 0 === r || r;
            if ("FeatureCollection" === (null !== (i = e.mutate) && void 0 !== i && i || (t = Ce(t)), t.type)) {
                var u = [];
                return t.features.forEach((function(t) {
                    u.push(J(Ti(t, {}, s, a)))
                })), y(u, o)
            }
            return Ti(t, o, s, a)
        }
        function Ti(t, e, n, r) {
            e = e || ("Feature" === t.type ? t.properties : {});
            var i = rt(t),
                o = i.coordinates,
                s = i.type;
            if (!o.length)
                throw new Error("line must contain coordinates");
            switch (s) {
            case "LineString":
                return n && (o = Pi(o)), l([o], e);
            case "MultiLineString":
                var a = [],
                    u = 0;
                return o.forEach((function(t) {
                    if (n && (t = Pi(t)), r) {
                        var e = function(t) {
                            var e = t[0],
                                n = t[1],
                                r = t[2],
                                i = t[3];
                            return Math.abs(e - r) * Math.abs(n - i)
                        }(K(c(t)));
                        e > u ? (a.unshift(t), u = e) : a.push(t)
                    } else
                        a.push(t)
                })), l(a, e);
            default:
                throw new Error("geometry type " + s + " is not supported")
            }
        }
        function Pi(t) {
            var e = t[0],
                n = e[0],
                r = e[1],
                i = t[t.length - 1],
                o = i[0],
                s = i[1];
            return n === o && r === s || t.push(e), t
        }
        function Li(t, e) {
            var n,
                r,
                i,
                o,
                s,
                a,
                u;
            for (r = 1; r <= 8; r *= 2) {
                for (n = [], o = !(Ni(i = t[t.length - 1], e) & r), s = 0; s < t.length; s++)
                    (u = !(Ni(a = t[s], e) & r)) !== o && n.push(Oi(i, a, r, e)),
                    u && n.push(a),
                    i = a,
                    o = u;
                if (!(t = n).length)
                    break
            }
            return n
        }
        function Oi(t, e, n, r) {
            return 8 & n ? [t[0] + (e[0] - t[0]) * (r[3] - t[1]) / (e[1] - t[1]), r[3]] : 4 & n ? [t[0] + (e[0] - t[0]) * (r[1] - t[1]) / (e[1] - t[1]), r[1]] : 2 & n ? [r[2], t[1] + (e[1] - t[1]) * (r[2] - t[0]) / (e[0] - t[0])] : 1 & n ? [r[0], t[1] + (e[1] - t[1]) * (r[0] - t[0]) / (e[0] - t[0])] : null
        }
        function Ni(t, e) {
            var n = 0;
            return t[0] < e[0] ? n |= 1 : t[0] > e[2] && (n |= 2), t[1] < e[1] ? n |= 4 : t[1] > e[3] && (n |= 8), n
        }
        function Ri(t, e) {
            for (var n = [], r = 0, i = t; r < i.length; r++) {
                var o = Li(i[r], e);
                o.length > 0 && (o[0][0] === o[o.length - 1][0] && o[0][1] === o[o.length - 1][1] || o.push(o[0]), o.length >= 4 && n.push(o))
            }
            return n
        }
        vi.prototype.interpolate = function(t) {
            var e = Math.sin((1 - t) * this.g) / Math.sin(this.g),
                n = Math.sin(t * this.g) / Math.sin(this.g),
                r = e * Math.cos(this.start.y) * Math.cos(this.start.x) + n * Math.cos(this.end.y) * Math.cos(this.end.x),
                i = e * Math.cos(this.start.y) * Math.sin(this.start.x) + n * Math.cos(this.end.y) * Math.sin(this.end.x),
                o = e * Math.sin(this.start.y) + n * Math.sin(this.end.y),
                s = fi * Math.atan2(o, Math.sqrt(Math.pow(r, 2) + Math.pow(i, 2)));
            return [fi * Math.atan2(i, r), s]
        },
        vi.prototype.Arc = function(t, e) {
            var n = [];
            if (!t || t <= 2)
                n.push([this.start.lon, this.start.lat]),
                n.push([this.end.lon, this.end.lat]);
            else
                for (var r = 1 / (t - 1), i = 0; i < t; ++i) {
                    var o = r * i,
                        s = this.interpolate(o);
                    n.push(s)
                }
            for (var a = !1, u = 0, l = e && e.offset ? e.offset : 10, h = 180 - l, c = -180 + l, p = 360 - l, f = 1; f < n.length; ++f) {
                var d = n[f - 1][0],
                    g = n[f][0],
                    y = Math.abs(g - d);
                y > p && (g > h && d < c || d > h && g < c) ? a = !0 : y > u && (u = y)
            }
            var v = [];
            if (a && u < l) {
                var m = [];
                v.push(m);
                for (var _ = 0; _ < n.length; ++_) {
                    var x = parseFloat(n[_][0]);
                    if (_ > 0 && Math.abs(x - n[_ - 1][0]) > p) {
                        var E = parseFloat(n[_ - 1][0]),
                            w = parseFloat(n[_ - 1][1]),
                            b = parseFloat(n[_][0]),
                            C = parseFloat(n[_][1]);
                        if (E > -180 && E < c && 180 === b && _ + 1 < n.length && n[_ - 1][0] > -180 && n[_ - 1][0] < c) {
                            m.push([-180, n[_][1]]),
                            _++,
                            m.push([n[_][0], n[_][1]]);
                            continue
                        }
                        if (E > h && E < 180 && -180 === b && _ + 1 < n.length && n[_ - 1][0] > h && n[_ - 1][0] < 180) {
                            m.push([180, n[_][1]]),
                            _++,
                            m.push([n[_][0], n[_][1]]);
                            continue
                        }
                        if (E < c && b > h) {
                            var M = E;
                            E = b,
                            b = M;
                            var S = w;
                            w = C,
                            C = S
                        }
                        if (E > h && b < c && (b += 360), E <= 180 && b >= 180 && E < b) {
                            var I = (180 - E) / (b - E),
                                T = I * C + (1 - I) * w;
                            m.push([n[_ - 1][0] > h ? 180 : -180, T]),
                            (m = []).push([n[_ - 1][0] > h ? -180 : 180, T]),
                            v.push(m)
                        } else
                            m = [],
                            v.push(m);
                        m.push([x, n[_][1]])
                    } else
                        m.push([n[_][0], n[_][1]])
                }
            } else {
                var P = [];
                v.push(P);
                for (var L = 0; L < n.length; ++L)
                    P.push([n[L][0], n[L][1]])
            }
            for (var O = new yi(this.properties), N = 0; N < v.length; ++N) {
                var R = new gi;
                O.geometries.push(R);
                for (var A = v[N], D = 0; D < A.length; ++D)
                    R.move_to(A[D])
            }
            return O
        };
        var Ai = Bt((function(t, e) {
                function n(t) {
                    var e = [];
                    for (var n in t)
                        e.push(n);
                    return e
                }
                (t.exports = "function" == typeof Object.keys ? Object.keys : n).shim = n
            })),
            Di = Bt((function(t, e) {
                var n = "[object Arguments]" == function() {
                    return Object.prototype.toString.call(arguments)
                }();
                function r(t) {
                    return "[object Arguments]" == Object.prototype.toString.call(t)
                }
                function i(t) {
                    return t && "object" == typeof t && "number" == typeof t.length && Object.prototype.hasOwnProperty.call(t, "callee") && !Object.prototype.propertyIsEnumerable.call(t, "callee") || !1
                }
                (e = t.exports = n ? r : i).supported = r,
                e.unsupported = i
            })),
            Fi = Bt((function(t) {
                var e = Array.prototype.slice,
                    n = t.exports = function(t, o, s) {
                        return s || (s = {}), t === o || (t instanceof Date && o instanceof Date ? t.getTime() === o.getTime() : !t || !o || "object" != typeof t && "object" != typeof o ? s.strict ? t === o : t == o : function(t, o, s) {
                            var a,
                                u;
                            if (r(t) || r(o))
                                return !1;
                            if (t.prototype !== o.prototype)
                                return !1;
                            if (Di(t))
                                return !!Di(o) && (t = e.call(t), o = e.call(o), n(t, o, s));
                            if (i(t)) {
                                if (!i(o))
                                    return !1;
                                if (t.length !== o.length)
                                    return !1;
                                for (a = 0; a < t.length; a++)
                                    if (t[a] !== o[a])
                                        return !1;
                                return !0
                            }
                            try {
                                var l = Ai(t),
                                    h = Ai(o)
                            } catch (t) {
                                return !1
                            }
                            if (l.length != h.length)
                                return !1;
                            for (l.sort(), h.sort(), a = l.length - 1; a >= 0; a--)
                                if (l[a] != h[a])
                                    return !1;
                            for (a = l.length - 1; a >= 0; a--)
                                if (u = l[a], !n(t[u], o[u], s))
                                    return !1;
                            return typeof t == typeof o
                        }(t, o, s))
                    };
                function r(t) {
                    return null == t
                }
                function i(t) {
                    return !(!t || "object" != typeof t || "number" != typeof t.length || "function" != typeof t.copy || "function" != typeof t.slice || t.length > 0 && "number" != typeof t[0])
                }
            }));
        function ki(t, e, n) {
            if (void 0 === n && (n = {}), !T(n = n || {}))
                throw new Error("options is invalid");
            var r,
                i = n.tolerance || 0,
                o = [],
                s = Pr(),
                a = Kn(t);
            return s.load(a), U(e, (function(t) {
                var e = !1;
                t && (F(s.search(t), (function(n) {
                    if (!1 === e) {
                        var o = J(t).sort(),
                            s = J(n).sort();
                        Fi(o, s) || (0 === i ? Wr(o[0], n) && Wr(o[1], n) : Rr(n, o[0]).properties.dist <= i && Rr(n, o[1]).properties.dist <= i) ? (e = !0, r = r ? ji(r, t) : t) : (0 === i ? Wr(s[0], t) && Wr(s[1], t) : Rr(t, s[0]).properties.dist <= i && Rr(t, s[1]).properties.dist <= i) && (r = r ? ji(r, n) : n)
                    }
                })), !1 === e && r && (o.push(r), r = void 0))
            })), r && o.push(r), f(o)
        }
        function ji(t, e) {
            var n = J(e),
                r = J(t),
                i = r[0],
                o = r[r.length - 1],
                s = t.geometry.coordinates;
            return Fi(n[0], i) ? s.unshift(n[1]) : Fi(n[0], o) ? s.push(n[1]) : Fi(n[1], i) ? s.unshift(n[0]) : Fi(n[1], o) && s.push(n[0]), t
        }
        function Gi(t) {
            var e = t % 360;
            return e < 0 && (e += 360), e
        }
        function Bi(t, e, n) {
            var r;
            return void 0 === n && (n = {}), (r = n.final ? qi(Z(e), Z(t)) : qi(Z(t), Z(e))) > 180 ? -(360 - r) : r
        }
        function qi(t, e) {
            var n = C(t[1]),
                r = C(e[1]),
                i = C(e[0] - t[0]);
            i > Math.PI && (i -= 2 * Math.PI),
            i < -Math.PI && (i += 2 * Math.PI);
            var o = Math.log(Math.tan(r / 2 + Math.PI / 4) / Math.tan(n / 2 + Math.PI / 4));
            return (b(Math.atan2(i, o)) + 360) % 360
        }
        function zi(t, n, r, i) {
            void 0 === i && (i = {});
            var o = n < 0,
                s = M(Math.abs(n), i.units, "meters");
            o && (s = -Math.abs(s));
            var u = Z(t),
                l = function(t, n, r, i) {
                    var o = n / (i = void 0 === i ? e : Number(i)),
                        s = t[0] * Math.PI / 180,
                        a = C(t[1]),
                        u = C(r),
                        l = o * Math.cos(u),
                        h = a + l;
                    Math.abs(h) > Math.PI / 2 && (h = h > 0 ? Math.PI - h : -Math.PI - h);
                    var c = Math.log(Math.tan(h / 2 + Math.PI / 4) / Math.tan(a / 2 + Math.PI / 4)),
                        p = Math.abs(c) > 1e-11 ? l / c : Math.cos(a);
                    return [(180 * (s + o * Math.sin(u) / p) / Math.PI + 540) % 360 - 180, 180 * h / Math.PI]
                }(u, s, r);
            return l[0] += l[0] - u[0] > 180 ? -360 : u[0] - l[0] > 180 ? 360 : 0, a(l, i.properties)
        }
        function Ui(t, e, n, r, i, o) {
            for (var s = 0; s < t.length; s++) {
                var a = t[s],
                    u = t[s + 1];
                s === t.length - 1 && (u = t[0]),
                r = Xi(a, u, e),
                n <= 0 && r > 0 ? Xi(e, a, i) < 0 || (i = a) : n > 0 && r <= 0 && (Vi(e, a, o) || (o = a)),
                n = r
            }
            return [i, o]
        }
        function Vi(t, e, n) {
            return Xi(t, e, n) > 0
        }
        function Xi(t, e, n) {
            return (e[0] - t[0]) * (n[1] - t[1]) - (n[0] - t[0]) * (e[1] - t[1])
        }
        function Hi(t) {
            for (var e, n, r = J(t), i = 0, o = 1; o < r.length;)
                e = n || r[0],
                i += ((n = r[o])[0] - e[0]) * (n[1] + e[1]),
                o++;
            return i > 0
        }
        function Yi(t, e) {
            switch ("Feature" === t.type ? t.geometry.type : t.type) {
            case "GeometryCollection":
                return G(t, (function(t) {
                    Yi(t, e)
                })), t;
            case "LineString":
                return Wi(J(t), e), t;
            case "Polygon":
                return $i(J(t), e), t;
            case "MultiLineString":
                return J(t).forEach((function(t) {
                    Wi(t, e)
                })), t;
            case "MultiPolygon":
                return J(t).forEach((function(t) {
                    $i(t, e)
                })), t;
            case "Point":
            case "MultiPoint":
                return t
            }
        }
        function Wi(t, e) {
            Hi(t) === e && t.reverse()
        }
        function $i(t, e) {
            Hi(t[0]) !== e && t[0].reverse();
            for (var n = 1; n < t.length; n++)
                Hi(t[n]) === e && t[n].reverse()
        }
        function Ki(t, e) {
            if (!T(e = e || {}))
                throw new Error("options is invalid");
            var n = e.zProperty || "elevation",
                r = e.flip,
                i = e.flags;
            nt(t, "Point", "input must contain Points");
            for (var o = function(t, e) {
                    var n = {};
                    return F(t, (function(t) {
                        var e = J(t)[1];
                        n[e] || (n[e] = []),
                        n[e].push(t)
                    })), Object.keys(n).map((function(t) {
                        return n[t].sort((function(t, e) {
                            return J(t)[0] - J(e)[0]
                        }))
                    })).sort((function(t, n) {
                        return e ? J(t[0])[1] - J(n[0])[1] : J(n[0])[1] - J(t[0])[1]
                    }))
                }(t, r), s = [], a = 0; a < o.length; a++) {
                for (var u = o[a], l = [], h = 0; h < u.length; h++) {
                    var c = u[h];
                    c.properties[n] ? l.push(c.properties[n]) : l.push(0),
                    !0 === i && (c.properties.matrixPosition = [a, h])
                }
                s.push(l)
            }
            return s
        }
        var Zi = {
                successCallback: null,
                verbose: !1,
                polygons: !1
            },
            Ji = {};
        function Qi(t, e, n, r) {
            r = r || {};
            for (var i = Object.keys(Zi), o = 0; o < i.length; o++) {
                var s = i[o],
                    a = r[s];
                a = null != a ? a : Zi[s],
                Ji[s] = a
            }
            Ji.verbose && console.log("MarchingSquaresJS-isoBands: computing isobands for [" + e + ":" + (e + n) + "]");
            var u,
                l = function(t, e, n) {
                    for (var r = t.length - 1, i = t[0].length - 1, o = {
                            rows: r,
                            cols: i,
                            cells: []
                        }, s = e + Math.abs(n), a = 0; a < r; ++a) {
                        o.cells[a] = [];
                        for (var u = 0; u < i; ++u) {
                            var l = 0,
                                h = t[a + 1][u],
                                c = t[a + 1][u + 1],
                                p = t[a][u + 1],
                                f = t[a][u];
                            if (!(isNaN(h) || isNaN(c) || isNaN(p) || isNaN(f))) {
                                l |= h < e ? 0 : h > s ? 128 : 64,
                                l |= c < e ? 0 : c > s ? 32 : 16,
                                l |= p < e ? 0 : p > s ? 8 : 4;
                                var d = +(l |= f < e ? 0 : f > s ? 2 : 1),
                                    g = 0;
                                if (17 === l || 18 === l || 33 === l || 34 === l || 38 === l || 68 === l || 72 === l || 98 === l || 102 === l || 132 === l || 136 === l || 137 === l || 152 === l || 153 === l) {
                                    var y = (h + c + p + f) / 4;
                                    g = y > s ? 2 : y < e ? 0 : 1,
                                    34 === l ? 1 === g ? l = 35 : 0 === g && (l = 136) : 136 === l ? 1 === g ? (l = 35, g = 4) : 0 === g && (l = 34) : 17 === l ? 1 === g ? (l = 155, g = 4) : 0 === g && (l = 153) : 68 === l ? 1 === g ? (l = 103, g = 4) : 0 === g && (l = 102) : 153 === l ? 1 === g && (l = 155) : 102 === l ? 1 === g && (l = 103) : 152 === l ? g < 2 && (l = 156, g = 1) : 137 === l ? g < 2 && (l = 139, g = 1) : 98 === l ? g < 2 && (l = 99, g = 1) : 38 === l ? g < 2 && (l = 39, g = 1) : 18 === l ? g > 0 ? (l = 156, g = 4) : l = 152 : 33 === l ? g > 0 ? (l = 139, g = 4) : l = 137 : 72 === l ? g > 0 ? (l = 99, g = 4) : l = 98 : 132 === l && (g > 0 ? (l = 39, g = 4) : l = 38)
                                }
                                if (0 != l && 170 != l) {
                                    var v,
                                        m,
                                        _,
                                        x,
                                        E,
                                        w,
                                        b,
                                        C;
                                    v = m = _ = x = E = w = b = C = .5;
                                    var M = [];
                                    1 === l ? (_ = 1 - Vo(e, p, f), C = 1 - Vo(e, h, f), M.push(jo[l])) : 169 === l ? (_ = Vo(s, f, p), C = Vo(s, f, h), M.push(jo[l])) : 4 === l ? (w = 1 - Vo(e, c, p), x = Vo(e, f, p), M.push(Fo[l])) : 166 === l ? (w = Vo(s, p, c), x = 1 - Vo(s, p, f), M.push(Fo[l])) : 16 === l ? (E = Vo(e, p, c), m = Vo(e, h, c), M.push(Do[l])) : 154 === l ? (E = 1 - Vo(s, c, p), m = 1 - Vo(s, c, h), M.push(Do[l])) : 64 === l ? (b = Vo(e, f, h), v = 1 - Vo(e, c, h), M.push(Bo[l])) : 106 === l ? (b = 1 - Vo(s, h, f), v = Vo(s, h, c), M.push(Bo[l])) : 168 === l ? (x = Vo(s, f, p), _ = Vo(e, f, p), C = Vo(e, f, h), b = Vo(s, f, h), M.push(ko[l]), M.push(jo[l])) : 2 === l ? (x = 1 - Vo(e, p, f), _ = 1 - Vo(s, p, f), C = 1 - Vo(s, h, f), b = 1 - Vo(e, h, f), M.push(ko[l]), M.push(jo[l])) : 162 === l ? (E = Vo(s, p, c), w = Vo(e, p, c), x = 1 - Vo(e, p, f), _ = 1 - Vo(s, p, f), M.push(ko[l]), M.push(jo[l])) : 8 === l ? (E = 1 - Vo(e, c, p), w = 1 - Vo(s, c, p), x = Vo(s, f, p), _ = Vo(e, f, p), M.push(Do[l]), M.push(Fo[l])) : 138 === l ? (E = 1 - Vo(e, c, p), w = 1 - Vo(s, c, p), v = 1 - Vo(s, c, h), m = 1 - Vo(e, c, h), M.push(Do[l]), M.push(Fo[l])) : 32 === l ? (E = Vo(s, p, c), w = Vo(e, p, c), v = Vo(e, h, c), m = Vo(s, h, c), M.push(Do[l]), M.push(Fo[l])) : 42 === l ? (C = 1 - Vo(s, h, f), b = 1 - Vo(e, h, f), v = Vo(e, h, c), m = Vo(s, h, c), M.push(Go[l]), M.push(Bo[l])) : 128 === l && (C = Vo(e, f, h), b = Vo(s, f, h), v = 1 - Vo(s, c, h), m = 1 - Vo(e, c, h), M.push(Go[l]), M.push(Bo[l])),
                                    5 === l ? (w = 1 - Vo(e, c, p), C = 1 - Vo(e, h, f), M.push(Fo[l])) : 165 === l ? (w = Vo(s, p, c), C = Vo(s, f, h), M.push(Fo[l])) : 20 === l ? (x = Vo(e, f, p), m = Vo(e, h, c), M.push(ko[l])) : 150 === l ? (x = 1 - Vo(s, p, f), m = 1 - Vo(s, c, h), M.push(ko[l])) : 80 === l ? (E = Vo(e, p, c), b = Vo(e, f, h), M.push(Do[l])) : 90 === l ? (E = 1 - Vo(s, c, p), b = 1 - Vo(s, h, f), M.push(Do[l])) : 65 === l ? (_ = 1 - Vo(e, p, f), v = 1 - Vo(e, c, h), M.push(jo[l])) : 105 === l ? (_ = Vo(s, f, p), v = Vo(s, h, c), M.push(jo[l])) : 160 === l ? (E = Vo(s, p, c), w = Vo(e, p, c), C = Vo(e, f, h), b = Vo(s, f, h), M.push(Do[l]), M.push(Fo[l])) : 10 === l ? (E = 1 - Vo(e, c, p), w = 1 - Vo(s, c, p), C = 1 - Vo(s, h, f), b = 1 - Vo(e, h, f), M.push(Do[l]), M.push(Fo[l])) : 130 === l ? (x = 1 - Vo(e, p, f), _ = 1 - Vo(s, p, f), v = 1 - Vo(s, c, h), m = 1 - Vo(e, c, h), M.push(ko[l]), M.push(jo[l])) : 40 === l ? (x = Vo(s, f, p), _ = Vo(e, f, p), v = Vo(e, h, c), m = Vo(s, h, c), M.push(ko[l]), M.push(jo[l])) : 101 === l ? (w = Vo(s, p, c), v = Vo(s, h, c), M.push(Fo[l])) : 69 === l ? (w = 1 - Vo(e, c, p), v = 1 - Vo(e, c, h), M.push(Fo[l])) : 149 === l ? (C = Vo(s, f, h), m = 1 - Vo(s, c, h), M.push(Go[l])) : 21 === l ? (C = 1 - Vo(e, h, f), m = Vo(e, h, c), M.push(Go[l])) : 86 === l ? (x = 1 - Vo(s, p, f), b = 1 - Vo(s, h, f), M.push(ko[l])) : 84 === l ? (x = Vo(e, f, p), b = Vo(e, f, h), M.push(ko[l])) : 89 === l ? (E = 1 - Vo(s, c, p), _ = Vo(s, f, p), M.push(jo[l])) : 81 === l ? (E = Vo(e, p, c), _ = 1 - Vo(e, p, f), M.push(jo[l])) : 96 === l ? (E = Vo(s, p, c), w = Vo(e, p, c), b = Vo(e, f, h), v = Vo(s, h, c), M.push(Do[l]), M.push(Fo[l])) : 74 === l ? (E = 1 - Vo(e, c, p), w = 1 - Vo(s, c, p), b = 1 - Vo(s, h, f), v = 1 - Vo(e, c, h), M.push(Do[l]), M.push(Fo[l])) : 24 === l ? (E = 1 - Vo(s, c, p), x = Vo(s, f, p), _ = Vo(e, f, p), m = Vo(e, h, c), M.push(Do[l]), M.push(jo[l])) : 146 === l ? (E = Vo(e, p, c), x = 1 - Vo(e, p, f), _ = 1 - Vo(s, p, f), m = 1 - Vo(s, c, h), M.push(Do[l]), M.push(jo[l])) : 6 === l ? (w = 1 - Vo(e, c, p), x = 1 - Vo(s, p, f), C = 1 - Vo(s, h, f), b = 1 - Vo(e, h, f), M.push(Fo[l]), M.push(ko[l])) : 164 === l ? (w = Vo(s, p, c), x = Vo(e, f, p), C = Vo(e, f, h), b = Vo(s, f, h), M.push(Fo[l]), M.push(ko[l])) : 129 === l ? (_ = 1 - Vo(e, p, f), C = Vo(s, f, h), v = 1 - Vo(s, c, h), m = 1 - Vo(e, c, h), M.push(jo[l]), M.push(Go[l])) : 41 === l ? (_ = Vo(s, f, p), C = 1 - Vo(e, h, f), v = Vo(e, h, c), m = Vo(s, h, c), M.push(jo[l]), M.push(Go[l])) : 66 === l ? (x = 1 - Vo(e, p, f), _ = 1 - Vo(s, p, f), b = 1 - Vo(s, h, f), v = 1 - Vo(e, c, h), M.push(ko[l]), M.push(jo[l])) : 104 === l ? (x = Vo(s, f, p), _ = Vo(e, f, p), b = Vo(e, f, h), v = Vo(s, h, c), M.push(jo[l]), M.push(qo[l])) : 144 === l ? (E = Vo(e, p, c), C = Vo(e, f, h), b = Vo(s, f, h), m = 1 - Vo(s, c, h), M.push(Do[l]), M.push(Bo[l])) : 26 === l ? (E = 1 - Vo(s, c, p), C = 1 - Vo(s, h, f), b = 1 - Vo(e, h, f), m = Vo(e, h, c), M.push(Do[l]), M.push(Bo[l])) : 36 === l ? (w = Vo(s, p, c), x = Vo(e, f, p), v = Vo(e, h, c), m = Vo(s, h, c), M.push(Fo[l]), M.push(ko[l])) : 134 === l ? (w = 1 - Vo(e, c, p), x = 1 - Vo(s, p, f), v = 1 - Vo(s, c, h), m = 1 - Vo(e, c, h), M.push(Fo[l]), M.push(ko[l])) : 9 === l ? (E = 1 - Vo(e, c, p), w = 1 - Vo(s, c, p), _ = Vo(s, f, p), C = 1 - Vo(e, h, f), M.push(Do[l]), M.push(Fo[l])) : 161 === l ? (E = Vo(s, p, c), w = Vo(e, p, c), _ = 1 - Vo(e, p, f), C = Vo(s, f, h), M.push(Do[l]), M.push(Fo[l])) : 37 === l ? (w = Vo(s, p, c), C = 1 - Vo(e, h, f), v = Vo(e, h, c), m = Vo(s, h, c), M.push(Fo[l]), M.push(Go[l])) : 133 === l ? (w = 1 - Vo(e, c, p), C = Vo(s, f, h), v = 1 - Vo(s, c, h), m = 1 - Vo(e, c, h), M.push(Fo[l]), M.push(Go[l])) : 148 === l ? (x = Vo(e, f, p), C = Vo(e, f, h), b = Vo(s, f, h), m = 1 - Vo(s, c, h), M.push(ko[l]), M.push(Bo[l])) : 22 === l ? (x = 1 - Vo(s, p, f), C = 1 - Vo(s, h, f), b = 1 - Vo(e, h, f), m = Vo(e, h, c), M.push(ko[l]), M.push(Bo[l])) : 82 === l ? (E = Vo(e, p, c), x = 1 - Vo(e, p, f), _ = 1 - Vo(s, p, f), b = 1 - Vo(s, h, f), M.push(Do[l]), M.push(jo[l])) : 88 === l ? (E = 1 - Vo(s, c, p), x = Vo(s, f, p), _ = Vo(e, f, p), b = Vo(e, f, h), M.push(Do[l]), M.push(jo[l])) : 73 === l ? (E = 1 - Vo(e, c, p), w = 1 - Vo(s, c, p), _ = Vo(s, f, p), v = 1 - Vo(e, c, h), M.push(Do[l]), M.push(Fo[l])) : 97 === l ? (E = Vo(s, p, c), w = Vo(e, p, c), _ = 1 - Vo(e, p, f), v = Vo(s, h, c), M.push(Do[l]), M.push(Fo[l])) : 145 === l ? (E = Vo(e, p, c), _ = 1 - Vo(e, p, f), C = Vo(s, f, h), m = 1 - Vo(s, c, h), M.push(Do[l]), M.push(Go[l])) : 25 === l ? (E = 1 - Vo(s, c, p), _ = Vo(s, f, p), C = 1 - Vo(e, h, f), m = Vo(e, h, c), M.push(Do[l]), M.push(Go[l])) : 70 === l ? (w = 1 - Vo(e, c, p), x = 1 - Vo(s, p, f), b = 1 - Vo(s, h, f), v = 1 - Vo(e, c, h), M.push(Fo[l]), M.push(ko[l])) : 100 === l ? (w = Vo(s, p, c), x = Vo(e, f, p), b = Vo(e, f, h), v = Vo(s, h, c), M.push(Fo[l]), M.push(ko[l])) : 34 === l ? (0 === g ? (E = 1 - Vo(e, c, p), w = 1 - Vo(s, c, p), x = Vo(s, f, p), _ = Vo(e, f, p), C = Vo(e, f, h), b = Vo(s, f, h), v = 1 - Vo(s, c, h), m = 1 - Vo(e, c, h)) : (E = Vo(s, p, c), w = Vo(e, p, c), x = 1 - Vo(e, p, f), _ = 1 - Vo(s, p, f), C = 1 - Vo(s, h, f), b = 1 - Vo(e, h, f), v = Vo(e, h, c), m = Vo(s, h, c)), M.push(Do[l]), M.push(Fo[l]), M.push(Go[l]), M.push(Bo[l])) : 35 === l ? (4 === g ? (E = 1 - Vo(e, c, p), w = 1 - Vo(s, c, p), x = Vo(s, f, p), _ = Vo(e, f, p), C = Vo(e, f, h), b = Vo(s, f, h), v = 1 - Vo(s, c, h), m = 1 - Vo(e, c, h)) : (E = Vo(s, p, c), w = Vo(e, p, c), x = 1 - Vo(e, p, f), _ = 1 - Vo(s, p, f), C = 1 - Vo(s, h, f), b = 1 - Vo(e, h, f), v = Vo(e, h, c), m = Vo(s, h, c)), M.push(Do[l]), M.push(Fo[l]), M.push(jo[l]), M.push(Bo[l])) : 136 === l ? (0 === g ? (E = Vo(s, p, c), w = Vo(e, p, c), x = 1 - Vo(e, p, f), _ = 1 - Vo(s, p, f), C = 1 - Vo(s, h, f), b = 1 - Vo(e, h, f), v = Vo(e, h, c), m = Vo(s, h, c)) : (E = 1 - Vo(e, c, p), w = 1 - Vo(s, c, p), x = Vo(s, f, p), _ = Vo(e, f, p), C = Vo(e, f, h), b = Vo(s, f, h), v = 1 - Vo(s, c, h), m = 1 - Vo(e, c, h)), M.push(Do[l]), M.push(Fo[l]), M.push(Go[l]), M.push(Bo[l])) : 153 === l ? (0 === g ? (E = Vo(e, p, c), _ = 1 - Vo(e, p, f), C = 1 - Vo(e, h, f), m = Vo(e, h, c)) : (E = 1 - Vo(s, c, p), _ = Vo(s, f, p), C = Vo(s, f, h), m = 1 - Vo(s, c, h)), M.push(Do[l]), M.push(jo[l])) : 102 === l ? (0 === g ? (w = 1 - Vo(e, c, p), x = Vo(e, f, p), b = Vo(e, f, h), v = 1 - Vo(e, c, h)) : (w = Vo(s, p, c), x = 1 - Vo(s, p, f), b = 1 - Vo(s, h, f), v = Vo(s, h, c)), M.push(Fo[l]), M.push(Bo[l])) : 155 === l ? (4 === g ? (E = Vo(e, p, c), _ = 1 - Vo(e, p, f), C = 1 - Vo(e, h, f), m = Vo(e, h, c)) : (E = 1 - Vo(s, c, p), _ = Vo(s, f, p), C = Vo(s, f, h), m = 1 - Vo(s, c, h)), M.push(Do[l]), M.push(Go[l])) : 103 === l ? (4 === g ? (w = 1 - Vo(e, c, p), x = Vo(e, f, p), b = Vo(e, f, h), v = 1 - Vo(e, c, h)) : (w = Vo(s, p, c), x = 1 - Vo(s, p, f), b = 1 - Vo(s, h, f), v = Vo(s, h, c)), M.push(Fo[l]), M.push(ko[l])) : 152 === l ? (0 === g ? (E = Vo(e, p, c), x = 1 - Vo(e, p, f), _ = 1 - Vo(s, p, f), C = 1 - Vo(s, h, f), b = 1 - Vo(e, h, f), m = Vo(e, h, c)) : (E = 1 - Vo(s, c, p), x = Vo(s, f, p), _ = Vo(e, f, p), C = Vo(e, f, h), b = Vo(s, f, h), m = 1 - Vo(s, c, h)), M.push(Do[l]), M.push(ko[l]), M.push(jo[l])) : 156 === l ? (4 === g ? (E = Vo(e, p, c), x = 1 - Vo(e, p, f), _ = 1 - Vo(s, p, f), C = 1 - Vo(s, h, f), b = 1 - Vo(e, h, f), m = Vo(e, h, c)) : (E = 1 - Vo(s, c, p), x = Vo(s, f, p), _ = Vo(e, f, p), C = Vo(e, f, h), b = Vo(s, f, h), m = 1 - Vo(s, c, h)), M.push(Do[l]), M.push(jo[l]), M.push(Bo[l])) : 137 === l ? (0 === g ? (E = Vo(s, p, c), w = Vo(e, p, c), _ = 1 - Vo(e, p, f), C = 1 - Vo(e, h, f), v = Vo(e, h, c), m = Vo(s, h, c)) : (E = 1 - Vo(e, c, p), w = 1 - Vo(s, c, p), _ = Vo(s, f, p), C = Vo(s, f, h), v = 1 - Vo(s, c, h), m = 1 - Vo(e, c, h)), M.push(Do[l]), M.push(Fo[l]), M.push(jo[l])) : 139 === l ? (4 === g ? (E = Vo(s, p, c), w = Vo(e, p, c), _ = 1 - Vo(e, p, f), C = 1 - Vo(e, h, f), v = Vo(e, h, c), m = Vo(s, h, c)) : (E = 1 - Vo(e, c, p), w = 1 - Vo(s, c, p), _ = Vo(s, f, p), C = Vo(s, f, h), v = 1 - Vo(s, c, h), m = 1 - Vo(e, c, h)), M.push(Do[l]), M.push(Fo[l]), M.push(Go[l])) : 98 === l ? (0 === g ? (E = 1 - Vo(e, c, p), w = 1 - Vo(s, c, p), x = Vo(s, f, p), _ = Vo(e, f, p), b = Vo(e, f, h), v = 1 - Vo(e, c, h)) : (E = Vo(s, p, c), w = Vo(e, p, c), x = 1 - Vo(e, p, f), _ = 1 - Vo(s, p, f), b = 1 - Vo(s, h, f), v = Vo(s, h, c)), M.push(Do[l]), M.push(Fo[l]), M.push(Bo[l])) : 99 === l ? (4 === g ? (E = 1 - Vo(e, c, p), w = 1 - Vo(s, c, p), x = Vo(s, f, p), _ = Vo(e, f, p), b = Vo(e, f, h), v = 1 - Vo(e, c, h)) : (E = Vo(s, p, c), w = Vo(e, p, c), x = 1 - Vo(e, p, f), _ = 1 - Vo(s, p, f), b = 1 - Vo(s, h, f), v = Vo(s, h, c)), M.push(Do[l]), M.push(Fo[l]), M.push(jo[l])) : 38 === l ? (0 === g ? (w = 1 - Vo(e, c, p), x = Vo(e, f, p), C = Vo(e, f, h), b = Vo(s, f, h), v = 1 - Vo(s, c, h), m = 1 - Vo(e, c, h)) : (w = Vo(s, p, c), x = 1 - Vo(s, p, f), C = 1 - Vo(s, h, f), b = 1 - Vo(e, h, f), v = Vo(e, h, c), m = Vo(s, h, c)), M.push(Fo[l]), M.push(Go[l]), M.push(Bo[l])) : 39 === l ? (4 === g ? (w = 1 - Vo(e, c, p), x = Vo(e, f, p), C = Vo(e, f, h), b = Vo(s, f, h), v = 1 - Vo(s, c, h), m = 1 - Vo(e, c, h)) : (w = Vo(s, p, c), x = 1 - Vo(s, p, f), C = 1 - Vo(s, h, f), b = 1 - Vo(e, h, f), v = Vo(e, h, c), m = Vo(s, h, c)), M.push(Fo[l]), M.push(ko[l]), M.push(Bo[l])) : 85 === l && (E = 1, w = 0, x = 1, _ = 0, C = 0, b = 1, v = 0, m = 1),
                                    (v < 0 || v > 1 || m < 0 || m > 1 || E < 0 || E > 1 || x < 0 || x > 1 || C < 0 || C > 1 || b < 0 || b > 1) && console.log("MarchingSquaresJS-isoBands: " + l + " " + d + " " + h + "," + c + "," + p + "," + f + " " + g + " " + v + " " + m + " " + E + " " + w + " " + x + " " + _ + " " + C + " " + b),
                                    o.cells[a][u] = {
                                        cval: l,
                                        cval_real: d,
                                        flipped: g,
                                        topleft: v,
                                        topright: m,
                                        righttop: E,
                                        rightbottom: w,
                                        bottomright: x,
                                        bottomleft: _,
                                        leftbottom: C,
                                        lefttop: b,
                                        edges: M
                                    }
                                }
                            }
                        }
                    }
                    return o
                }(t, e, n);
            return Ji.polygons ? (Ji.verbose && console.log("MarchingSquaresJS-isoBands: returning single polygons for each grid cell"), u = function(t) {
                var e = [],
                    n = 0;
                return t.cells.forEach((function(t, r) {
                    t.forEach((function(t, i) {
                        if (void 0 !== t) {
                            var o = Uo[t.cval](t);
                            "object" == typeof o && Xo(o) ? "object" == typeof o[0] && Xo(o[0]) ? "object" == typeof o[0][0] && Xo(o[0][0]) ? o.forEach((function(t) {
                                t.forEach((function(t) {
                                    t[0] += i,
                                    t[1] += r
                                })),
                                e[n++] = t
                            })) : (o.forEach((function(t) {
                                t[0] += i,
                                t[1] += r
                            })), e[n++] = o) : console.log("MarchingSquaresJS-isoBands: bandcell polygon with malformed coordinates") : console.log("MarchingSquaresJS-isoBands: bandcell polygon with null coordinates")
                        }
                    }))
                })), e
            }(l)) : (Ji.verbose && console.log("MarchingSquaresJS-isoBands: returning polygon paths for entire data grid"), u = function(t) {
                for (var e = [], n = t.rows, r = t.cols, i = [], o = 0; o < n; o++)
                    for (var s = 0; s < r; s++)
                        if (void 0 !== t.cells[o][s] && t.cells[o][s].edges.length > 0) {
                            var a = Yo(t.cells[o][s]),
                                u = null,
                                l = s,
                                h = o;
                            null !== a && i.push([a.p[0] + l, a.p[1] + h]);
                            do {
                                if (null === (u = Wo(t.cells[h][l], a.x, a.y, a.o)))
                                    break;
                                if (i.push([u.p[0] + l, u.p[1] + h]), l += u.x, a = u, (h += u.y) < 0 || h >= n || l < 0 || l >= r || void 0 === t.cells[h][l]) {
                                    var c = Ho(t, l -= u.x, h -= u.y, u.x, u.y, u.o);
                                    if (null === c)
                                        break;
                                    c.path.forEach((function(t) {
                                        i.push(t)
                                    })),
                                    l = c.i,
                                    h = c.j,
                                    a = c
                                }
                            } while (void 0 !== t.cells[h][l] && t.cells[h][l].edges.length > 0);
                            e.push(i),
                            i = [],
                            t.cells[o][s].edges.length > 0 && s--
                        }
                return e
            }(l)), "function" == typeof Ji.successCallback && Ji.successCallback(u), u
        }
        var to = 64,
            eo = 16,
            no = [],
            ro = [],
            io = [],
            oo = [],
            so = [],
            ao = [],
            uo = [],
            lo = [],
            ho = [],
            co = [],
            po = [],
            fo = [],
            go = [],
            yo = [],
            vo = [],
            mo = [],
            _o = [],
            xo = [],
            Eo = [],
            wo = [],
            bo = [],
            Co = [],
            Mo = [],
            So = [];
        uo[85] = co[85] = -1,
        lo[85] = po[85] = 0,
        ho[85] = fo[85] = 1,
        Eo[85] = Co[85] = 1,
        wo[85] = Mo[85] = 0,
        bo[85] = So[85] = 1,
        no[85] = oo[85] = 0,
        ro[85] = so[85] = -1,
        io[85] = vo[85] = 0,
        mo[85] = go[85] = 0,
        _o[85] = yo[85] = 1,
        ao[85] = xo[85] = 1,
        Co[1] = Co[169] = 0,
        Mo[1] = Mo[169] = -1,
        So[1] = So[169] = 0,
        go[1] = go[169] = -1,
        yo[1] = yo[169] = 0,
        vo[1] = vo[169] = 0,
        co[4] = co[166] = 0,
        po[4] = po[166] = -1,
        fo[4] = fo[166] = 1,
        mo[4] = mo[166] = 1,
        _o[4] = _o[166] = 0,
        xo[4] = xo[166] = 0,
        uo[16] = uo[154] = 0,
        lo[16] = lo[154] = 1,
        ho[16] = ho[154] = 1,
        oo[16] = oo[154] = 1,
        so[16] = so[154] = 0,
        ao[16] = ao[154] = 1,
        Eo[64] = Eo[106] = 0,
        wo[64] = wo[106] = 1,
        bo[64] = bo[106] = 0,
        no[64] = no[106] = -1,
        ro[64] = ro[106] = 0,
        io[64] = io[106] = 1,
        Eo[2] = Eo[168] = 0,
        wo[2] = wo[168] = -1,
        bo[2] = bo[168] = 1,
        Co[2] = Co[168] = 0,
        Mo[2] = Mo[168] = -1,
        So[2] = So[168] = 0,
        go[2] = go[168] = -1,
        yo[2] = yo[168] = 0,
        vo[2] = vo[168] = 0,
        mo[2] = mo[168] = -1,
        _o[2] = _o[168] = 0,
        xo[2] = xo[168] = 1,
        uo[8] = uo[162] = 0,
        lo[8] = lo[162] = -1,
        ho[8] = ho[162] = 0,
        co[8] = co[162] = 0,
        po[8] = po[162] = -1,
        fo[8] = fo[162] = 1,
        go[8] = go[162] = 1,
        yo[8] = yo[162] = 0,
        vo[8] = vo[162] = 1,
        mo[8] = mo[162] = 1,
        _o[8] = _o[162] = 0,
        xo[8] = xo[162] = 0,
        uo[32] = uo[138] = 0,
        lo[32] = lo[138] = 1,
        ho[32] = ho[138] = 1,
        co[32] = co[138] = 0,
        po[32] = po[138] = 1,
        fo[32] = fo[138] = 0,
        no[32] = no[138] = 1,
        ro[32] = ro[138] = 0,
        io[32] = io[138] = 0,
        oo[32] = oo[138] = 1,
        so[32] = so[138] = 0,
        ao[32] = ao[138] = 1,
        Co[128] = Co[42] = 0,
        Mo[128] = Mo[42] = 1,
        So[128] = So[42] = 1,
        Eo[128] = Eo[42] = 0,
        wo[128] = wo[42] = 1,
        bo[128] = bo[42] = 0,
        no[128] = no[42] = -1,
        ro[128] = ro[42] = 0,
        io[128] = io[42] = 1,
        oo[128] = oo[42] = -1,
        so[128] = so[42] = 0,
        ao[128] = ao[42] = 0,
        co[5] = co[165] = -1,
        po[5] = po[165] = 0,
        fo[5] = fo[165] = 0,
        Co[5] = Co[165] = 1,
        Mo[5] = Mo[165] = 0,
        So[5] = So[165] = 0,
        mo[20] = mo[150] = 0,
        _o[20] = _o[150] = 1,
        xo[20] = xo[150] = 1,
        oo[20] = oo[150] = 0,
        so[20] = so[150] = -1,
        ao[20] = ao[150] = 1,
        uo[80] = uo[90] = -1,
        lo[80] = lo[90] = 0,
        ho[80] = ho[90] = 1,
        Eo[80] = Eo[90] = 1,
        wo[80] = wo[90] = 0,
        bo[80] = bo[90] = 1,
        go[65] = go[105] = 0,
        yo[65] = yo[105] = 1,
        vo[65] = vo[105] = 0,
        no[65] = no[105] = 0,
        ro[65] = ro[105] = -1,
        io[65] = io[105] = 0,
        uo[160] = uo[10] = -1,
        lo[160] = lo[10] = 0,
        ho[160] = ho[10] = 1,
        co[160] = co[10] = -1,
        po[160] = po[10] = 0,
        fo[160] = fo[10] = 0,
        Co[160] = Co[10] = 1,
        Mo[160] = Mo[10] = 0,
        So[160] = So[10] = 0,
        Eo[160] = Eo[10] = 1,
        wo[160] = wo[10] = 0,
        bo[160] = bo[10] = 1,
        mo[130] = mo[40] = 0,
        _o[130] = _o[40] = 1,
        xo[130] = xo[40] = 1,
        go[130] = go[40] = 0,
        yo[130] = yo[40] = 1,
        vo[130] = vo[40] = 0,
        no[130] = no[40] = 0,
        ro[130] = ro[40] = -1,
        io[130] = io[40] = 0,
        oo[130] = oo[40] = 0,
        so[130] = so[40] = -1,
        ao[130] = ao[40] = 1,
        co[37] = co[133] = 0,
        po[37] = po[133] = 1,
        fo[37] = fo[133] = 1,
        Co[37] = Co[133] = 0,
        Mo[37] = Mo[133] = 1,
        So[37] = So[133] = 0,
        no[37] = no[133] = -1,
        ro[37] = ro[133] = 0,
        io[37] = io[133] = 0,
        oo[37] = oo[133] = 1,
        so[37] = so[133] = 0,
        ao[37] = ao[133] = 0,
        mo[148] = mo[22] = -1,
        _o[148] = _o[22] = 0,
        xo[148] = xo[22] = 0,
        Co[148] = Co[22] = 0,
        Mo[148] = Mo[22] = -1,
        So[148] = So[22] = 1,
        Eo[148] = Eo[22] = 0,
        wo[148] = wo[22] = 1,
        bo[148] = bo[22] = 1,
        oo[148] = oo[22] = -1,
        so[148] = so[22] = 0,
        ao[148] = ao[22] = 1,
        uo[82] = uo[88] = 0,
        lo[82] = lo[88] = -1,
        ho[82] = ho[88] = 1,
        mo[82] = mo[88] = 1,
        _o[82] = _o[88] = 0,
        xo[82] = xo[88] = 1,
        go[82] = go[88] = -1,
        yo[82] = yo[88] = 0,
        vo[82] = vo[88] = 1,
        Eo[82] = Eo[88] = 0,
        wo[82] = wo[88] = -1,
        bo[82] = bo[88] = 0,
        uo[73] = uo[97] = 0,
        lo[73] = lo[97] = 1,
        ho[73] = ho[97] = 0,
        co[73] = co[97] = 0,
        po[73] = po[97] = -1,
        fo[73] = fo[97] = 0,
        go[73] = go[97] = 1,
        yo[73] = yo[97] = 0,
        vo[73] = vo[97] = 0,
        no[73] = no[97] = 1,
        ro[73] = ro[97] = 0,
        io[73] = io[97] = 1,
        uo[145] = uo[25] = 0,
        lo[145] = lo[25] = -1,
        ho[145] = ho[25] = 0,
        go[145] = go[25] = 1,
        yo[145] = yo[25] = 0,
        vo[145] = vo[25] = 1,
        Co[145] = Co[25] = 0,
        Mo[145] = Mo[25] = 1,
        So[145] = So[25] = 1,
        oo[145] = oo[25] = -1,
        so[145] = so[25] = 0,
        ao[145] = ao[25] = 0,
        co[70] = co[100] = 0,
        po[70] = po[100] = 1,
        fo[70] = fo[100] = 0,
        mo[70] = mo[100] = -1,
        _o[70] = _o[100] = 0,
        xo[70] = xo[100] = 1,
        Eo[70] = Eo[100] = 0,
        wo[70] = wo[100] = -1,
        bo[70] = bo[100] = 1,
        no[70] = no[100] = 1,
        ro[70] = ro[100] = 0,
        io[70] = io[100] = 0,
        co[101] = co[69] = 0,
        po[101] = po[69] = 1,
        fo[101] = fo[69] = 0,
        no[101] = no[69] = 1,
        ro[101] = ro[69] = 0,
        io[101] = io[69] = 0,
        Co[149] = Co[21] = 0,
        Mo[149] = Mo[21] = 1,
        So[149] = So[21] = 1,
        oo[149] = oo[21] = -1,
        so[149] = so[21] = 0,
        ao[149] = ao[21] = 0,
        mo[86] = mo[84] = -1,
        _o[86] = _o[84] = 0,
        xo[86] = xo[84] = 1,
        Eo[86] = Eo[84] = 0,
        wo[86] = wo[84] = -1,
        bo[86] = bo[84] = 1,
        uo[89] = uo[81] = 0,
        lo[89] = lo[81] = -1,
        ho[89] = ho[81] = 0,
        go[89] = go[81] = 1,
        yo[89] = yo[81] = 0,
        vo[89] = vo[81] = 1,
        uo[96] = uo[74] = 0,
        lo[96] = lo[74] = 1,
        ho[96] = ho[74] = 0,
        co[96] = co[74] = -1,
        po[96] = po[74] = 0,
        fo[96] = fo[74] = 1,
        Eo[96] = Eo[74] = 1,
        wo[96] = wo[74] = 0,
        bo[96] = bo[74] = 0,
        no[96] = no[74] = 1,
        ro[96] = ro[74] = 0,
        io[96] = io[74] = 1,
        uo[24] = uo[146] = 0,
        lo[24] = lo[146] = -1,
        ho[24] = ho[146] = 1,
        mo[24] = mo[146] = 1,
        _o[24] = _o[146] = 0,
        xo[24] = xo[146] = 1,
        go[24] = go[146] = 0,
        yo[24] = yo[146] = 1,
        vo[24] = vo[146] = 1,
        oo[24] = oo[146] = 0,
        so[24] = so[146] = -1,
        ao[24] = ao[146] = 0,
        co[6] = co[164] = -1,
        po[6] = po[164] = 0,
        fo[6] = fo[164] = 1,
        mo[6] = mo[164] = -1,
        _o[6] = _o[164] = 0,
        xo[6] = xo[164] = 0,
        Co[6] = Co[164] = 0,
        Mo[6] = Mo[164] = -1,
        So[6] = So[164] = 1,
        Eo[6] = Eo[164] = 1,
        wo[6] = wo[164] = 0,
        bo[6] = bo[164] = 0,
        go[129] = go[41] = 0,
        yo[129] = yo[41] = 1,
        vo[129] = vo[41] = 1,
        Co[129] = Co[41] = 0,
        Mo[129] = Mo[41] = 1,
        So[129] = So[41] = 0,
        no[129] = no[41] = -1,
        ro[129] = ro[41] = 0,
        io[129] = io[41] = 0,
        oo[129] = oo[41] = 0,
        so[129] = so[41] = -1,
        ao[129] = ao[41] = 0,
        mo[66] = mo[104] = 0,
        _o[66] = _o[104] = 1,
        xo[66] = xo[104] = 0,
        go[66] = go[104] = -1,
        yo[66] = yo[104] = 0,
        vo[66] = vo[104] = 1,
        Eo[66] = Eo[104] = 0,
        wo[66] = wo[104] = -1,
        bo[66] = bo[104] = 0,
        no[66] = no[104] = 0,
        ro[66] = ro[104] = -1,
        io[66] = io[104] = 1,
        uo[144] = uo[26] = -1,
        lo[144] = lo[26] = 0,
        ho[144] = ho[26] = 0,
        Co[144] = Co[26] = 1,
        Mo[144] = Mo[26] = 0,
        So[144] = So[26] = 1,
        Eo[144] = Eo[26] = 0,
        wo[144] = wo[26] = 1,
        bo[144] = bo[26] = 1,
        oo[144] = oo[26] = -1,
        so[144] = so[26] = 0,
        ao[144] = ao[26] = 1,
        co[36] = co[134] = 0,
        po[36] = po[134] = 1,
        fo[36] = fo[134] = 1,
        mo[36] = mo[134] = 0,
        _o[36] = _o[134] = 1,
        xo[36] = xo[134] = 0,
        no[36] = no[134] = 0,
        ro[36] = ro[134] = -1,
        io[36] = io[134] = 1,
        oo[36] = oo[134] = 1,
        so[36] = so[134] = 0,
        ao[36] = ao[134] = 0,
        uo[9] = uo[161] = -1,
        lo[9] = lo[161] = 0,
        ho[9] = ho[161] = 0,
        co[9] = co[161] = 0,
        po[9] = po[161] = -1,
        fo[9] = fo[161] = 0,
        go[9] = go[161] = 1,
        yo[9] = yo[161] = 0,
        vo[9] = vo[161] = 0,
        Co[9] = Co[161] = 1,
        Mo[9] = Mo[161] = 0,
        So[9] = So[161] = 1,
        uo[136] = 0,
        lo[136] = 1,
        ho[136] = 1,
        co[136] = 0,
        po[136] = 1,
        fo[136] = 0,
        mo[136] = -1,
        _o[136] = 0,
        xo[136] = 1,
        go[136] = -1,
        yo[136] = 0,
        vo[136] = 0,
        Co[136] = 0,
        Mo[136] = -1,
        So[136] = 0,
        Eo[136] = 0,
        wo[136] = -1,
        bo[136] = 1,
        no[136] = 1,
        ro[136] = 0,
        io[136] = 0,
        oo[136] = 1,
        so[136] = 0,
        ao[136] = 1,
        uo[34] = 0,
        lo[34] = -1,
        ho[34] = 0,
        co[34] = 0,
        po[34] = -1,
        fo[34] = 1,
        mo[34] = 1,
        _o[34] = 0,
        xo[34] = 0,
        go[34] = 1,
        yo[34] = 0,
        vo[34] = 1,
        Co[34] = 0,
        Mo[34] = 1,
        So[34] = 1,
        Eo[34] = 0,
        wo[34] = 1,
        bo[34] = 0,
        no[34] = -1,
        ro[34] = 0,
        io[34] = 1,
        oo[34] = -1,
        so[34] = 0,
        ao[34] = 0,
        uo[35] = 0,
        lo[35] = 1,
        ho[35] = 1,
        co[35] = 0,
        po[35] = -1,
        fo[35] = 1,
        mo[35] = 1,
        _o[35] = 0,
        xo[35] = 0,
        go[35] = -1,
        yo[35] = 0,
        vo[35] = 0,
        Co[35] = 0,
        Mo[35] = -1,
        So[35] = 0,
        Eo[35] = 0,
        wo[35] = 1,
        bo[35] = 0,
        no[35] = -1,
        ro[35] = 0,
        io[35] = 1,
        oo[35] = 1,
        so[35] = 0,
        ao[35] = 1,
        uo[153] = 0,
        lo[153] = 1,
        ho[153] = 1,
        go[153] = -1,
        yo[153] = 0,
        vo[153] = 0,
        Co[153] = 0,
        Mo[153] = -1,
        So[153] = 0,
        oo[153] = 1,
        so[153] = 0,
        ao[153] = 1,
        co[102] = 0,
        po[102] = -1,
        fo[102] = 1,
        mo[102] = 1,
        _o[102] = 0,
        xo[102] = 0,
        Eo[102] = 0,
        wo[102] = 1,
        bo[102] = 0,
        no[102] = -1,
        ro[102] = 0,
        io[102] = 1,
        uo[155] = 0,
        lo[155] = -1,
        ho[155] = 0,
        go[155] = 1,
        yo[155] = 0,
        vo[155] = 1,
        Co[155] = 0,
        Mo[155] = 1,
        So[155] = 1,
        oo[155] = -1,
        so[155] = 0,
        ao[155] = 0,
        co[103] = 0,
        po[103] = 1,
        fo[103] = 0,
        mo[103] = -1,
        _o[103] = 0,
        xo[103] = 1,
        Eo[103] = 0,
        wo[103] = -1,
        bo[103] = 1,
        no[103] = 1,
        ro[103] = 0,
        io[103] = 0,
        uo[152] = 0,
        lo[152] = 1,
        ho[152] = 1,
        mo[152] = -1,
        _o[152] = 0,
        xo[152] = 1,
        go[152] = -1,
        yo[152] = 0,
        vo[152] = 0,
        Co[152] = 0,
        Mo[152] = -1,
        So[152] = 0,
        Eo[152] = 0,
        wo[152] = -1,
        bo[152] = 1,
        oo[152] = 1,
        so[152] = 0,
        ao[152] = 1,
        uo[156] = 0,
        lo[156] = -1,
        ho[156] = 1,
        mo[156] = 1,
        _o[156] = 0,
        xo[156] = 1,
        go[156] = -1,
        yo[156] = 0,
        vo[156] = 0,
        Co[156] = 0,
        Mo[156] = -1,
        So[156] = 0,
        Eo[156] = 0,
        wo[156] = 1,
        bo[156] = 1,
        oo[156] = -1,
        so[156] = 0,
        ao[156] = 1,
        uo[137] = 0,
        lo[137] = 1,
        ho[137] = 1,
        co[137] = 0,
        po[137] = 1,
        fo[137] = 0,
        go[137] = -1,
        yo[137] = 0,
        vo[137] = 0,
        Co[137] = 0,
        Mo[137] = -1,
        So[137] = 0,
        no[137] = 1,
        ro[137] = 0,
        io[137] = 0,
        oo[137] = 1,
        so[137] = 0,
        ao[137] = 1,
        uo[139] = 0,
        lo[139] = 1,
        ho[139] = 1,
        co[139] = 0,
        po[139] = -1,
        fo[139] = 0,
        go[139] = 1,
        yo[139] = 0,
        vo[139] = 0,
        Co[139] = 0,
        Mo[139] = 1,
        So[139] = 0,
        no[139] = -1,
        ro[139] = 0,
        io[139] = 0,
        oo[139] = 1,
        so[139] = 0,
        ao[139] = 1,
        uo[98] = 0,
        lo[98] = -1,
        ho[98] = 0,
        co[98] = 0,
        po[98] = -1,
        fo[98] = 1,
        mo[98] = 1,
        _o[98] = 0,
        xo[98] = 0,
        go[98] = 1,
        yo[98] = 0,
        vo[98] = 1,
        Eo[98] = 0,
        wo[98] = 1,
        bo[98] = 0,
        no[98] = -1,
        ro[98] = 0,
        io[98] = 1,
        uo[99] = 0,
        lo[99] = 1,
        ho[99] = 0,
        co[99] = 0,
        po[99] = -1,
        fo[99] = 1,
        mo[99] = 1,
        _o[99] = 0,
        xo[99] = 0,
        go[99] = -1,
        yo[99] = 0,
        vo[99] = 1,
        Eo[99] = 0,
        wo[99] = -1,
        bo[99] = 0,
        no[99] = 1,
        ro[99] = 0,
        io[99] = 1,
        co[38] = 0,
        po[38] = -1,
        fo[38] = 1,
        mo[38] = 1,
        _o[38] = 0,
        xo[38] = 0,
        Co[38] = 0,
        Mo[38] = 1,
        So[38] = 1,
        Eo[38] = 0,
        wo[38] = 1,
        bo[38] = 0,
        no[38] = -1,
        ro[38] = 0,
        io[38] = 1,
        oo[38] = -1,
        so[38] = 0,
        ao[38] = 0,
        co[39] = 0,
        po[39] = 1,
        fo[39] = 1,
        mo[39] = -1,
        _o[39] = 0,
        xo[39] = 0,
        Co[39] = 0,
        Mo[39] = -1,
        So[39] = 1,
        Eo[39] = 0,
        wo[39] = 1,
        bo[39] = 0,
        no[39] = -1,
        ro[39] = 0,
        io[39] = 1,
        oo[39] = 1,
        so[39] = 0,
        ao[39] = 0;
        var Io = function(t) {
                return [[t.bottomleft, 0], [0, 0], [0, t.leftbottom]]
            },
            To = function(t) {
                return [[1, t.rightbottom], [1, 0], [t.bottomright, 0]]
            },
            Po = function(t) {
                return [[t.topright, 1], [1, 1], [1, t.righttop]]
            },
            Lo = function(t) {
                return [[0, t.lefttop], [0, 1], [t.topleft, 1]]
            },
            Oo = function(t) {
                return [[t.bottomright, 0], [t.bottomleft, 0], [0, t.leftbottom], [0, t.lefttop]]
            },
            No = function(t) {
                return [[t.bottomright, 0], [t.bottomleft, 0], [1, t.righttop], [1, t.rightbottom]]
            },
            Ro = function(t) {
                return [[1, t.righttop], [1, t.rightbottom], [t.topleft, 1], [t.topright, 1]]
            },
            Ao = function(t) {
                return [[0, t.leftbottom], [0, t.lefttop], [t.topleft, 1], [t.topright, 1]]
            },
            Do = [],
            Fo = [],
            ko = [],
            jo = [],
            Go = [],
            Bo = [],
            qo = [],
            zo = [];
        jo[1] = Go[1] = 18,
        jo[169] = Go[169] = 18,
        ko[4] = Fo[4] = 12,
        ko[166] = Fo[166] = 12,
        Do[16] = zo[16] = 4,
        Do[154] = zo[154] = 4,
        Bo[64] = qo[64] = 22,
        Bo[106] = qo[106] = 22,
        ko[2] = Bo[2] = 17,
        jo[2] = Go[2] = 18,
        ko[168] = Bo[168] = 17,
        jo[168] = Go[168] = 18,
        Do[8] = jo[8] = 9,
        Fo[8] = ko[8] = 12,
        Do[162] = jo[162] = 9,
        Fo[162] = ko[162] = 12,
        Do[32] = zo[32] = 4,
        Fo[32] = qo[32] = 1,
        Do[138] = zo[138] = 4,
        Fo[138] = qo[138] = 1,
        Go[128] = zo[128] = 21,
        Bo[128] = qo[128] = 22,
        Go[42] = zo[42] = 21,
        Bo[42] = qo[42] = 22,
        Fo[5] = Go[5] = 14,
        Fo[165] = Go[165] = 14,
        ko[20] = zo[20] = 6,
        ko[150] = zo[150] = 6,
        Do[80] = Bo[80] = 11,
        Do[90] = Bo[90] = 11,
        jo[65] = qo[65] = 3,
        jo[105] = qo[105] = 3,
        Do[160] = Bo[160] = 11,
        Fo[160] = Go[160] = 14,
        Do[10] = Bo[10] = 11,
        Fo[10] = Go[10] = 14,
        ko[130] = zo[130] = 6,
        jo[130] = qo[130] = 3,
        ko[40] = zo[40] = 6,
        jo[40] = qo[40] = 3,
        Fo[101] = qo[101] = 1,
        Fo[69] = qo[69] = 1,
        Go[149] = zo[149] = 21,
        Go[21] = zo[21] = 21,
        ko[86] = Bo[86] = 17,
        ko[84] = Bo[84] = 17,
        Do[89] = jo[89] = 9,
        Do[81] = jo[81] = 9,
        Do[96] = qo[96] = 0,
        Fo[96] = Bo[96] = 15,
        Do[74] = qo[74] = 0,
        Fo[74] = Bo[74] = 15,
        Do[24] = ko[24] = 8,
        jo[24] = zo[24] = 7,
        Do[146] = ko[146] = 8,
        jo[146] = zo[146] = 7,
        Fo[6] = Bo[6] = 15,
        ko[6] = Go[6] = 16,
        Fo[164] = Bo[164] = 15,
        ko[164] = Go[164] = 16,
        jo[129] = zo[129] = 7,
        Go[129] = qo[129] = 20,
        jo[41] = zo[41] = 7,
        Go[41] = qo[41] = 20,
        ko[66] = qo[66] = 2,
        jo[66] = Bo[66] = 19,
        ko[104] = qo[104] = 2,
        jo[104] = Bo[104] = 19,
        Do[144] = Go[144] = 10,
        Bo[144] = zo[144] = 23,
        Do[26] = Go[26] = 10,
        Bo[26] = zo[26] = 23,
        Fo[36] = zo[36] = 5,
        ko[36] = qo[36] = 2,
        Fo[134] = zo[134] = 5,
        ko[134] = qo[134] = 2,
        Do[9] = Go[9] = 10,
        Fo[9] = jo[9] = 13,
        Do[161] = Go[161] = 10,
        Fo[161] = jo[161] = 13,
        Fo[37] = zo[37] = 5,
        Go[37] = qo[37] = 20,
        Fo[133] = zo[133] = 5,
        Go[133] = qo[133] = 20,
        ko[148] = Go[148] = 16,
        Bo[148] = zo[148] = 23,
        ko[22] = Go[22] = 16,
        Bo[22] = zo[22] = 23,
        Do[82] = ko[82] = 8,
        jo[82] = Bo[82] = 19,
        Do[88] = ko[88] = 8,
        jo[88] = Bo[88] = 19,
        Do[73] = qo[73] = 0,
        Fo[73] = jo[73] = 13,
        Do[97] = qo[97] = 0,
        Fo[97] = jo[97] = 13,
        Do[145] = jo[145] = 9,
        Go[145] = zo[145] = 21,
        Do[25] = jo[25] = 9,
        Go[25] = zo[25] = 21,
        Fo[70] = qo[70] = 1,
        ko[70] = Bo[70] = 17,
        Fo[100] = qo[100] = 1,
        ko[100] = Bo[100] = 17,
        Do[34] = jo[34] = 9,
        Fo[34] = ko[34] = 12,
        Go[34] = zo[34] = 21,
        Bo[34] = qo[34] = 22,
        Do[136] = zo[136] = 4,
        Fo[136] = qo[136] = 1,
        ko[136] = Bo[136] = 17,
        jo[136] = Go[136] = 18,
        Do[35] = zo[35] = 4,
        Fo[35] = ko[35] = 12,
        jo[35] = Go[35] = 18,
        Bo[35] = qo[35] = 22,
        Do[153] = zo[153] = 4,
        jo[153] = Go[153] = 18,
        Fo[102] = ko[102] = 12,
        Bo[102] = qo[102] = 22,
        Do[155] = jo[155] = 9,
        Go[155] = zo[155] = 23,
        Fo[103] = qo[103] = 1,
        ko[103] = Bo[103] = 17,
        Do[152] = zo[152] = 4,
        ko[152] = Bo[152] = 17,
        jo[152] = Go[152] = 18,
        Do[156] = ko[156] = 8,
        jo[156] = Go[156] = 18,
        Bo[156] = zo[156] = 23,
        Do[137] = zo[137] = 4,
        Fo[137] = qo[137] = 1,
        jo[137] = Go[137] = 18,
        Do[139] = zo[139] = 4,
        Fo[139] = jo[139] = 13,
        Go[139] = qo[139] = 20,
        Do[98] = jo[98] = 9,
        Fo[98] = ko[98] = 12,
        Bo[98] = qo[98] = 22,
        Do[99] = qo[99] = 0,
        Fo[99] = ko[99] = 12,
        jo[99] = Bo[99] = 19,
        Fo[38] = ko[38] = 12,
        Go[38] = zo[38] = 21,
        Bo[38] = qo[38] = 22,
        Fo[39] = zo[39] = 5,
        ko[39] = Go[39] = 16,
        Bo[39] = qo[39] = 22;
        var Uo = [];
        function Vo(t, e, n) {
            return (t - e) / (n - e)
        }
        function Xo(t) {
            return t.constructor.toString().indexOf("Array") > -1
        }
        function Ho(t, e, n, r, i, o) {
            for (var s = t.cells[n][e], a = s.cval_real, u = e + r, l = n + i, h = [], c = !1; !c;) {
                if (void 0 === t.cells[l] || void 0 === t.cells[l][u])
                    if (l -= i, u -= r, a = (s = t.cells[l][u]).cval_real, -1 === i)
                        if (0 === o)
                            if (1 & a)
                                h.push([u, l]),
                                r = -1,
                                i = 0,
                                o = 0;
                            else {
                                if (!(4 & a)) {
                                    h.push([u + s.bottomright, l]),
                                    r = 0,
                                    i = 1,
                                    o = 1,
                                    c = !0;
                                    break
                                }
                                h.push([u + 1, l]),
                                r = 1,
                                i = 0,
                                o = 0
                            }
                        else {
                            if (!(1 & a)) {
                                if (4 & a) {
                                    h.push([u + s.bottomright, l]),
                                    r = 0,
                                    i = 1,
                                    o = 1,
                                    c = !0;
                                    break
                                }
                                h.push([u + s.bottomleft, l]),
                                r = 0,
                                i = 1,
                                o = 0,
                                c = !0;
                                break
                            }
                            h.push([u, l]),
                            r = -1,
                            i = 0,
                            o = 0
                        }
                    else if (1 === i)
                        if (0 === o) {
                            if (!(a & eo)) {
                                if (a & to) {
                                    h.push([u + s.topleft, l + 1]),
                                    r = 0,
                                    i = -1,
                                    o = 0,
                                    c = !0;
                                    break
                                }
                                h.push([u + s.topright, l + 1]),
                                r = 0,
                                i = -1,
                                o = 1,
                                c = !0;
                                break
                            }
                            h.push([u + 1, l + 1]),
                            r = 1,
                            i = 0,
                            o = 1
                        } else
                            h.push([u + 1, l + 1]),
                            r = 1,
                            i = 0,
                            o = 1;
                    else if (-1 === r)
                        if (0 === o) {
                            if (!(a & to)) {
                                if (1 & a) {
                                    h.push([u, l + s.leftbottom]),
                                    r = 1,
                                    i = 0,
                                    o = 0,
                                    c = !0;
                                    break
                                }
                                h.push([u, l + s.lefttop]),
                                r = 1,
                                i = 0,
                                o = 1,
                                c = !0;
                                break
                            }
                            h.push([u, l + 1]),
                            r = 0,
                            i = 1,
                            o = 0
                        } else {
                            if (!(a & to)) {
                                console.log("MarchingSquaresJS-isoBands: wtf");
                                break
                            }
                            h.push([u, l + 1]),
                            r = 0,
                            i = 1,
                            o = 0
                        }
                    else {
                        if (1 !== r) {
                            console.log("MarchingSquaresJS-isoBands: we came from nowhere!");
                            break
                        }
                        if (0 === o) {
                            if (!(4 & a)) {
                                h.push([u + 1, l + s.rightbottom]),
                                r = -1,
                                i = 0,
                                o = 0,
                                c = !0;
                                break
                            }
                            h.push([u + 1, l]),
                            r = 0,
                            i = -1,
                            o = 1
                        } else {
                            if (!(4 & a)) {
                                if (a & eo) {
                                    h.push([u + 1, l + s.righttop]),
                                    r = -1,
                                    i = 0,
                                    o = 1;
                                    break
                                }
                                h.push([u + 1, l + s.rightbottom]),
                                r = -1,
                                i = 0,
                                o = 0,
                                c = !0;
                                break
                            }
                            h.push([u + 1, l]),
                            r = 0,
                            i = -1,
                            o = 1
                        }
                    }
                else if (a = (s = t.cells[l][u]).cval_real, -1 === r)
                    if (0 === o)
                        if (void 0 !== t.cells[l - 1] && void 0 !== t.cells[l - 1][u])
                            r = 0,
                            i = -1,
                            o = 1;
                        else {
                            if (!(1 & a)) {
                                h.push([u + s.bottomright, l]),
                                r = 0,
                                i = 1,
                                o = 1,
                                c = !0;
                                break
                            }
                            h.push([u, l])
                        }
                    else {
                        if (!(a & to)) {
                            console.log("MarchingSquaresJS-isoBands: found entry from top at " + u + "," + l);
                            break
                        }
                        console.log("MarchingSquaresJS-isoBands: proceeding in x-direction!")
                    }
                else if (1 === r) {
                    if (0 === o) {
                        console.log("MarchingSquaresJS-isoBands: wtf");
                        break
                    }
                    if (void 0 !== t.cells[l + 1] && void 0 !== t.cells[l + 1][u])
                        r = 0,
                        i = 1,
                        o = 0;
                    else {
                        if (!(a & eo)) {
                            h.push([u + s.topleft, l + 1]),
                            r = 0,
                            i = -1,
                            o = 0,
                            c = !0;
                            break
                        }
                        h.push([u + 1, l + 1]),
                        r = 1,
                        i = 0,
                        o = 1
                    }
                } else if (-1 === i) {
                    if (1 !== o) {
                        console.log("MarchingSquaresJS-isoBands: wtf");
                        break
                    }
                    if (void 0 !== t.cells[l][u + 1])
                        r = 1,
                        i = 0,
                        o = 1;
                    else {
                        if (!(4 & a)) {
                            h.push([u + 1, l + s.righttop]),
                            r = -1,
                            i = 0,
                            o = 1,
                            c = !0;
                            break
                        }
                        h.push([u + 1, l]),
                        r = 0,
                        i = -1,
                        o = 1
                    }
                } else {
                    if (1 !== i) {
                        console.log("MarchingSquaresJS-isoBands: where did we came from???");
                        break
                    }
                    if (0 !== o) {
                        console.log("MarchingSquaresJS-isoBands: wtf");
                        break
                    }
                    if (void 0 !== t.cells[l][u - 1])
                        r = -1,
                        i = 0,
                        o = 0;
                    else {
                        if (!(a & to)) {
                            h.push([u, l + s.leftbottom]),
                            r = 1,
                            i = 0,
                            o = 0,
                            c = !0;
                            break
                        }
                        h.push([u, l + 1]),
                        r = 0,
                        i = 1,
                        o = 0
                    }
                }
                if (l += i, (u += r) === e && l === n)
                    break
            }
            return {
                path: h,
                i: u,
                j: l,
                x: r,
                y: i,
                o: o
            }
        }
        function Yo(t) {
            if (t.edges.length > 0) {
                var e = t.edges[t.edges.length - 1],
                    n = t.cval_real;
                switch (e) {
                case 0:
                    return n & eo ? {
                        p: [1, t.righttop],
                        x: -1,
                        y: 0,
                        o: 1
                    } : {
                        p: [t.topleft, 1],
                        x: 0,
                        y: -1,
                        o: 0
                    };
                case 1:
                    return 4 & n ? {
                        p: [t.topleft, 1],
                        x: 0,
                        y: -1,
                        o: 0
                    } : {
                        p: [1, t.rightbottom],
                        x: -1,
                        y: 0,
                        o: 0
                    };
                case 2:
                    return 4 & n ? {
                        p: [t.bottomright, 0],
                        x: 0,
                        y: 1,
                        o: 1
                    } : {
                        p: [t.topleft, 1],
                        x: 0,
                        y: -1,
                        o: 0
                    };
                case 3:
                    return 1 & n ? {
                        p: [t.topleft, 1],
                        x: 0,
                        y: -1,
                        o: 0
                    } : {
                        p: [t.bottomleft, 0],
                        x: 0,
                        y: 1,
                        o: 0
                    };
                case 4:
                    return n & eo ? {
                        p: [1, t.righttop],
                        x: -1,
                        y: 0,
                        o: 1
                    } : {
                        p: [t.topright, 1],
                        x: 0,
                        y: -1,
                        o: 1
                    };
                case 5:
                    return 4 & n ? {
                        p: [t.topright, 1],
                        x: 0,
                        y: -1,
                        o: 1
                    } : {
                        p: [1, t.rightbottom],
                        x: -1,
                        y: 0,
                        o: 0
                    };
                case 6:
                    return 4 & n ? {
                        p: [t.bottomright, 0],
                        x: 0,
                        y: 1,
                        o: 1
                    } : {
                        p: [t.topright, 1],
                        x: 0,
                        y: -1,
                        o: 1
                    };
                case 7:
                    return 1 & n ? {
                        p: [t.topright, 1],
                        x: 0,
                        y: -1,
                        o: 1
                    } : {
                        p: [t.bottomleft, 0],
                        x: 0,
                        y: 1,
                        o: 0
                    };
                case 8:
                    return 4 & n ? {
                        p: [t.bottomright, 0],
                        x: 0,
                        y: 1,
                        o: 1
                    } : {
                        p: [1, t.righttop],
                        x: -1,
                        y: 0,
                        o: 1
                    };
                case 9:
                    return 1 & n ? {
                        p: [1, t.righttop],
                        x: -1,
                        y: 0,
                        o: 1
                    } : {
                        p: [t.bottomleft, 0],
                        x: 0,
                        y: 1,
                        o: 0
                    };
                case 10:
                    return 1 & n ? {
                        p: [0, t.leftbottom],
                        x: 1,
                        y: 0,
                        o: 0
                    } : {
                        p: [1, t.righttop],
                        x: -1,
                        y: 0,
                        o: 1
                    };
                case 11:
                    return n & to ? {
                        p: [1, t.righttop],
                        x: -1,
                        y: 0,
                        o: 1
                    } : {
                        p: [0, t.lefttop],
                        x: 1,
                        y: 0,
                        o: 1
                    };
                case 12:
                    return 4 & n ? {
                        p: [t.bottomright, 0],
                        x: 0,
                        y: 1,
                        o: 1
                    } : {
                        p: [1, t.rightbottom],
                        x: -1,
                        y: 0,
                        o: 0
                    };
                case 13:
                    return 1 & n ? {
                        p: [1, t.rightbottom],
                        x: -1,
                        y: 0,
                        o: 0
                    } : {
                        p: [t.bottomleft, 0],
                        x: 0,
                        y: 1,
                        o: 0
                    };
                case 14:
                    return 1 & n ? {
                        p: [0, t.leftbottom],
                        x: 1,
                        y: 0,
                        o: 0
                    } : {
                        p: [1, t.rightbottom],
                        x: -1,
                        y: 0,
                        o: 0
                    };
                case 15:
                    return n & to ? {
                        p: [1, t.rightbottom],
                        x: -1,
                        y: 0,
                        o: 0
                    } : {
                        p: [0, t.lefttop],
                        x: 1,
                        y: 0,
                        o: 1
                    };
                case 16:
                    return 4 & n ? {
                        p: [t.bottomright, 0],
                        x: 0,
                        y: 1,
                        o: 1
                    } : {
                        p: [0, t.leftbottom],
                        x: 1,
                        y: 0,
                        o: 0
                    };
                case 17:
                    return n & to ? {
                        p: [t.bottomright, 0],
                        x: 0,
                        y: 1,
                        o: 1
                    } : {
                        p: [0, t.lefttop],
                        x: 1,
                        y: 0,
                        o: 1
                    };
                case 18:
                    return 1 & n ? {
                        p: [0, t.leftbottom],
                        x: 1,
                        y: 0,
                        o: 0
                    } : {
                        p: [t.bottomleft, 0],
                        x: 0,
                        y: 1,
                        o: 0
                    };
                case 19:
                    return n & to ? {
                        p: [t.bottomleft, 0],
                        x: 0,
                        y: 1,
                        o: 0
                    } : {
                        p: [0, t.lefttop],
                        x: 1,
                        y: 0,
                        o: 1
                    };
                case 20:
                    return n & to ? {
                        p: [t.topleft, 1],
                        x: 0,
                        y: -1,
                        o: 0
                    } : {
                        p: [0, t.leftbottom],
                        x: 1,
                        y: 0,
                        o: 0
                    };
                case 21:
                    return n & eo ? {
                        p: [0, t.leftbottom],
                        x: 1,
                        y: 0,
                        o: 0
                    } : {
                        p: [t.topright, 1],
                        x: 0,
                        y: -1,
                        o: 1
                    };
                case 22:
                    return n & to ? {
                        p: [t.topleft, 1],
                        x: 0,
                        y: -1,
                        o: 0
                    } : {
                        p: [0, t.lefttop],
                        x: 1,
                        y: 0,
                        o: 1
                    };
                case 23:
                    return n & eo ? {
                        p: [0, t.lefttop],
                        x: 1,
                        y: 0,
                        o: 1
                    } : {
                        p: [t.topright, 1],
                        x: 0,
                        y: -1,
                        o: 1
                    };
                default:
                    console.log("MarchingSquaresJS-isoBands: edge index out of range!"),
                    console.log(t)
                }
            }
            return null
        }
        function Wo(t, e, n, r) {
            var i,
                o,
                s,
                a,
                u,
                l = t.cval;
            switch (e) {
            case -1:
                0 === r ? (i = Fo[l], s = co[l], a = po[l], u = fo[l]) : (i = Do[l], s = uo[l], a = lo[l], u = ho[l]);
                break;
            case 1:
                0 === r ? (i = Go[l], s = Co[l], a = Mo[l], u = So[l]) : (i = Bo[l], s = Eo[l], a = wo[l], u = bo[l]);
                break;
            default:
                switch (n) {
                case -1:
                    0 === r ? (i = qo[l], s = no[l], a = ro[l], u = io[l]) : (i = zo[l], s = oo[l], a = so[l], u = ao[l]);
                    break;
                case 1:
                    0 === r ? (i = jo[l], s = go[l], a = yo[l], u = vo[l]) : (i = ko[l], s = mo[l], a = _o[l], u = xo[l])
                }
            }
            if (o = t.edges.indexOf(i), void 0 === t.edges[o])
                return null;
            switch (function(t, e) {
                delete t.edges[e];
                for (var n = e + 1; n < t.edges.length; n++)
                    t.edges[n - 1] = t.edges[n];
                t.edges.pop()
            }(t, o), l = t.cval_real, i) {
            case 0:
                l & eo ? (e = t.topleft, n = 1) : (e = 1, n = t.righttop);
                break;
            case 1:
                4 & l ? (e = 1, n = t.rightbottom) : (e = t.topleft, n = 1);
                break;
            case 2:
                4 & l ? (e = t.topleft, n = 1) : (e = t.bottomright, n = 0);
                break;
            case 3:
                1 & l ? (e = t.bottomleft, n = 0) : (e = t.topleft, n = 1);
                break;
            case 4:
                l & eo ? (e = t.topright, n = 1) : (e = 1, n = t.righttop);
                break;
            case 5:
                4 & l ? (e = 1, n = t.rightbottom) : (e = t.topright, n = 1);
                break;
            case 6:
                4 & l ? (e = t.topright, n = 1) : (e = t.bottomright, n = 0);
                break;
            case 7:
                1 & l ? (e = t.bottomleft, n = 0) : (e = t.topright, n = 1);
                break;
            case 8:
                4 & l ? (e = 1, n = t.righttop) : (e = t.bottomright, n = 0);
                break;
            case 9:
                1 & l ? (e = t.bottomleft, n = 0) : (e = 1, n = t.righttop);
                break;
            case 10:
                1 & l ? (e = 1, n = t.righttop) : (e = 0, n = t.leftbottom);
                break;
            case 11:
                l & to ? (e = 0, n = t.lefttop) : (e = 1, n = t.righttop);
                break;
            case 12:
                4 & l ? (e = 1, n = t.rightbottom) : (e = t.bottomright, n = 0);
                break;
            case 13:
                1 & l ? (e = t.bottomleft, n = 0) : (e = 1, n = t.rightbottom);
                break;
            case 14:
                1 & l ? (e = 1, n = t.rightbottom) : (e = 0, n = t.leftbottom);
                break;
            case 15:
                l & to ? (e = 0, n = t.lefttop) : (e = 1, n = t.rightbottom);
                break;
            case 16:
                4 & l ? (e = 0, n = t.leftbottom) : (e = t.bottomright, n = 0);
                break;
            case 17:
                l & to ? (e = 0, n = t.lefttop) : (e = t.bottomright, n = 0);
                break;
            case 18:
                1 & l ? (e = t.bottomleft, n = 0) : (e = 0, n = t.leftbottom);
                break;
            case 19:
                l & to ? (e = 0, n = t.lefttop) : (e = t.bottomleft, n = 0);
                break;
            case 20:
                l & to ? (e = 0, n = t.leftbottom) : (e = t.topleft, n = 1);
                break;
            case 21:
                l & eo ? (e = t.topright, n = 1) : (e = 0, n = t.leftbottom);
                break;
            case 22:
                l & to ? (e = 0, n = t.lefttop) : (e = t.topleft, n = 1);
                break;
            case 23:
                l & eo ? (e = t.topright, n = 1) : (e = 0, n = t.lefttop);
                break;
            default:
                return console.log("MarchingSquaresJS-isoBands: edge index out of range!"), console.log(t), null
            }
            return void 0 !== e && void 0 !== n && void 0 !== s && void 0 !== a && void 0 !== u || (console.log("MarchingSquaresJS-isoBands: undefined value!"), console.log(t), console.log(e + " " + n + " " + s + " " + a + " " + u)), {
                p: [e, n],
                x: s,
                y: a,
                o: u
            }
        }
        function $o(t) {
            var e = [],
                n = [];
            t.forEach((function(t) {
                var r = zr(l([t]));
                n.push(r),
                e.push({
                    ring: t,
                    area: r
                })
            })),
            n.sort((function(t, e) {
                return e - t
            }));
            var r = [];
            return n.forEach((function(t) {
                for (var n = 0; n < e.length; n++)
                    if (e[n].area === t) {
                        r.push(e[n].ring),
                        e.splice(n, 1);
                        break
                    }
            })), r
        }
        function Ko(t) {
            for (var e = t.map((function(t) {
                    return {
                        lrCoordinates: t,
                        grouped: !1
                    }
                })), n = []; !Jo(e);)
                for (var r = 0; r < e.length; r++)
                    if (!e[r].grouped) {
                        var i = [];
                        i.push(e[r].lrCoordinates),
                        e[r].grouped = !0;
                        for (var o = l([e[r].lrCoordinates]), s = r + 1; s < e.length; s++)
                            e[s].grouped || Zo(l([e[s].lrCoordinates]), o) && (i.push(e[s].lrCoordinates), e[s].grouped = !0);
                        n.push(i)
                    }
            return n
        }
        function Zo(t, e) {
            for (var n = wn(t), r = 0; r < n.features.length; r++)
                if (!ye(n.features[r], e))
                    return !1;
            return !0
        }
        function Jo(t) {
            for (var e = 0; e < t.length; e++)
                if (!1 === t[e].grouped)
                    return !1;
            return !0
        }
        function Qo(t, e, n) {
            if (!T(n = n || {}))
                throw new Error("options is invalid");
            var r = n.pivot,
                i = n.mutate;
            if (!t)
                throw new Error("geojson is required");
            if (null == e || isNaN(e))
                throw new Error("angle is required");
            return 0 === e || (r || (r = En(t)), !1 !== i && void 0 !== i || (t = Ce(t)), N(t, (function(t) {
                var n = Bi(r, t) + e,
                    i = Ar(r, t),
                    o = J(zi(r, i, n));
                t[0] = o[0],
                t[1] = o[1]
            }))), t
        }
        function ts(t, e, n) {
            if (!T(n = n || {}))
                throw new Error("options is invalid");
            var r = n.origin,
                i = n.mutate;
            if (!t)
                throw new Error("geojson required");
            if ("number" != typeof e || 0 === e)
                throw new Error("invalid factor");
            var o = Array.isArray(r) || "object" == typeof r;
            return !0 !== i && (t = Ce(t)), "FeatureCollection" !== t.type || o ? es(t, e, r) : (F(t, (function(n, i) {
                t.features[i] = es(n, e, r)
            })), t)
        }
        function es(t, e, n) {
            var r = "Point" === it(t);
            return n = function(t, e) {
                if (null == e && (e = "centroid"), Array.isArray(e) || "object" == typeof e)
                    return Z(e);
                var n = t.bbox ? t.bbox : K(t),
                    r = n[0],
                    i = n[1],
                    o = n[2],
                    s = n[3];
                switch (e) {
                case "sw":
                case "southwest":
                case "westsouth":
                case "bottomleft":
                    return a([r, i]);
                case "se":
                case "southeast":
                case "eastsouth":
                case "bottomright":
                    return a([o, i]);
                case "nw":
                case "northwest":
                case "westnorth":
                case "topleft":
                    return a([r, s]);
                case "ne":
                case "northeast":
                case "eastnorth":
                case "topright":
                    return a([o, s]);
                case "center":
                    return xn(t);
                case void 0:
                case null:
                case "centroid":
                    return En(t);
                default:
                    throw new Error("invalid origin")
                }
            }(t, n), 1 === e || r || N(t, (function(t) {
                var r = Ar(n, t),
                    i = Bi(n, t),
                    o = J(zi(n, r * e, i));
                t[0] = o[0],
                t[1] = o[1],
                3 === t.length && (t[2] *= e)
            })), t
        }
        function ns(t) {
            var e = t[0],
                n = t[1];
            return [n[0] - e[0], n[1] - e[1]]
        }
        function rs(t, e) {
            return t[0] * e[1] - e[0] * t[1]
        }
        function is(t, e) {
            return !function(t, e) {
                    return 0 === rs(ns(t), ns(e))
                }(t, e) && function(t, e) {
                    var n,
                        r,
                        i = t[0],
                        o = ns(t),
                        s = e[0],
                        a = ns(e),
                        u = rs(o, a);
                    return function(t, e) {
                        return [t[0] + e[0], t[1] + e[1]]
                    }(i, function(t, e) {
                        return [t * e[0], t * e[1]]
                    }(rs((r = i, [(n = s)[0] - r[0], n[1] - r[1]]), a) / u, o))
                }(t, e)
        }
        function os(t, e, n) {
            var r = [],
                i = E(e, n),
                o = J(t),
                s = [];
            return o.forEach((function(t, e) {
                if (e !== o.length - 1) {
                    var n = (l = t, h = o[e + 1], c = i, p = Math.sqrt((l[0] - h[0]) * (l[0] - h[0]) + (l[1] - h[1]) * (l[1] - h[1])), f = l[0] + c * (h[1] - l[1]) / p, d = h[0] + c * (h[1] - l[1]) / p, [[f, l[1] + c * (l[0] - h[0]) / p], [d, h[1] + c * (l[0] - h[0]) / p]]);
                    if (r.push(n), e > 0) {
                        var a = r[e - 1],
                            u = is(n, a);
                        !1 !== u && (a[1] = u, n[0] = u),
                        s.push(a[0]),
                        e === o.length - 2 && (s.push(n[0]), s.push(n[1]))
                    }
                    2 === o.length && (s.push(n[0]), s.push(n[1]))
                }
                var l,
                    h,
                    c,
                    p,
                    f,
                    d
            })), c(s, t.properties)
        }
        function ss(t, e, n) {
            var r = e[0] - t[0],
                i = e[1] - t[1],
                o = n[0] - e[0];
            return function(t) {
                return (t > 0) - (t < 0) || +t
            }(r * (n[1] - e[1]) - o * i)
        }
        function as(t, e) {
            return e.geometry.coordinates[0].every((function(e) {
                return ye(a(e), t)
            }))
        }
        Uo[1] = Uo[169] = Io,
        Uo[4] = Uo[166] = To,
        Uo[16] = Uo[154] = Po,
        Uo[64] = Uo[106] = Lo,
        Uo[168] = Uo[2] = Oo,
        Uo[162] = Uo[8] = No,
        Uo[138] = Uo[32] = Ro,
        Uo[42] = Uo[128] = Ao,
        Uo[5] = Uo[165] = function(t) {
            return [[0, 0], [0, t.leftbottom], [1, t.rightbottom], [1, 0]]
        },
        Uo[20] = Uo[150] = function(t) {
            return [[1, 0], [t.bottomright, 0], [t.topright, 1], [1, 1]]
        },
        Uo[80] = Uo[90] = function(t) {
            return [[1, 1], [1, t.righttop], [0, t.lefttop], [0, 1]]
        },
        Uo[65] = Uo[105] = function(t) {
            return [[t.bottomleft, 0], [0, 0], [0, 1], [t.topleft, 1]]
        },
        Uo[160] = Uo[10] = function(t) {
            return [[1, t.righttop], [1, t.rightbottom], [0, t.leftbottom], [0, t.lefttop]]
        },
        Uo[130] = Uo[40] = function(t) {
            return [[t.topleft, 1], [t.topright, 1], [t.bottomright, 0], [t.bottomleft, 0]]
        },
        Uo[85] = function() {
            return [[0, 0], [0, 1], [1, 1], [1, 0]]
        },
        Uo[101] = Uo[69] = function(t) {
            return [[1, t.rightbottom], [1, 0], [0, 0], [0, 1], [t.topleft, 1]]
        },
        Uo[149] = Uo[21] = function(t) {
            return [[t.topright, 1], [1, 1], [1, 0], [0, 0], [0, t.leftbottom]]
        },
        Uo[86] = Uo[84] = function(t) {
            return [[1, 0], [t.bottomright, 0], [0, t.lefttop], [0, 1], [1, 1]]
        },
        Uo[89] = Uo[81] = function(t) {
            return [[1, 1], [1, t.righttop], [t.bottomleft, 0], [0, 0], [0, 1]]
        },
        Uo[96] = Uo[74] = function(t) {
            return [[1, t.righttop], [1, t.rightbottom], [0, t.lefttop], [0, 1], [t.topleft, 1]]
        },
        Uo[24] = Uo[146] = function(t) {
            return [[1, 1], [1, t.righttop], [t.bottomright, 0], [t.bottomleft, 0], [t.topright, 1]]
        },
        Uo[6] = Uo[164] = function(t) {
            return [[1, t.rightbottom], [1, 0], [t.bottomright, 0], [0, t.leftbottom], [0, t.lefttop]]
        },
        Uo[129] = Uo[41] = function(t) {
            return [[t.topright, 1], [t.bottomleft, 0], [0, 0], [0, t.leftbottom], [t.topleft, 1]]
        },
        Uo[66] = Uo[104] = function(t) {
            return [[t.bottomright, 0], [t.bottomleft, 0], [0, t.lefttop], [0, 1], [t.topleft, 1]]
        },
        Uo[144] = Uo[26] = function(t) {
            return [[1, 1], [1, t.righttop], [0, t.leftbottom], [0, t.lefttop], [t.topright, 1]]
        },
        Uo[36] = Uo[134] = function(t) {
            return [[1, t.rightbottom], [1, 0], [t.bottomright, 0], [t.topleft, 1], [t.topright, 1]]
        },
        Uo[9] = Uo[161] = function(t) {
            return [[1, t.righttop], [1, t.rightbottom], [t.bottomleft, 0], [0, 0], [0, t.leftbottom]]
        },
        Uo[37] = Uo[133] = function(t) {
            return [[1, t.rightbottom], [1, 0], [0, 0], [0, t.leftbottom], [t.topleft, 1], [t.topright, 1]]
        },
        Uo[148] = Uo[22] = function(t) {
            return [[1, 1], [1, 0], [t.bottomright, 0], [0, t.leftbottom], [0, t.lefttop], [t.topright, 1]]
        },
        Uo[82] = Uo[88] = function(t) {
            return [[1, 1], [1, t.righttop], [t.bottomright, 0], [t.bottomleft, 0], [0, t.lefttop], [0, 1]]
        },
        Uo[73] = Uo[97] = function(t) {
            return [[1, t.righttop], [1, t.rightbottom], [t.bottomleft, 0], [0, 0], [0, 1], [t.topleft, 1]]
        },
        Uo[145] = Uo[25] = function(t) {
            return [[1, 1], [1, t.righttop], [t.bottomleft, 0], [0, 0], [0, t.leftbottom], [t.topright, 1]]
        },
        Uo[70] = Uo[100] = function(t) {
            return [[1, t.rightbottom], [1, 0], [t.bottomright, 0], [0, t.lefttop], [0, 1], [t.topleft, 1]]
        },
        Uo[34] = function(t) {
            return [Ao(t), No(t)]
        },
        Uo[35] = function(t) {
            return [[1, t.righttop], [1, t.rightbottom], [t.bottomright, 0], [t.bottomleft, 0], [0, t.leftbottom], [0, t.lefttop], [t.topleft, 1], [t.topright, 1]]
        },
        Uo[136] = function(t) {
            return [Ro(t), Oo(t)]
        },
        Uo[153] = function(t) {
            return [Po(t), Io(t)]
        },
        Uo[102] = function(t) {
            return [To(t), Lo(t)]
        },
        Uo[155] = function(t) {
            return [[1, 1], [1, t.righttop], [t.bottomleft, 0], [0, 0], [0, t.leftbottom], [t.topright, 1]]
        },
        Uo[103] = function(t) {
            return [[1, t.rightbottom], [1, 0], [t.bottomright, 0], [0, t.lefttop], [0, 1], [t.topleft, 1]]
        },
        Uo[152] = function(t) {
            return [Po(t), Oo(t)]
        },
        Uo[156] = function(t) {
            return [[1, 1], [1, t.righttop], [t.bottomright, 0], [t.bottomleft, 0], [0, t.leftbottom], [0, t.lefttop], [t.topright, 1]]
        },
        Uo[137] = function(t) {
            return [Ro(t), Io(t)]
        },
        Uo[139] = function(t) {
            return [[1, t.righttop], [1, t.rightbottom], [t.bottomleft, 0], [0, 0], [0, t.leftbottom], [t.topleft, 1], [t.topright, 1]]
        },
        Uo[98] = function(t) {
            return [No(t), Lo(t)]
        },
        Uo[99] = function(t) {
            return [[1, t.righttop], [1, t.rightbottom], [t.bottomright, 0], [t.bottomleft, 0], [0, t.lefttop], [0, 1], [t.topleft, 1]]
        },
        Uo[38] = function(t) {
            return [To(t), Ao(t)]
        },
        Uo[39] = function(t) {
            return [[1, t.rightbottom], [1, 0], [t.bottomright, 0], [0, t.leftbottom], [0, t.lefttop], [t.topleft, 1], [t.topright, 1]]
        };
        var us = function() {
                function t(e) {
                    this.id = t.buildId(e),
                    this.coordinates = e,
                    this.innerEdges = [],
                    this.outerEdges = [],
                    this.outerEdgesSorted = !1
                }
                return t.buildId = function(t) {
                    return t.join(",")
                }, t.prototype.removeInnerEdge = function(t) {
                    this.innerEdges = this.innerEdges.filter((function(e) {
                        return e.from.id !== t.from.id
                    }))
                }, t.prototype.removeOuterEdge = function(t) {
                    this.outerEdges = this.outerEdges.filter((function(e) {
                        return e.to.id !== t.to.id
                    }))
                }, t.prototype.addOuterEdge = function(t) {
                    this.outerEdges.push(t),
                    this.outerEdgesSorted = !1
                }, t.prototype.sortOuterEdges = function() {
                    var t = this;
                    this.outerEdgesSorted || (this.outerEdges.sort((function(e, n) {
                        var r = e.to,
                            i = n.to;
                        if (r.coordinates[0] - t.coordinates[0] >= 0 && i.coordinates[0] - t.coordinates[0] < 0)
                            return 1;
                        if (r.coordinates[0] - t.coordinates[0] < 0 && i.coordinates[0] - t.coordinates[0] >= 0)
                            return -1;
                        if (r.coordinates[0] - t.coordinates[0] == 0 && i.coordinates[0] - t.coordinates[0] == 0)
                            return r.coordinates[1] - t.coordinates[1] >= 0 || i.coordinates[1] - t.coordinates[1] >= 0 ? r.coordinates[1] - i.coordinates[1] : i.coordinates[1] - r.coordinates[1];
                        var o = ss(t.coordinates, r.coordinates, i.coordinates);
                        return o < 0 ? 1 : o > 0 ? -1 : Math.pow(r.coordinates[0] - t.coordinates[0], 2) + Math.pow(r.coordinates[1] - t.coordinates[1], 2) - (Math.pow(i.coordinates[0] - t.coordinates[0], 2) + Math.pow(i.coordinates[1] - t.coordinates[1], 2))
                    })), this.outerEdgesSorted = !0)
                }, t.prototype.getOuterEdges = function() {
                    return this.sortOuterEdges(), this.outerEdges
                }, t.prototype.getOuterEdge = function(t) {
                    return this.sortOuterEdges(), this.outerEdges[t]
                }, t.prototype.addInnerEdge = function(t) {
                    this.innerEdges.push(t)
                }, t
            }(),
            ls = function() {
                function t(t, e) {
                    this.from = t,
                    this.to = e,
                    this.next = void 0,
                    this.label = void 0,
                    this.symetric = void 0,
                    this.ring = void 0,
                    this.from.addOuterEdge(this),
                    this.to.addInnerEdge(this)
                }
                return t.prototype.getSymetric = function() {
                    return this.symetric || (this.symetric = new t(this.to, this.from), this.symetric.symetric = this), this.symetric
                }, t.prototype.deleteEdge = function() {
                    this.from.removeOuterEdge(this),
                    this.to.removeInnerEdge(this)
                }, t.prototype.isEqual = function(t) {
                    return this.from.id === t.from.id && this.to.id === t.to.id
                }, t.prototype.toString = function() {
                    return "Edge { " + this.from.id + " -> " + this.to.id + " }"
                }, t.prototype.toLineString = function() {
                    return c([this.from.coordinates, this.to.coordinates])
                }, t.prototype.compareTo = function(t) {
                    return ss(t.from.coordinates, t.to.coordinates, this.to.coordinates)
                }, t
            }(),
            hs = function() {
                function t() {
                    this.edges = [],
                    this.polygon = void 0,
                    this.envelope = void 0
                }
                return t.prototype.push = function(t) {
                    this.edges.push(t),
                    this.polygon = this.envelope = void 0
                }, t.prototype.get = function(t) {
                    return this.edges[t]
                }, Object.defineProperty(t.prototype, "length", {
                    get: function() {
                        return this.edges.length
                    },
                    enumerable: !0,
                    configurable: !0
                }), t.prototype.forEach = function(t) {
                    this.edges.forEach(t)
                }, t.prototype.map = function(t) {
                    return this.edges.map(t)
                }, t.prototype.some = function(t) {
                    return this.edges.some(t)
                }, t.prototype.isValid = function() {
                    return !0
                }, t.prototype.isHole = function() {
                    var t = this,
                        e = this.edges.reduce((function(e, n, r) {
                            return n.from.coordinates[1] > t.edges[e].from.coordinates[1] && (e = r), e
                        }), 0),
                        n = (0 === e ? this.length : e) - 1,
                        r = (e + 1) % this.length,
                        i = ss(this.edges[n].from.coordinates, this.edges[e].from.coordinates, this.edges[r].from.coordinates);
                    return 0 === i ? this.edges[n].from.coordinates[0] > this.edges[r].from.coordinates[0] : i > 0
                }, t.prototype.toMultiPoint = function() {
                    return g(this.edges.map((function(t) {
                        return t.from.coordinates
                    })))
                }, t.prototype.toPolygon = function() {
                    if (this.polygon)
                        return this.polygon;
                    var t = this.edges.map((function(t) {
                        return t.from.coordinates
                    }));
                    return t.push(this.edges[0].from.coordinates), this.polygon = l([t])
                }, t.prototype.getEnvelope = function() {
                    return this.envelope ? this.envelope : this.envelope = gn(this.toPolygon())
                }, t.findEdgeRingContaining = function(t, e) {
                    var n,
                        r,
                        i = t.getEnvelope();
                    return e.forEach((function(e) {
                        var o,
                            s,
                            u,
                            l,
                            h,
                            c,
                            p = e.getEnvelope();
                        if (r && (n = r.getEnvelope()), s = i, u = (o = p).geometry.coordinates[0].map((function(t) {
                            return t[0]
                        })), l = o.geometry.coordinates[0].map((function(t) {
                            return t[1]
                        })), h = s.geometry.coordinates[0].map((function(t) {
                            return t[0]
                        })), c = s.geometry.coordinates[0].map((function(t) {
                            return t[1]
                        })), (Math.max.apply(null, u) !== Math.max.apply(null, h) || Math.max.apply(null, l) !== Math.max.apply(null, c) || Math.min.apply(null, u) !== Math.min.apply(null, h) || Math.min.apply(null, l) !== Math.min.apply(null, c)) && as(p, i)) {
                            for (var f = t.map((function(t) {
                                    return t.from.coordinates
                                })), d = void 0, g = function(t) {
                                    e.some((function(e) {
                                        var n,
                                            r;
                                        return n = t, r = e.from.coordinates, n[0] === r[0] && n[1] === r[1]
                                    })) || (d = t)
                                }, y = 0, v = f; y < v.length; y++)
                                g(v[y]);
                            d && e.inside(a(d)) && (r && !as(n, p) || (r = e))
                        }
                    })), r
                }, t.prototype.inside = function(t) {
                    return ye(t, this.toPolygon())
                }, t
            }(),
            cs = function() {
                function t() {
                    this.edges = [],
                    this.nodes = {}
                }
                return t.fromGeoJson = function(e) {
                    !function(t) {
                        if (!t)
                            throw new Error("No geojson passed");
                        if ("FeatureCollection" !== t.type && "GeometryCollection" !== t.type && "MultiLineString" !== t.type && "LineString" !== t.type && "Feature" !== t.type)
                            throw new Error("Invalid input type '" + t.type + "'. Geojson must be FeatureCollection, GeometryCollection, LineString, MultiLineString or Feature")
                    }(e);
                    var n = new t;
                    return q(e, (function(t) {
                        et(t, "LineString", "Graph::fromGeoJson"),
                        R(t, (function(t, e) {
                            if (t) {
                                var r = n.getNode(t),
                                    i = n.getNode(e);
                                n.addEdge(r, i)
                            }
                            return e
                        }))
                    })), n
                }, t.prototype.getNode = function(t) {
                    var e = us.buildId(t),
                        n = this.nodes[e];
                    return n || (n = this.nodes[e] = new us(t)), n
                }, t.prototype.addEdge = function(t, e) {
                    var n = new ls(t, e),
                        r = n.getSymetric();
                    this.edges.push(n),
                    this.edges.push(r)
                }, t.prototype.deleteDangles = function() {
                    var t = this;
                    Object.keys(this.nodes).map((function(e) {
                        return t.nodes[e]
                    })).forEach((function(e) {
                        return t._removeIfDangle(e)
                    }))
                }, t.prototype._removeIfDangle = function(t) {
                    var e = this;
                    if (t.innerEdges.length <= 1) {
                        var n = t.getOuterEdges().map((function(t) {
                            return t.to
                        }));
                        this.removeNode(t),
                        n.forEach((function(t) {
                            return e._removeIfDangle(t)
                        }))
                    }
                }, t.prototype.deleteCutEdges = function() {
                    var t = this;
                    this._computeNextCWEdges(),
                    this._findLabeledEdgeRings(),
                    this.edges.forEach((function(e) {
                        e.label === e.symetric.label && (t.removeEdge(e.symetric), t.removeEdge(e))
                    }))
                }, t.prototype._computeNextCWEdges = function(t) {
                    var e = this;
                    void 0 === t ? Object.keys(this.nodes).forEach((function(t) {
                        return e._computeNextCWEdges(e.nodes[t])
                    })) : t.getOuterEdges().forEach((function(e, n) {
                        t.getOuterEdge((0 === n ? t.getOuterEdges().length : n) - 1).symetric.next = e
                    }))
                }, t.prototype._computeNextCCWEdges = function(t, e) {
                    for (var n, r, i = t.getOuterEdges(), o = i.length - 1; o >= 0; --o) {
                        var s = i[o],
                            a = s.symetric,
                            u = void 0,
                            l = void 0;
                        s.label === e && (u = s),
                        a.label === e && (l = a),
                        u && l && (l && (r = l), u && (r && (r.next = u, r = void 0), n || (n = u)))
                    }
                    r && (r.next = n)
                }, t.prototype._findLabeledEdgeRings = function() {
                    var t = [],
                        e = 0;
                    return this.edges.forEach((function(n) {
                        if (!(n.label >= 0)) {
                            t.push(n);
                            var r = n;
                            do {
                                r.label = e,
                                r = r.next
                            } while (!n.isEqual(r));
                            e++
                        }
                    })), t
                }, t.prototype.getEdgeRings = function() {
                    var t = this;
                    this._computeNextCWEdges(),
                    this.edges.forEach((function(t) {
                        t.label = void 0
                    })),
                    this._findLabeledEdgeRings().forEach((function(e) {
                        t._findIntersectionNodes(e).forEach((function(n) {
                            t._computeNextCCWEdges(n, e.label)
                        }))
                    }));
                    var e = [];
                    return this.edges.forEach((function(n) {
                        n.ring || e.push(t._findEdgeRing(n))
                    })), e
                }, t.prototype._findIntersectionNodes = function(t) {
                    var e = [],
                        n = t,
                        r = function() {
                            var r = 0;
                            n.from.getOuterEdges().forEach((function(e) {
                                e.label === t.label && ++r
                            })),
                            r > 1 && e.push(n.from),
                            n = n.next
                        };
                    do {
                        r()
                    } while (!t.isEqual(n));
                    return e
                }, t.prototype._findEdgeRing = function(t) {
                    var e = t,
                        n = new hs;
                    do {
                        n.push(e),
                        e.ring = n,
                        e = e.next
                    } while (!t.isEqual(e));
                    return n
                }, t.prototype.removeNode = function(t) {
                    var e = this;
                    t.getOuterEdges().forEach((function(t) {
                        return e.removeEdge(t)
                    })),
                    t.innerEdges.forEach((function(t) {
                        return e.removeEdge(t)
                    })),
                    delete this.nodes[t.id]
                }, t.prototype.removeEdge = function(t) {
                    this.edges = this.edges.filter((function(e) {
                        return !e.isEqual(t)
                    })),
                    t.deleteEdge()
                }, t
            }();
        function ps(t, e) {
            var n = !0;
            return q(t, (function(t) {
                q(e, (function(e) {
                    if (!1 === n)
                        return !1;
                    n = function(t, e) {
                        switch (t.type) {
                        case "Point":
                            switch (e.type) {
                            case "Point":
                                return n = t.coordinates, r = e.coordinates, !(n[0] === r[0] && n[1] === r[1]);
                            case "LineString":
                                return !fs(e, t);
                            case "Polygon":
                                return !ye(t, e)
                            }
                            break;
                        case "LineString":
                            switch (e.type) {
                            case "Point":
                                return !fs(t, e);
                            case "LineString":
                                return !function(t, e) {
                                    return Or(t, e).features.length > 0
                                }(t, e);
                            case "Polygon":
                                return !ds(e, t)
                            }
                            break;
                        case "Polygon":
                            switch (e.type) {
                            case "Point":
                                return !ye(e, t);
                            case "LineString":
                                return !ds(t, e);
                            case "Polygon":
                                return !function(t, e) {
                                    for (var n = 0, r = t.coordinates[0]; n < r.length; n++)
                                        if (ye(r[n], e))
                                            return !0;
                                    for (var i = 0, o = e.coordinates[0]; i < o.length; i++)
                                        if (ye(o[i], t))
                                            return !0;
                                    return Or(Ci(t), Ci(e)).features.length > 0
                                }(e, t)
                            }
                        }
                        var n,
                            r;
                        return !1
                    }(t.geometry, e.geometry)
                }))
            })), n
        }
        function fs(t, e) {
            for (var n = 0; n < t.coordinates.length - 1; n++)
                if (gs(t.coordinates[n], t.coordinates[n + 1], e.coordinates))
                    return !0;
            return !1
        }
        function ds(t, e) {
            for (var n = 0, r = e.coordinates; n < r.length; n++)
                if (ye(r[n], t))
                    return !0;
            return Or(e, Ci(t)).features.length > 0
        }
        function gs(t, e, n) {
            var r = n[0] - t[0],
                i = n[1] - t[1],
                o = e[0] - t[0],
                s = e[1] - t[1];
            return 0 == r * s - i * o && (Math.abs(o) >= Math.abs(s) ? o > 0 ? t[0] <= n[0] && n[0] <= e[0] : e[0] <= n[0] && n[0] <= t[0] : s > 0 ? t[1] <= n[1] && n[1] <= e[1] : e[1] <= n[1] && n[1] <= t[1])
        }
        function ys(t, e) {
            return !(t[0] > e[0] || t[2] < e[2] || t[1] > e[1] || t[3] < e[3])
        }
        function vs(t, e) {
            return t[0] === e[0] && t[1] === e[1]
        }
        function ms(t, e) {
            return [(t[0] + e[0]) / 2, (t[1] + e[1]) / 2]
        }
        function _s(t, e) {
            for (var n = !1, r = !1, i = t.coordinates.length, o = 0; o < i && !n && !r;) {
                for (var s = 0; s < e.coordinates.length - 1; s++) {
                    var a = !0;
                    0 !== s && s !== e.coordinates.length - 2 || (a = !1),
                    ws(e.coordinates[s], e.coordinates[s + 1], t.coordinates[o], a) ? n = !0 : r = !0
                }
                o++
            }
            return n && r
        }
        function xs(t, e) {
            return Or(t, Mi(e)).features.length > 0
        }
        function Es(t, e) {
            for (var n = !1, r = !1, i = t.coordinates.length, o = 0; o < i && (!n || !r); o++)
                ye(a(t.coordinates[o]), e) ? n = !0 : r = !0;
            return r && n
        }
        function ws(t, e, n, r) {
            var i = n[0] - t[0],
                o = n[1] - t[1],
                s = e[0] - t[0],
                a = e[1] - t[1];
            return 0 == i * a - o * s && (r ? Math.abs(s) >= Math.abs(a) ? s > 0 ? t[0] <= n[0] && n[0] <= e[0] : e[0] <= n[0] && n[0] <= t[0] : a > 0 ? t[1] <= n[1] && n[1] <= e[1] : e[1] <= n[1] && n[1] <= t[1] : Math.abs(s) >= Math.abs(a) ? s > 0 ? t[0] < n[0] && n[0] < e[0] : e[0] < n[0] && n[0] < t[0] : a > 0 ? t[1] < n[1] && n[1] < e[1] : e[1] < n[1] && n[1] < t[1])
        }
        var bs = function(t) {
            this.precision = t && t.precision ? t.precision : 17,
            this.direction = !(!t || !t.direction) && t.direction,
            this.pseudoNode = !(!t || !t.pseudoNode) && t.pseudoNode,
            this.objectComparator = t && t.objectComparator ? t.objectComparator : Ss
        };
        function Cs(t) {
            return t.coordinates.map((function(e) {
                return {
                    type: t.type.replace("Multi", ""),
                    coordinates: e
                }
            }))
        }
        function Ms(t, e) {
            return t.hasOwnProperty("coordinates") ? t.coordinates.length === e.coordinates.length : t.length === e.length
        }
        function Ss(t, e) {
            return Fi(t, e, {
                strict: !0
            })
        }
        bs.prototype.compare = function(t, e) {
            if (t.type !== e.type || !Ms(t, e))
                return !1;
            switch (t.type) {
            case "Point":
                return this.compareCoord(t.coordinates, e.coordinates);
            case "LineString":
                return this.compareLine(t.coordinates, e.coordinates, 0, !1);
            case "Polygon":
                return this.comparePolygon(t, e);
            case "Feature":
                return this.compareFeature(t, e);
            default:
                if (0 === t.type.indexOf("Multi")) {
                    var n = this,
                        r = Cs(t),
                        i = Cs(e);
                    return r.every((function(t) {
                        return this.some((function(e) {
                            return n.compare(t, e)
                        }))
                    }), i)
                }
            }
            return !1
        },
        bs.prototype.compareCoord = function(t, e) {
            if (t.length !== e.length)
                return !1;
            for (var n = 0; n < t.length; n++)
                if (t[n].toFixed(this.precision) !== e[n].toFixed(this.precision))
                    return !1;
            return !0
        },
        bs.prototype.compareLine = function(t, e, n, r) {
            if (!Ms(t, e))
                return !1;
            var i = this.pseudoNode ? t : this.removePseudo(t),
                o = this.pseudoNode ? e : this.removePseudo(e);
            if (!r || this.compareCoord(i[0], o[0]) || (o = this.fixStartIndex(o, i))) {
                var s = this.compareCoord(i[n], o[n]);
                return this.direction || s ? this.comparePath(i, o) : !!this.compareCoord(i[n], o[o.length - (1 + n)]) && this.comparePath(i.slice().reverse(), o)
            }
        },
        bs.prototype.fixStartIndex = function(t, e) {
            for (var n, r = -1, i = 0; i < t.length; i++)
                if (this.compareCoord(t[i], e[0])) {
                    r = i;
                    break
                }
            return r >= 0 && (n = [].concat(t.slice(r, t.length), t.slice(1, r + 1))), n
        },
        bs.prototype.comparePath = function(t, e) {
            var n = this;
            return t.every((function(t, e) {
                return n.compareCoord(t, this[e])
            }), e)
        },
        bs.prototype.comparePolygon = function(t, e) {
            if (this.compareLine(t.coordinates[0], e.coordinates[0], 1, !0)) {
                var n = t.coordinates.slice(1, t.coordinates.length),
                    r = e.coordinates.slice(1, e.coordinates.length),
                    i = this;
                return n.every((function(t) {
                    return this.some((function(e) {
                        return i.compareLine(t, e, 1, !0)
                    }))
                }), r)
            }
            return !1
        },
        bs.prototype.compareFeature = function(t, e) {
            return !(t.id !== e.id || !this.objectComparator(t.properties, e.properties) || !this.compareBBox(t, e)) && this.compare(t.geometry, e.geometry)
        },
        bs.prototype.compareBBox = function(t, e) {
            return !!(!t.bbox && !e.bbox || t.bbox && e.bbox && this.compareCoord(t.bbox, e.bbox))
        },
        bs.prototype.removePseudo = function(t) {
            return t
        };
        var Is = bs;
        function Ts(t, e) {
            var n = !1;
            return q(t, (function(t) {
                q(e, (function(e) {
                    if (!0 === n)
                        return !0;
                    n = !ps(t.geometry, e.geometry)
                }))
            })), n
        }
        var Ps = Bt((function(t) {
                function e(t, e, n, r) {
                    this.dataset = [],
                    this.epsilon = 1,
                    this.minPts = 2,
                    this.distance = this._euclideanDistance,
                    this.clusters = [],
                    this.noise = [],
                    this._visited = [],
                    this._assigned = [],
                    this._datasetLength = 0,
                    this._init(t, e, n, r)
                }
                e.prototype.run = function(t, e, n, r) {
                    this._init(t, e, n, r);
                    for (var i = 0; i < this._datasetLength; i++)
                        if (1 !== this._visited[i]) {
                            this._visited[i] = 1;
                            var o = this._regionQuery(i);
                            if (o.length < this.minPts)
                                this.noise.push(i);
                            else {
                                var s = this.clusters.length;
                                this.clusters.push([]),
                                this._addToCluster(i, s),
                                this._expandCluster(s, o)
                            }
                        }
                    return this.clusters
                },
                e.prototype._init = function(t, e, n, r) {
                    if (t) {
                        if (!(t instanceof Array))
                            throw Error("Dataset must be of type array, " + typeof t + " given");
                        this.dataset = t,
                        this.clusters = [],
                        this.noise = [],
                        this._datasetLength = t.length,
                        this._visited = new Array(this._datasetLength),
                        this._assigned = new Array(this._datasetLength)
                    }
                    e && (this.epsilon = e),
                    n && (this.minPts = n),
                    r && (this.distance = r)
                },
                e.prototype._expandCluster = function(t, e) {
                    for (var n = 0; n < e.length; n++) {
                        var r = e[n];
                        if (1 !== this._visited[r]) {
                            this._visited[r] = 1;
                            var i = this._regionQuery(r);
                            i.length >= this.minPts && (e = this._mergeArrays(e, i))
                        }
                        1 !== this._assigned[r] && this._addToCluster(r, t)
                    }
                },
                e.prototype._addToCluster = function(t, e) {
                    this.clusters[e].push(t),
                    this._assigned[t] = 1
                },
                e.prototype._regionQuery = function(t) {
                    for (var e = [], n = 0; n < this._datasetLength; n++)
                        this.distance(this.dataset[t], this.dataset[n]) < this.epsilon && e.push(n);
                    return e
                },
                e.prototype._mergeArrays = function(t, e) {
                    for (var n = e.length, r = 0; r < n; r++) {
                        var i = e[r];
                        t.indexOf(i) < 0 && t.push(i)
                    }
                    return t
                },
                e.prototype._euclideanDistance = function(t, e) {
                    for (var n = 0, r = Math.min(t.length, e.length); r--;)
                        n += (t[r] - e[r]) * (t[r] - e[r]);
                    return Math.sqrt(n)
                },
                t.exports && (t.exports = e)
            })),
            Ls = Bt((function(t) {
                function e(t, e, n) {
                    this.k = 3,
                    this.dataset = [],
                    this.assignments = [],
                    this.centroids = [],
                    this.init(t, e, n)
                }
                e.prototype.init = function(t, e, n) {
                    this.assignments = [],
                    this.centroids = [],
                    void 0 !== t && (this.dataset = t),
                    void 0 !== e && (this.k = e),
                    void 0 !== n && (this.distance = n)
                },
                e.prototype.run = function(t, e) {
                    this.init(t, e);
                    for (var n = this.dataset.length, r = 0; r < this.k; r++)
                        this.centroids[r] = this.randomCentroid();
                    for (var i = !0; i;) {
                        i = this.assign();
                        for (var o = 0; o < this.k; o++) {
                            for (var s = new Array(h), a = 0, u = 0; u < h; u++)
                                s[u] = 0;
                            for (var l = 0; l < n; l++) {
                                var h = this.dataset[l].length;
                                if (o === this.assignments[l]) {
                                    for (u = 0; u < h; u++)
                                        s[u] += this.dataset[l][u];
                                    a++
                                }
                            }
                            if (a > 0) {
                                for (u = 0; u < h; u++)
                                    s[u] /= a;
                                this.centroids[o] = s
                            } else
                                this.centroids[o] = this.randomCentroid(),
                                i = !0
                        }
                    }
                    return this.getClusters()
                },
                e.prototype.randomCentroid = function() {
                    var t,
                        e,
                        n = this.dataset.length - 1;
                    do {
                        e = Math.round(Math.random() * n),
                        t = this.dataset[e]
                    } while (this.centroids.indexOf(t) >= 0);
                    return t
                },
                e.prototype.assign = function() {
                    for (var t, e = !1, n = this.dataset.length, r = 0; r < n; r++)
                        (t = this.argmin(this.dataset[r], this.centroids, this.distance)) != this.assignments[r] && (this.assignments[r] = t, e = !0);
                    return e
                },
                e.prototype.getClusters = function() {
                    for (var t, e = new Array(this.k), n = 0; n < this.assignments.length; n++)
                        void 0 === e[t = this.assignments[n]] && (e[t] = []),
                        e[t].push(n);
                    return e
                },
                e.prototype.argmin = function(t, e, n) {
                    for (var r, i = Number.MAX_VALUE, o = 0, s = e.length, a = 0; a < s; a++)
                        (r = n(t, e[a])) < i && (i = r, o = a);
                    return o
                },
                e.prototype.distance = function(t, e) {
                    for (var n = 0, r = Math.min(t.length, e.length); r--;) {
                        var i = t[r] - e[r];
                        n += i * i
                    }
                    return Math.sqrt(n)
                },
                t.exports && (t.exports = e)
            })),
            Os = Bt((function(t) {
                function e(t, e, n) {
                    this._queue = [],
                    this._priorities = [],
                    this._sorting = "desc",
                    this._init(t, e, n)
                }
                e.prototype.insert = function(t, e) {
                    for (var n = this._queue.length, r = n; r--;) {
                        var i = this._priorities[r];
                        "desc" === this._sorting ? e > i && (n = r) : e < i && (n = r)
                    }
                    this._insertAt(t, e, n)
                },
                e.prototype.remove = function(t) {
                    for (var e = this._queue.length; e--;)
                        if (t === this._queue[e]) {
                            this._queue.splice(e, 1),
                            this._priorities.splice(e, 1);
                            break
                        }
                },
                e.prototype.forEach = function(t) {
                    this._queue.forEach(t)
                },
                e.prototype.getElements = function() {
                    return this._queue
                },
                e.prototype.getElementPriority = function(t) {
                    return this._priorities[t]
                },
                e.prototype.getPriorities = function() {
                    return this._priorities
                },
                e.prototype.getElementsWithPriorities = function() {
                    for (var t = [], e = 0, n = this._queue.length; e < n; e++)
                        t.push([this._queue[e], this._priorities[e]]);
                    return t
                },
                e.prototype._init = function(t, e, n) {
                    if (t && e) {
                        if (this._queue = [], this._priorities = [], t.length !== e.length)
                            throw new Error("Arrays must have the same length");
                        for (var r = 0; r < t.length; r++)
                            this.insert(t[r], e[r])
                    }
                    n && (this._sorting = n)
                },
                e.prototype._insertAt = function(t, e, n) {
                    this._queue.length === n ? (this._queue.push(t), this._priorities.push(e)) : (this._queue.splice(n, 0, t), this._priorities.splice(n, 0, e))
                },
                t.exports && (t.exports = e)
            })),
            Ns = Bt((function(t) {
                if (t.exports)
                    var e = Os;
                function n(t, e, n, r) {
                    this.epsilon = 1,
                    this.minPts = 1,
                    this.distance = this._euclideanDistance,
                    this._reachability = [],
                    this._processed = [],
                    this._coreDistance = 0,
                    this._orderedList = [],
                    this._init(t, e, n, r)
                }
                n.prototype.run = function(t, n, r, i) {
                    this._init(t, n, r, i);
                    for (var o = 0, s = this.dataset.length; o < s; o++)
                        if (1 !== this._processed[o]) {
                            this._processed[o] = 1,
                            this.clusters.push([o]);
                            var a = this.clusters.length - 1;
                            this._orderedList.push(o);
                            var u = new e(null, null, "asc"),
                                l = this._regionQuery(o);
                            void 0 !== this._distanceToCore(o) && (this._updateQueue(o, l, u), this._expandCluster(a, u))
                        }
                    return this.clusters
                },
                n.prototype.getReachabilityPlot = function() {
                    for (var t = [], e = 0, n = this._orderedList.length; e < n; e++) {
                        var r = this._orderedList[e],
                            i = this._reachability[r];
                        t.push([r, i])
                    }
                    return t
                },
                n.prototype._init = function(t, e, n, r) {
                    if (t) {
                        if (!(t instanceof Array))
                            throw Error("Dataset must be of type array, " + typeof t + " given");
                        this.dataset = t,
                        this.clusters = [],
                        this._reachability = new Array(this.dataset.length),
                        this._processed = new Array(this.dataset.length),
                        this._coreDistance = 0,
                        this._orderedList = []
                    }
                    e && (this.epsilon = e),
                    n && (this.minPts = n),
                    r && (this.distance = r)
                },
                n.prototype._updateQueue = function(t, e, n) {
                    var r = this;
                    this._coreDistance = this._distanceToCore(t),
                    e.forEach((function(e) {
                        if (void 0 === r._processed[e]) {
                            var i = r.distance(r.dataset[t], r.dataset[e]),
                                o = Math.max(r._coreDistance, i);
                            void 0 === r._reachability[e] ? (r._reachability[e] = o, n.insert(e, o)) : o < r._reachability[e] && (r._reachability[e] = o, n.remove(e), n.insert(e, o))
                        }
                    }))
                },
                n.prototype._expandCluster = function(t, e) {
                    for (var n = e.getElements(), r = 0, i = n.length; r < i; r++) {
                        var o = n[r];
                        if (void 0 === this._processed[o]) {
                            var s = this._regionQuery(o);
                            this._processed[o] = 1,
                            this.clusters[t].push(o),
                            this._orderedList.push(o),
                            void 0 !== this._distanceToCore(o) && (this._updateQueue(o, s, e), this._expandCluster(t, e))
                        }
                    }
                },
                n.prototype._distanceToCore = function(t) {
                    for (var e = this.epsilon, n = 0; n < e; n++)
                        if (this._regionQuery(t, n).length >= this.minPts)
                            return n
                },
                n.prototype._regionQuery = function(t, e) {
                    e = e || this.epsilon;
                    for (var n = [], r = 0, i = this.dataset.length; r < i; r++)
                        this.distance(this.dataset[t], this.dataset[r]) < e && n.push(r);
                    return n
                },
                n.prototype._euclideanDistance = function(t, e) {
                    for (var n = 0, r = Math.min(t.length, e.length); r--;)
                        n += (t[r] - e[r]) * (t[r] - e[r]);
                    return Math.sqrt(n)
                },
                t.exports && (t.exports = n)
            })),
            Rs = Bt((function(t) {
                t.exports && (t.exports = {
                    DBSCAN: Ps,
                    KMEANS: Ls,
                    OPTICS: Ns,
                    PriorityQueue: Os
                })
            })),
            As = function(t, e, n) {
                for (var r = t.length, i = 0, o = 0; o < r; o++) {
                    var s = (t[o] || 0) - (e[o] || 0);
                    i += s * s
                }
                return n ? Math.sqrt(i) : i
            },
            Ds = As,
            Fs = function(t, e, n) {
                var r = Math.abs(t - e);
                return n ? r : r * r
            },
            ks = As,
            js = function(t, e) {
                for (var n = {}, r = [], i = e << 2, o = t.length, s = t[0].length > 0; r.length < e && i-- > 0;) {
                    var a = t[Math.floor(Math.random() * o)],
                        u = s ? a.join("_") : "" + a;
                    n[u] || (n[u] = !0, r.push(a))
                }
                if (r.length < e)
                    throw new Error("Error initializating clusters");
                return r
            },
            Gs = function(t, e) {
                var n = t[0].length ? Ds : Fs,
                    r = [],
                    i = t.length,
                    o = t[0].length > 0,
                    s = t[Math.floor(Math.random() * i)];
                for (o && s.join("_"), r.push(s); r.length < e;) {
                    for (var a = [], u = r.length, l = 0, h = [], c = 0; c < i; c++) {
                        for (var p = 1 / 0, f = 0; f < u; f++) {
                            var d = n(t[c], r[f]);
                            d <= p && (p = d)
                        }
                        a[c] = p
                    }
                    for (var g = 0; g < i; g++)
                        l += a[g];
                    for (var y = 0; y < i; y++)
                        h[y] = {
                            i: y,
                            v: t[y],
                            pr: a[y] / l,
                            cs: 0
                        };
                    h.sort((function(t, e) {
                        return t.pr - e.pr
                    })),
                    h[0].cs = h[0].pr;
                    for (var v = 1; v < i; v++)
                        h[v].cs = h[v - 1].cs + h[v].pr;
                    for (var m = Math.random(), _ = 0; _ < i - 1 && h[_++].cs < m;)
                        ;
                    r.push(h[_ - 1].v)
                }
                return r
            };
        function Bs(t, e, n) {
            n = n || [];
            for (var r = 0; r < t; r++)
                n[r] = e;
            return n
        }
        var qs = function(t, e, n, r) {
            var i = [],
                o = [],
                s = [],
                a = [],
                u = !1,
                l = r || 1e4,
                h = t.length,
                c = t[0].length,
                p = c > 0,
                f = [];
            if (n)
                i = "kmrand" == n ? js(t, e) : "kmpp" == n ? Gs(t, e) : n;
            else
                for (var d = {}; i.length < e;) {
                    var g = Math.floor(Math.random() * h);
                    d[g] || (d[g] = !0, i.push(t[g]))
                }
            do {
                Bs(e, 0, f);
                for (var y = 0; y < h; y++) {
                    for (var v = 1 / 0, m = 0, _ = 0; _ < e; _++)
                        (a = p ? ks(t[y], i[_]) : Math.abs(t[y] - i[_])) <= v && (v = a, m = _);
                    s[y] = m,
                    f[m]++
                }
                for (var x = [], E = (o = [], 0); E < e; E++)
                    x[E] = p ? Bs(c, 0, x[E]) : 0,
                    o[E] = i[E];
                if (p) {
                    for (var w = 0; w < e; w++)
                        i[w] = [];
                    for (var b = 0; b < h; b++)
                        for (var C = x[s[b]], M = t[b], S = 0; S < c; S++)
                            C[S] += M[S];
                    u = !0;
                    for (var I = 0; I < e; I++) {
                        for (var T = i[I], P = x[I], L = o[I], O = f[I], N = 0; N < c; N++)
                            T[N] = P[N] / O || 0;
                        if (u)
                            for (var R = 0; R < c; R++)
                                if (L[R] != T[R]) {
                                    u = !1;
                                    break
                                }
                    }
                } else {
                    for (var A = 0; A < h; A++)
                        x[s[A]] += t[A];
                    for (var D = 0; D < e; D++)
                        i[D] = x[D] / f[D] || 0;
                    u = !0;
                    for (var F = 0; F < e; F++)
                        if (o[F] != i[F]) {
                            u = !1;
                            break
                        }
                }
                u = u || --l <= 0
            } while (!u);
            return {
                it: 1e4 - l,
                k: e,
                idxs: s,
                centroids: i
            }
        };
        function zs(t, e) {
            return w(Bi(t[0], t[1])) === w(Bi(e[0], e[1]))
        }
        function Us(t, e) {
            if (t.geometry && t.geometry.type)
                return t.geometry.type;
            if (t.type)
                return t.type;
            throw new Error("Invalid GeoJSON object for " + e)
        }
        function Vs(t) {
            for (var e = t, n = []; e.parent;)
                n.unshift(e),
                e = e.parent;
            return n
        }
        var Xs = {
            search: function(t, e, n, r) {
                t.cleanDirty();
                var i = (r = r || {}).heuristic || Xs.heuristics.manhattan,
                    o = r.closest || !1,
                    s = new Ws((function(t) {
                        return t.f
                    })),
                    a = e;
                for (e.h = i(e, n), s.push(e); s.size() > 0;) {
                    var u = s.pop();
                    if (u === n)
                        return Vs(u);
                    u.closed = !0;
                    for (var l = t.neighbors(u), h = 0, c = l.length; h < c; ++h) {
                        var p = l[h];
                        if (!p.closed && !p.isWall()) {
                            var f = u.g + p.getCost(u),
                                d = p.visited;
                            (!d || f < p.g) && (p.visited = !0, p.parent = u, p.h = p.h || i(p, n), p.g = f, p.f = p.g + p.h, t.markDirty(p), o && (p.h < a.h || p.h === a.h && p.g < a.g) && (a = p), d ? s.rescoreElement(p) : s.push(p))
                        }
                    }
                }
                return o ? Vs(a) : []
            },
            heuristics: {
                manhattan: function(t, e) {
                    return Math.abs(e.x - t.x) + Math.abs(e.y - t.y)
                },
                diagonal: function(t, e) {
                    var n = Math.sqrt(2),
                        r = Math.abs(e.x - t.x),
                        i = Math.abs(e.y - t.y);
                    return 1 * (r + i) + (n - 2) * Math.min(r, i)
                }
            },
            cleanNode: function(t) {
                t.f = 0,
                t.g = 0,
                t.h = 0,
                t.visited = !1,
                t.closed = !1,
                t.parent = null
            }
        };
        function Hs(t, e) {
            e = e || {},
            this.nodes = [],
            this.diagonal = !!e.diagonal,
            this.grid = [];
            for (var n = 0; n < t.length; n++) {
                this.grid[n] = [];
                for (var r = 0, i = t[n]; r < i.length; r++) {
                    var o = new Ys(n, r, i[r]);
                    this.grid[n][r] = o,
                    this.nodes.push(o)
                }
            }
            this.init()
        }
        function Ys(t, e, n) {
            this.x = t,
            this.y = e,
            this.weight = n
        }
        function Ws(t) {
            this.content = [],
            this.scoreFunction = t
        }
        function $s(t, e) {
            for (var n = 0; n < e.features.length; n++)
                if (ye(t, e.features[n]))
                    return !0;
            return !1
        }
        function Ks(t) {
            return function() {
                return t
            }
        }
        function Zs(t) {
            return t[0]
        }
        function Js(t) {
            return t[1]
        }
        function Qs() {
            this._ = null
        }
        function ta(t) {
            t.U = t.C = t.L = t.R = t.P = t.N = null
        }
        function ea(t, e) {
            var n = e,
                r = e.R,
                i = n.U;
            i ? i.L === n ? i.L = r : i.R = r : t._ = r,
            r.U = i,
            n.U = r,
            n.R = r.L,
            n.R && (n.R.U = n),
            r.L = n
        }
        function na(t, e) {
            var n = e,
                r = e.L,
                i = n.U;
            i ? i.L === n ? i.L = r : i.R = r : t._ = r,
            r.U = i,
            n.U = r,
            n.L = r.R,
            n.L && (n.L.U = n),
            r.R = n
        }
        function ra(t) {
            for (; t.L;)
                t = t.L;
            return t
        }
        function ia(t, e, n, r) {
            var i = [null, null],
                o = Ta.push(i) - 1;
            return i.left = t, i.right = e, n && sa(i, t, e, n), r && sa(i, e, t, r), Sa[t.index].halfedges.push(o), Sa[e.index].halfedges.push(o), i
        }
        function oa(t, e, n) {
            var r = [e, n];
            return r.left = t, r
        }
        function sa(t, e, n, r) {
            t[0] || t[1] ? t.left === n ? t[1] = r : t[0] = r : (t[0] = r, t.left = e, t.right = n)
        }
        function aa(t, e, n, r, i) {
            var o,
                s = t[0],
                a = t[1],
                u = s[0],
                l = s[1],
                h = 0,
                c = 1,
                p = a[0] - u,
                f = a[1] - l;
            if (o = e - u, p || !(o > 0)) {
                if (o /= p, p < 0) {
                    if (o < h)
                        return;
                    o < c && (c = o)
                } else if (p > 0) {
                    if (o > c)
                        return;
                    o > h && (h = o)
                }
                if (o = r - u, p || !(o < 0)) {
                    if (o /= p, p < 0) {
                        if (o > c)
                            return;
                        o > h && (h = o)
                    } else if (p > 0) {
                        if (o < h)
                            return;
                        o < c && (c = o)
                    }
                    if (o = n - l, f || !(o > 0)) {
                        if (o /= f, f < 0) {
                            if (o < h)
                                return;
                            o < c && (c = o)
                        } else if (f > 0) {
                            if (o > c)
                                return;
                            o > h && (h = o)
                        }
                        if (o = i - l, f || !(o < 0)) {
                            if (o /= f, f < 0) {
                                if (o > c)
                                    return;
                                o > h && (h = o)
                            } else if (f > 0) {
                                if (o < h)
                                    return;
                                o < c && (c = o)
                            }
                            return !(h > 0 || c < 1) || (h > 0 && (t[0] = [u + h * p, l + h * f]), c < 1 && (t[1] = [u + c * p, l + c * f]), !0)
                        }
                    }
                }
            }
        }
        function ua(t, e, n, r, i) {
            var o = t[1];
            if (o)
                return !0;
            var s,
                a,
                u = t[0],
                l = t.left,
                h = t.right,
                c = l[0],
                p = l[1],
                f = h[0],
                d = h[1],
                g = (c + f) / 2,
                y = (p + d) / 2;
            if (d === p) {
                if (g < e || g >= r)
                    return;
                if (c > f) {
                    if (u) {
                        if (u[1] >= i)
                            return
                    } else
                        u = [g, n];
                    o = [g, i]
                } else {
                    if (u) {
                        if (u[1] < n)
                            return
                    } else
                        u = [g, i];
                    o = [g, n]
                }
            } else if (a = y - (s = (c - f) / (d - p)) * g, s < -1 || s > 1)
                if (c > f) {
                    if (u) {
                        if (u[1] >= i)
                            return
                    } else
                        u = [(n - a) / s, n];
                    o = [(i - a) / s, i]
                } else {
                    if (u) {
                        if (u[1] < n)
                            return
                    } else
                        u = [(i - a) / s, i];
                    o = [(n - a) / s, n]
                }
            else if (p < d) {
                if (u) {
                    if (u[0] >= r)
                        return
                } else
                    u = [e, s * e + a];
                o = [r, s * r + a]
            } else {
                if (u) {
                    if (u[0] < e)
                        return
                } else
                    u = [r, s * r + a];
                o = [e, s * e + a]
            }
            return t[0] = u, t[1] = o, !0
        }
        function la(t, e) {
            var n = t.site,
                r = e.left,
                i = e.right;
            return n === i && (i = r, r = n), i ? Math.atan2(i[1] - r[1], i[0] - r[0]) : (n === r ? (r = e[1], i = e[0]) : (r = e[0], i = e[1]), Math.atan2(r[0] - i[0], i[1] - r[1]))
        }
        function ha(t, e) {
            return e[+(e.left !== t.site)]
        }
        function ca(t, e) {
            return e[+(e.left === t.site)]
        }
        Hs.prototype.init = function() {
            this.dirtyNodes = [];
            for (var t = 0; t < this.nodes.length; t++)
                Xs.cleanNode(this.nodes[t])
        },
        Hs.prototype.cleanDirty = function() {
            for (var t = 0; t < this.dirtyNodes.length; t++)
                Xs.cleanNode(this.dirtyNodes[t]);
            this.dirtyNodes = []
        },
        Hs.prototype.markDirty = function(t) {
            this.dirtyNodes.push(t)
        },
        Hs.prototype.neighbors = function(t) {
            var e = [],
                n = t.x,
                r = t.y,
                i = this.grid;
            return i[n - 1] && i[n - 1][r] && e.push(i[n - 1][r]), i[n + 1] && i[n + 1][r] && e.push(i[n + 1][r]), i[n] && i[n][r - 1] && e.push(i[n][r - 1]), i[n] && i[n][r + 1] && e.push(i[n][r + 1]), this.diagonal && (i[n - 1] && i[n - 1][r - 1] && e.push(i[n - 1][r - 1]), i[n + 1] && i[n + 1][r - 1] && e.push(i[n + 1][r - 1]), i[n - 1] && i[n - 1][r + 1] && e.push(i[n - 1][r + 1]), i[n + 1] && i[n + 1][r + 1] && e.push(i[n + 1][r + 1])), e
        },
        Hs.prototype.toString = function() {
            for (var t, e, n, r, i = [], o = this.grid, s = 0, a = o.length; s < a; s++) {
                for (t = [], n = 0, r = (e = o[s]).length; n < r; n++)
                    t.push(e[n].weight);
                i.push(t.join(" "))
            }
            return i.join("\n")
        },
        Ys.prototype.toString = function() {
            return "[" + this.x + " " + this.y + "]"
        },
        Ys.prototype.getCost = function(t) {
            return t && t.x !== this.x && t.y !== this.y ? 1.41421 * this.weight : this.weight
        },
        Ys.prototype.isWall = function() {
            return 0 === this.weight
        },
        Ws.prototype = {
            push: function(t) {
                this.content.push(t),
                this.sinkDown(this.content.length - 1)
            },
            pop: function() {
                var t = this.content[0],
                    e = this.content.pop();
                return this.content.length > 0 && (this.content[0] = e, this.bubbleUp(0)), t
            },
            remove: function(t) {
                var e = this.content.indexOf(t),
                    n = this.content.pop();
                e !== this.content.length - 1 && (this.content[e] = n, this.scoreFunction(n) < this.scoreFunction(t) ? this.sinkDown(e) : this.bubbleUp(e))
            },
            size: function() {
                return this.content.length
            },
            rescoreElement: function(t) {
                this.sinkDown(this.content.indexOf(t))
            },
            sinkDown: function(t) {
                for (var e = this.content[t]; t > 0;) {
                    var n = (t + 1 >> 1) - 1,
                        r = this.content[n];
                    if (!(this.scoreFunction(e) < this.scoreFunction(r)))
                        break;
                    this.content[n] = e,
                    this.content[t] = r,
                    t = n
                }
            },
            bubbleUp: function(t) {
                for (var e = this.content.length, n = this.content[t], r = this.scoreFunction(n);;) {
                    var i,
                        o = t + 1 << 1,
                        s = o - 1,
                        a = null;
                    if (s < e) {
                        var u = this.content[s];
                        (i = this.scoreFunction(u)) < r && (a = s)
                    }
                    if (o < e) {
                        var l = this.content[o];
                        this.scoreFunction(l) < (null === a ? r : i) && (a = o)
                    }
                    if (null === a)
                        break;
                    this.content[t] = this.content[a],
                    this.content[a] = n,
                    t = a
                }
            }
        },
        Qs.prototype = {
            constructor: Qs,
            insert: function(t, e) {
                var n,
                    r,
                    i;
                if (t) {
                    if (e.P = t, e.N = t.N, t.N && (t.N.P = e), t.N = e, t.R) {
                        for (t = t.R; t.L;)
                            t = t.L;
                        t.L = e
                    } else
                        t.R = e;
                    n = t
                } else
                    this._ ? (t = ra(this._), e.P = null, e.N = t, t.P = t.L = e, n = t) : (e.P = e.N = null, this._ = e, n = null);
                for (e.L = e.R = null, e.U = n, e.C = !0, t = e; n && n.C;)
                    n === (r = n.U).L ? (i = r.R) && i.C ? (n.C = i.C = !1, r.C = !0, t = r) : (t === n.R && (ea(this, n), n = (t = n).U), n.C = !1, r.C = !0, na(this, r)) : (i = r.L) && i.C ? (n.C = i.C = !1, r.C = !0, t = r) : (t === n.L && (na(this, n), n = (t = n).U), n.C = !1, r.C = !0, ea(this, r)),
                    n = t.U;
                this._.C = !1
            },
            remove: function(t) {
                t.N && (t.N.P = t.P),
                t.P && (t.P.N = t.N),
                t.N = t.P = null;
                var e,
                    n,
                    r,
                    i = t.U,
                    o = t.L,
                    s = t.R;
                if (n = o ? s ? ra(s) : o : s, i ? i.L === t ? i.L = n : i.R = n : this._ = n, o && s ? (r = n.C, n.C = t.C, n.L = o, o.U = n, n !== s ? (i = n.U, n.U = t.U, t = n.R, i.L = t, n.R = s, s.U = n) : (n.U = i, i = n, t = n.R)) : (r = t.C, t = n), t && (t.U = i), !r)
                    if (t && t.C)
                        t.C = !1;
                    else {
                        do {
                            if (t === this._)
                                break;
                            if (t === i.L) {
                                if ((e = i.R).C && (e.C = !1, i.C = !0, ea(this, i), e = i.R), e.L && e.L.C || e.R && e.R.C) {
                                    e.R && e.R.C || (e.L.C = !1, e.C = !0, na(this, e), e = i.R),
                                    e.C = i.C,
                                    i.C = e.R.C = !1,
                                    ea(this, i),
                                    t = this._;
                                    break
                                }
                            } else if ((e = i.L).C && (e.C = !1, i.C = !0, na(this, i), e = i.L), e.L && e.L.C || e.R && e.R.C) {
                                e.L && e.L.C || (e.R.C = !1, e.C = !0, ea(this, e), e = i.L),
                                e.C = i.C,
                                i.C = e.L.C = !1,
                                na(this, i),
                                t = this._;
                                break
                            }
                            e.C = !0,
                            t = i,
                            i = i.U
                        } while (!t.C);
                        t && (t.C = !1)
                    }
            }
        };
        var pa,
            fa = [];
        function da() {
            ta(this),
            this.x = this.y = this.arc = this.site = this.cy = null
        }
        function ga(t) {
            var e = t.P,
                n = t.N;
            if (e && n) {
                var r = e.site,
                    i = t.site,
                    o = n.site;
                if (r !== o) {
                    var s = i[0],
                        a = i[1],
                        u = r[0] - s,
                        l = r[1] - a,
                        h = o[0] - s,
                        c = o[1] - a,
                        p = 2 * (u * c - l * h);
                    if (!(p >= -La)) {
                        var f = u * u + l * l,
                            d = h * h + c * c,
                            g = (c * f - l * d) / p,
                            y = (u * d - h * f) / p,
                            v = fa.pop() || new da;
                        v.arc = t,
                        v.site = i,
                        v.x = g + s,
                        v.y = (v.cy = y + a) + Math.sqrt(g * g + y * y),
                        t.circle = v;
                        for (var m = null, _ = Ia._; _;)
                            if (v.y < _.y || v.y === _.y && v.x <= _.x) {
                                if (!_.L) {
                                    m = _.P;
                                    break
                                }
                                _ = _.L
                            } else {
                                if (!_.R) {
                                    m = _;
                                    break
                                }
                                _ = _.R
                            }
                        Ia.insert(m, v),
                        m || (pa = v)
                    }
                }
            }
        }
        function ya(t) {
            var e = t.circle;
            e && (e.P || (pa = e.N), Ia.remove(e), fa.push(e), ta(e), t.circle = null)
        }
        var va = [];
        function ma() {
            ta(this),
            this.edge = this.site = this.circle = null
        }
        function _a(t) {
            var e = va.pop() || new ma;
            return e.site = t, e
        }
        function xa(t) {
            ya(t),
            Ma.remove(t),
            va.push(t),
            ta(t)
        }
        function Ea(t) {
            var e = t.circle,
                n = e.x,
                r = e.cy,
                i = [n, r],
                o = t.P,
                s = t.N,
                a = [t];
            xa(t);
            for (var u = o; u.circle && Math.abs(n - u.circle.x) < Pa && Math.abs(r - u.circle.cy) < Pa;)
                o = u.P,
                a.unshift(u),
                xa(u),
                u = o;
            a.unshift(u),
            ya(u);
            for (var l = s; l.circle && Math.abs(n - l.circle.x) < Pa && Math.abs(r - l.circle.cy) < Pa;)
                s = l.N,
                a.push(l),
                xa(l),
                l = s;
            a.push(l),
            ya(l);
            var h,
                c = a.length;
            for (h = 1; h < c; ++h)
                l = a[h],
                u = a[h - 1],
                sa(l.edge, u.site, l.site, i);
            u = a[0],
            (l = a[c - 1]).edge = ia(u.site, l.site, null, i),
            ga(u),
            ga(l)
        }
        function wa(t) {
            for (var e, n, r, i, o = t[0], s = t[1], a = Ma._; a;)
                if ((r = ba(a, s) - o) > Pa)
                    a = a.L;
                else {
                    if (!((i = o - Ca(a, s)) > Pa)) {
                        r > -Pa ? (e = a.P, n = a) : i > -Pa ? (e = a, n = a.N) : e = n = a;
                        break
                    }
                    if (!a.R) {
                        e = a;
                        break
                    }
                    a = a.R
                }
            !function(t) {
                Sa[t.index] = {
                    site: t,
                    halfedges: []
                }
            }(t);
            var u = _a(t);
            if (Ma.insert(e, u), e || n) {
                if (e === n)
                    return ya(e), n = _a(e.site), Ma.insert(u, n), u.edge = n.edge = ia(e.site, u.site), ga(e), void ga(n);
                if (n) {
                    ya(e),
                    ya(n);
                    var l = e.site,
                        h = l[0],
                        c = l[1],
                        p = t[0] - h,
                        f = t[1] - c,
                        d = n.site,
                        g = d[0] - h,
                        y = d[1] - c,
                        v = 2 * (p * y - f * g),
                        m = p * p + f * f,
                        _ = g * g + y * y,
                        x = [(y * m - f * _) / v + h, (p * _ - g * m) / v + c];
                    sa(n.edge, l, d, x),
                    u.edge = ia(l, t, null, x),
                    n.edge = ia(t, d, null, x),
                    ga(e),
                    ga(n)
                } else
                    u.edge = ia(e.site, u.site)
            }
        }
        function ba(t, e) {
            var n = t.site,
                r = n[0],
                i = n[1],
                o = i - e;
            if (!o)
                return r;
            var s = t.P;
            if (!s)
                return -1 / 0;
            var a = (n = s.site)[0],
                u = n[1],
                l = u - e;
            if (!l)
                return a;
            var h = a - r,
                c = 1 / o - 1 / l,
                p = h / l;
            return c ? (-p + Math.sqrt(p * p - 2 * c * (h * h / (-2 * l) - u + l / 2 + i - o / 2))) / c + r : (r + a) / 2
        }
        function Ca(t, e) {
            var n = t.N;
            if (n)
                return ba(n, e);
            var r = t.site;
            return r[1] === e ? r[0] : 1 / 0
        }
        var Ma,
            Sa,
            Ia,
            Ta,
            Pa = 1e-6,
            La = 1e-12;
        function Oa(t, e) {
            return e[1] - t[1] || e[0] - t[0]
        }
        function Na(t, e) {
            var n,
                r,
                i,
                o = t.sort(Oa).pop();
            for (Ta = [], Sa = new Array(t.length), Ma = new Qs, Ia = new Qs;;)
                if (i = pa, o && (!i || o[1] < i.y || o[1] === i.y && o[0] < i.x))
                    o[0] === n && o[1] === r || (wa(o), n = o[0], r = o[1]),
                    o = t.pop();
                else {
                    if (!i)
                        break;
                    Ea(i.arc)
                }
            if (function() {
                for (var t, e, n, r, i = 0, o = Sa.length; i < o; ++i)
                    if ((t = Sa[i]) && (r = (e = t.halfedges).length)) {
                        var s = new Array(r),
                            a = new Array(r);
                        for (n = 0; n < r; ++n)
                            s[n] = n,
                            a[n] = la(t, Ta[e[n]]);
                        for (s.sort((function(t, e) {
                            return a[e] - a[t]
                        })), n = 0; n < r; ++n)
                            a[n] = e[s[n]];
                        for (n = 0; n < r; ++n)
                            e[n] = a[n]
                    }
            }(), e) {
                var s = +e[0][0],
                    a = +e[0][1],
                    u = +e[1][0],
                    l = +e[1][1];
                !function(t, e, n, r) {
                    for (var i, o = Ta.length; o--;)
                        ua(i = Ta[o], t, e, n, r) && aa(i, t, e, n, r) && (Math.abs(i[0][0] - i[1][0]) > Pa || Math.abs(i[0][1] - i[1][1]) > Pa) || delete Ta[o]
                }(s, a, u, l),
                function(t, e, n, r) {
                    var i,
                        o,
                        s,
                        a,
                        u,
                        l,
                        h,
                        c,
                        p,
                        f,
                        d,
                        g,
                        y = Sa.length,
                        v = !0;
                    for (i = 0; i < y; ++i)
                        if (o = Sa[i]) {
                            for (s = o.site, a = (u = o.halfedges).length; a--;)
                                Ta[u[a]] || u.splice(a, 1);
                            for (a = 0, l = u.length; a < l;)
                                d = (f = ca(o, Ta[u[a]]))[0],
                                g = f[1],
                                c = (h = ha(o, Ta[u[++a % l]]))[0],
                                p = h[1],
                                (Math.abs(d - c) > Pa || Math.abs(g - p) > Pa) && (u.splice(a, 0, Ta.push(oa(s, f, Math.abs(d - t) < Pa && r - g > Pa ? [t, Math.abs(c - t) < Pa ? p : r] : Math.abs(g - r) < Pa && n - d > Pa ? [Math.abs(p - r) < Pa ? c : n, r] : Math.abs(d - n) < Pa && g - e > Pa ? [n, Math.abs(c - n) < Pa ? p : e] : Math.abs(g - e) < Pa && d - t > Pa ? [Math.abs(p - e) < Pa ? c : t, e] : null)) - 1), ++l);
                            l && (v = !1)
                        }
                    if (v) {
                        var m,
                            _,
                            x,
                            E = 1 / 0;
                        for (i = 0, v = null; i < y; ++i)
                            (o = Sa[i]) && (x = (m = (s = o.site)[0] - t) * m + (_ = s[1] - e) * _) < E && (E = x, v = o);
                        if (v) {
                            var w = [t, e],
                                b = [t, r],
                                C = [n, r],
                                M = [n, e];
                            v.halfedges.push(Ta.push(oa(s = v.site, w, b)) - 1, Ta.push(oa(s, b, C)) - 1, Ta.push(oa(s, C, M)) - 1, Ta.push(oa(s, M, w)) - 1)
                        }
                    }
                    for (i = 0; i < y; ++i)
                        (o = Sa[i]) && (o.halfedges.length || delete Sa[i])
                }(s, a, u, l)
            }
            this.edges = Ta,
            this.cells = Sa,
            Ma = Ia = Ta = Sa = null
        }
        function Ra(t) {
            return (t = t.slice()).push(t[0]), l([t])
        }
        function Aa(t, e, n, r) {
            var i = (r = r || {}).steps || 64,
                o = r.units || "kilometers",
                s = r.angle || 0,
                a = r.pivot || t,
                u = r.properties || t.properties || {};
            if (!t)
                throw new Error("center is required");
            if (!e)
                throw new Error("xSemiAxis is required");
            if (!n)
                throw new Error("ySemiAxis is required");
            if (!T(r))
                throw new Error("options must be an object");
            if (!I(i))
                throw new Error("steps must be a number");
            if (!I(s))
                throw new Error("angle must be a number");
            var h = Z(t);
            if ("degrees" === o)
                var c = C(s);
            else
                e = zi(t, e, 90, {
                    units: o
                }),
                n = zi(t, n, 0, {
                    units: o
                }),
                e = Z(e)[0] - h[0],
                n = Z(n)[1] - h[1];
            for (var p = [], f = 0; f < i; f += 1) {
                var d = -360 * f / i,
                    g = e * n / Math.sqrt(Math.pow(n, 2) + Math.pow(e, 2) * Math.pow(Da(d), 2)),
                    y = e * n / Math.sqrt(Math.pow(e, 2) + Math.pow(n, 2) / Math.pow(Da(d), 2));
                if (d < -90 && d >= -270 && (g = -g), d < -180 && d >= -360 && (y = -y), "degrees" === o) {
                    var v = g * Math.cos(c) + y * Math.sin(c),
                        m = y * Math.cos(c) - g * Math.sin(c);
                    g = v,
                    y = m
                }
                p.push([g + h[0], y + h[1]])
            }
            return p.push(p[0]), "degrees" === o ? l([p], u) : Qo(l([p], u), s, {
                pivot: a
            })
        }
        function Da(t) {
            var e = t * Math.PI / 180;
            return Math.tan(e)
        }
        function Fa(t, e) {
            void 0 === e && (e = {});
            var n = 0,
                r = 0,
                i = 0;
            return G(t, (function(t, o, s) {
                var a = e.weight ? null == s ? void 0 : s[e.weight] : void 0;
                if (!I(a = null == a ? 1 : a))
                    throw new Error("weight value must be a number for feature index " + o);
                (a = Number(a)) > 0 && N(t, (function(t) {
                    n += t[0] * a,
                    r += t[1] * a,
                    i += a
                }))
            })), a([n / i, r / i], e.properties, e)
        }
        function ka(t, e, n, r, i) {
            var o = r.tolerance || .001,
                s = 0,
                u = 0,
                l = 0,
                h = 0;
            if (F(n, (function(e) {
                var n,
                    r = null === (n = e.properties) || void 0 === n ? void 0 : n.weight,
                    i = null == r ? 1 : r;
                if (!I(i = Number(i)))
                    throw new Error("weight value must be a number");
                if (i > 0) {
                    h += 1;
                    var o = i * _e(e, t);
                    0 === o && (o = 1);
                    var a = i / o;
                    s += e.geometry.coordinates[0] * a,
                    u += e.geometry.coordinates[1] * a,
                    l += a
                }
            })), h < 1)
                throw new Error("no features to measure");
            var c = s / l,
                p = u / l;
            return 1 === h || 0 === i || Math.abs(c - e[0]) < o && Math.abs(p - e[1]) < o ? a([c, p], {
                medianCandidates: r.medianCandidates
            }) : (r.medianCandidates.push([c, p]), ka([c, p], t, n, r, i - 1))
        }
        function ja(t, e) {
            return {
                x: t[0] - e[0],
                y: t[1] - e[1]
            }
        }
        function Ga(t, e) {
            var n = 0,
                r = 0;
            N(t, (function(i, o, s, a, u) {
                u > n && (n = u, r = o, e.push([]));
                var l = o - r,
                    h = t.coordinates[u][l + 1],
                    c = i[0],
                    p = i[1],
                    f = h[0],
                    d = h[1];
                e[u].push([.75 * c + .25 * f, .75 * p + .25 * d]),
                e[u].push([.25 * c + .75 * f, .25 * p + .75 * d])
            }), !0),
            e.forEach((function(t) {
                t.push(t[0])
            }))
        }
        function Ba(t, e) {
            var n = 0,
                r = 0,
                i = 0;
            N(t, (function(o, s, a, u, l) {
                u > i && (i = u, r = s, e.push([[]])),
                l > n && (n = l, r = s, e[u].push([]));
                var h = s - r,
                    c = t.coordinates[u][l][h + 1],
                    p = o[0],
                    f = o[1],
                    d = c[0],
                    g = c[1];
                e[u][l].push([.75 * p + .25 * d, .75 * f + .25 * g]),
                e[u][l].push([.25 * p + .75 * d, .25 * f + .75 * g])
            }), !0),
            e.forEach((function(t) {
                t.forEach((function(t) {
                    t.push(t[0])
                }))
            }))
        }
        function qa(t, e, n) {
            void 0 === n && (n = 2);
            var r = Z(t),
                i = Z(e),
                o = r[0] - i[0],
                s = r[1] - i[1];
            return 1 === n ? Math.abs(o) + Math.abs(s) : Math.pow(Math.pow(o, n) + Math.pow(s, n), 1 / n)
        }
        function za(t, e) {
            var n = (e = e || {}).threshold || 1e4,
                r = e.p || 2,
                i = e.binary || !1,
                o = e.alpha || -1,
                s = e.standardization || !1,
                a = [];
            F(t, (function(t) {
                a.push(En(t))
            }));
            for (var u = [], l = 0; l < a.length; l++)
                u[l] = [];
            for (l = 0; l < a.length; l++)
                for (var h = l; h < a.length; h++) {
                    l === h && (u[l][h] = 0);
                    var c = qa(a[l], a[h], r);
                    u[l][h] = c,
                    u[h][l] = c
                }
            for (l = 0; l < a.length; l++)
                for (h = 0; h < a.length; h++)
                    0 !== (c = u[l][h]) && (u[l][h] = i ? c <= n ? 1 : 0 : c <= n ? Math.pow(c, o) : 0);
            if (s)
                for (l = 0; l < a.length; l++) {
                    var p = u[l].reduce((function(t, e) {
                        return t + e
                    }), 0);
                    for (h = 0; h < a.length; h++)
                        u[l][h] = u[l][h] / p
                }
            return u
        }
        function Ua(t) {
            for (var e = 0, n = 0, r = t; n < r.length; n++)
                e += r[n];
            return e / t.length
        }
        function Va(t, e) {
            return void 0 === e && (e = {}), Ha(t, "mercator", e)
        }
        function Xa(t, e) {
            return void 0 === e && (e = {}), Ha(t, "wgs84", e)
        }
        function Ha(t, e, n) {
            void 0 === n && (n = {});
            var r = (n = n || {}).mutate;
            if (!t)
                throw new Error("geojson is required");
            return Array.isArray(t) && I(t[0]) ? t = "mercator" === e ? Ya(t) : Wa(t) : (!0 !== r && (t = Ce(t)), N(t, (function(t) {
                var n = "mercator" === e ? Ya(t) : Wa(t);
                t[0] = n[0],
                t[1] = n[1]
            }))), t
        }
        function Ya(t) {
            var e = Math.PI / 180,
                n = 6378137,
                r = 20037508.342789244,
                i = [n * (Math.abs(t[0]) <= 180 ? t[0] : t[0] - 360 * function(t) {
                    return t < 0 ? -1 : t > 0 ? 1 : 0
                }(t[0])) * e, n * Math.log(Math.tan(.25 * Math.PI + .5 * t[1] * e))];
            return i[0] > r && (i[0] = r), i[0] < -r && (i[0] = -r), i[1] > r && (i[1] = r), i[1] < -r && (i[1] = -r), i
        }
        function Wa(t) {
            var e = 180 / Math.PI,
                n = 6378137;
            return [t[0] * e / n, (.5 * Math.PI - 2 * Math.atan(Math.exp(-t[1] / n))) * e]
        }
        Na.prototype = {
            constructor: Na,
            polygons: function() {
                var t = this.edges;
                return this.cells.map((function(e) {
                    var n = e.halfedges.map((function(n) {
                        return ha(e, t[n])
                    }));
                    return n.data = e.site.data, n
                }))
            },
            triangles: function() {
                var t = [],
                    e = this.edges;
                return this.cells.forEach((function(n, r) {
                    if (o = (i = n.halfedges).length)
                        for (var i, o, s, a, u, l, h = n.site, c = -1, p = e[i[o - 1]], f = p.left === h ? p.right : p.left; ++c < o;)
                            s = f,
                            f = (p = e[i[c]]).left === h ? p.right : p.left,
                            s && f && r < s.index && r < f.index && (u = s, l = f, ((a = h)[0] - l[0]) * (u[1] - a[1]) - (a[0] - u[0]) * (l[1] - a[1]) < 0) && t.push([h.data, s.data, f.data])
                })), t
            },
            links: function() {
                return this.edges.filter((function(t) {
                    return t.right
                })).map((function(t) {
                    return {
                        source: t.left.data,
                        target: t.right.data
                    }
                }))
            },
            find: function(t, e, n) {
                for (var r, i, o = this, s = o._found || 0, a = o.cells.length; !(i = o.cells[s]);)
                    if (++s >= a)
                        return null;
                var u = t - i.site[0],
                    l = e - i.site[1],
                    h = u * u + l * l;
                do {
                    i = o.cells[r = s],
                    s = null,
                    i.halfedges.forEach((function(n) {
                        var r = o.edges[n],
                            a = r.left;
                        if (a !== i.site && a || (a = r.right)) {
                            var u = t - a[0],
                                l = e - a[1],
                                c = u * u + l * l;
                            c < h && (h = c, s = a.index)
                        }
                    }))
                } while (null !== s);
                return o._found = r, null == n || h <= n * n ? i.site : null
            }
        };
        var $a = Object.freeze({
                __proto__: null,
                toMercator: Va,
                toWgs84: Xa
            }),
            Ka = function() {
                for (var t = 0, e = 0, n = arguments.length; e < n; e++)
                    t += arguments[e].length;
                var r = Array(t),
                    i = 0;
                for (e = 0; e < n; e++)
                    for (var o = arguments[e], s = 0, a = o.length; s < a; s++, i++)
                        r[i] = o[s];
                return r
            };
        function Za(t) {
            return Array.isArray(t) ? nu(t) : t && t.bbox ? nu(t.bbox) : [360 * eu(), 180 * eu()]
        }
        function Ja(t, e) {
            void 0 === e && (e = {}),
            null == t && (t = 1);
            for (var n = [], r = 0; r < t; r++)
                n.push(a(Za(e.bbox)));
            return f(n)
        }
        function Qa(t, e) {
            void 0 === e && (e = {}),
            null == t && (t = 1),
            I(e.num_vertices) && void 0 !== e.num_vertices || (e.num_vertices = 10),
            I(e.max_radial_length) && void 0 !== e.max_radial_length || (e.max_radial_length = 10);
            for (var n = [], r = function(t) {
                    var r,
                        i = [],
                        o = Ka(Array(e.num_vertices + 1)).map(Math.random);
                    o.forEach((function(t, e, n) {
                        n[e] = e > 0 ? t + n[e - 1] : t
                    })),
                    o.forEach((function(t) {
                        t = 2 * t * Math.PI / o[o.length - 1];
                        var n = Math.random();
                        i.push([n * (e.max_radial_length || 10) * Math.sin(t), n * (e.max_radial_length || 10) * Math.cos(t)])
                    })),
                    i[i.length - 1] = i[0],
                    i = i.map((r = Za(e.bbox), function(t) {
                        return [t[0] + r[0], t[1] + r[1]]
                    })),
                    n.push(l([i]))
                }, i = 0; i < t; i++)
                r();
            return f(n)
        }
        function tu(t, e) {
            if (void 0 === e && (e = {}), !T(e = e || {}))
                throw new Error("options is invalid");
            var n = e.bbox,
                r = e.num_vertices,
                i = e.max_length,
                o = e.max_rotation;
            null == t && (t = 1),
            (!I(r) || void 0 === r || r < 2) && (r = 10),
            I(i) && void 0 !== i || (i = 1e-4),
            I(o) && void 0 !== o || (o = Math.PI / 8);
            for (var s = [], a = 0; a < t; a++) {
                for (var u = [Za(n)], l = 0; l < r - 1; l++) {
                    var h = (0 === l ? 2 * Math.random() * Math.PI : Math.tan((u[l][1] - u[l - 1][1]) / (u[l][0] - u[l - 1][0]))) + (Math.random() - .5) * o * 2,
                        p = Math.random() * i;
                    u.push([u[l][0] + p * Math.cos(h), u[l][1] + p * Math.sin(h)])
                }
                s.push(c(u))
            }
            return f(s)
        }
        function eu() {
            return Math.random() - .5
        }
        function nu(t) {
            return [Math.random() * (t[2] - t[0]) + t[0], Math.random() * (t[3] - t[1]) + t[1]]
        }
        var ru = Object.freeze({
            __proto__: null,
            randomPosition: Za,
            randomPoint: Ja,
            randomPolygon: Qa,
            randomLineString: tu
        });
        function iu(t, e) {
            if (!t)
                throw new Error("geojson is required");
            if ("FeatureCollection" !== t.type)
                throw new Error("geojson must be a FeatureCollection");
            if (null == e)
                throw new Error("filter is required");
            var n = [];
            return F(t, (function(t) {
                uu(t.properties, e) && n.push(t)
            })), f(n)
        }
        function ou(t, e, n) {
            if (!t)
                throw new Error("geojson is required");
            if ("FeatureCollection" !== t.type)
                throw new Error("geojson must be a FeatureCollection");
            if (null == e)
                throw new Error("property is required");
            for (var r = au(t, e), i = Object.keys(r), o = 0; o < i.length; o++) {
                for (var s = i[o], a = r[s], u = [], l = 0; l < a.length; l++)
                    u.push(t.features[a[l]]);
                n(f(u), s, o)
            }
        }
        function su(t, e, n, r) {
            var i = r;
            return ou(t, e, (function(t, e, o) {
                i = 0 === o && void 0 === r ? t : n(i, t, e, o)
            })), i
        }
        function au(t, e) {
            var n = {};
            return F(t, (function(t, r) {
                var i = t.properties || {};
                if (Object.prototype.hasOwnProperty.call(i, String(e))) {
                    var o = i[e];
                    Object.prototype.hasOwnProperty.call(n, o) ? n[o].push(r) : n[o] = [r]
                }
            })), n
        }
        function uu(t, e) {
            if (void 0 === t)
                return !1;
            var n = typeof e;
            if ("number" === n || "string" === n)
                return Object.prototype.hasOwnProperty.call(t, e);
            if (Array.isArray(e)) {
                for (var r = 0; r < e.length; r++)
                    if (!uu(t, e[r]))
                        return !1;
                return !0
            }
            return lu(t, e)
        }
        function lu(t, e) {
            for (var n = Object.keys(e), r = 0; r < n.length; r++) {
                var i = n[r];
                if (t[i] !== e[i])
                    return !1
            }
            return !0
        }
        function hu(t, e) {
            if (!e)
                return {};
            if (!e.length)
                return {};
            for (var n = {}, r = 0; r < e.length; r++) {
                var i = e[r];
                Object.prototype.hasOwnProperty.call(t, i) && (n[i] = t[i])
            }
            return n
        }
        var cu = Object.freeze({
                __proto__: null,
                getCluster: iu,
                clusterEach: ou,
                clusterReduce: su,
                createBins: au,
                applyFilter: uu,
                propertiesContainsFilter: lu,
                filterProperties: hu
            }),
            pu = function(t, e) {
                this.next = null,
                this.key = t,
                this.data = e,
                this.left = null,
                this.right = null
            };
        /**
             * splaytree v3.1.0
             * Fast Splay tree for Node and browser
             *
             * @author Alexander Milevski <info@w8r.name>
             * @license MIT
             * @preserve
             */
        function fu(t, e) {
            return t > e ? 1 : t < e ? -1 : 0
        }
        function du(t, e, n) {
            for (var r = new pu(null, null), i = r, o = r;;) {
                var s = n(t, e.key);
                if (s < 0) {
                    if (null === e.left)
                        break;
                    if (n(t, e.left.key) < 0) {
                        var a = e.left;
                        if (e.left = a.right, a.right = e, null === (e = a).left)
                            break
                    }
                    o.left = e,
                    o = e,
                    e = e.left
                } else {
                    if (!(s > 0))
                        break;
                    if (null === e.right)
                        break;
                    if (n(t, e.right.key) > 0 && (a = e.right, e.right = a.left, a.left = e, null === (e = a).right))
                        break;
                    i.right = e,
                    i = e,
                    e = e.right
                }
            }
            return i.right = e.left, o.left = e.right, e.left = r.right, e.right = r.left, e
        }
        function gu(t, e, n, r) {
            var i = new pu(t, e);
            if (null === n)
                return i.left = i.right = null, i;
            var o = r(t, (n = du(t, n, r)).key);
            return o < 0 ? (i.left = n.left, i.right = n, n.left = null) : o >= 0 && (i.right = n.right, i.left = n, n.right = null), i
        }
        function yu(t, e, n) {
            var r = null,
                i = null;
            if (e) {
                var o = n((e = du(t, e, n)).key, t);
                0 === o ? (r = e.left, i = e.right) : o < 0 ? (i = e.right, e.right = null, r = e) : (r = e.left, e.left = null, i = e)
            }
            return {
                left: r,
                right: i
            }
        }
        function vu(t, e, n, r, i) {
            if (t) {
                r(e + (n ? "└── " : "├── ") + i(t) + "\n");
                var o = e + (n ? "    " : "│   ");
                t.left && vu(t.left, o, !1, r, i),
                t.right && vu(t.right, o, !0, r, i)
            }
        }
        var mu = function() {
            function t(t) {
                void 0 === t && (t = fu),
                this._root = null,
                this._size = 0,
                this._comparator = t
            }
            return t.prototype.insert = function(t, e) {
                return this._size++, this._root = gu(t, e, this._root, this._comparator)
            }, t.prototype.add = function(t, e) {
                var n = new pu(t, e);
                null === this._root && (n.left = n.right = null, this._size++, this._root = n);
                var r = this._comparator,
                    i = du(t, this._root, r),
                    o = r(t, i.key);
                return 0 === o ? this._root = i : (o < 0 ? (n.left = i.left, n.right = i, i.left = null) : o > 0 && (n.right = i.right, n.left = i, i.right = null), this._size++, this._root = n), this._root
            }, t.prototype.remove = function(t) {
                this._root = this._remove(t, this._root, this._comparator)
            }, t.prototype._remove = function(t, e, n) {
                var r;
                return null === e ? null : 0 === n(t, (e = du(t, e, n)).key) ? (null === e.left ? r = e.right : (r = du(t, e.left, n)).right = e.right, this._size--, r) : e
            }, t.prototype.pop = function() {
                var t = this._root;
                if (t) {
                    for (; t.left;)
                        t = t.left;
                    return this._root = du(t.key, this._root, this._comparator), this._root = this._remove(t.key, this._root, this._comparator), {
                        key: t.key,
                        data: t.data
                    }
                }
                return null
            }, t.prototype.findStatic = function(t) {
                for (var e = this._root, n = this._comparator; e;) {
                    var r = n(t, e.key);
                    if (0 === r)
                        return e;
                    e = r < 0 ? e.left : e.right
                }
                return null
            }, t.prototype.find = function(t) {
                return this._root && (this._root = du(t, this._root, this._comparator), 0 !== this._comparator(t, this._root.key)) ? null : this._root
            }, t.prototype.contains = function(t) {
                for (var e = this._root, n = this._comparator; e;) {
                    var r = n(t, e.key);
                    if (0 === r)
                        return !0;
                    e = r < 0 ? e.left : e.right
                }
                return !1
            }, t.prototype.forEach = function(t, e) {
                for (var n = this._root, r = [], i = !1; !i;)
                    null !== n ? (r.push(n), n = n.left) : 0 !== r.length ? (n = r.pop(), t.call(e, n), n = n.right) : i = !0;
                return this
            }, t.prototype.range = function(t, e, n, r) {
                for (var i = [], o = this._comparator, s = this._root; 0 !== i.length || s;)
                    if (s)
                        i.push(s),
                        s = s.left;
                    else {
                        if (o((s = i.pop()).key, e) > 0)
                            break;
                        if (o(s.key, t) >= 0 && n.call(r, s))
                            return this;
                        s = s.right
                    }
                return this
            }, t.prototype.keys = function() {
                var t = [];
                return this.forEach((function(e) {
                    var n = e.key;
                    return t.push(n)
                })), t
            }, t.prototype.values = function() {
                var t = [];
                return this.forEach((function(e) {
                    var n = e.data;
                    return t.push(n)
                })), t
            }, t.prototype.min = function() {
                return this._root ? this.minNode(this._root).key : null
            }, t.prototype.max = function() {
                return this._root ? this.maxNode(this._root).key : null
            }, t.prototype.minNode = function(t) {
                if (void 0 === t && (t = this._root), t)
                    for (; t.left;)
                        t = t.left;
                return t
            }, t.prototype.maxNode = function(t) {
                if (void 0 === t && (t = this._root), t)
                    for (; t.right;)
                        t = t.right;
                return t
            }, t.prototype.at = function(t) {
                for (var e = this._root, n = !1, r = 0, i = []; !n;)
                    if (e)
                        i.push(e),
                        e = e.left;
                    else if (i.length > 0) {
                        if (e = i.pop(), r === t)
                            return e;
                        r++,
                        e = e.right
                    } else
                        n = !0;
                return null
            }, t.prototype.next = function(t) {
                var e = this._root,
                    n = null;
                if (t.right) {
                    for (n = t.right; n.left;)
                        n = n.left;
                    return n
                }
                for (var r = this._comparator; e;) {
                    var i = r(t.key, e.key);
                    if (0 === i)
                        break;
                    i < 0 ? (n = e, e = e.left) : e = e.right
                }
                return n
            }, t.prototype.prev = function(t) {
                var e = this._root,
                    n = null;
                if (null !== t.left) {
                    for (n = t.left; n.right;)
                        n = n.right;
                    return n
                }
                for (var r = this._comparator; e;) {
                    var i = r(t.key, e.key);
                    if (0 === i)
                        break;
                    i < 0 ? e = e.left : (n = e, e = e.right)
                }
                return n
            }, t.prototype.clear = function() {
                return this._root = null, this._size = 0, this
            }, t.prototype.toList = function() {
                return function(t) {
                    for (var e = t, n = [], r = !1, i = new pu(null, null), o = i; !r;)
                        e ? (n.push(e), e = e.left) : n.length > 0 ? e = (e = o = o.next = n.pop()).right : r = !0;
                    return o.next = null, i.next
                }(this._root)
            }, t.prototype.load = function(t, e, n) {
                void 0 === e && (e = []),
                void 0 === n && (n = !1);
                var r = t.length,
                    i = this._comparator;
                if (n && Eu(t, e, 0, r - 1, i), null === this._root)
                    this._root = _u(t, e, 0, r),
                    this._size = r;
                else {
                    var o = function(t, e, n) {
                        for (var r = new pu(null, null), i = r, o = t, s = e; null !== o && null !== s;)
                            n(o.key, s.key) < 0 ? (i.next = o, o = o.next) : (i.next = s, s = s.next),
                            i = i.next;
                        return null !== o ? i.next = o : null !== s && (i.next = s), r.next
                    }(this.toList(), function(t, e) {
                        for (var n = new pu(null, null), r = n, i = 0; i < t.length; i++)
                            r = r.next = new pu(t[i], e[i]);
                        return r.next = null, n.next
                    }(t, e), i);
                    r = this._size + r,
                    this._root = xu({
                        head: o
                    }, 0, r)
                }
                return this
            }, t.prototype.isEmpty = function() {
                return null === this._root
            }, Object.defineProperty(t.prototype, "size", {
                get: function() {
                    return this._size
                },
                enumerable: !0,
                configurable: !0
            }), Object.defineProperty(t.prototype, "root", {
                get: function() {
                    return this._root
                },
                enumerable: !0,
                configurable: !0
            }), t.prototype.toString = function(t) {
                void 0 === t && (t = function(t) {
                    return String(t.key)
                });
                var e = [];
                return vu(this._root, "", !0, (function(t) {
                    return e.push(t)
                }), t), e.join("")
            }, t.prototype.update = function(t, e, n) {
                var r = this._comparator,
                    i = yu(t, this._root, r),
                    o = i.left,
                    s = i.right;
                r(t, e) < 0 ? s = gu(e, n, s, r) : o = gu(e, n, o, r),
                this._root = function(t, e, n) {
                    return null === e ? t : (null === t || ((e = du(t.key, e, n)).left = t), e)
                }(o, s, r)
            }, t.prototype.split = function(t) {
                return yu(t, this._root, this._comparator)
            }, t
        }();
        function _u(t, e, n, r) {
            var i = r - n;
            if (i > 0) {
                var o = n + Math.floor(i / 2),
                    s = t[o],
                    a = e[o],
                    u = new pu(s, a);
                return u.left = _u(t, e, n, o), u.right = _u(t, e, o + 1, r), u
            }
            return null
        }
        function xu(t, e, n) {
            var r = n - e;
            if (r > 0) {
                var i = e + Math.floor(r / 2),
                    o = xu(t, e, i),
                    s = t.head;
                return s.left = o, t.head = t.head.next, s.right = xu(t, i + 1, n), s
            }
            return null
        }
        function Eu(t, e, n, r, i) {
            if (!(n >= r)) {
                for (var o = t[n + r >> 1], s = n - 1, a = r + 1;;) {
                    do {
                        s++
                    } while (i(t[s], o) < 0);
                    do {
                        a--
                    } while (i(t[a], o) > 0);
                    if (s >= a)
                        break;
                    var u = t[s];
                    t[s] = t[a],
                    t[a] = u,
                    u = e[s],
                    e[s] = e[a],
                    e[a] = u
                }
                Eu(t, e, n, a, i),
                Eu(t, e, a + 1, r, i)
            }
        }
        function wu(t, e) {
            if (!(t instanceof e))
                throw new TypeError("Cannot call a class as a function")
        }
        function bu(t, e) {
            for (var n = 0; n < e.length; n++) {
                var r = e[n];
                r.enumerable = r.enumerable || !1,
                r.configurable = !0,
                "value" in r && (r.writable = !0),
                Object.defineProperty(t, r.key, r)
            }
        }
        function Cu(t, e, n) {
            return e && bu(t.prototype, e), n && bu(t, n), t
        }
        var Mu = function(t, e) {
                return t.ll.x <= e.x && e.x <= t.ur.x && t.ll.y <= e.y && e.y <= t.ur.y
            },
            Su = function(t, e) {
                if (e.ur.x < t.ll.x || t.ur.x < e.ll.x || e.ur.y < t.ll.y || t.ur.y < e.ll.y)
                    return null;
                var n = t.ll.x < e.ll.x ? e.ll.x : t.ll.x,
                    r = t.ur.x < e.ur.x ? t.ur.x : e.ur.x;
                return {
                    ll: {
                        x: n,
                        y: t.ll.y < e.ll.y ? e.ll.y : t.ll.y
                    },
                    ur: {
                        x: r,
                        y: t.ur.y < e.ur.y ? t.ur.y : e.ur.y
                    }
                }
            },
            Iu = Number.EPSILON;
        void 0 === Iu && (Iu = Math.pow(2, -52));
        var Tu = Iu * Iu,
            Pu = function(t, e) {
                if (-Iu < t && t < Iu && -Iu < e && e < Iu)
                    return 0;
                var n = t - e;
                return n * n < Tu * t * e ? 0 : t < e ? -1 : 1
            },
            Lu = function() {
                function t() {
                    wu(this, t),
                    this.reset()
                }
                return Cu(t, [{
                    key: "reset",
                    value: function() {
                        this.xRounder = new Ou,
                        this.yRounder = new Ou
                    }
                }, {
                    key: "round",
                    value: function(t, e) {
                        return {
                            x: this.xRounder.round(t),
                            y: this.yRounder.round(e)
                        }
                    }
                }]), t
            }(),
            Ou = function() {
                function t() {
                    wu(this, t),
                    this.tree = new mu,
                    this.round(0)
                }
                return Cu(t, [{
                    key: "round",
                    value: function(t) {
                        var e = this.tree.add(t),
                            n = this.tree.prev(e);
                        if (null !== n && 0 === Pu(e.key, n.key))
                            return this.tree.remove(t), n.key;
                        var r = this.tree.next(e);
                        return null !== r && 0 === Pu(e.key, r.key) ? (this.tree.remove(t), r.key) : t
                    }
                }]), t
            }(),
            Nu = new Lu,
            Ru = function(t, e) {
                return t.x * e.y - t.y * e.x
            },
            Au = function(t, e) {
                return t.x * e.x + t.y * e.y
            },
            Du = function(t, e, n) {
                var r = {
                        x: e.x - t.x,
                        y: e.y - t.y
                    },
                    i = {
                        x: n.x - t.x,
                        y: n.y - t.y
                    },
                    o = Ru(r, i);
                return Pu(o, 0)
            },
            Fu = function(t) {
                return Math.sqrt(Au(t, t))
            },
            ku = function(t, e, n) {
                var r = {
                        x: e.x - t.x,
                        y: e.y - t.y
                    },
                    i = {
                        x: n.x - t.x,
                        y: n.y - t.y
                    };
                return Au(i, r) / Fu(i) / Fu(r)
            },
            ju = function(t, e, n) {
                return 0 === e.y ? null : {
                    x: t.x + e.x / e.y * (n - t.y),
                    y: n
                }
            },
            Gu = function(t, e, n) {
                return 0 === e.x ? null : {
                    x: n,
                    y: t.y + e.y / e.x * (n - t.x)
                }
            },
            Bu = function() {
                function t(e, n) {
                    wu(this, t),
                    void 0 === e.events ? e.events = [this] : e.events.push(this),
                    this.point = e,
                    this.isLeft = n
                }
                return Cu(t, null, [{
                    key: "compare",
                    value: function(e, n) {
                        var r = t.comparePoints(e.point, n.point);
                        return 0 !== r ? r : (e.point !== n.point && e.link(n), e.isLeft !== n.isLeft ? e.isLeft ? 1 : -1 : zu.compare(e.segment, n.segment))
                    }
                }, {
                    key: "comparePoints",
                    value: function(t, e) {
                        return t.x < e.x ? -1 : t.x > e.x ? 1 : t.y < e.y ? -1 : t.y > e.y ? 1 : 0
                    }
                }]), Cu(t, [{
                    key: "link",
                    value: function(t) {
                        if (t.point === this.point)
                            throw new Error("Tried to link already linked events");
                        for (var e = t.point.events, n = 0, r = e.length; n < r; n++) {
                            var i = e[n];
                            this.point.events.push(i),
                            i.point = this.point
                        }
                        this.checkForConsuming()
                    }
                }, {
                    key: "checkForConsuming",
                    value: function() {
                        for (var t = this.point.events.length, e = 0; e < t; e++) {
                            var n = this.point.events[e];
                            if (void 0 === n.segment.consumedBy)
                                for (var r = e + 1; r < t; r++) {
                                    var i = this.point.events[r];
                                    void 0 === i.consumedBy && n.otherSE.point.events === i.otherSE.point.events && n.segment.consume(i.segment)
                                }
                        }
                    }
                }, {
                    key: "getAvailableLinkedEvents",
                    value: function() {
                        for (var t = [], e = 0, n = this.point.events.length; e < n; e++) {
                            var r = this.point.events[e];
                            r !== this && !r.segment.ringOut && r.segment.isInResult() && t.push(r)
                        }
                        return t
                    }
                }, {
                    key: "getLeftmostComparator",
                    value: function(t) {
                        var e = this,
                            n = new Map,
                            r = function(r) {
                                var i,
                                    o,
                                    s,
                                    a,
                                    u,
                                    l = r.otherSE;
                                n.set(r, {
                                    sine: (i = e.point, o = t.point, s = l.point, a = {
                                        x: o.x - i.x,
                                        y: o.y - i.y
                                    }, u = {
                                        x: s.x - i.x,
                                        y: s.y - i.y
                                    }, Ru(u, a) / Fu(u) / Fu(a)),
                                    cosine: ku(e.point, t.point, l.point)
                                })
                            };
                        return function(t, e) {
                            n.has(t) || r(t),
                            n.has(e) || r(e);
                            var i = n.get(t),
                                o = i.sine,
                                s = i.cosine,
                                a = n.get(e),
                                u = a.sine,
                                l = a.cosine;
                            return o >= 0 && u >= 0 ? s < l ? 1 : s > l ? -1 : 0 : o < 0 && u < 0 ? s < l ? -1 : s > l ? 1 : 0 : u < o ? -1 : u > o ? 1 : 0
                        }
                    }
                }]), t
            }(),
            qu = 0,
            zu = function() {
                function t(e, n, r, i) {
                    wu(this, t),
                    this.id = ++qu,
                    this.leftSE = e,
                    e.segment = this,
                    e.otherSE = n,
                    this.rightSE = n,
                    n.segment = this,
                    n.otherSE = e,
                    this.rings = r,
                    this.windings = i
                }
                return Cu(t, null, [{
                    key: "compare",
                    value: function(t, e) {
                        var n = t.leftSE.point.x,
                            r = e.leftSE.point.x,
                            i = t.rightSE.point.x,
                            o = e.rightSE.point.x;
                        if (o < n)
                            return 1;
                        if (i < r)
                            return -1;
                        var s = t.leftSE.point.y,
                            a = e.leftSE.point.y,
                            u = t.rightSE.point.y,
                            l = e.rightSE.point.y;
                        if (n < r) {
                            if (a < s && a < u)
                                return 1;
                            if (a > s && a > u)
                                return -1;
                            var h = t.comparePoint(e.leftSE.point);
                            if (h < 0)
                                return 1;
                            if (h > 0)
                                return -1;
                            var c = e.comparePoint(t.rightSE.point);
                            return 0 !== c ? c : -1
                        }
                        if (n > r) {
                            if (s < a && s < l)
                                return -1;
                            if (s > a && s > l)
                                return 1;
                            var p = e.comparePoint(t.leftSE.point);
                            if (0 !== p)
                                return p;
                            var f = t.comparePoint(e.rightSE.point);
                            return f < 0 ? 1 : f > 0 ? -1 : 1
                        }
                        if (s < a)
                            return -1;
                        if (s > a)
                            return 1;
                        if (i < o) {
                            var d = e.comparePoint(t.rightSE.point);
                            if (0 !== d)
                                return d
                        }
                        if (i > o) {
                            var g = t.comparePoint(e.rightSE.point);
                            if (g < 0)
                                return 1;
                            if (g > 0)
                                return -1
                        }
                        if (i !== o) {
                            var y = u - s,
                                v = i - n,
                                m = l - a,
                                _ = o - r;
                            if (y > v && m < _)
                                return 1;
                            if (y < v && m > _)
                                return -1
                        }
                        return i > o ? 1 : i < o || u < l ? -1 : u > l ? 1 : t.id < e.id ? -1 : t.id > e.id ? 1 : 0
                    }
                }]), Cu(t, [{
                    key: "replaceRightSE",
                    value: function(t) {
                        this.rightSE = t,
                        this.rightSE.segment = this,
                        this.rightSE.otherSE = this.leftSE,
                        this.leftSE.otherSE = this.rightSE
                    }
                }, {
                    key: "bbox",
                    value: function() {
                        var t = this.leftSE.point.y,
                            e = this.rightSE.point.y;
                        return {
                            ll: {
                                x: this.leftSE.point.x,
                                y: t < e ? t : e
                            },
                            ur: {
                                x: this.rightSE.point.x,
                                y: t > e ? t : e
                            }
                        }
                    }
                }, {
                    key: "vector",
                    value: function() {
                        return {
                            x: this.rightSE.point.x - this.leftSE.point.x,
                            y: this.rightSE.point.y - this.leftSE.point.y
                        }
                    }
                }, {
                    key: "isAnEndpoint",
                    value: function(t) {
                        return t.x === this.leftSE.point.x && t.y === this.leftSE.point.y || t.x === this.rightSE.point.x && t.y === this.rightSE.point.y
                    }
                }, {
                    key: "comparePoint",
                    value: function(t) {
                        if (this.isAnEndpoint(t))
                            return 0;
                        var e = this.leftSE.point,
                            n = this.rightSE.point,
                            r = this.vector();
                        if (e.x === n.x)
                            return t.x === e.x ? 0 : t.x < e.x ? 1 : -1;
                        var i = (t.y - e.y) / r.y,
                            o = e.x + i * r.x;
                        if (t.x === o)
                            return 0;
                        var s = (t.x - e.x) / r.x,
                            a = e.y + s * r.y;
                        return t.y === a ? 0 : t.y < a ? -1 : 1
                    }
                }, {
                    key: "getIntersection",
                    value: function(t) {
                        var e = this.bbox(),
                            n = t.bbox(),
                            r = Su(e, n);
                        if (null === r)
                            return null;
                        var i = this.leftSE.point,
                            o = this.rightSE.point,
                            s = t.leftSE.point,
                            a = t.rightSE.point,
                            u = Mu(e, s) && 0 === this.comparePoint(s),
                            l = Mu(n, i) && 0 === t.comparePoint(i),
                            h = Mu(e, a) && 0 === this.comparePoint(a),
                            c = Mu(n, o) && 0 === t.comparePoint(o);
                        if (l && u)
                            return c && !h ? o : !c && h ? a : null;
                        if (l)
                            return h && i.x === a.x && i.y === a.y ? null : i;
                        if (u)
                            return c && o.x === s.x && o.y === s.y ? null : s;
                        if (c && h)
                            return null;
                        if (c)
                            return o;
                        if (h)
                            return a;
                        var p = function(t, e, n, r) {
                            if (0 === e.x)
                                return Gu(n, r, t.x);
                            if (0 === r.x)
                                return Gu(t, e, n.x);
                            if (0 === e.y)
                                return ju(n, r, t.y);
                            if (0 === r.y)
                                return ju(t, e, n.y);
                            var i = Ru(e, r);
                            if (0 == i)
                                return null;
                            var o = {
                                    x: n.x - t.x,
                                    y: n.y - t.y
                                },
                                s = Ru(o, e) / i,
                                a = Ru(o, r) / i;
                            return {
                                x: (t.x + a * e.x + (n.x + s * r.x)) / 2,
                                y: (t.y + a * e.y + (n.y + s * r.y)) / 2
                            }
                        }(i, this.vector(), s, t.vector());
                        return null === p ? null : Mu(r, p) ? Nu.round(p.x, p.y) : null
                    }
                }, {
                    key: "split",
                    value: function(e) {
                        var n = [],
                            r = void 0 !== e.events,
                            i = new Bu(e, !0),
                            o = new Bu(e, !1),
                            s = this.rightSE;
                        this.replaceRightSE(o),
                        n.push(o),
                        n.push(i);
                        var a = new t(i, s, this.rings.slice(), this.windings.slice());
                        return Bu.comparePoints(a.leftSE.point, a.rightSE.point) > 0 && a.swapEvents(), Bu.comparePoints(this.leftSE.point, this.rightSE.point) > 0 && this.swapEvents(), r && (i.checkForConsuming(), o.checkForConsuming()), n
                    }
                }, {
                    key: "swapEvents",
                    value: function() {
                        var t = this.rightSE;
                        this.rightSE = this.leftSE,
                        this.leftSE = t,
                        this.leftSE.isLeft = !0,
                        this.rightSE.isLeft = !1;
                        for (var e = 0, n = this.windings.length; e < n; e++)
                            this.windings[e] *= -1
                    }
                }, {
                    key: "consume",
                    value: function(e) {
                        for (var n = this, r = e; n.consumedBy;)
                            n = n.consumedBy;
                        for (; r.consumedBy;)
                            r = r.consumedBy;
                        var i = t.compare(n, r);
                        if (0 !== i) {
                            if (i > 0) {
                                var o = n;
                                n = r,
                                r = o
                            }
                            if (n.prev === r) {
                                var s = n;
                                n = r,
                                r = s
                            }
                            for (var a = 0, u = r.rings.length; a < u; a++) {
                                var l = r.rings[a],
                                    h = r.windings[a],
                                    c = n.rings.indexOf(l);
                                -1 === c ? (n.rings.push(l), n.windings.push(h)) : n.windings[c] += h
                            }
                            r.rings = null,
                            r.windings = null,
                            r.consumedBy = n,
                            r.leftSE.consumedBy = n.leftSE,
                            r.rightSE.consumedBy = n.rightSE
                        }
                    }
                }, {
                    key: "prevInResult",
                    value: function() {
                        return void 0 !== this._prevInResult || (this.prev ? this.prev.isInResult() ? this._prevInResult = this.prev : this._prevInResult = this.prev.prevInResult() : this._prevInResult = null), this._prevInResult
                    }
                }, {
                    key: "beforeState",
                    value: function() {
                        if (void 0 !== this._beforeState)
                            return this._beforeState;
                        if (this.prev) {
                            var t = this.prev.consumedBy || this.prev;
                            this._beforeState = t.afterState()
                        } else
                            this._beforeState = {
                                rings: [],
                                windings: [],
                                multiPolys: []
                            };
                        return this._beforeState
                    }
                }, {
                    key: "afterState",
                    value: function() {
                        if (void 0 !== this._afterState)
                            return this._afterState;
                        var t = this.beforeState();
                        this._afterState = {
                            rings: t.rings.slice(0),
                            windings: t.windings.slice(0),
                            multiPolys: []
                        };
                        for (var e = this._afterState.rings, n = this._afterState.windings, r = this._afterState.multiPolys, i = 0, o = this.rings.length; i < o; i++) {
                            var s = this.rings[i],
                                a = this.windings[i],
                                u = e.indexOf(s);
                            -1 === u ? (e.push(s), n.push(a)) : n[u] += a
                        }
                        for (var l = [], h = [], c = 0, p = e.length; c < p; c++)
                            if (0 !== n[c]) {
                                var f = e[c],
                                    d = f.poly;
                                if (-1 === h.indexOf(d))
                                    if (f.isExterior)
                                        l.push(d);
                                    else {
                                        -1 === h.indexOf(d) && h.push(d);
                                        var g = l.indexOf(f.poly);
                                        -1 !== g && l.splice(g, 1)
                                    }
                            }
                        for (var y = 0, v = l.length; y < v; y++) {
                            var m = l[y].multiPoly;
                            -1 === r.indexOf(m) && r.push(m)
                        }
                        return this._afterState
                    }
                }, {
                    key: "isInResult",
                    value: function() {
                        if (this.consumedBy)
                            return !1;
                        if (void 0 !== this._isInResult)
                            return this._isInResult;
                        var t = this.beforeState().multiPolys,
                            e = this.afterState().multiPolys;
                        switch (Ju.type) {
                        case "union":
                            var n = 0 === t.length,
                                r = 0 === e.length;
                            this._isInResult = n !== r;
                            break;
                        case "intersection":
                            var i,
                                o;
                            t.length < e.length ? (i = t.length, o = e.length) : (i = e.length, o = t.length),
                            this._isInResult = o === Ju.numMultiPolys && i < o;
                            break;
                        case "xor":
                            var s = Math.abs(t.length - e.length);
                            this._isInResult = s % 2 == 1;
                            break;
                        case "difference":
                            var a = function(t) {
                                return 1 === t.length && t[0].isSubject
                            };
                            this._isInResult = a(t) !== a(e);
                            break;
                        default:
                            throw new Error("Unrecognized operation type found ".concat(Ju.type))
                        }
                        return this._isInResult
                    }
                }], [{
                    key: "fromRing",
                    value: function(e, n, r) {
                        var i,
                            o,
                            s,
                            a = Bu.comparePoints(e, n);
                        if (a < 0)
                            i = e,
                            o = n,
                            s = 1;
                        else {
                            if (!(a > 0))
                                throw new Error("Tried to create degenerate segment at [".concat(e.x, ", ").concat(e.y, "]"));
                            i = n,
                            o = e,
                            s = -1
                        }
                        return new t(new Bu(i, !0), new Bu(o, !1), [r], [s])
                    }
                }]), t
            }(),
            Uu = function() {
                function t(e, n, r) {
                    if (wu(this, t), !Array.isArray(e) || 0 === e.length)
                        throw new Error("Input geometry is not a valid Polygon or MultiPolygon");
                    if (this.poly = n, this.isExterior = r, this.segments = [], "number" != typeof e[0][0] || "number" != typeof e[0][1])
                        throw new Error("Input geometry is not a valid Polygon or MultiPolygon");
                    var i = Nu.round(e[0][0], e[0][1]);
                    this.bbox = {
                        ll: {
                            x: i.x,
                            y: i.y
                        },
                        ur: {
                            x: i.x,
                            y: i.y
                        }
                    };
                    for (var o = i, s = 1, a = e.length; s < a; s++) {
                        if ("number" != typeof e[s][0] || "number" != typeof e[s][1])
                            throw new Error("Input geometry is not a valid Polygon or MultiPolygon");
                        var u = Nu.round(e[s][0], e[s][1]);
                        u.x === o.x && u.y === o.y || (this.segments.push(zu.fromRing(o, u, this)), u.x < this.bbox.ll.x && (this.bbox.ll.x = u.x), u.y < this.bbox.ll.y && (this.bbox.ll.y = u.y), u.x > this.bbox.ur.x && (this.bbox.ur.x = u.x), u.y > this.bbox.ur.y && (this.bbox.ur.y = u.y), o = u)
                    }
                    i.x === o.x && i.y === o.y || this.segments.push(zu.fromRing(o, i, this))
                }
                return Cu(t, [{
                    key: "getSweepEvents",
                    value: function() {
                        for (var t = [], e = 0, n = this.segments.length; e < n; e++) {
                            var r = this.segments[e];
                            t.push(r.leftSE),
                            t.push(r.rightSE)
                        }
                        return t
                    }
                }]), t
            }(),
            Vu = function() {
                function t(e, n) {
                    if (wu(this, t), !Array.isArray(e))
                        throw new Error("Input geometry is not a valid Polygon or MultiPolygon");
                    this.exteriorRing = new Uu(e[0], this, !0),
                    this.bbox = {
                        ll: {
                            x: this.exteriorRing.bbox.ll.x,
                            y: this.exteriorRing.bbox.ll.y
                        },
                        ur: {
                            x: this.exteriorRing.bbox.ur.x,
                            y: this.exteriorRing.bbox.ur.y
                        }
                    },
                    this.interiorRings = [];
                    for (var r = 1, i = e.length; r < i; r++) {
                        var o = new Uu(e[r], this, !1);
                        o.bbox.ll.x < this.bbox.ll.x && (this.bbox.ll.x = o.bbox.ll.x),
                        o.bbox.ll.y < this.bbox.ll.y && (this.bbox.ll.y = o.bbox.ll.y),
                        o.bbox.ur.x > this.bbox.ur.x && (this.bbox.ur.x = o.bbox.ur.x),
                        o.bbox.ur.y > this.bbox.ur.y && (this.bbox.ur.y = o.bbox.ur.y),
                        this.interiorRings.push(o)
                    }
                    this.multiPoly = n
                }
                return Cu(t, [{
                    key: "getSweepEvents",
                    value: function() {
                        for (var t = this.exteriorRing.getSweepEvents(), e = 0, n = this.interiorRings.length; e < n; e++)
                            for (var r = this.interiorRings[e].getSweepEvents(), i = 0, o = r.length; i < o; i++)
                                t.push(r[i]);
                        return t
                    }
                }]), t
            }(),
            Xu = function() {
                function t(e, n) {
                    if (wu(this, t), !Array.isArray(e))
                        throw new Error("Input geometry is not a valid Polygon or MultiPolygon");
                    try {
                        "number" == typeof e[0][0][0] && (e = [e])
                    } catch (t) {}
                    this.polys = [],
                    this.bbox = {
                        ll: {
                            x: Number.POSITIVE_INFINITY,
                            y: Number.POSITIVE_INFINITY
                        },
                        ur: {
                            x: Number.NEGATIVE_INFINITY,
                            y: Number.NEGATIVE_INFINITY
                        }
                    };
                    for (var r = 0, i = e.length; r < i; r++) {
                        var o = new Vu(e[r], this);
                        o.bbox.ll.x < this.bbox.ll.x && (this.bbox.ll.x = o.bbox.ll.x),
                        o.bbox.ll.y < this.bbox.ll.y && (this.bbox.ll.y = o.bbox.ll.y),
                        o.bbox.ur.x > this.bbox.ur.x && (this.bbox.ur.x = o.bbox.ur.x),
                        o.bbox.ur.y > this.bbox.ur.y && (this.bbox.ur.y = o.bbox.ur.y),
                        this.polys.push(o)
                    }
                    this.isSubject = n
                }
                return Cu(t, [{
                    key: "getSweepEvents",
                    value: function() {
                        for (var t = [], e = 0, n = this.polys.length; e < n; e++)
                            for (var r = this.polys[e].getSweepEvents(), i = 0, o = r.length; i < o; i++)
                                t.push(r[i]);
                        return t
                    }
                }]), t
            }(),
            Hu = function() {
                function t(e) {
                    wu(this, t),
                    this.events = e;
                    for (var n = 0, r = e.length; n < r; n++)
                        e[n].segment.ringOut = this;
                    this.poly = null
                }
                return Cu(t, null, [{
                    key: "factory",
                    value: function(e) {
                        for (var n = [], r = 0, i = e.length; r < i; r++) {
                            var o = e[r];
                            if (o.isInResult() && !o.ringOut) {
                                for (var s = null, a = o.leftSE, u = o.rightSE, l = [a], h = a.point, c = []; s = a, a = u, l.push(a), a.point !== h;)
                                    for (;;) {
                                        var p = a.getAvailableLinkedEvents();
                                        if (0 === p.length) {
                                            var f = l[0].point,
                                                d = l[l.length - 1].point;
                                            throw new Error("Unable to complete output ring starting at [".concat(f.x, ",") + " ".concat(f.y, "]. Last matching segment found ends at") + " [".concat(d.x, ", ").concat(d.y, "]."))
                                        }
                                        if (1 === p.length) {
                                            u = p[0].otherSE;
                                            break
                                        }
                                        for (var g = null, y = 0, v = c.length; y < v; y++)
                                            if (c[y].point === a.point) {
                                                g = y;
                                                break
                                            }
                                        if (null === g) {
                                            c.push({
                                                index: l.length,
                                                point: a.point
                                            });
                                            var m = a.getLeftmostComparator(s);
                                            u = p.sort(m)[0].otherSE;
                                            break
                                        }
                                        var _ = c.splice(g)[0],
                                            x = l.splice(_.index);
                                        x.unshift(x[0].otherSE),
                                        n.push(new t(x.reverse()))
                                    }
                                n.push(new t(l))
                            }
                        }
                        return n
                    }
                }]), Cu(t, [{
                    key: "getGeom",
                    value: function() {
                        for (var t = this.events[0].point, e = [t], n = 1, r = this.events.length - 1; n < r; n++) {
                            var i = this.events[n].point,
                                o = this.events[n + 1].point;
                            0 !== Du(i, t, o) && (e.push(i), t = i)
                        }
                        if (1 === e.length)
                            return null;
                        var s = e[0],
                            a = e[1];
                        0 === Du(s, t, a) && e.shift(),
                        e.push(e[0]);
                        for (var u = this.isExteriorRing() ? 1 : -1, l = this.isExteriorRing() ? 0 : e.length - 1, h = this.isExteriorRing() ? e.length : -1, c = [], p = l; p != h; p += u)
                            c.push([e[p].x, e[p].y]);
                        return c
                    }
                }, {
                    key: "isExteriorRing",
                    value: function() {
                        if (void 0 === this._isExteriorRing) {
                            var t = this.enclosingRing();
                            this._isExteriorRing = !t || !t.isExteriorRing()
                        }
                        return this._isExteriorRing
                    }
                }, {
                    key: "enclosingRing",
                    value: function() {
                        return void 0 === this._enclosingRing && (this._enclosingRing = this._calcEnclosingRing()), this._enclosingRing
                    }
                }, {
                    key: "_calcEnclosingRing",
                    value: function() {
                        for (var t = this.events[0], e = 1, n = this.events.length; e < n; e++) {
                            var r = this.events[e];
                            Bu.compare(t, r) > 0 && (t = r)
                        }
                        for (var i = t.segment.prevInResult(), o = i ? i.prevInResult() : null;;) {
                            if (!i)
                                return null;
                            if (!o)
                                return i.ringOut;
                            if (o.ringOut !== i.ringOut)
                                return o.ringOut.enclosingRing() !== i.ringOut ? i.ringOut : i.ringOut.enclosingRing();
                            i = o.prevInResult(),
                            o = i ? i.prevInResult() : null
                        }
                    }
                }]), t
            }(),
            Yu = function() {
                function t(e) {
                    wu(this, t),
                    this.exteriorRing = e,
                    e.poly = this,
                    this.interiorRings = []
                }
                return Cu(t, [{
                    key: "addInterior",
                    value: function(t) {
                        this.interiorRings.push(t),
                        t.poly = this
                    }
                }, {
                    key: "getGeom",
                    value: function() {
                        var t = [this.exteriorRing.getGeom()];
                        if (null === t[0])
                            return null;
                        for (var e = 0, n = this.interiorRings.length; e < n; e++) {
                            var r = this.interiorRings[e].getGeom();
                            null !== r && t.push(r)
                        }
                        return t
                    }
                }]), t
            }(),
            Wu = function() {
                function t(e) {
                    wu(this, t),
                    this.rings = e,
                    this.polys = this._composePolys(e)
                }
                return Cu(t, [{
                    key: "getGeom",
                    value: function() {
                        for (var t = [], e = 0, n = this.polys.length; e < n; e++) {
                            var r = this.polys[e].getGeom();
                            null !== r && t.push(r)
                        }
                        return t
                    }
                }, {
                    key: "_composePolys",
                    value: function(t) {
                        for (var e = [], n = 0, r = t.length; n < r; n++) {
                            var i = t[n];
                            if (!i.poly)
                                if (i.isExteriorRing())
                                    e.push(new Yu(i));
                                else {
                                    var o = i.enclosingRing();
                                    o.poly || e.push(new Yu(o)),
                                    o.poly.addInterior(i)
                                }
                        }
                        return e
                    }
                }]), t
            }(),
            $u = function() {
                function t(e) {
                    var n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : zu.compare;
                    wu(this, t),
                    this.queue = e,
                    this.tree = new mu(n),
                    this.segments = []
                }
                return Cu(t, [{
                    key: "process",
                    value: function(t) {
                        var e = t.segment,
                            n = [];
                        if (t.consumedBy)
                            return t.isLeft ? this.queue.remove(t.otherSE) : this.tree.remove(e), n;
                        var r = t.isLeft ? this.tree.insert(e) : this.tree.find(e);
                        if (!r)
                            throw new Error("Unable to find segment #".concat(e.id, " ") + "[".concat(e.leftSE.point.x, ", ").concat(e.leftSE.point.y, "] -> ") + "[".concat(e.rightSE.point.x, ", ").concat(e.rightSE.point.y, "] ") + "in SweepLine tree. Please submit a bug report.");
                        for (var i = r, o = r, s = void 0, a = void 0; void 0 === s;)
                            null === (i = this.tree.prev(i)) ? s = null : void 0 === i.key.consumedBy && (s = i.key);
                        for (; void 0 === a;)
                            null === (o = this.tree.next(o)) ? a = null : void 0 === o.key.consumedBy && (a = o.key);
                        if (t.isLeft) {
                            var u = null;
                            if (s) {
                                var l = s.getIntersection(e);
                                if (null !== l && (e.isAnEndpoint(l) || (u = l), !s.isAnEndpoint(l)))
                                    for (var h = this._splitSafely(s, l), c = 0, p = h.length; c < p; c++)
                                        n.push(h[c])
                            }
                            var f = null;
                            if (a) {
                                var d = a.getIntersection(e);
                                if (null !== d && (e.isAnEndpoint(d) || (f = d), !a.isAnEndpoint(d)))
                                    for (var g = this._splitSafely(a, d), y = 0, v = g.length; y < v; y++)
                                        n.push(g[y])
                            }
                            if (null !== u || null !== f) {
                                var m = null;
                                m = null === u ? f : null === f || Bu.comparePoints(u, f) <= 0 ? u : f,
                                this.queue.remove(e.rightSE),
                                n.push(e.rightSE);
                                for (var _ = e.split(m), x = 0, E = _.length; x < E; x++)
                                    n.push(_[x])
                            }
                            n.length > 0 ? (this.tree.remove(e), n.push(t)) : (this.segments.push(e), e.prev = s)
                        } else {
                            if (s && a) {
                                var w = s.getIntersection(a);
                                if (null !== w) {
                                    if (!s.isAnEndpoint(w))
                                        for (var b = this._splitSafely(s, w), C = 0, M = b.length; C < M; C++)
                                            n.push(b[C]);
                                    if (!a.isAnEndpoint(w))
                                        for (var S = this._splitSafely(a, w), I = 0, T = S.length; I < T; I++)
                                            n.push(S[I])
                                }
                            }
                            this.tree.remove(e)
                        }
                        return n
                    }
                }, {
                    key: "_splitSafely",
                    value: function(t, e) {
                        this.tree.remove(t);
                        var n = t.rightSE;
                        this.queue.remove(n);
                        var r = t.split(e);
                        return r.push(n), void 0 === t.consumedBy && this.tree.insert(t), r
                    }
                }]), t
            }(),
            Ku = 1e6,
            Zu = 1e6,
            Ju = new (function() {
                function t() {
                    wu(this, t)
                }
                return Cu(t, [{
                    key: "run",
                    value: function(t, e, n) {
                        Ju.type = t,
                        Nu.reset();
                        for (var r = [new Xu(e, !0)], i = 0, o = n.length; i < o; i++)
                            r.push(new Xu(n[i], !1));
                        if (Ju.numMultiPolys = r.length, "difference" === Ju.type)
                            for (var s = r[0], a = 1; a < r.length;)
                                null !== Su(r[a].bbox, s.bbox) ? a++ : r.splice(a, 1);
                        if ("intersection" === Ju.type)
                            for (var u = 0, l = r.length; u < l; u++)
                                for (var h = r[u], c = u + 1, p = r.length; c < p; c++)
                                    if (null === Su(h.bbox, r[c].bbox))
                                        return [];
                        for (var f = new mu(Bu.compare), d = 0, g = r.length; d < g; d++)
                            for (var y = r[d].getSweepEvents(), v = 0, m = y.length; v < m; v++)
                                if (f.insert(y[v]), f.size > Ku)
                                    throw new Error("Infinite loop when putting segment endpoints in a priority queue (queue size too big). Please file a bug report.");
                        for (var _ = new $u(f), x = f.size, E = f.pop(); E;) {
                            var w = E.key;
                            if (f.size === x) {
                                var b = w.segment;
                                throw new Error("Unable to pop() ".concat(w.isLeft ? "left" : "right", " SweepEvent ") + "[".concat(w.point.x, ", ").concat(w.point.y, "] from segment #").concat(b.id, " ") + "[".concat(b.leftSE.point.x, ", ").concat(b.leftSE.point.y, "] -> ") + "[".concat(b.rightSE.point.x, ", ").concat(b.rightSE.point.y, "] from queue. ") + "Please file a bug report.")
                            }
                            if (f.size > Ku)
                                throw new Error("Infinite loop when passing sweep line over endpoints (queue size too big). Please file a bug report.");
                            if (_.segments.length > Zu)
                                throw new Error("Infinite loop when passing sweep line over endpoints (too many sweep line segments). Please file a bug report.");
                            for (var C = _.process(w), M = 0, S = C.length; M < S; M++) {
                                var I = C[M];
                                void 0 === I.consumedBy && f.insert(I)
                            }
                            x = f.size,
                            E = f.pop()
                        }
                        Nu.reset();
                        var T = Hu.factory(_.segments);
                        return new Wu(T).getGeom()
                    }
                }]), t
            }()),
            Qu = {
                union: function(t) {
                    for (var e = arguments.length, n = new Array(e > 1 ? e - 1 : 0), r = 1; r < e; r++)
                        n[r - 1] = arguments[r];
                    return Ju.run("union", t, n)
                },
                intersection: function(t) {
                    for (var e = arguments.length, n = new Array(e > 1 ? e - 1 : 0), r = 1; r < e; r++)
                        n[r - 1] = arguments[r];
                    return Ju.run("intersection", t, n)
                },
                xor: function(t) {
                    for (var e = arguments.length, n = new Array(e > 1 ? e - 1 : 0), r = 1; r < e; r++)
                        n[r - 1] = arguments[r];
                    return Ju.run("xor", t, n)
                },
                difference: function(t) {
                    for (var e = arguments.length, n = new Array(e > 1 ? e - 1 : 0), r = 1; r < e; r++)
                        n[r - 1] = arguments[r];
                    return Ju.run("difference", t, n)
                }
            };
        "fill" in Array.prototype || Object.defineProperty(Array.prototype, "fill", {
            configurable: !0,
            value: function(t) {
                if (null == this)
                    throw new TypeError(this + " is not an object");
                var e = Object(this),
                    n = Math.max(Math.min(e.length, 9007199254740991), 0) || 0,
                    r = 1 in arguments && parseInt(Number(arguments[1]), 10) || 0;
                r = r < 0 ? Math.max(n + r, 0) : Math.min(r, n);
                var i = 2 in arguments && void 0 !== arguments[2] ? parseInt(Number(arguments[2]), 10) || 0 : n;
                for (i = i < 0 ? Math.max(n + arguments[2], 0) : Math.min(i, n); r < i;)
                    e[r] = t,
                    ++r;
                return e
            },
            writable: !0
        }),
        Number.isFinite = Number.isFinite || function(t) {
            return "number" == typeof t && isFinite(t)
        },
        Number.isInteger = Number.isInteger || function(t) {
            return "number" == typeof t && isFinite(t) && Math.floor(t) === t
        },
        Number.parseFloat = Number.parseFloat || parseFloat,
        Number.isNaN = Number.isNaN || function(t) {
            return t != t
        },
        Math.trunc = Math.trunc || function(t) {
            return t < 0 ? Math.ceil(t) : Math.floor(t)
        };
        var tl = function() {};
        tl.prototype.interfaces_ = function() {
            return []
        },
        tl.prototype.getClass = function() {
            return tl
        },
        tl.prototype.equalsWithTolerance = function(t, e, n) {
            return Math.abs(t - e) <= n
        };
        var el = function(t) {
                function e(e) {
                    t.call(this, e),
                    this.name = "IllegalArgumentException",
                    this.message = e,
                    this.stack = (new t).stack
                }
                return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e
            }(Error),
            nl = function() {},
            rl = {
                MAX_VALUE: {
                    configurable: !0
                }
            };
        nl.isNaN = function(t) {
            return Number.isNaN(t)
        },
        nl.doubleToLongBits = function(t) {
            return t
        },
        nl.longBitsToDouble = function(t) {
            return t
        },
        nl.isInfinite = function(t) {
            return !Number.isFinite(t)
        },
        rl.MAX_VALUE.get = function() {
            return Number.MAX_VALUE
        },
        Object.defineProperties(nl, rl);
        var il = function() {},
            ol = function() {},
            sl = function() {};
        function al() {}
        var ul = function t() {
                if (this.x = null, this.y = null, this.z = null, 0 === arguments.length)
                    this.x = 0,
                    this.y = 0,
                    this.z = t.NULL_ORDINATE;
                else if (1 === arguments.length) {
                    var e = arguments[0];
                    this.x = e.x,
                    this.y = e.y,
                    this.z = e.z
                } else
                    2 === arguments.length ? (this.x = arguments[0], this.y = arguments[1], this.z = t.NULL_ORDINATE) : 3 === arguments.length && (this.x = arguments[0], this.y = arguments[1], this.z = arguments[2])
            },
            ll = {
                DimensionalComparator: {
                    configurable: !0
                },
                serialVersionUID: {
                    configurable: !0
                },
                NULL_ORDINATE: {
                    configurable: !0
                },
                X: {
                    configurable: !0
                },
                Y: {
                    configurable: !0
                },
                Z: {
                    configurable: !0
                }
            };
        ul.prototype.setOrdinate = function(t, e) {
            switch (t) {
            case ul.X:
                this.x = e;
                break;
            case ul.Y:
                this.y = e;
                break;
            case ul.Z:
                this.z = e;
                break;
            default:
                throw new el("Invalid ordinate index: " + t)
            }
        },
        ul.prototype.equals2D = function() {
            if (1 === arguments.length) {
                var t = arguments[0];
                return this.x === t.x && this.y === t.y
            }
            if (2 === arguments.length) {
                var e = arguments[0],
                    n = arguments[1];
                return !!tl.equalsWithTolerance(this.x, e.x, n) && !!tl.equalsWithTolerance(this.y, e.y, n)
            }
        },
        ul.prototype.getOrdinate = function(t) {
            switch (t) {
            case ul.X:
                return this.x;
            case ul.Y:
                return this.y;
            case ul.Z:
                return this.z
            }
            throw new el("Invalid ordinate index: " + t)
        },
        ul.prototype.equals3D = function(t) {
            return this.x === t.x && this.y === t.y && (this.z === t.z || nl.isNaN(this.z)) && nl.isNaN(t.z)
        },
        ul.prototype.equals = function(t) {
            return t instanceof ul && this.equals2D(t)
        },
        ul.prototype.equalInZ = function(t, e) {
            return tl.equalsWithTolerance(this.z, t.z, e)
        },
        ul.prototype.compareTo = function(t) {
            var e = t;
            return this.x < e.x ? -1 : this.x > e.x ? 1 : this.y < e.y ? -1 : this.y > e.y ? 1 : 0
        },
        ul.prototype.clone = function() {},
        ul.prototype.copy = function() {
            return new ul(this)
        },
        ul.prototype.toString = function() {
            return "(" + this.x + ", " + this.y + ", " + this.z + ")"
        },
        ul.prototype.distance3D = function(t) {
            var e = this.x - t.x,
                n = this.y - t.y,
                r = this.z - t.z;
            return Math.sqrt(e * e + n * n + r * r)
        },
        ul.prototype.distance = function(t) {
            var e = this.x - t.x,
                n = this.y - t.y;
            return Math.sqrt(e * e + n * n)
        },
        ul.prototype.hashCode = function() {
            var t = 17;
            return 37 * (t = 37 * t + ul.hashCode(this.x)) + ul.hashCode(this.y)
        },
        ul.prototype.setCoordinate = function(t) {
            this.x = t.x,
            this.y = t.y,
            this.z = t.z
        },
        ul.prototype.interfaces_ = function() {
            return [il, ol, al]
        },
        ul.prototype.getClass = function() {
            return ul
        },
        ul.hashCode = function() {
            if (1 === arguments.length) {
                var t = arguments[0],
                    e = nl.doubleToLongBits(t);
                return Math.trunc((e ^ e) >>> 32)
            }
        },
        ll.DimensionalComparator.get = function() {
            return hl
        },
        ll.serialVersionUID.get = function() {
            return 0x5cbf2c235c7e5800
        },
        ll.NULL_ORDINATE.get = function() {
            return nl.NaN
        },
        ll.X.get = function() {
            return 0
        },
        ll.Y.get = function() {
            return 1
        },
        ll.Z.get = function() {
            return 2
        },
        Object.defineProperties(ul, ll);
        var hl = function(t) {
            if (this._dimensionsToTest = 2, 0 === arguments.length)
                ;
            else if (1 === arguments.length) {
                var e = arguments[0];
                if (2 !== e && 3 !== e)
                    throw new el("only 2 or 3 dimensions may be specified");
                this._dimensionsToTest = e
            }
        };
        hl.prototype.compare = function(t, e) {
            var n = t,
                r = e,
                i = hl.compare(n.x, r.x);
            if (0 !== i)
                return i;
            var o = hl.compare(n.y, r.y);
            return 0 !== o ? o : this._dimensionsToTest <= 2 ? 0 : hl.compare(n.z, r.z)
        },
        hl.prototype.interfaces_ = function() {
            return [sl]
        },
        hl.prototype.getClass = function() {
            return hl
        },
        hl.compare = function(t, e) {
            return t < e ? -1 : t > e ? 1 : nl.isNaN(t) ? nl.isNaN(e) ? 0 : -1 : nl.isNaN(e) ? 1 : 0
        };
        var cl = function() {};
        cl.prototype.create = function() {},
        cl.prototype.interfaces_ = function() {
            return []
        },
        cl.prototype.getClass = function() {
            return cl
        };
        var pl = function() {},
            fl = {
                INTERIOR: {
                    configurable: !0
                },
                BOUNDARY: {
                    configurable: !0
                },
                EXTERIOR: {
                    configurable: !0
                },
                NONE: {
                    configurable: !0
                }
            };
        pl.prototype.interfaces_ = function() {
            return []
        },
        pl.prototype.getClass = function() {
            return pl
        },
        pl.toLocationSymbol = function(t) {
            switch (t) {
            case pl.EXTERIOR:
                return "e";
            case pl.BOUNDARY:
                return "b";
            case pl.INTERIOR:
                return "i";
            case pl.NONE:
                return "-"
            }
            throw new el("Unknown location value: " + t)
        },
        fl.INTERIOR.get = function() {
            return 0
        },
        fl.BOUNDARY.get = function() {
            return 1
        },
        fl.EXTERIOR.get = function() {
            return 2
        },
        fl.NONE.get = function() {
            return -1
        },
        Object.defineProperties(pl, fl);
        var dl = function(t, e) {
                return t.interfaces_ && t.interfaces_().indexOf(e) > -1
            },
            gl = function() {},
            yl = {
                LOG_10: {
                    configurable: !0
                }
            };
        gl.prototype.interfaces_ = function() {
            return []
        },
        gl.prototype.getClass = function() {
            return gl
        },
        gl.log10 = function(t) {
            var e = Math.log(t);
            return nl.isInfinite(e) || nl.isNaN(e) ? e : e / gl.LOG_10
        },
        gl.min = function(t, e, n, r) {
            var i = t;
            return e < i && (i = e), n < i && (i = n), r < i && (i = r), i
        },
        gl.clamp = function() {
            if ("number" == typeof arguments[2] && "number" == typeof arguments[0] && "number" == typeof arguments[1]) {
                var t = arguments[0],
                    e = arguments[1],
                    n = arguments[2];
                return t < e ? e : t > n ? n : t
            }
            if (Number.isInteger(arguments[2]) && Number.isInteger(arguments[0]) && Number.isInteger(arguments[1])) {
                var r = arguments[0],
                    i = arguments[1],
                    o = arguments[2];
                return r < i ? i : r > o ? o : r
            }
        },
        gl.wrap = function(t, e) {
            return t < 0 ? e - -t % e : t % e
        },
        gl.max = function() {
            if (3 === arguments.length) {
                var t = arguments[1],
                    e = arguments[2],
                    n = arguments[0];
                return t > n && (n = t), e > n && (n = e), n
            }
            if (4 === arguments.length) {
                var r = arguments[1],
                    i = arguments[2],
                    o = arguments[3],
                    s = arguments[0];
                return r > s && (s = r), i > s && (s = i), o > s && (s = o), s
            }
        },
        gl.average = function(t, e) {
            return (t + e) / 2
        },
        yl.LOG_10.get = function() {
            return Math.log(10)
        },
        Object.defineProperties(gl, yl);
        var vl = function(t) {
            this.str = t
        };
        vl.prototype.append = function(t) {
            this.str += t
        },
        vl.prototype.setCharAt = function(t, e) {
            this.str = this.str.substr(0, t) + e + this.str.substr(t + 1)
        },
        vl.prototype.toString = function(t) {
            return this.str
        };
        var ml = function(t) {
            this.value = t
        };
        ml.prototype.intValue = function() {
            return this.value
        },
        ml.prototype.compareTo = function(t) {
            return this.value < t ? -1 : this.value > t ? 1 : 0
        },
        ml.isNaN = function(t) {
            return Number.isNaN(t)
        };
        var _l = function() {};
        _l.isWhitespace = function(t) {
            return t <= 32 && t >= 0 || 127 === t
        },
        _l.toUpperCase = function(t) {
            return t.toUpperCase()
        };
        var xl = function t() {
                if (this._hi = 0, this._lo = 0, 0 === arguments.length)
                    this.init(0);
                else if (1 === arguments.length)
                    if ("number" == typeof arguments[0]) {
                        var e = arguments[0];
                        this.init(e)
                    } else if (arguments[0] instanceof t) {
                        var n = arguments[0];
                        this.init(n)
                    } else
                        "string" == typeof arguments[0] && t.call(this, t.parse(arguments[0]));
                else if (2 === arguments.length) {
                    var r = arguments[0],
                        i = arguments[1];
                    this.init(r, i)
                }
            },
            El = {
                PI: {
                    configurable: !0
                },
                TWO_PI: {
                    configurable: !0
                },
                PI_2: {
                    configurable: !0
                },
                E: {
                    configurable: !0
                },
                NaN: {
                    configurable: !0
                },
                EPS: {
                    configurable: !0
                },
                SPLIT: {
                    configurable: !0
                },
                MAX_PRINT_DIGITS: {
                    configurable: !0
                },
                TEN: {
                    configurable: !0
                },
                ONE: {
                    configurable: !0
                },
                SCI_NOT_EXPONENT_CHAR: {
                    configurable: !0
                },
                SCI_NOT_ZERO: {
                    configurable: !0
                }
            };
        xl.prototype.le = function(t) {
            return (this._hi < t._hi || this._hi === t._hi) && this._lo <= t._lo
        },
        xl.prototype.extractSignificantDigits = function(t, e) {
            var n = this.abs(),
                r = xl.magnitude(n._hi),
                i = xl.TEN.pow(r);
            (n = n.divide(i)).gt(xl.TEN) ? (n = n.divide(xl.TEN), r += 1) : n.lt(xl.ONE) && (n = n.multiply(xl.TEN), r -= 1);
            for (var o = r + 1, s = new vl, a = xl.MAX_PRINT_DIGITS - 1, u = 0; u <= a; u++) {
                t && u === o && s.append(".");
                var l = Math.trunc(n._hi);
                if (l < 0)
                    break;
                var h = !1,
                    c = 0;
                l > 9 ? (h = !0, c = "9") : c = "0" + l,
                s.append(c),
                n = n.subtract(xl.valueOf(l)).multiply(xl.TEN),
                h && n.selfAdd(xl.TEN);
                var p = !0,
                    f = xl.magnitude(n._hi);
                if (f < 0 && Math.abs(f) >= a - u && (p = !1), !p)
                    break
            }
            return e[0] = r, s.toString()
        },
        xl.prototype.sqr = function() {
            return this.multiply(this)
        },
        xl.prototype.doubleValue = function() {
            return this._hi + this._lo
        },
        xl.prototype.subtract = function() {
            if (arguments[0] instanceof xl) {
                var t = arguments[0];
                return this.add(t.negate())
            }
            if ("number" == typeof arguments[0]) {
                var e = arguments[0];
                return this.add(-e)
            }
        },
        xl.prototype.equals = function() {
            if (1 === arguments.length) {
                var t = arguments[0];
                return this._hi === t._hi && this._lo === t._lo
            }
        },
        xl.prototype.isZero = function() {
            return 0 === this._hi && 0 === this._lo
        },
        xl.prototype.selfSubtract = function() {
            if (arguments[0] instanceof xl) {
                var t = arguments[0];
                return this.isNaN() ? this : this.selfAdd(-t._hi, -t._lo)
            }
            if ("number" == typeof arguments[0]) {
                var e = arguments[0];
                return this.isNaN() ? this : this.selfAdd(-e, 0)
            }
        },
        xl.prototype.getSpecialNumberString = function() {
            return this.isZero() ? "0.0" : this.isNaN() ? "NaN " : null
        },
        xl.prototype.min = function(t) {
            return this.le(t) ? this : t
        },
        xl.prototype.selfDivide = function() {
            if (1 === arguments.length) {
                if (arguments[0] instanceof xl) {
                    var t = arguments[0];
                    return this.selfDivide(t._hi, t._lo)
                }
                if ("number" == typeof arguments[0]) {
                    var e = arguments[0];
                    return this.selfDivide(e, 0)
                }
            } else if (2 === arguments.length) {
                var n = arguments[0],
                    r = arguments[1],
                    i = null,
                    o = null,
                    s = null,
                    a = null,
                    u = null,
                    l = null,
                    h = null,
                    c = null;
                return u = this._hi / n, c = (i = (l = xl.SPLIT * u) - (i = l - u)) * (s = (c = xl.SPLIT * n) - (s = c - n)) - (h = u * n) + i * (a = n - s) + (o = u - i) * s + o * a, c = u + (l = (this._hi - h - c + this._lo - u * r) / n), this._hi = c, this._lo = u - c + l, this
            }
        },
        xl.prototype.dump = function() {
            return "DD<" + this._hi + ", " + this._lo + ">"
        },
        xl.prototype.divide = function() {
            if (arguments[0] instanceof xl) {
                var t = arguments[0],
                    e = null,
                    n = null,
                    r = null,
                    i = null,
                    o = null,
                    s = null,
                    a = null,
                    u = null;
                n = (o = this._hi / t._hi) - (e = (s = xl.SPLIT * o) - (e = s - o)),
                u = e * (r = (u = xl.SPLIT * t._hi) - (r = u - t._hi)) - (a = o * t._hi) + e * (i = t._hi - r) + n * r + n * i;
                var l = u = o + (s = (this._hi - a - u + this._lo - o * t._lo) / t._hi);
                return new xl(l, o - u + s)
            }
            if ("number" == typeof arguments[0]) {
                var h = arguments[0];
                return nl.isNaN(h) ? xl.createNaN() : xl.copy(this).selfDivide(h, 0)
            }
        },
        xl.prototype.ge = function(t) {
            return (this._hi > t._hi || this._hi === t._hi) && this._lo >= t._lo
        },
        xl.prototype.pow = function(t) {
            if (0 === t)
                return xl.valueOf(1);
            var e = new xl(this),
                n = xl.valueOf(1),
                r = Math.abs(t);
            if (r > 1)
                for (; r > 0;)
                    r % 2 == 1 && n.selfMultiply(e),
                    (r /= 2) > 0 && (e = e.sqr());
            else
                n = e;
            return t < 0 ? n.reciprocal() : n
        },
        xl.prototype.ceil = function() {
            if (this.isNaN())
                return xl.NaN;
            var t = Math.ceil(this._hi),
                e = 0;
            return t === this._hi && (e = Math.ceil(this._lo)), new xl(t, e)
        },
        xl.prototype.compareTo = function(t) {
            var e = t;
            return this._hi < e._hi ? -1 : this._hi > e._hi ? 1 : this._lo < e._lo ? -1 : this._lo > e._lo ? 1 : 0
        },
        xl.prototype.rint = function() {
            return this.isNaN() ? this : this.add(.5).floor()
        },
        xl.prototype.setValue = function() {
            if (arguments[0] instanceof xl) {
                var t = arguments[0];
                return this.init(t), this
            }
            if ("number" == typeof arguments[0]) {
                var e = arguments[0];
                return this.init(e), this
            }
        },
        xl.prototype.max = function(t) {
            return this.ge(t) ? this : t
        },
        xl.prototype.sqrt = function() {
            if (this.isZero())
                return xl.valueOf(0);
            if (this.isNegative())
                return xl.NaN;
            var t = 1 / Math.sqrt(this._hi),
                e = this._hi * t,
                n = xl.valueOf(e),
                r = this.subtract(n.sqr())._hi * (.5 * t);
            return n.add(r)
        },
        xl.prototype.selfAdd = function() {
            if (1 === arguments.length) {
                if (arguments[0] instanceof xl) {
                    var t = arguments[0];
                    return this.selfAdd(t._hi, t._lo)
                }
                if ("number" == typeof arguments[0]) {
                    var e = arguments[0],
                        n = null,
                        r = null,
                        i = null,
                        o = null,
                        s = null,
                        a = null;
                    return o = (i = this._hi + e) - (s = i - this._hi), r = (a = (o = e - s + (this._hi - o)) + this._lo) + (i - (n = i + a)), this._hi = n + r, this._lo = r + (n - this._hi), this
                }
            } else if (2 === arguments.length) {
                var u = arguments[0],
                    l = arguments[1],
                    h = null,
                    c = null,
                    p = null,
                    f = null,
                    d = null,
                    g = null,
                    y = null;
                f = this._hi + u,
                c = this._lo + l,
                d = f - (g = f - this._hi),
                p = c - (y = c - this._lo);
                var v = (h = f + (g = (d = u - g + (this._hi - d)) + c)) + (g = (p = l - y + (this._lo - p)) + (g + (f - h))),
                    m = g + (h - v);
                return this._hi = v, this._lo = m, this
            }
        },
        xl.prototype.selfMultiply = function() {
            if (1 === arguments.length) {
                if (arguments[0] instanceof xl) {
                    var t = arguments[0];
                    return this.selfMultiply(t._hi, t._lo)
                }
                if ("number" == typeof arguments[0]) {
                    var e = arguments[0];
                    return this.selfMultiply(e, 0)
                }
            } else if (2 === arguments.length) {
                var n = arguments[0],
                    r = arguments[1],
                    i = null,
                    o = null,
                    s = null,
                    a = null,
                    u = null,
                    l = null;
                i = (u = xl.SPLIT * this._hi) - this._hi,
                l = xl.SPLIT * n,
                i = u - i,
                o = this._hi - i,
                s = l - n;
                var h = (u = this._hi * n) + (l = i * (s = l - s) - u + i * (a = n - s) + o * s + o * a + (this._hi * r + this._lo * n)),
                    c = l + (i = u - h);
                return this._hi = h, this._lo = c, this
            }
        },
        xl.prototype.selfSqr = function() {
            return this.selfMultiply(this)
        },
        xl.prototype.floor = function() {
            if (this.isNaN())
                return xl.NaN;
            var t = Math.floor(this._hi),
                e = 0;
            return t === this._hi && (e = Math.floor(this._lo)), new xl(t, e)
        },
        xl.prototype.negate = function() {
            return this.isNaN() ? this : new xl(-this._hi, -this._lo)
        },
        xl.prototype.clone = function() {},
        xl.prototype.multiply = function() {
            if (arguments[0] instanceof xl) {
                var t = arguments[0];
                return t.isNaN() ? xl.createNaN() : xl.copy(this).selfMultiply(t)
            }
            if ("number" == typeof arguments[0]) {
                var e = arguments[0];
                return nl.isNaN(e) ? xl.createNaN() : xl.copy(this).selfMultiply(e, 0)
            }
        },
        xl.prototype.isNaN = function() {
            return nl.isNaN(this._hi)
        },
        xl.prototype.intValue = function() {
            return Math.trunc(this._hi)
        },
        xl.prototype.toString = function() {
            var t = xl.magnitude(this._hi);
            return t >= -3 && t <= 20 ? this.toStandardNotation() : this.toSciNotation()
        },
        xl.prototype.toStandardNotation = function() {
            var t = this.getSpecialNumberString();
            if (null !== t)
                return t;
            var e = new Array(1).fill(null),
                n = this.extractSignificantDigits(!0, e),
                r = e[0] + 1,
                i = n;
            if ("." === n.charAt(0))
                i = "0" + n;
            else if (r < 0)
                i = "0." + xl.stringOfChar("0", -r) + n;
            else if (-1 === n.indexOf(".")) {
                var o = r - n.length;
                i = n + xl.stringOfChar("0", o) + ".0"
            }
            return this.isNegative() ? "-" + i : i
        },
        xl.prototype.reciprocal = function() {
            var t,
                e,
                n,
                r,
                i = null,
                o = null,
                s = null,
                a = null;
            t = (n = 1 / this._hi) - (i = (s = xl.SPLIT * n) - (i = s - n)),
            o = (a = xl.SPLIT * this._hi) - this._hi;
            var u = n + (s = (1 - (r = n * this._hi) - (a = i * (o = a - o) - r + i * (e = this._hi - o) + t * o + t * e) - n * this._lo) / this._hi);
            return new xl(u, n - u + s)
        },
        xl.prototype.toSciNotation = function() {
            if (this.isZero())
                return xl.SCI_NOT_ZERO;
            var t = this.getSpecialNumberString();
            if (null !== t)
                return t;
            var e = new Array(1).fill(null),
                n = this.extractSignificantDigits(!1, e),
                r = xl.SCI_NOT_EXPONENT_CHAR + e[0];
            if ("0" === n.charAt(0))
                throw new Error("Found leading zero: " + n);
            var i = "";
            n.length > 1 && (i = n.substring(1));
            var o = n.charAt(0) + "." + i;
            return this.isNegative() ? "-" + o + r : o + r
        },
        xl.prototype.abs = function() {
            return this.isNaN() ? xl.NaN : this.isNegative() ? this.negate() : new xl(this)
        },
        xl.prototype.isPositive = function() {
            return (this._hi > 0 || 0 === this._hi) && this._lo > 0
        },
        xl.prototype.lt = function(t) {
            return (this._hi < t._hi || this._hi === t._hi) && this._lo < t._lo
        },
        xl.prototype.add = function() {
            if (arguments[0] instanceof xl) {
                var t = arguments[0];
                return xl.copy(this).selfAdd(t)
            }
            if ("number" == typeof arguments[0]) {
                var e = arguments[0];
                return xl.copy(this).selfAdd(e)
            }
        },
        xl.prototype.init = function() {
            if (1 === arguments.length) {
                if ("number" == typeof arguments[0]) {
                    var t = arguments[0];
                    this._hi = t,
                    this._lo = 0
                } else if (arguments[0] instanceof xl) {
                    var e = arguments[0];
                    this._hi = e._hi,
                    this._lo = e._lo
                }
            } else if (2 === arguments.length) {
                var n = arguments[0],
                    r = arguments[1];
                this._hi = n,
                this._lo = r
            }
        },
        xl.prototype.gt = function(t) {
            return (this._hi > t._hi || this._hi === t._hi) && this._lo > t._lo
        },
        xl.prototype.isNegative = function() {
            return (this._hi < 0 || 0 === this._hi) && this._lo < 0
        },
        xl.prototype.trunc = function() {
            return this.isNaN() ? xl.NaN : this.isPositive() ? this.floor() : this.ceil()
        },
        xl.prototype.signum = function() {
            return this._hi > 0 ? 1 : this._hi < 0 ? -1 : this._lo > 0 ? 1 : this._lo < 0 ? -1 : 0
        },
        xl.prototype.interfaces_ = function() {
            return [al, il, ol]
        },
        xl.prototype.getClass = function() {
            return xl
        },
        xl.sqr = function(t) {
            return xl.valueOf(t).selfMultiply(t)
        },
        xl.valueOf = function() {
            if ("string" == typeof arguments[0]) {
                var t = arguments[0];
                return xl.parse(t)
            }
            if ("number" == typeof arguments[0])
                return new xl(arguments[0])
        },
        xl.sqrt = function(t) {
            return xl.valueOf(t).sqrt()
        },
        xl.parse = function(t) {
            for (var e = 0, n = t.length; _l.isWhitespace(t.charAt(e));)
                e++;
            var r = !1;
            if (e < n) {
                var i = t.charAt(e);
                "-" !== i && "+" !== i || (e++, "-" === i && (r = !0))
            }
            for (var o = new xl, s = 0, a = 0, u = 0; !(e >= n);) {
                var l = t.charAt(e);
                if (e++, _l.isDigit(l)) {
                    var h = l - "0";
                    o.selfMultiply(xl.TEN),
                    o.selfAdd(h),
                    s++
                } else {
                    if ("." !== l) {
                        if ("e" === l || "E" === l) {
                            var c = t.substring(e);
                            try {
                                u = ml.parseInt(c)
                            } catch (e) {
                                throw e instanceof Error ? new Error("Invalid exponent " + c + " in string " + t) : e
                            }
                            break
                        }
                        throw new Error("Unexpected character '" + l + "' at position " + e + " in string " + t)
                    }
                    a = s
                }
            }
            var p = o,
                f = s - a - u;
            if (0 === f)
                p = o;
            else if (f > 0) {
                var d = xl.TEN.pow(f);
                p = o.divide(d)
            } else if (f < 0) {
                var g = xl.TEN.pow(-f);
                p = o.multiply(g)
            }
            return r ? p.negate() : p
        },
        xl.createNaN = function() {
            return new xl(nl.NaN, nl.NaN)
        },
        xl.copy = function(t) {
            return new xl(t)
        },
        xl.magnitude = function(t) {
            var e = Math.abs(t),
                n = Math.log(e) / Math.log(10),
                r = Math.trunc(Math.floor(n));
            return 10 * Math.pow(10, r) <= e && (r += 1), r
        },
        xl.stringOfChar = function(t, e) {
            for (var n = new vl, r = 0; r < e; r++)
                n.append(t);
            return n.toString()
        },
        El.PI.get = function() {
            return new xl(3.141592653589793, 12246467991473532e-32)
        },
        El.TWO_PI.get = function() {
            return new xl(6.283185307179586, 24492935982947064e-32)
        },
        El.PI_2.get = function() {
            return new xl(1.5707963267948966, 6123233995736766e-32)
        },
        El.E.get = function() {
            return new xl(2.718281828459045, 14456468917292502e-32)
        },
        El.NaN.get = function() {
            return new xl(nl.NaN, nl.NaN)
        },
        El.EPS.get = function() {
            return 123259516440783e-46
        },
        El.SPLIT.get = function() {
            return 134217729
        },
        El.MAX_PRINT_DIGITS.get = function() {
            return 32
        },
        El.TEN.get = function() {
            return xl.valueOf(10)
        },
        El.ONE.get = function() {
            return xl.valueOf(1)
        },
        El.SCI_NOT_EXPONENT_CHAR.get = function() {
            return "E"
        },
        El.SCI_NOT_ZERO.get = function() {
            return "0.0E0"
        },
        Object.defineProperties(xl, El);
        var wl = function() {},
            bl = {
                DP_SAFE_EPSILON: {
                    configurable: !0
                }
            };
        wl.prototype.interfaces_ = function() {
            return []
        },
        wl.prototype.getClass = function() {
            return wl
        },
        wl.orientationIndex = function(t, e, n) {
            var r = wl.orientationIndexFilter(t, e, n);
            if (r <= 1)
                return r;
            var i = xl.valueOf(e.x).selfAdd(-t.x),
                o = xl.valueOf(e.y).selfAdd(-t.y),
                s = xl.valueOf(n.x).selfAdd(-e.x),
                a = xl.valueOf(n.y).selfAdd(-e.y);
            return i.selfMultiply(a).selfSubtract(o.selfMultiply(s)).signum()
        },
        wl.signOfDet2x2 = function(t, e, n, r) {
            return t.multiply(r).selfSubtract(e.multiply(n)).signum()
        },
        wl.intersection = function(t, e, n, r) {
            var i = xl.valueOf(r.y).selfSubtract(n.y).selfMultiply(xl.valueOf(e.x).selfSubtract(t.x)),
                o = xl.valueOf(r.x).selfSubtract(n.x).selfMultiply(xl.valueOf(e.y).selfSubtract(t.y)),
                s = i.subtract(o),
                a = xl.valueOf(r.x).selfSubtract(n.x).selfMultiply(xl.valueOf(t.y).selfSubtract(n.y)),
                u = xl.valueOf(r.y).selfSubtract(n.y).selfMultiply(xl.valueOf(t.x).selfSubtract(n.x)),
                l = a.subtract(u).selfDivide(s).doubleValue(),
                h = xl.valueOf(t.x).selfAdd(xl.valueOf(e.x).selfSubtract(t.x).selfMultiply(l)).doubleValue(),
                c = xl.valueOf(e.x).selfSubtract(t.x).selfMultiply(xl.valueOf(t.y).selfSubtract(n.y)),
                p = xl.valueOf(e.y).selfSubtract(t.y).selfMultiply(xl.valueOf(t.x).selfSubtract(n.x)),
                f = c.subtract(p).selfDivide(s).doubleValue(),
                d = xl.valueOf(n.y).selfAdd(xl.valueOf(r.y).selfSubtract(n.y).selfMultiply(f)).doubleValue();
            return new ul(h, d)
        },
        wl.orientationIndexFilter = function(t, e, n) {
            var r = null,
                i = (t.x - n.x) * (e.y - n.y),
                o = (t.y - n.y) * (e.x - n.x),
                s = i - o;
            if (i > 0) {
                if (o <= 0)
                    return wl.signum(s);
                r = i + o
            } else {
                if (!(i < 0))
                    return wl.signum(s);
                if (o >= 0)
                    return wl.signum(s);
                r = -i - o
            }
            var a = wl.DP_SAFE_EPSILON * r;
            return s >= a || -s >= a ? wl.signum(s) : 2
        },
        wl.signum = function(t) {
            return t > 0 ? 1 : t < 0 ? -1 : 0
        },
        bl.DP_SAFE_EPSILON.get = function() {
            return 1e-15
        },
        Object.defineProperties(wl, bl);
        var Cl = function() {},
            Ml = {
                X: {
                    configurable: !0
                },
                Y: {
                    configurable: !0
                },
                Z: {
                    configurable: !0
                },
                M: {
                    configurable: !0
                }
            };
        Ml.X.get = function() {
            return 0
        },
        Ml.Y.get = function() {
            return 1
        },
        Ml.Z.get = function() {
            return 2
        },
        Ml.M.get = function() {
            return 3
        },
        Cl.prototype.setOrdinate = function(t, e, n) {},
        Cl.prototype.size = function() {},
        Cl.prototype.getOrdinate = function(t, e) {},
        Cl.prototype.getCoordinate = function() {},
        Cl.prototype.getCoordinateCopy = function(t) {},
        Cl.prototype.getDimension = function() {},
        Cl.prototype.getX = function(t) {},
        Cl.prototype.clone = function() {},
        Cl.prototype.expandEnvelope = function(t) {},
        Cl.prototype.copy = function() {},
        Cl.prototype.getY = function(t) {},
        Cl.prototype.toCoordinateArray = function() {},
        Cl.prototype.interfaces_ = function() {
            return [ol]
        },
        Cl.prototype.getClass = function() {
            return Cl
        },
        Object.defineProperties(Cl, Ml);
        var Sl = function() {},
            Il = function(t) {
                function e() {
                    t.call(this, "Projective point not representable on the Cartesian plane.")
                }
                return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.interfaces_ = function() {
                    return []
                }, e.prototype.getClass = function() {
                    return e
                }, e
            }(Sl),
            Tl = function() {};
        Tl.arraycopy = function(t, e, n, r, i) {
            for (var o = 0, s = e; s < e + i; s++)
                n[r + o] = t[s],
                o++
        },
        Tl.getProperty = function(t) {
            return {
                "line.separator": "\n"
            }[t]
        };
        var Pl = function t() {
            if (this.x = null, this.y = null, this.w = null, 0 === arguments.length)
                this.x = 0,
                this.y = 0,
                this.w = 1;
            else if (1 === arguments.length) {
                var e = arguments[0];
                this.x = e.x,
                this.y = e.y,
                this.w = 1
            } else if (2 === arguments.length) {
                if ("number" == typeof arguments[0] && "number" == typeof arguments[1]) {
                    var n = arguments[0],
                        r = arguments[1];
                    this.x = n,
                    this.y = r,
                    this.w = 1
                } else if (arguments[0] instanceof t && arguments[1] instanceof t) {
                    var i = arguments[0],
                        o = arguments[1];
                    this.x = i.y * o.w - o.y * i.w,
                    this.y = o.x * i.w - i.x * o.w,
                    this.w = i.x * o.y - o.x * i.y
                } else if (arguments[0] instanceof ul && arguments[1] instanceof ul) {
                    var s = arguments[0],
                        a = arguments[1];
                    this.x = s.y - a.y,
                    this.y = a.x - s.x,
                    this.w = s.x * a.y - a.x * s.y
                }
            } else if (3 === arguments.length) {
                var u = arguments[0],
                    l = arguments[1],
                    h = arguments[2];
                this.x = u,
                this.y = l,
                this.w = h
            } else if (4 === arguments.length) {
                var c = arguments[0],
                    p = arguments[1],
                    f = arguments[2],
                    d = arguments[3],
                    g = c.y - p.y,
                    y = p.x - c.x,
                    v = c.x * p.y - p.x * c.y,
                    m = f.y - d.y,
                    _ = d.x - f.x,
                    x = f.x * d.y - d.x * f.y;
                this.x = y * x - _ * v,
                this.y = m * v - g * x,
                this.w = g * _ - m * y
            }
        };
        Pl.prototype.getY = function() {
            var t = this.y / this.w;
            if (nl.isNaN(t) || nl.isInfinite(t))
                throw new Il;
            return t
        },
        Pl.prototype.getX = function() {
            var t = this.x / this.w;
            if (nl.isNaN(t) || nl.isInfinite(t))
                throw new Il;
            return t
        },
        Pl.prototype.getCoordinate = function() {
            var t = new ul;
            return t.x = this.getX(), t.y = this.getY(), t
        },
        Pl.prototype.interfaces_ = function() {
            return []
        },
        Pl.prototype.getClass = function() {
            return Pl
        },
        Pl.intersection = function(t, e, n, r) {
            var i = t.y - e.y,
                o = e.x - t.x,
                s = t.x * e.y - e.x * t.y,
                a = n.y - r.y,
                u = r.x - n.x,
                l = n.x * r.y - r.x * n.y,
                h = i * u - a * o,
                c = (o * l - u * s) / h,
                p = (a * s - i * l) / h;
            if (nl.isNaN(c) || nl.isInfinite(c) || nl.isNaN(p) || nl.isInfinite(p))
                throw new Il;
            return new ul(c, p)
        };
        var Ll = function t() {
                if (this._minx = null, this._maxx = null, this._miny = null, this._maxy = null, 0 === arguments.length)
                    this.init();
                else if (1 === arguments.length) {
                    if (arguments[0] instanceof ul) {
                        var e = arguments[0];
                        this.init(e.x, e.x, e.y, e.y)
                    } else if (arguments[0] instanceof t) {
                        var n = arguments[0];
                        this.init(n)
                    }
                } else if (2 === arguments.length) {
                    var r = arguments[0],
                        i = arguments[1];
                    this.init(r.x, i.x, r.y, i.y)
                } else if (4 === arguments.length) {
                    var o = arguments[0],
                        s = arguments[1],
                        a = arguments[2],
                        u = arguments[3];
                    this.init(o, s, a, u)
                }
            },
            Ol = {
                serialVersionUID: {
                    configurable: !0
                }
            };
        Ll.prototype.getArea = function() {
            return this.getWidth() * this.getHeight()
        },
        Ll.prototype.equals = function(t) {
            if (!(t instanceof Ll))
                return !1;
            var e = t;
            return this.isNull() ? e.isNull() : this._maxx === e.getMaxX() && this._maxy === e.getMaxY() && this._minx === e.getMinX() && this._miny === e.getMinY()
        },
        Ll.prototype.intersection = function(t) {
            if (this.isNull() || t.isNull() || !this.intersects(t))
                return new Ll;
            var e = this._minx > t._minx ? this._minx : t._minx,
                n = this._miny > t._miny ? this._miny : t._miny,
                r = this._maxx < t._maxx ? this._maxx : t._maxx,
                i = this._maxy < t._maxy ? this._maxy : t._maxy;
            return new Ll(e, r, n, i)
        },
        Ll.prototype.isNull = function() {
            return this._maxx < this._minx
        },
        Ll.prototype.getMaxX = function() {
            return this._maxx
        },
        Ll.prototype.covers = function() {
            if (1 === arguments.length) {
                if (arguments[0] instanceof ul) {
                    var t = arguments[0];
                    return this.covers(t.x, t.y)
                }
                if (arguments[0] instanceof Ll) {
                    var e = arguments[0];
                    return !this.isNull() && !e.isNull() && e.getMinX() >= this._minx && e.getMaxX() <= this._maxx && e.getMinY() >= this._miny && e.getMaxY() <= this._maxy
                }
            } else if (2 === arguments.length) {
                var n = arguments[0],
                    r = arguments[1];
                return !this.isNull() && n >= this._minx && n <= this._maxx && r >= this._miny && r <= this._maxy
            }
        },
        Ll.prototype.intersects = function() {
            if (1 === arguments.length) {
                if (arguments[0] instanceof Ll) {
                    var t = arguments[0];
                    return !this.isNull() && !t.isNull() && !(t._minx > this._maxx || t._maxx < this._minx || t._miny > this._maxy || t._maxy < this._miny)
                }
                if (arguments[0] instanceof ul) {
                    var e = arguments[0];
                    return this.intersects(e.x, e.y)
                }
            } else if (2 === arguments.length) {
                var n = arguments[0],
                    r = arguments[1];
                return !this.isNull() && !(n > this._maxx || n < this._minx || r > this._maxy || r < this._miny)
            }
        },
        Ll.prototype.getMinY = function() {
            return this._miny
        },
        Ll.prototype.getMinX = function() {
            return this._minx
        },
        Ll.prototype.expandToInclude = function() {
            if (1 === arguments.length) {
                if (arguments[0] instanceof ul) {
                    var t = arguments[0];
                    this.expandToInclude(t.x, t.y)
                } else if (arguments[0] instanceof Ll) {
                    var e = arguments[0];
                    if (e.isNull())
                        return null;
                    this.isNull() ? (this._minx = e.getMinX(), this._maxx = e.getMaxX(), this._miny = e.getMinY(), this._maxy = e.getMaxY()) : (e._minx < this._minx && (this._minx = e._minx), e._maxx > this._maxx && (this._maxx = e._maxx), e._miny < this._miny && (this._miny = e._miny), e._maxy > this._maxy && (this._maxy = e._maxy))
                }
            } else if (2 === arguments.length) {
                var n = arguments[0],
                    r = arguments[1];
                this.isNull() ? (this._minx = n, this._maxx = n, this._miny = r, this._maxy = r) : (n < this._minx && (this._minx = n), n > this._maxx && (this._maxx = n), r < this._miny && (this._miny = r), r > this._maxy && (this._maxy = r))
            }
        },
        Ll.prototype.minExtent = function() {
            if (this.isNull())
                return 0;
            var t = this.getWidth(),
                e = this.getHeight();
            return t < e ? t : e
        },
        Ll.prototype.getWidth = function() {
            return this.isNull() ? 0 : this._maxx - this._minx
        },
        Ll.prototype.compareTo = function(t) {
            var e = t;
            return this.isNull() ? e.isNull() ? 0 : -1 : e.isNull() ? 1 : this._minx < e._minx ? -1 : this._minx > e._minx ? 1 : this._miny < e._miny ? -1 : this._miny > e._miny ? 1 : this._maxx < e._maxx ? -1 : this._maxx > e._maxx ? 1 : this._maxy < e._maxy ? -1 : this._maxy > e._maxy ? 1 : 0
        },
        Ll.prototype.translate = function(t, e) {
            if (this.isNull())
                return null;
            this.init(this.getMinX() + t, this.getMaxX() + t, this.getMinY() + e, this.getMaxY() + e)
        },
        Ll.prototype.toString = function() {
            return "Env[" + this._minx + " : " + this._maxx + ", " + this._miny + " : " + this._maxy + "]"
        },
        Ll.prototype.setToNull = function() {
            this._minx = 0,
            this._maxx = -1,
            this._miny = 0,
            this._maxy = -1
        },
        Ll.prototype.getHeight = function() {
            return this.isNull() ? 0 : this._maxy - this._miny
        },
        Ll.prototype.maxExtent = function() {
            if (this.isNull())
                return 0;
            var t = this.getWidth(),
                e = this.getHeight();
            return t > e ? t : e
        },
        Ll.prototype.expandBy = function() {
            if (1 === arguments.length) {
                var t = arguments[0];
                this.expandBy(t, t)
            } else if (2 === arguments.length) {
                var e = arguments[0],
                    n = arguments[1];
                if (this.isNull())
                    return null;
                this._minx -= e,
                this._maxx += e,
                this._miny -= n,
                this._maxy += n,
                (this._minx > this._maxx || this._miny > this._maxy) && this.setToNull()
            }
        },
        Ll.prototype.contains = function() {
            if (1 === arguments.length) {
                if (arguments[0] instanceof Ll) {
                    var t = arguments[0];
                    return this.covers(t)
                }
                if (arguments[0] instanceof ul) {
                    var e = arguments[0];
                    return this.covers(e)
                }
            } else if (2 === arguments.length) {
                var n = arguments[0],
                    r = arguments[1];
                return this.covers(n, r)
            }
        },
        Ll.prototype.centre = function() {
            return this.isNull() ? null : new ul((this.getMinX() + this.getMaxX()) / 2, (this.getMinY() + this.getMaxY()) / 2)
        },
        Ll.prototype.init = function() {
            if (0 === arguments.length)
                this.setToNull();
            else if (1 === arguments.length) {
                if (arguments[0] instanceof ul) {
                    var t = arguments[0];
                    this.init(t.x, t.x, t.y, t.y)
                } else if (arguments[0] instanceof Ll) {
                    var e = arguments[0];
                    this._minx = e._minx,
                    this._maxx = e._maxx,
                    this._miny = e._miny,
                    this._maxy = e._maxy
                }
            } else if (2 === arguments.length) {
                var n = arguments[0],
                    r = arguments[1];
                this.init(n.x, r.x, n.y, r.y)
            } else if (4 === arguments.length) {
                var i = arguments[0],
                    o = arguments[1],
                    s = arguments[2],
                    a = arguments[3];
                i < o ? (this._minx = i, this._maxx = o) : (this._minx = o, this._maxx = i),
                s < a ? (this._miny = s, this._maxy = a) : (this._miny = a, this._maxy = s)
            }
        },
        Ll.prototype.getMaxY = function() {
            return this._maxy
        },
        Ll.prototype.distance = function(t) {
            if (this.intersects(t))
                return 0;
            var e = 0;
            this._maxx < t._minx ? e = t._minx - this._maxx : this._minx > t._maxx && (e = this._minx - t._maxx);
            var n = 0;
            return this._maxy < t._miny ? n = t._miny - this._maxy : this._miny > t._maxy && (n = this._miny - t._maxy), 0 === e ? n : 0 === n ? e : Math.sqrt(e * e + n * n)
        },
        Ll.prototype.hashCode = function() {
            var t = 17;
            return 37 * (t = 37 * (t = 37 * (t = 37 * t + ul.hashCode(this._minx)) + ul.hashCode(this._maxx)) + ul.hashCode(this._miny)) + ul.hashCode(this._maxy)
        },
        Ll.prototype.interfaces_ = function() {
            return [il, al]
        },
        Ll.prototype.getClass = function() {
            return Ll
        },
        Ll.intersects = function() {
            if (3 === arguments.length) {
                var t = arguments[0],
                    e = arguments[1],
                    n = arguments[2];
                return n.x >= (t.x < e.x ? t.x : e.x) && n.x <= (t.x > e.x ? t.x : e.x) && n.y >= (t.y < e.y ? t.y : e.y) && n.y <= (t.y > e.y ? t.y : e.y)
            }
            if (4 === arguments.length) {
                var r = arguments[0],
                    i = arguments[1],
                    o = arguments[2],
                    s = arguments[3],
                    a = Math.min(o.x, s.x),
                    u = Math.max(o.x, s.x),
                    l = Math.min(r.x, i.x),
                    h = Math.max(r.x, i.x);
                return !(l > u || h < a || (a = Math.min(o.y, s.y), u = Math.max(o.y, s.y), l = Math.min(r.y, i.y), h = Math.max(r.y, i.y), l > u || h < a))
            }
        },
        Ol.serialVersionUID.get = function() {
            return 0x51845cd552189800
        },
        Object.defineProperties(Ll, Ol);
        var Nl = {
                typeStr: /^\s*(\w+)\s*\(\s*(.*)\s*\)\s*$/,
                emptyTypeStr: /^\s*(\w+)\s*EMPTY\s*$/,
                spaces: /\s+/,
                parenComma: /\)\s*,\s*\(/,
                doubleParenComma: /\)\s*\)\s*,\s*\(\s*\(/,
                trimParens: /^\s*\(?(.*?)\)?\s*$/
            },
            Rl = function(t) {
                this.geometryFactory = t || new mc
            };
        Rl.prototype.read = function(t) {
            var e,
                n,
                r;
            t = t.replace(/[\n\r]/g, " ");
            var i = Nl.typeStr.exec(t);
            if (-1 !== t.search("EMPTY") && ((i = Nl.emptyTypeStr.exec(t))[2] = void 0), i && (n = i[1].toLowerCase(), r = i[2], Dl[n] && (e = Dl[n].apply(this, [r]))), void 0 === e)
                throw new Error("Could not parse WKT " + t);
            return e
        },
        Rl.prototype.write = function(t) {
            return this.extractGeometry(t)
        },
        Rl.prototype.extractGeometry = function(t) {
            var e = t.getGeometryType().toLowerCase();
            if (!Al[e])
                return null;
            var n = e.toUpperCase();
            return t.isEmpty() ? n + " EMPTY" : n + "(" + Al[e].apply(this, [t]) + ")"
        };
        var Al = {
                coordinate: function(t) {
                    return t.x + " " + t.y
                },
                point: function(t) {
                    return Al.coordinate.call(this, t._coordinates._coordinates[0])
                },
                multipoint: function(t) {
                    for (var e = [], n = 0, r = t._geometries.length; n < r; ++n)
                        e.push("(" + Al.point.apply(this, [t._geometries[n]]) + ")");
                    return e.join(",")
                },
                linestring: function(t) {
                    for (var e = [], n = 0, r = t._points._coordinates.length; n < r; ++n)
                        e.push(Al.coordinate.apply(this, [t._points._coordinates[n]]));
                    return e.join(",")
                },
                linearring: function(t) {
                    for (var e = [], n = 0, r = t._points._coordinates.length; n < r; ++n)
                        e.push(Al.coordinate.apply(this, [t._points._coordinates[n]]));
                    return e.join(",")
                },
                multilinestring: function(t) {
                    for (var e = [], n = 0, r = t._geometries.length; n < r; ++n)
                        e.push("(" + Al.linestring.apply(this, [t._geometries[n]]) + ")");
                    return e.join(",")
                },
                polygon: function(t) {
                    var e = [];
                    e.push("(" + Al.linestring.apply(this, [t._shell]) + ")");
                    for (var n = 0, r = t._holes.length; n < r; ++n)
                        e.push("(" + Al.linestring.apply(this, [t._holes[n]]) + ")");
                    return e.join(",")
                },
                multipolygon: function(t) {
                    for (var e = [], n = 0, r = t._geometries.length; n < r; ++n)
                        e.push("(" + Al.polygon.apply(this, [t._geometries[n]]) + ")");
                    return e.join(",")
                },
                geometrycollection: function(t) {
                    for (var e = [], n = 0, r = t._geometries.length; n < r; ++n)
                        e.push(this.extractGeometry(t._geometries[n]));
                    return e.join(",")
                }
            },
            Dl = {
                point: function(t) {
                    if (void 0 === t)
                        return this.geometryFactory.createPoint();
                    var e = t.trim().split(Nl.spaces);
                    return this.geometryFactory.createPoint(new ul(Number.parseFloat(e[0]), Number.parseFloat(e[1])))
                },
                multipoint: function(t) {
                    var e;
                    if (void 0 === t)
                        return this.geometryFactory.createMultiPoint();
                    for (var n = t.trim().split(","), r = [], i = 0, o = n.length; i < o; ++i)
                        e = n[i].replace(Nl.trimParens, "$1"),
                        r.push(Dl.point.apply(this, [e]));
                    return this.geometryFactory.createMultiPoint(r)
                },
                linestring: function(t) {
                    if (void 0 === t)
                        return this.geometryFactory.createLineString();
                    for (var e, n = t.trim().split(","), r = [], i = 0, o = n.length; i < o; ++i)
                        e = n[i].trim().split(Nl.spaces),
                        r.push(new ul(Number.parseFloat(e[0]), Number.parseFloat(e[1])));
                    return this.geometryFactory.createLineString(r)
                },
                linearring: function(t) {
                    if (void 0 === t)
                        return this.geometryFactory.createLinearRing();
                    for (var e, n = t.trim().split(","), r = [], i = 0, o = n.length; i < o; ++i)
                        e = n[i].trim().split(Nl.spaces),
                        r.push(new ul(Number.parseFloat(e[0]), Number.parseFloat(e[1])));
                    return this.geometryFactory.createLinearRing(r)
                },
                multilinestring: function(t) {
                    var e;
                    if (void 0 === t)
                        return this.geometryFactory.createMultiLineString();
                    for (var n = t.trim().split(Nl.parenComma), r = [], i = 0, o = n.length; i < o; ++i)
                        e = n[i].replace(Nl.trimParens, "$1"),
                        r.push(Dl.linestring.apply(this, [e]));
                    return this.geometryFactory.createMultiLineString(r)
                },
                polygon: function(t) {
                    var e,
                        n,
                        r;
                    if (void 0 === t)
                        return this.geometryFactory.createPolygon();
                    for (var i, o = t.trim().split(Nl.parenComma), s = [], a = 0, u = o.length; a < u; ++a)
                        e = o[a].replace(Nl.trimParens, "$1"),
                        n = Dl.linestring.apply(this, [e]),
                        r = this.geometryFactory.createLinearRing(n._points),
                        0 === a ? i = r : s.push(r);
                    return this.geometryFactory.createPolygon(i, s)
                },
                multipolygon: function(t) {
                    var e;
                    if (void 0 === t)
                        return this.geometryFactory.createMultiPolygon();
                    for (var n = t.trim().split(Nl.doubleParenComma), r = [], i = 0, o = n.length; i < o; ++i)
                        e = n[i].replace(Nl.trimParens, "$1"),
                        r.push(Dl.polygon.apply(this, [e]));
                    return this.geometryFactory.createMultiPolygon(r)
                },
                geometrycollection: function(t) {
                    if (void 0 === t)
                        return this.geometryFactory.createGeometryCollection();
                    for (var e = (t = t.replace(/,\s*([A-Za-z])/g, "|$1")).trim().split("|"), n = [], r = 0, i = e.length; r < i; ++r)
                        n.push(this.read(e[r]));
                    return this.geometryFactory.createGeometryCollection(n)
                }
            },
            Fl = function(t) {
                this.parser = new Rl(t)
            };
        Fl.prototype.write = function(t) {
            return this.parser.write(t)
        },
        Fl.toLineString = function(t, e) {
            if (2 !== arguments.length)
                throw new Error("Not implemented");
            return "LINESTRING ( " + t.x + " " + t.y + ", " + e.x + " " + e.y + " )"
        };
        var kl = function(t) {
                function e(e) {
                    t.call(this, e),
                    this.name = "RuntimeException",
                    this.message = e,
                    this.stack = (new t).stack
                }
                return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e
            }(Error),
            jl = function(t) {
                function e() {
                    if (t.call(this), 0 === arguments.length)
                        t.call(this);
                    else if (1 === arguments.length) {
                        var e = arguments[0];
                        t.call(this, e)
                    }
                }
                return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.interfaces_ = function() {
                    return []
                }, e.prototype.getClass = function() {
                    return e
                }, e
            }(kl),
            Gl = function() {};
        Gl.prototype.interfaces_ = function() {
            return []
        },
        Gl.prototype.getClass = function() {
            return Gl
        },
        Gl.shouldNeverReachHere = function() {
            if (0 === arguments.length)
                Gl.shouldNeverReachHere(null);
            else if (1 === arguments.length) {
                var t = arguments[0];
                throw new jl("Should never reach here" + (null !== t ? ": " + t : ""))
            }
        },
        Gl.isTrue = function() {
            var t;
            if (1 === arguments.length)
                Gl.isTrue(arguments[0], null);
            else if (2 === arguments.length && (t = arguments[1], !arguments[0]))
                throw null === t ? new jl : new jl(t)
        },
        Gl.equals = function() {
            var t,
                e,
                n;
            if (2 === arguments.length)
                Gl.equals(t = arguments[0], e = arguments[1], null);
            else if (3 === arguments.length && (t = arguments[0], n = arguments[2], !(e = arguments[1]).equals(t)))
                throw new jl("Expected " + t + " but encountered " + e + (null !== n ? ": " + n : ""))
        };
        var Bl = function() {
                this._result = null,
                this._inputLines = Array(2).fill().map((function() {
                    return Array(2)
                })),
                this._intPt = new Array(2).fill(null),
                this._intLineIndex = null,
                this._isProper = null,
                this._pa = null,
                this._pb = null,
                this._precisionModel = null,
                this._intPt[0] = new ul,
                this._intPt[1] = new ul,
                this._pa = this._intPt[0],
                this._pb = this._intPt[1],
                this._result = 0
            },
            ql = {
                DONT_INTERSECT: {
                    configurable: !0
                },
                DO_INTERSECT: {
                    configurable: !0
                },
                COLLINEAR: {
                    configurable: !0
                },
                NO_INTERSECTION: {
                    configurable: !0
                },
                POINT_INTERSECTION: {
                    configurable: !0
                },
                COLLINEAR_INTERSECTION: {
                    configurable: !0
                }
            };
        Bl.prototype.getIndexAlongSegment = function(t, e) {
            return this.computeIntLineIndex(), this._intLineIndex[t][e]
        },
        Bl.prototype.getTopologySummary = function() {
            var t = new vl;
            return this.isEndPoint() && t.append(" endpoint"), this._isProper && t.append(" proper"), this.isCollinear() && t.append(" collinear"), t.toString()
        },
        Bl.prototype.computeIntersection = function(t, e, n, r) {
            this._inputLines[0][0] = t,
            this._inputLines[0][1] = e,
            this._inputLines[1][0] = n,
            this._inputLines[1][1] = r,
            this._result = this.computeIntersect(t, e, n, r)
        },
        Bl.prototype.getIntersectionNum = function() {
            return this._result
        },
        Bl.prototype.computeIntLineIndex = function() {
            if (0 === arguments.length)
                null === this._intLineIndex && (this._intLineIndex = Array(2).fill().map((function() {
                    return Array(2)
                })), this.computeIntLineIndex(0), this.computeIntLineIndex(1));
            else if (1 === arguments.length) {
                var t = arguments[0];
                this.getEdgeDistance(t, 0) > this.getEdgeDistance(t, 1) ? (this._intLineIndex[t][0] = 0, this._intLineIndex[t][1] = 1) : (this._intLineIndex[t][0] = 1, this._intLineIndex[t][1] = 0)
            }
        },
        Bl.prototype.isProper = function() {
            return this.hasIntersection() && this._isProper
        },
        Bl.prototype.setPrecisionModel = function(t) {
            this._precisionModel = t
        },
        Bl.prototype.isInteriorIntersection = function() {
            var t = this;
            if (0 === arguments.length)
                return !!this.isInteriorIntersection(0) || !!this.isInteriorIntersection(1);
            if (1 === arguments.length) {
                for (var e = arguments[0], n = 0; n < this._result; n++)
                    if (!t._intPt[n].equals2D(t._inputLines[e][0]) && !t._intPt[n].equals2D(t._inputLines[e][1]))
                        return !0;
                return !1
            }
        },
        Bl.prototype.getIntersection = function(t) {
            return this._intPt[t]
        },
        Bl.prototype.isEndPoint = function() {
            return this.hasIntersection() && !this._isProper
        },
        Bl.prototype.hasIntersection = function() {
            return this._result !== Bl.NO_INTERSECTION
        },
        Bl.prototype.getEdgeDistance = function(t, e) {
            return Bl.computeEdgeDistance(this._intPt[e], this._inputLines[t][0], this._inputLines[t][1])
        },
        Bl.prototype.isCollinear = function() {
            return this._result === Bl.COLLINEAR_INTERSECTION
        },
        Bl.prototype.toString = function() {
            return Fl.toLineString(this._inputLines[0][0], this._inputLines[0][1]) + " - " + Fl.toLineString(this._inputLines[1][0], this._inputLines[1][1]) + this.getTopologySummary()
        },
        Bl.prototype.getEndpoint = function(t, e) {
            return this._inputLines[t][e]
        },
        Bl.prototype.isIntersection = function(t) {
            for (var e = 0; e < this._result; e++)
                if (this._intPt[e].equals2D(t))
                    return !0;
            return !1
        },
        Bl.prototype.getIntersectionAlongSegment = function(t, e) {
            return this.computeIntLineIndex(), this._intPt[this._intLineIndex[t][e]]
        },
        Bl.prototype.interfaces_ = function() {
            return []
        },
        Bl.prototype.getClass = function() {
            return Bl
        },
        Bl.computeEdgeDistance = function(t, e, n) {
            var r = Math.abs(n.x - e.x),
                i = Math.abs(n.y - e.y),
                o = -1;
            if (t.equals(e))
                o = 0;
            else if (t.equals(n))
                o = r > i ? r : i;
            else {
                var s = Math.abs(t.x - e.x),
                    a = Math.abs(t.y - e.y);
                0 !== (o = r > i ? s : a) || t.equals(e) || (o = Math.max(s, a))
            }
            return Gl.isTrue(!(0 === o && !t.equals(e)), "Bad distance calculation"), o
        },
        Bl.nonRobustComputeEdgeDistance = function(t, e, n) {
            var r = t.x - e.x,
                i = t.y - e.y,
                o = Math.sqrt(r * r + i * i);
            return Gl.isTrue(!(0 === o && !t.equals(e)), "Invalid distance calculation"), o
        },
        ql.DONT_INTERSECT.get = function() {
            return 0
        },
        ql.DO_INTERSECT.get = function() {
            return 1
        },
        ql.COLLINEAR.get = function() {
            return 2
        },
        ql.NO_INTERSECTION.get = function() {
            return 0
        },
        ql.POINT_INTERSECTION.get = function() {
            return 1
        },
        ql.COLLINEAR_INTERSECTION.get = function() {
            return 2
        },
        Object.defineProperties(Bl, ql);
        var zl = function(t) {
                function e() {
                    t.apply(this, arguments)
                }
                return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.isInSegmentEnvelopes = function(t) {
                    var e = new Ll(this._inputLines[0][0], this._inputLines[0][1]),
                        n = new Ll(this._inputLines[1][0], this._inputLines[1][1]);
                    return e.contains(t) && n.contains(t)
                }, e.prototype.computeIntersection = function() {
                    if (3 !== arguments.length)
                        return t.prototype.computeIntersection.apply(this, arguments);
                    var e = arguments[0],
                        n = arguments[1],
                        r = arguments[2];
                    if (this._isProper = !1, Ll.intersects(n, r, e) && 0 === Xl.orientationIndex(n, r, e) && 0 === Xl.orientationIndex(r, n, e))
                        return this._isProper = !0, (e.equals(n) || e.equals(r)) && (this._isProper = !1), this._result = t.POINT_INTERSECTION, null;
                    this._result = t.NO_INTERSECTION
                }, e.prototype.normalizeToMinimum = function(t, e, n, r, i) {
                    i.x = this.smallestInAbsValue(t.x, e.x, n.x, r.x),
                    i.y = this.smallestInAbsValue(t.y, e.y, n.y, r.y),
                    t.x -= i.x,
                    t.y -= i.y,
                    e.x -= i.x,
                    e.y -= i.y,
                    n.x -= i.x,
                    n.y -= i.y,
                    r.x -= i.x,
                    r.y -= i.y
                }, e.prototype.safeHCoordinateIntersection = function(t, n, r, i) {
                    var o = null;
                    try {
                        o = Pl.intersection(t, n, r, i)
                    } catch (s) {
                        if (!(s instanceof Il))
                            throw s;
                        o = e.nearestEndpoint(t, n, r, i)
                    }
                    return o
                }, e.prototype.intersection = function(t, n, r, i) {
                    var o = this.intersectionWithNormalization(t, n, r, i);
                    return this.isInSegmentEnvelopes(o) || (o = new ul(e.nearestEndpoint(t, n, r, i))), null !== this._precisionModel && this._precisionModel.makePrecise(o), o
                }, e.prototype.smallestInAbsValue = function(t, e, n, r) {
                    var i = t,
                        o = Math.abs(i);
                    return Math.abs(e) < o && (i = e, o = Math.abs(e)), Math.abs(n) < o && (i = n, o = Math.abs(n)), Math.abs(r) < o && (i = r), i
                }, e.prototype.checkDD = function(t, e, n, r, i) {
                    var o = wl.intersection(t, e, n, r),
                        s = this.isInSegmentEnvelopes(o);
                    Tl.out.println("DD in env = " + s + "  --------------------- " + o),
                    i.distance(o) > 1e-4 && Tl.out.println("Distance = " + i.distance(o))
                }, e.prototype.intersectionWithNormalization = function(t, e, n, r) {
                    var i = new ul(t),
                        o = new ul(e),
                        s = new ul(n),
                        a = new ul(r),
                        u = new ul;
                    this.normalizeToEnvCentre(i, o, s, a, u);
                    var l = this.safeHCoordinateIntersection(i, o, s, a);
                    return l.x += u.x, l.y += u.y, l
                }, e.prototype.computeCollinearIntersection = function(e, n, r, i) {
                    var o = Ll.intersects(e, n, r),
                        s = Ll.intersects(e, n, i),
                        a = Ll.intersects(r, i, e),
                        u = Ll.intersects(r, i, n);
                    return o && s ? (this._intPt[0] = r, this._intPt[1] = i, t.COLLINEAR_INTERSECTION) : a && u ? (this._intPt[0] = e, this._intPt[1] = n, t.COLLINEAR_INTERSECTION) : o && a ? (this._intPt[0] = r, this._intPt[1] = e, !r.equals(e) || s || u ? t.COLLINEAR_INTERSECTION : t.POINT_INTERSECTION) : o && u ? (this._intPt[0] = r, this._intPt[1] = n, !r.equals(n) || s || a ? t.COLLINEAR_INTERSECTION : t.POINT_INTERSECTION) : s && a ? (this._intPt[0] = i, this._intPt[1] = e, !i.equals(e) || o || u ? t.COLLINEAR_INTERSECTION : t.POINT_INTERSECTION) : s && u ? (this._intPt[0] = i, this._intPt[1] = n, !i.equals(n) || o || a ? t.COLLINEAR_INTERSECTION : t.POINT_INTERSECTION) : t.NO_INTERSECTION
                }, e.prototype.normalizeToEnvCentre = function(t, e, n, r, i) {
                    var o = t.x < e.x ? t.x : e.x,
                        s = t.y < e.y ? t.y : e.y,
                        a = t.x > e.x ? t.x : e.x,
                        u = t.y > e.y ? t.y : e.y,
                        l = n.x < r.x ? n.x : r.x,
                        h = n.y < r.y ? n.y : r.y,
                        c = n.x > r.x ? n.x : r.x,
                        p = n.y > r.y ? n.y : r.y,
                        f = ((o > l ? o : l) + (a < c ? a : c)) / 2,
                        d = ((s > h ? s : h) + (u < p ? u : p)) / 2;
                    i.x = f,
                    i.y = d,
                    t.x -= i.x,
                    t.y -= i.y,
                    e.x -= i.x,
                    e.y -= i.y,
                    n.x -= i.x,
                    n.y -= i.y,
                    r.x -= i.x,
                    r.y -= i.y
                }, e.prototype.computeIntersect = function(e, n, r, i) {
                    if (this._isProper = !1, !Ll.intersects(e, n, r, i))
                        return t.NO_INTERSECTION;
                    var o = Xl.orientationIndex(e, n, r),
                        s = Xl.orientationIndex(e, n, i);
                    if (o > 0 && s > 0 || o < 0 && s < 0)
                        return t.NO_INTERSECTION;
                    var a = Xl.orientationIndex(r, i, e),
                        u = Xl.orientationIndex(r, i, n);
                    return a > 0 && u > 0 || a < 0 && u < 0 ? t.NO_INTERSECTION : 0 === o && 0 === s && 0 === a && 0 === u ? this.computeCollinearIntersection(e, n, r, i) : (0 === o || 0 === s || 0 === a || 0 === u ? (this._isProper = !1, e.equals2D(r) || e.equals2D(i) ? this._intPt[0] = e : n.equals2D(r) || n.equals2D(i) ? this._intPt[0] = n : 0 === o ? this._intPt[0] = new ul(r) : 0 === s ? this._intPt[0] = new ul(i) : 0 === a ? this._intPt[0] = new ul(e) : 0 === u && (this._intPt[0] = new ul(n))) : (this._isProper = !0, this._intPt[0] = this.intersection(e, n, r, i)), t.POINT_INTERSECTION)
                }, e.prototype.interfaces_ = function() {
                    return []
                }, e.prototype.getClass = function() {
                    return e
                }, e.nearestEndpoint = function(t, e, n, r) {
                    var i = t,
                        o = Xl.distancePointLine(t, n, r),
                        s = Xl.distancePointLine(e, n, r);
                    return s < o && (o = s, i = e), (s = Xl.distancePointLine(n, t, e)) < o && (o = s, i = n), (s = Xl.distancePointLine(r, t, e)) < o && (o = s, i = r), i
                }, e
            }(Bl),
            Ul = function() {};
        Ul.prototype.interfaces_ = function() {
            return []
        },
        Ul.prototype.getClass = function() {
            return Ul
        },
        Ul.orientationIndex = function(t, e, n) {
            var r = e.x - t.x,
                i = e.y - t.y,
                o = n.x - e.x,
                s = n.y - e.y;
            return Ul.signOfDet2x2(r, i, o, s)
        },
        Ul.signOfDet2x2 = function(t, e, n, r) {
            var i = null,
                o = null,
                s = null;
            if (i = 1, 0 === t || 0 === r)
                return 0 === e || 0 === n ? 0 : e > 0 ? n > 0 ? -i : i : n > 0 ? i : -i;
            if (0 === e || 0 === n)
                return r > 0 ? t > 0 ? i : -i : t > 0 ? -i : i;
            if (e > 0 ? r > 0 ? e <= r || (i = -i, o = t, t = n, n = o, o = e, e = r, r = o) : e <= -r ? (i = -i, n = -n, r = -r) : (o = t, t = -n, n = o, o = e, e = -r, r = o) : r > 0 ? -e <= r ? (i = -i, t = -t, e = -e) : (o = -t, t = n, n = o, o = -e, e = r, r = o) : e >= r ? (t = -t, e = -e, n = -n, r = -r) : (i = -i, o = -t, t = -n, n = o, o = -e, e = -r, r = o), t > 0) {
                if (!(n > 0))
                    return i;
                if (!(t <= n))
                    return i
            } else {
                if (n > 0)
                    return -i;
                if (!(t >= n))
                    return -i;
                i = -i,
                t = -t,
                n = -n
            }
            for (;;) {
                if ((r -= (s = Math.floor(n / t)) * e) < 0)
                    return -i;
                if (r > e)
                    return i;
                if (t > (n -= s * t) + n) {
                    if (e < r + r)
                        return i
                } else {
                    if (e > r + r)
                        return -i;
                    n = t - n,
                    r = e - r,
                    i = -i
                }
                if (0 === r)
                    return 0 === n ? 0 : -i;
                if (0 === n)
                    return i;
                if ((e -= (s = Math.floor(t / n)) * r) < 0)
                    return i;
                if (e > r)
                    return -i;
                if (n > (t -= s * n) + t) {
                    if (r < e + e)
                        return -i
                } else {
                    if (r > e + e)
                        return i;
                    t = n - t,
                    e = r - e,
                    i = -i
                }
                if (0 === e)
                    return 0 === t ? 0 : i;
                if (0 === t)
                    return -i
            }
        };
        var Vl = function() {
            this._p = null,
            this._crossingCount = 0,
            this._isPointOnSegment = !1;
            var t = arguments[0];
            this._p = t
        };
        Vl.prototype.countSegment = function(t, e) {
            if (t.x < this._p.x && e.x < this._p.x)
                return null;
            if (this._p.x === e.x && this._p.y === e.y)
                return this._isPointOnSegment = !0, null;
            if (t.y === this._p.y && e.y === this._p.y) {
                var n = t.x,
                    r = e.x;
                return n > r && (n = e.x, r = t.x), this._p.x >= n && this._p.x <= r && (this._isPointOnSegment = !0), null
            }
            if (t.y > this._p.y && e.y <= this._p.y || e.y > this._p.y && t.y <= this._p.y) {
                var i = t.x - this._p.x,
                    o = t.y - this._p.y,
                    s = e.x - this._p.x,
                    a = e.y - this._p.y,
                    u = Ul.signOfDet2x2(i, o, s, a);
                if (0 === u)
                    return this._isPointOnSegment = !0, null;
                a < o && (u = -u),
                u > 0 && this._crossingCount++
            }
        },
        Vl.prototype.isPointInPolygon = function() {
            return this.getLocation() !== pl.EXTERIOR
        },
        Vl.prototype.getLocation = function() {
            return this._isPointOnSegment ? pl.BOUNDARY : this._crossingCount % 2 == 1 ? pl.INTERIOR : pl.EXTERIOR
        },
        Vl.prototype.isOnSegment = function() {
            return this._isPointOnSegment
        },
        Vl.prototype.interfaces_ = function() {
            return []
        },
        Vl.prototype.getClass = function() {
            return Vl
        },
        Vl.locatePointInRing = function() {
            if (arguments[0] instanceof ul && dl(arguments[1], Cl)) {
                for (var t = arguments[1], e = new Vl(arguments[0]), n = new ul, r = new ul, i = 1; i < t.size(); i++)
                    if (t.getCoordinate(i, n), t.getCoordinate(i - 1, r), e.countSegment(n, r), e.isOnSegment())
                        return e.getLocation();
                return e.getLocation()
            }
            if (arguments[0] instanceof ul && arguments[1] instanceof Array) {
                for (var o = arguments[1], s = new Vl(arguments[0]), a = 1; a < o.length; a++) {
                    var u = o[a],
                        l = o[a - 1];
                    if (s.countSegment(u, l), s.isOnSegment())
                        return s.getLocation()
                }
                return s.getLocation()
            }
        };
        var Xl = function() {},
            Hl = {
                CLOCKWISE: {
                    configurable: !0
                },
                RIGHT: {
                    configurable: !0
                },
                COUNTERCLOCKWISE: {
                    configurable: !0
                },
                LEFT: {
                    configurable: !0
                },
                COLLINEAR: {
                    configurable: !0
                },
                STRAIGHT: {
                    configurable: !0
                }
            };
        Xl.prototype.interfaces_ = function() {
            return []
        },
        Xl.prototype.getClass = function() {
            return Xl
        },
        Xl.orientationIndex = function(t, e, n) {
            return wl.orientationIndex(t, e, n)
        },
        Xl.signedArea = function() {
            if (arguments[0] instanceof Array) {
                var t = arguments[0];
                if (t.length < 3)
                    return 0;
                for (var e = 0, n = t[0].x, r = 1; r < t.length - 1; r++) {
                    var i = t[r].x - n,
                        o = t[r + 1].y;
                    e += i * (t[r - 1].y - o)
                }
                return e / 2
            }
            if (dl(arguments[0], Cl)) {
                var s = arguments[0],
                    a = s.size();
                if (a < 3)
                    return 0;
                var u = new ul,
                    l = new ul,
                    h = new ul;
                s.getCoordinate(0, l),
                s.getCoordinate(1, h);
                var c = l.x;
                h.x -= c;
                for (var p = 0, f = 1; f < a - 1; f++)
                    u.y = l.y,
                    l.x = h.x,
                    l.y = h.y,
                    s.getCoordinate(f + 1, h),
                    h.x -= c,
                    p += l.x * (u.y - h.y);
                return p / 2
            }
        },
        Xl.distanceLineLine = function(t, e, n, r) {
            if (t.equals(e))
                return Xl.distancePointLine(t, n, r);
            if (n.equals(r))
                return Xl.distancePointLine(r, t, e);
            var i = !1;
            if (Ll.intersects(t, e, n, r)) {
                var o = (e.x - t.x) * (r.y - n.y) - (e.y - t.y) * (r.x - n.x);
                if (0 === o)
                    i = !0;
                else {
                    var s = (t.y - n.y) * (r.x - n.x) - (t.x - n.x) * (r.y - n.y),
                        a = ((t.y - n.y) * (e.x - t.x) - (t.x - n.x) * (e.y - t.y)) / o,
                        u = s / o;
                    (u < 0 || u > 1 || a < 0 || a > 1) && (i = !0)
                }
            } else
                i = !0;
            return i ? gl.min(Xl.distancePointLine(t, n, r), Xl.distancePointLine(e, n, r), Xl.distancePointLine(n, t, e), Xl.distancePointLine(r, t, e)) : 0
        },
        Xl.isPointInRing = function(t, e) {
            return Xl.locatePointInRing(t, e) !== pl.EXTERIOR
        },
        Xl.computeLength = function(t) {
            var e = t.size();
            if (e <= 1)
                return 0;
            var n = 0,
                r = new ul;
            t.getCoordinate(0, r);
            for (var i = r.x, o = r.y, s = 1; s < e; s++) {
                t.getCoordinate(s, r);
                var a = r.x,
                    u = r.y,
                    l = a - i,
                    h = u - o;
                n += Math.sqrt(l * l + h * h),
                i = a,
                o = u
            }
            return n
        },
        Xl.isCCW = function(t) {
            var e = t.length - 1;
            if (e < 3)
                throw new el("Ring has fewer than 4 points, so orientation cannot be determined");
            for (var n = t[0], r = 0, i = 1; i <= e; i++) {
                var o = t[i];
                o.y > n.y && (n = o, r = i)
            }
            var s = r;
            do {
                (s -= 1) < 0 && (s = e)
            } while (t[s].equals2D(n) && s !== r);
            var a = r;
            do {
                a = (a + 1) % e
            } while (t[a].equals2D(n) && a !== r);
            var u = t[s],
                l = t[a];
            if (u.equals2D(n) || l.equals2D(n) || u.equals2D(l))
                return !1;
            var h = Xl.computeOrientation(u, n, l);
            return 0 === h ? u.x > l.x : h > 0
        },
        Xl.locatePointInRing = function(t, e) {
            return Vl.locatePointInRing(t, e)
        },
        Xl.distancePointLinePerpendicular = function(t, e, n) {
            var r = (n.x - e.x) * (n.x - e.x) + (n.y - e.y) * (n.y - e.y),
                i = ((e.y - t.y) * (n.x - e.x) - (e.x - t.x) * (n.y - e.y)) / r;
            return Math.abs(i) * Math.sqrt(r)
        },
        Xl.computeOrientation = function(t, e, n) {
            return Xl.orientationIndex(t, e, n)
        },
        Xl.distancePointLine = function() {
            if (2 === arguments.length) {
                var t = arguments[0],
                    e = arguments[1];
                if (0 === e.length)
                    throw new el("Line array must contain at least one vertex");
                for (var n = t.distance(e[0]), r = 0; r < e.length - 1; r++) {
                    var i = Xl.distancePointLine(t, e[r], e[r + 1]);
                    i < n && (n = i)
                }
                return n
            }
            if (3 === arguments.length) {
                var o = arguments[0],
                    s = arguments[1],
                    a = arguments[2];
                if (s.x === a.x && s.y === a.y)
                    return o.distance(s);
                var u = (a.x - s.x) * (a.x - s.x) + (a.y - s.y) * (a.y - s.y),
                    l = ((o.x - s.x) * (a.x - s.x) + (o.y - s.y) * (a.y - s.y)) / u;
                if (l <= 0)
                    return o.distance(s);
                if (l >= 1)
                    return o.distance(a);
                var h = ((s.y - o.y) * (a.x - s.x) - (s.x - o.x) * (a.y - s.y)) / u;
                return Math.abs(h) * Math.sqrt(u)
            }
        },
        Xl.isOnLine = function(t, e) {
            for (var n = new zl, r = 1; r < e.length; r++) {
                var i = e[r - 1],
                    o = e[r];
                if (n.computeIntersection(t, i, o), n.hasIntersection())
                    return !0
            }
            return !1
        },
        Hl.CLOCKWISE.get = function() {
            return -1
        },
        Hl.RIGHT.get = function() {
            return Xl.CLOCKWISE
        },
        Hl.COUNTERCLOCKWISE.get = function() {
            return 1
        },
        Hl.LEFT.get = function() {
            return Xl.COUNTERCLOCKWISE
        },
        Hl.COLLINEAR.get = function() {
            return 0
        },
        Hl.STRAIGHT.get = function() {
            return Xl.COLLINEAR
        },
        Object.defineProperties(Xl, Hl);
        var Yl = function() {};
        Yl.prototype.filter = function(t) {},
        Yl.prototype.interfaces_ = function() {
            return []
        },
        Yl.prototype.getClass = function() {
            return Yl
        };
        var Wl = function() {
                var t = arguments[0];
                this._envelope = null,
                this._factory = null,
                this._SRID = null,
                this._userData = null,
                this._factory = t,
                this._SRID = t.getSRID()
            },
            $l = {
                serialVersionUID: {
                    configurable: !0
                },
                SORTINDEX_POINT: {
                    configurable: !0
                },
                SORTINDEX_MULTIPOINT: {
                    configurable: !0
                },
                SORTINDEX_LINESTRING: {
                    configurable: !0
                },
                SORTINDEX_LINEARRING: {
                    configurable: !0
                },
                SORTINDEX_MULTILINESTRING: {
                    configurable: !0
                },
                SORTINDEX_POLYGON: {
                    configurable: !0
                },
                SORTINDEX_MULTIPOLYGON: {
                    configurable: !0
                },
                SORTINDEX_GEOMETRYCOLLECTION: {
                    configurable: !0
                },
                geometryChangedFilter: {
                    configurable: !0
                }
            };
        Wl.prototype.isGeometryCollection = function() {
            return this.getSortIndex() === Wl.SORTINDEX_GEOMETRYCOLLECTION
        },
        Wl.prototype.getFactory = function() {
            return this._factory
        },
        Wl.prototype.getGeometryN = function(t) {
            return this
        },
        Wl.prototype.getArea = function() {
            return 0
        },
        Wl.prototype.isRectangle = function() {
            return !1
        },
        Wl.prototype.equals = function() {
            if (arguments[0] instanceof Wl) {
                var t = arguments[0];
                return null !== t && this.equalsTopo(t)
            }
            if (arguments[0] instanceof Object) {
                var e = arguments[0];
                if (!(e instanceof Wl))
                    return !1;
                var n = e;
                return this.equalsExact(n)
            }
        },
        Wl.prototype.equalsExact = function(t) {
            return this === t || this.equalsExact(t, 0)
        },
        Wl.prototype.geometryChanged = function() {
            this.apply(Wl.geometryChangedFilter)
        },
        Wl.prototype.geometryChangedAction = function() {
            this._envelope = null
        },
        Wl.prototype.equalsNorm = function(t) {
            return null !== t && this.norm().equalsExact(t.norm())
        },
        Wl.prototype.getLength = function() {
            return 0
        },
        Wl.prototype.getNumGeometries = function() {
            return 1
        },
        Wl.prototype.compareTo = function() {
            if (1 === arguments.length) {
                var t = arguments[0],
                    e = t;
                return this.getSortIndex() !== e.getSortIndex() ? this.getSortIndex() - e.getSortIndex() : this.isEmpty() && e.isEmpty() ? 0 : this.isEmpty() ? -1 : e.isEmpty() ? 1 : this.compareToSameClass(t)
            }
            if (2 === arguments.length) {
                var n = arguments[0],
                    r = arguments[1];
                return this.getSortIndex() !== n.getSortIndex() ? this.getSortIndex() - n.getSortIndex() : this.isEmpty() && n.isEmpty() ? 0 : this.isEmpty() ? -1 : n.isEmpty() ? 1 : this.compareToSameClass(n, r)
            }
        },
        Wl.prototype.getUserData = function() {
            return this._userData
        },
        Wl.prototype.getSRID = function() {
            return this._SRID
        },
        Wl.prototype.getEnvelope = function() {
            return this.getFactory().toGeometry(this.getEnvelopeInternal())
        },
        Wl.prototype.checkNotGeometryCollection = function(t) {
            if (t.getSortIndex() === Wl.SORTINDEX_GEOMETRYCOLLECTION)
                throw new el("This method does not support GeometryCollection arguments")
        },
        Wl.prototype.equal = function(t, e, n) {
            return 0 === n ? t.equals(e) : t.distance(e) <= n
        },
        Wl.prototype.norm = function() {
            var t = this.copy();
            return t.normalize(), t
        },
        Wl.prototype.getPrecisionModel = function() {
            return this._factory.getPrecisionModel()
        },
        Wl.prototype.getEnvelopeInternal = function() {
            return null === this._envelope && (this._envelope = this.computeEnvelopeInternal()), new Ll(this._envelope)
        },
        Wl.prototype.setSRID = function(t) {
            this._SRID = t
        },
        Wl.prototype.setUserData = function(t) {
            this._userData = t
        },
        Wl.prototype.compare = function(t, e) {
            for (var n = t.iterator(), r = e.iterator(); n.hasNext() && r.hasNext();) {
                var i = n.next(),
                    o = r.next(),
                    s = i.compareTo(o);
                if (0 !== s)
                    return s
            }
            return n.hasNext() ? 1 : r.hasNext() ? -1 : 0
        },
        Wl.prototype.hashCode = function() {
            return this.getEnvelopeInternal().hashCode()
        },
        Wl.prototype.isGeometryCollectionOrDerived = function() {
            return this.getSortIndex() === Wl.SORTINDEX_GEOMETRYCOLLECTION || this.getSortIndex() === Wl.SORTINDEX_MULTIPOINT || this.getSortIndex() === Wl.SORTINDEX_MULTILINESTRING || this.getSortIndex() === Wl.SORTINDEX_MULTIPOLYGON
        },
        Wl.prototype.interfaces_ = function() {
            return [ol, il, al]
        },
        Wl.prototype.getClass = function() {
            return Wl
        },
        Wl.hasNonEmptyElements = function(t) {
            for (var e = 0; e < t.length; e++)
                if (!t[e].isEmpty())
                    return !0;
            return !1
        },
        Wl.hasNullElements = function(t) {
            for (var e = 0; e < t.length; e++)
                if (null === t[e])
                    return !0;
            return !1
        },
        $l.serialVersionUID.get = function() {
            return 0x799ea46522854c00
        },
        $l.SORTINDEX_POINT.get = function() {
            return 0
        },
        $l.SORTINDEX_MULTIPOINT.get = function() {
            return 1
        },
        $l.SORTINDEX_LINESTRING.get = function() {
            return 2
        },
        $l.SORTINDEX_LINEARRING.get = function() {
            return 3
        },
        $l.SORTINDEX_MULTILINESTRING.get = function() {
            return 4
        },
        $l.SORTINDEX_POLYGON.get = function() {
            return 5
        },
        $l.SORTINDEX_MULTIPOLYGON.get = function() {
            return 6
        },
        $l.SORTINDEX_GEOMETRYCOLLECTION.get = function() {
            return 7
        },
        $l.geometryChangedFilter.get = function() {
            return Kl
        },
        Object.defineProperties(Wl, $l);
        var Kl = function() {};
        Kl.interfaces_ = function() {
            return [Yl]
        },
        Kl.filter = function(t) {
            t.geometryChangedAction()
        };
        var Zl = function() {};
        Zl.prototype.filter = function(t) {},
        Zl.prototype.interfaces_ = function() {
            return []
        },
        Zl.prototype.getClass = function() {
            return Zl
        };
        var Jl = function() {},
            Ql = {
                Mod2BoundaryNodeRule: {
                    configurable: !0
                },
                EndPointBoundaryNodeRule: {
                    configurable: !0
                },
                MultiValentEndPointBoundaryNodeRule: {
                    configurable: !0
                },
                MonoValentEndPointBoundaryNodeRule: {
                    configurable: !0
                },
                MOD2_BOUNDARY_RULE: {
                    configurable: !0
                },
                ENDPOINT_BOUNDARY_RULE: {
                    configurable: !0
                },
                MULTIVALENT_ENDPOINT_BOUNDARY_RULE: {
                    configurable: !0
                },
                MONOVALENT_ENDPOINT_BOUNDARY_RULE: {
                    configurable: !0
                },
                OGC_SFS_BOUNDARY_RULE: {
                    configurable: !0
                }
            };
        Jl.prototype.isInBoundary = function(t) {},
        Jl.prototype.interfaces_ = function() {
            return []
        },
        Jl.prototype.getClass = function() {
            return Jl
        },
        Ql.Mod2BoundaryNodeRule.get = function() {
            return th
        },
        Ql.EndPointBoundaryNodeRule.get = function() {
            return eh
        },
        Ql.MultiValentEndPointBoundaryNodeRule.get = function() {
            return nh
        },
        Ql.MonoValentEndPointBoundaryNodeRule.get = function() {
            return rh
        },
        Ql.MOD2_BOUNDARY_RULE.get = function() {
            return new th
        },
        Ql.ENDPOINT_BOUNDARY_RULE.get = function() {
            return new eh
        },
        Ql.MULTIVALENT_ENDPOINT_BOUNDARY_RULE.get = function() {
            return new nh
        },
        Ql.MONOVALENT_ENDPOINT_BOUNDARY_RULE.get = function() {
            return new rh
        },
        Ql.OGC_SFS_BOUNDARY_RULE.get = function() {
            return Jl.MOD2_BOUNDARY_RULE
        },
        Object.defineProperties(Jl, Ql);
        var th = function() {};
        th.prototype.isInBoundary = function(t) {
            return t % 2 == 1
        },
        th.prototype.interfaces_ = function() {
            return [Jl]
        },
        th.prototype.getClass = function() {
            return th
        };
        var eh = function() {};
        eh.prototype.isInBoundary = function(t) {
            return t > 0
        },
        eh.prototype.interfaces_ = function() {
            return [Jl]
        },
        eh.prototype.getClass = function() {
            return eh
        };
        var nh = function() {};
        nh.prototype.isInBoundary = function(t) {
            return t > 1
        },
        nh.prototype.interfaces_ = function() {
            return [Jl]
        },
        nh.prototype.getClass = function() {
            return nh
        };
        var rh = function() {};
        rh.prototype.isInBoundary = function(t) {
            return 1 === t
        },
        rh.prototype.interfaces_ = function() {
            return [Jl]
        },
        rh.prototype.getClass = function() {
            return rh
        };
        var ih = function() {};
        function oh(t) {
            this.message = t || ""
        }
        ih.prototype.add = function() {},
        ih.prototype.addAll = function() {},
        ih.prototype.isEmpty = function() {},
        ih.prototype.iterator = function() {},
        ih.prototype.size = function() {},
        ih.prototype.toArray = function() {},
        ih.prototype.remove = function() {},
        oh.prototype = new Error,
        oh.prototype.name = "IndexOutOfBoundsException";
        var sh = function() {};
        sh.prototype.hasNext = function() {},
        sh.prototype.next = function() {},
        sh.prototype.remove = function() {};
        var ah = function(t) {
            function e() {
                t.apply(this, arguments)
            }
            return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.get = function() {}, e.prototype.set = function() {}, e.prototype.isEmpty = function() {}, e
        }(ih);
        function uh(t) {
            this.message = t || ""
        }
        uh.prototype = new Error,
        uh.prototype.name = "NoSuchElementException";
        var lh = function(t) {
                function e() {
                    t.call(this),
                    this.array_ = [],
                    arguments[0] instanceof ih && this.addAll(arguments[0])
                }
                return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.ensureCapacity = function() {}, e.prototype.interfaces_ = function() {
                    return [t, ih]
                }, e.prototype.add = function(t) {
                    return 1 === arguments.length ? this.array_.push(t) : this.array_.splice(arguments[0], arguments[1]), !0
                }, e.prototype.clear = function() {
                    this.array_ = []
                }, e.prototype.addAll = function(t) {
                    for (var e = t.iterator(); e.hasNext();)
                        this.add(e.next());
                    return !0
                }, e.prototype.set = function(t, e) {
                    var n = this.array_[t];
                    return this.array_[t] = e, n
                }, e.prototype.iterator = function() {
                    return new hh(this)
                }, e.prototype.get = function(t) {
                    if (t < 0 || t >= this.size())
                        throw new oh;
                    return this.array_[t]
                }, e.prototype.isEmpty = function() {
                    return 0 === this.array_.length
                }, e.prototype.size = function() {
                    return this.array_.length
                }, e.prototype.toArray = function() {
                    for (var t = [], e = 0, n = this.array_.length; e < n; e++)
                        t.push(this.array_[e]);
                    return t
                }, e.prototype.remove = function(t) {
                    for (var e = !1, n = 0, r = this.array_.length; n < r; n++)
                        if (this.array_[n] === t) {
                            this.array_.splice(n, 1),
                            e = !0;
                            break
                        }
                    return e
                }, e
            }(ah),
            hh = function(t) {
                function e(e) {
                    t.call(this),
                    this.arrayList_ = e,
                    this.position_ = 0
                }
                return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.next = function() {
                    if (this.position_ === this.arrayList_.size())
                        throw new uh;
                    return this.arrayList_.get(this.position_++)
                }, e.prototype.hasNext = function() {
                    return this.position_ < this.arrayList_.size()
                }, e.prototype.set = function(t) {
                    return this.arrayList_.set(this.position_ - 1, t)
                }, e.prototype.remove = function() {
                    this.arrayList_.remove(this.arrayList_.get(this.position_))
                }, e
            }(sh),
            ch = function(t) {
                function e() {
                    if (t.call(this), 0 === arguments.length)
                        ;
                    else if (1 === arguments.length) {
                        var e = arguments[0];
                        this.ensureCapacity(e.length),
                        this.add(e, !0)
                    } else if (2 === arguments.length) {
                        var n = arguments[0],
                            r = arguments[1];
                        this.ensureCapacity(n.length),
                        this.add(n, r)
                    }
                }
                t && (e.__proto__ = t),
                e.prototype = Object.create(t && t.prototype),
                e.prototype.constructor = e;
                var n = {
                    coordArrayType: {
                        configurable: !0
                    }
                };
                return n.coordArrayType.get = function() {
                    return new Array(0).fill(null)
                }, e.prototype.getCoordinate = function(t) {
                    return this.get(t)
                }, e.prototype.addAll = function() {
                    var e = this;
                    if (2 === arguments.length) {
                        for (var n = arguments[1], r = !1, i = arguments[0].iterator(); i.hasNext();)
                            e.add(i.next(), n),
                            r = !0;
                        return r
                    }
                    return t.prototype.addAll.apply(this, arguments)
                }, e.prototype.clone = function() {
                    for (var e = t.prototype.clone.call(this), n = 0; n < this.size(); n++)
                        e.add(n, this.get(n).copy());
                    return e
                }, e.prototype.toCoordinateArray = function() {
                    return this.toArray(e.coordArrayType)
                }, e.prototype.add = function() {
                    var e = this;
                    if (1 === arguments.length) {
                        var n = arguments[0];
                        t.prototype.add.call(this, n)
                    } else if (2 === arguments.length) {
                        if (arguments[0] instanceof Array && "boolean" == typeof arguments[1]) {
                            var r = arguments[0],
                                i = arguments[1];
                            return this.add(r, i, !0), !0
                        }
                        if (arguments[0] instanceof ul && "boolean" == typeof arguments[1]) {
                            var o = arguments[0];
                            if (!arguments[1] && this.size() >= 1 && this.get(this.size() - 1).equals2D(o))
                                return null;
                            t.prototype.add.call(this, o)
                        } else if (arguments[0] instanceof Object && "boolean" == typeof arguments[1]) {
                            var s = arguments[0],
                                a = arguments[1];
                            return this.add(s, a), !0
                        }
                    } else if (3 === arguments.length) {
                        if ("boolean" == typeof arguments[2] && arguments[0] instanceof Array && "boolean" == typeof arguments[1]) {
                            var u = arguments[0],
                                l = arguments[1];
                            if (arguments[2])
                                for (var h = 0; h < u.length; h++)
                                    e.add(u[h], l);
                            else
                                for (var c = u.length - 1; c >= 0; c--)
                                    e.add(u[c], l);
                            return !0
                        }
                        if ("boolean" == typeof arguments[2] && Number.isInteger(arguments[0]) && arguments[1] instanceof ul) {
                            var p = arguments[0],
                                f = arguments[1];
                            if (!arguments[2]) {
                                var d = this.size();
                                if (d > 0) {
                                    if (p > 0 && this.get(p - 1).equals2D(f))
                                        return null;
                                    if (p < d && this.get(p).equals2D(f))
                                        return null
                                }
                            }
                            t.prototype.add.call(this, p, f)
                        }
                    } else if (4 === arguments.length) {
                        var g = arguments[0],
                            y = arguments[1],
                            v = arguments[2],
                            m = arguments[3],
                            _ = 1;
                        v > m && (_ = -1);
                        for (var x = v; x !== m; x += _)
                            e.add(g[x], y);
                        return !0
                    }
                }, e.prototype.closeRing = function() {
                    this.size() > 0 && this.add(new ul(this.get(0)), !1)
                }, e.prototype.interfaces_ = function() {
                    return []
                }, e.prototype.getClass = function() {
                    return e
                }, Object.defineProperties(e, n), e
            }(lh),
            ph = function() {},
            fh = {
                ForwardComparator: {
                    configurable: !0
                },
                BidirectionalComparator: {
                    configurable: !0
                },
                coordArrayType: {
                    configurable: !0
                }
            };
        fh.ForwardComparator.get = function() {
            return dh
        },
        fh.BidirectionalComparator.get = function() {
            return gh
        },
        fh.coordArrayType.get = function() {
            return new Array(0).fill(null)
        },
        ph.prototype.interfaces_ = function() {
            return []
        },
        ph.prototype.getClass = function() {
            return ph
        },
        ph.isRing = function(t) {
            return !(t.length < 4 || !t[0].equals2D(t[t.length - 1]))
        },
        ph.ptNotInList = function(t, e) {
            for (var n = 0; n < t.length; n++) {
                var r = t[n];
                if (ph.indexOf(r, e) < 0)
                    return r
            }
            return null
        },
        ph.scroll = function(t, e) {
            var n = ph.indexOf(e, t);
            if (n < 0)
                return null;
            var r = new Array(t.length).fill(null);
            Tl.arraycopy(t, n, r, 0, t.length - n),
            Tl.arraycopy(t, 0, r, t.length - n, n),
            Tl.arraycopy(r, 0, t, 0, t.length)
        },
        ph.equals = function() {
            if (2 === arguments.length) {
                var t = arguments[0],
                    e = arguments[1];
                if (t === e)
                    return !0;
                if (null === t || null === e)
                    return !1;
                if (t.length !== e.length)
                    return !1;
                for (var n = 0; n < t.length; n++)
                    if (!t[n].equals(e[n]))
                        return !1;
                return !0
            }
            if (3 === arguments.length) {
                var r = arguments[0],
                    i = arguments[1],
                    o = arguments[2];
                if (r === i)
                    return !0;
                if (null === r || null === i)
                    return !1;
                if (r.length !== i.length)
                    return !1;
                for (var s = 0; s < r.length; s++)
                    if (0 !== o.compare(r[s], i[s]))
                        return !1;
                return !0
            }
        },
        ph.intersection = function(t, e) {
            for (var n = new ch, r = 0; r < t.length; r++)
                e.intersects(t[r]) && n.add(t[r], !0);
            return n.toCoordinateArray()
        },
        ph.hasRepeatedPoints = function(t) {
            for (var e = 1; e < t.length; e++)
                if (t[e - 1].equals(t[e]))
                    return !0;
            return !1
        },
        ph.removeRepeatedPoints = function(t) {
            return ph.hasRepeatedPoints(t) ? new ch(t, !1).toCoordinateArray() : t
        },
        ph.reverse = function(t) {
            for (var e = t.length - 1, n = Math.trunc(e / 2), r = 0; r <= n; r++) {
                var i = t[r];
                t[r] = t[e - r],
                t[e - r] = i
            }
        },
        ph.removeNull = function(t) {
            for (var e = 0, n = 0; n < t.length; n++)
                null !== t[n] && e++;
            var r = new Array(e).fill(null);
            if (0 === e)
                return r;
            for (var i = 0, o = 0; o < t.length; o++)
                null !== t[o] && (r[i++] = t[o]);
            return r
        },
        ph.copyDeep = function() {
            if (1 === arguments.length) {
                for (var t = arguments[0], e = new Array(t.length).fill(null), n = 0; n < t.length; n++)
                    e[n] = new ul(t[n]);
                return e
            }
            if (5 === arguments.length)
                for (var r = arguments[0], i = arguments[1], o = arguments[2], s = arguments[3], a = arguments[4], u = 0; u < a; u++)
                    o[s + u] = new ul(r[i + u])
        },
        ph.isEqualReversed = function(t, e) {
            for (var n = 0; n < t.length; n++) {
                var r = t[n],
                    i = e[t.length - n - 1];
                if (0 !== r.compareTo(i))
                    return !1
            }
            return !0
        },
        ph.envelope = function(t) {
            for (var e = new Ll, n = 0; n < t.length; n++)
                e.expandToInclude(t[n]);
            return e
        },
        ph.toCoordinateArray = function(t) {
            return t.toArray(ph.coordArrayType)
        },
        ph.atLeastNCoordinatesOrNothing = function(t, e) {
            return e.length >= t ? e : []
        },
        ph.indexOf = function(t, e) {
            for (var n = 0; n < e.length; n++)
                if (t.equals(e[n]))
                    return n;
            return -1
        },
        ph.increasingDirection = function(t) {
            for (var e = 0; e < Math.trunc(t.length / 2); e++) {
                var n = t.length - 1 - e,
                    r = t[e].compareTo(t[n]);
                if (0 !== r)
                    return r
            }
            return 1
        },
        ph.compare = function(t, e) {
            for (var n = 0; n < t.length && n < e.length;) {
                var r = t[n].compareTo(e[n]);
                if (0 !== r)
                    return r;
                n++
            }
            return n < e.length ? -1 : n < t.length ? 1 : 0
        },
        ph.minCoordinate = function(t) {
            for (var e = null, n = 0; n < t.length; n++)
                (null === e || e.compareTo(t[n]) > 0) && (e = t[n]);
            return e
        },
        ph.extract = function(t, e, n) {
            e = gl.clamp(e, 0, t.length);
            var r = (n = gl.clamp(n, -1, t.length)) - e + 1;
            n < 0 && (r = 0),
            e >= t.length && (r = 0),
            n < e && (r = 0);
            var i = new Array(r).fill(null);
            if (0 === r)
                return i;
            for (var o = 0, s = e; s <= n; s++)
                i[o++] = t[s];
            return i
        },
        Object.defineProperties(ph, fh);
        var dh = function() {};
        dh.prototype.compare = function(t, e) {
            return ph.compare(t, e)
        },
        dh.prototype.interfaces_ = function() {
            return [sl]
        },
        dh.prototype.getClass = function() {
            return dh
        };
        var gh = function() {};
        gh.prototype.compare = function(t, e) {
            var n = t,
                r = e;
            if (n.length < r.length)
                return -1;
            if (n.length > r.length)
                return 1;
            if (0 === n.length)
                return 0;
            var i = ph.compare(n, r);
            return ph.isEqualReversed(n, r) ? 0 : i
        },
        gh.prototype.OLDcompare = function(t, e) {
            var n = t,
                r = e;
            if (n.length < r.length)
                return -1;
            if (n.length > r.length)
                return 1;
            if (0 === n.length)
                return 0;
            for (var i = ph.increasingDirection(n), o = ph.increasingDirection(r), s = i > 0 ? 0 : n.length - 1, a = o > 0 ? 0 : n.length - 1, u = 0; u < n.length; u++) {
                var l = n[s].compareTo(r[a]);
                if (0 !== l)
                    return l;
                s += i,
                a += o
            }
            return 0
        },
        gh.prototype.interfaces_ = function() {
            return [sl]
        },
        gh.prototype.getClass = function() {
            return gh
        };
        var yh = function() {};
        yh.prototype.get = function() {},
        yh.prototype.put = function() {},
        yh.prototype.size = function() {},
        yh.prototype.values = function() {},
        yh.prototype.entrySet = function() {};
        var vh = function(t) {
            function e() {
                t.apply(this, arguments)
            }
            return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e
        }(yh);
        function mh(t) {
            this.message = t || ""
        }
        function _h() {}
        mh.prototype = new Error,
        mh.prototype.name = "OperationNotSupported",
        _h.prototype = new ih,
        _h.prototype.contains = function() {};
        var xh = function(t) {
                function e() {
                    t.call(this),
                    this.array_ = [],
                    arguments[0] instanceof ih && this.addAll(arguments[0])
                }
                return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.contains = function(t) {
                    for (var e = 0, n = this.array_.length; e < n; e++)
                        if (this.array_[e] === t)
                            return !0;
                    return !1
                }, e.prototype.add = function(t) {
                    return !this.contains(t) && (this.array_.push(t), !0)
                }, e.prototype.addAll = function(t) {
                    for (var e = t.iterator(); e.hasNext();)
                        this.add(e.next());
                    return !0
                }, e.prototype.remove = function(t) {
                    throw new Error
                }, e.prototype.size = function() {
                    return this.array_.length
                }, e.prototype.isEmpty = function() {
                    return 0 === this.array_.length
                }, e.prototype.toArray = function() {
                    for (var t = [], e = 0, n = this.array_.length; e < n; e++)
                        t.push(this.array_[e]);
                    return t
                }, e.prototype.iterator = function() {
                    return new Eh(this)
                }, e
            }(_h),
            Eh = function(t) {
                function e(e) {
                    t.call(this),
                    this.hashSet_ = e,
                    this.position_ = 0
                }
                return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.next = function() {
                    if (this.position_ === this.hashSet_.size())
                        throw new uh;
                    return this.hashSet_.array_[this.position_++]
                }, e.prototype.hasNext = function() {
                    return this.position_ < this.hashSet_.size()
                }, e.prototype.remove = function() {
                    throw new mh
                }, e
            }(sh);
        function wh(t) {
            return null === t ? 0 : t.color
        }
        function bh(t) {
            return null === t ? null : t.parent
        }
        function Ch(t, e) {
            null !== t && (t.color = e)
        }
        function Mh(t) {
            return null === t ? null : t.left
        }
        function Sh(t) {
            return null === t ? null : t.right
        }
        function Ih() {
            this.root_ = null,
            this.size_ = 0
        }
        Ih.prototype = new vh,
        Ih.prototype.get = function(t) {
            for (var e = this.root_; null !== e;) {
                var n = t.compareTo(e.key);
                if (n < 0)
                    e = e.left;
                else {
                    if (!(n > 0))
                        return e.value;
                    e = e.right
                }
            }
            return null
        },
        Ih.prototype.put = function(t, e) {
            if (null === this.root_)
                return this.root_ = {
                    key: t,
                    value: e,
                    left: null,
                    right: null,
                    parent: null,
                    color: 0,
                    getValue: function() {
                        return this.value
                    },
                    getKey: function() {
                        return this.key
                    }
                }, this.size_ = 1, null;
            var n,
                r,
                i = this.root_;
            do {
                if (n = i, (r = t.compareTo(i.key)) < 0)
                    i = i.left;
                else {
                    if (!(r > 0)) {
                        var o = i.value;
                        return i.value = e, o
                    }
                    i = i.right
                }
            } while (null !== i);
            var s = {
                key: t,
                left: null,
                right: null,
                value: e,
                parent: n,
                color: 0,
                getValue: function() {
                    return this.value
                },
                getKey: function() {
                    return this.key
                }
            };
            return r < 0 ? n.left = s : n.right = s, this.fixAfterInsertion(s), this.size_++, null
        },
        Ih.prototype.fixAfterInsertion = function(t) {
            var e = this;
            for (t.color = 1; null != t && t !== this.root_ && 1 === t.parent.color;)
                if (bh(t) === Mh(bh(bh(t)))) {
                    var n = Sh(bh(bh(t)));
                    1 === wh(n) ? (Ch(bh(t), 0), Ch(n, 0), Ch(bh(bh(t)), 1), t = bh(bh(t))) : (t === Sh(bh(t)) && (t = bh(t), e.rotateLeft(t)), Ch(bh(t), 0), Ch(bh(bh(t)), 1), e.rotateRight(bh(bh(t))))
                } else {
                    var r = Mh(bh(bh(t)));
                    1 === wh(r) ? (Ch(bh(t), 0), Ch(r, 0), Ch(bh(bh(t)), 1), t = bh(bh(t))) : (t === Mh(bh(t)) && (t = bh(t), e.rotateRight(t)), Ch(bh(t), 0), Ch(bh(bh(t)), 1), e.rotateLeft(bh(bh(t))))
                }
            this.root_.color = 0
        },
        Ih.prototype.values = function() {
            var t = new lh,
                e = this.getFirstEntry();
            if (null !== e)
                for (t.add(e.value); null !== (e = Ih.successor(e));)
                    t.add(e.value);
            return t
        },
        Ih.prototype.entrySet = function() {
            var t = new xh,
                e = this.getFirstEntry();
            if (null !== e)
                for (t.add(e); null !== (e = Ih.successor(e));)
                    t.add(e);
            return t
        },
        Ih.prototype.rotateLeft = function(t) {
            if (null != t) {
                var e = t.right;
                t.right = e.left,
                null != e.left && (e.left.parent = t),
                e.parent = t.parent,
                null === t.parent ? this.root_ = e : t.parent.left === t ? t.parent.left = e : t.parent.right = e,
                e.left = t,
                t.parent = e
            }
        },
        Ih.prototype.rotateRight = function(t) {
            if (null != t) {
                var e = t.left;
                t.left = e.right,
                null != e.right && (e.right.parent = t),
                e.parent = t.parent,
                null === t.parent ? this.root_ = e : t.parent.right === t ? t.parent.right = e : t.parent.left = e,
                e.right = t,
                t.parent = e
            }
        },
        Ih.prototype.getFirstEntry = function() {
            var t = this.root_;
            if (null != t)
                for (; null != t.left;)
                    t = t.left;
            return t
        },
        Ih.successor = function(t) {
            if (null === t)
                return null;
            if (null !== t.right) {
                for (var e = t.right; null !== e.left;)
                    e = e.left;
                return e
            }
            for (var n = t.parent, r = t; null !== n && r === n.right;)
                r = n,
                n = n.parent;
            return n
        },
        Ih.prototype.size = function() {
            return this.size_
        };
        var Th = function() {};
        function Ph() {}
        function Lh() {
            this.array_ = [],
            arguments[0] instanceof ih && this.addAll(arguments[0])
        }
        Th.prototype.interfaces_ = function() {
            return []
        },
        Th.prototype.getClass = function() {
            return Th
        },
        Ph.prototype = new _h,
        Lh.prototype = new Ph,
        Lh.prototype.contains = function(t) {
            for (var e = 0, n = this.array_.length; e < n; e++)
                if (0 === this.array_[e].compareTo(t))
                    return !0;
            return !1
        },
        Lh.prototype.add = function(t) {
            if (this.contains(t))
                return !1;
            for (var e = 0, n = this.array_.length; e < n; e++)
                if (1 === this.array_[e].compareTo(t))
                    return this.array_.splice(e, 0, t), !0;
            return this.array_.push(t), !0
        },
        Lh.prototype.addAll = function(t) {
            for (var e = t.iterator(); e.hasNext();)
                this.add(e.next());
            return !0
        },
        Lh.prototype.remove = function(t) {
            throw new mh
        },
        Lh.prototype.size = function() {
            return this.array_.length
        },
        Lh.prototype.isEmpty = function() {
            return 0 === this.array_.length
        },
        Lh.prototype.toArray = function() {
            for (var t = [], e = 0, n = this.array_.length; e < n; e++)
                t.push(this.array_[e]);
            return t
        },
        Lh.prototype.iterator = function() {
            return new Oh(this)
        };
        var Oh = function(t) {
            this.treeSet_ = t,
            this.position_ = 0
        };
        Oh.prototype.next = function() {
            if (this.position_ === this.treeSet_.size())
                throw new uh;
            return this.treeSet_.array_[this.position_++]
        },
        Oh.prototype.hasNext = function() {
            return this.position_ < this.treeSet_.size()
        },
        Oh.prototype.remove = function() {
            throw new mh
        };
        var Nh = function() {};
        Nh.sort = function() {
            var t,
                e,
                n,
                r,
                i = arguments[0];
            if (1 === arguments.length)
                r = function(t, e) {
                    return t.compareTo(e)
                },
                i.sort(r);
            else if (2 === arguments.length)
                n = arguments[1],
                r = function(t, e) {
                    return n.compare(t, e)
                },
                i.sort(r);
            else if (3 === arguments.length) {
                (e = i.slice(arguments[1], arguments[2])).sort();
                var o = i.slice(0, arguments[1]).concat(e, i.slice(arguments[2], i.length));
                for (i.splice(0, i.length), t = 0; t < o.length; t++)
                    i.push(o[t])
            } else if (4 === arguments.length)
                for (e = i.slice(arguments[1], arguments[2]), n = arguments[3], r = function(t, e) {
                    return n.compare(t, e)
                }, e.sort(r), o = i.slice(0, arguments[1]).concat(e, i.slice(arguments[2], i.length)), i.splice(0, i.length), t = 0; t < o.length; t++)
                    i.push(o[t])
        },
        Nh.asList = function(t) {
            for (var e = new lh, n = 0, r = t.length; n < r; n++)
                e.add(t[n]);
            return e
        };
        var Rh = function() {},
            Ah = {
                P: {
                    configurable: !0
                },
                L: {
                    configurable: !0
                },
                A: {
                    configurable: !0
                },
                FALSE: {
                    configurable: !0
                },
                TRUE: {
                    configurable: !0
                },
                DONTCARE: {
                    configurable: !0
                },
                SYM_FALSE: {
                    configurable: !0
                },
                SYM_TRUE: {
                    configurable: !0
                },
                SYM_DONTCARE: {
                    configurable: !0
                },
                SYM_P: {
                    configurable: !0
                },
                SYM_L: {
                    configurable: !0
                },
                SYM_A: {
                    configurable: !0
                }
            };
        Ah.P.get = function() {
            return 0
        },
        Ah.L.get = function() {
            return 1
        },
        Ah.A.get = function() {
            return 2
        },
        Ah.FALSE.get = function() {
            return -1
        },
        Ah.TRUE.get = function() {
            return -2
        },
        Ah.DONTCARE.get = function() {
            return -3
        },
        Ah.SYM_FALSE.get = function() {
            return "F"
        },
        Ah.SYM_TRUE.get = function() {
            return "T"
        },
        Ah.SYM_DONTCARE.get = function() {
            return "*"
        },
        Ah.SYM_P.get = function() {
            return "0"
        },
        Ah.SYM_L.get = function() {
            return "1"
        },
        Ah.SYM_A.get = function() {
            return "2"
        },
        Rh.prototype.interfaces_ = function() {
            return []
        },
        Rh.prototype.getClass = function() {
            return Rh
        },
        Rh.toDimensionSymbol = function(t) {
            switch (t) {
            case Rh.FALSE:
                return Rh.SYM_FALSE;
            case Rh.TRUE:
                return Rh.SYM_TRUE;
            case Rh.DONTCARE:
                return Rh.SYM_DONTCARE;
            case Rh.P:
                return Rh.SYM_P;
            case Rh.L:
                return Rh.SYM_L;
            case Rh.A:
                return Rh.SYM_A
            }
            throw new el("Unknown dimension value: " + t)
        },
        Rh.toDimensionValue = function(t) {
            switch (_l.toUpperCase(t)) {
            case Rh.SYM_FALSE:
                return Rh.FALSE;
            case Rh.SYM_TRUE:
                return Rh.TRUE;
            case Rh.SYM_DONTCARE:
                return Rh.DONTCARE;
            case Rh.SYM_P:
                return Rh.P;
            case Rh.SYM_L:
                return Rh.L;
            case Rh.SYM_A:
                return Rh.A
            }
            throw new el("Unknown dimension symbol: " + t)
        },
        Object.defineProperties(Rh, Ah);
        var Dh = function() {};
        Dh.prototype.filter = function(t) {},
        Dh.prototype.interfaces_ = function() {
            return []
        },
        Dh.prototype.getClass = function() {
            return Dh
        };
        var Fh = function() {};
        Fh.prototype.filter = function(t, e) {},
        Fh.prototype.isDone = function() {},
        Fh.prototype.isGeometryChanged = function() {},
        Fh.prototype.interfaces_ = function() {
            return []
        },
        Fh.prototype.getClass = function() {
            return Fh
        };
        var kh = function(t) {
                function e(e, n) {
                    if (t.call(this, n), this._geometries = e || [], t.hasNullElements(this._geometries))
                        throw new el("geometries must not contain null elements")
                }
                t && (e.__proto__ = t),
                e.prototype = Object.create(t && t.prototype),
                e.prototype.constructor = e;
                var n = {
                    serialVersionUID: {
                        configurable: !0
                    }
                };
                return e.prototype.computeEnvelopeInternal = function() {
                    for (var t = new Ll, e = 0; e < this._geometries.length; e++)
                        t.expandToInclude(this._geometries[e].getEnvelopeInternal());
                    return t
                }, e.prototype.getGeometryN = function(t) {
                    return this._geometries[t]
                }, e.prototype.getSortIndex = function() {
                    return t.SORTINDEX_GEOMETRYCOLLECTION
                }, e.prototype.getCoordinates = function() {
                    for (var t = new Array(this.getNumPoints()).fill(null), e = -1, n = 0; n < this._geometries.length; n++)
                        for (var r = this._geometries[n].getCoordinates(), i = 0; i < r.length; i++)
                            t[++e] = r[i];
                    return t
                }, e.prototype.getArea = function() {
                    for (var t = 0, e = 0; e < this._geometries.length; e++)
                        t += this._geometries[e].getArea();
                    return t
                }, e.prototype.equalsExact = function() {
                    var e = this;
                    if (2 === arguments.length) {
                        var n = arguments[0],
                            r = arguments[1];
                        if (!this.isEquivalentClass(n))
                            return !1;
                        var i = n;
                        if (this._geometries.length !== i._geometries.length)
                            return !1;
                        for (var o = 0; o < this._geometries.length; o++)
                            if (!e._geometries[o].equalsExact(i._geometries[o], r))
                                return !1;
                        return !0
                    }
                    return t.prototype.equalsExact.apply(this, arguments)
                }, e.prototype.normalize = function() {
                    for (var t = 0; t < this._geometries.length; t++)
                        this._geometries[t].normalize();
                    Nh.sort(this._geometries)
                }, e.prototype.getCoordinate = function() {
                    return this.isEmpty() ? null : this._geometries[0].getCoordinate()
                }, e.prototype.getBoundaryDimension = function() {
                    for (var t = Rh.FALSE, e = 0; e < this._geometries.length; e++)
                        t = Math.max(t, this._geometries[e].getBoundaryDimension());
                    return t
                }, e.prototype.getDimension = function() {
                    for (var t = Rh.FALSE, e = 0; e < this._geometries.length; e++)
                        t = Math.max(t, this._geometries[e].getDimension());
                    return t
                }, e.prototype.getLength = function() {
                    for (var t = 0, e = 0; e < this._geometries.length; e++)
                        t += this._geometries[e].getLength();
                    return t
                }, e.prototype.getNumPoints = function() {
                    for (var t = 0, e = 0; e < this._geometries.length; e++)
                        t += this._geometries[e].getNumPoints();
                    return t
                }, e.prototype.getNumGeometries = function() {
                    return this._geometries.length
                }, e.prototype.reverse = function() {
                    for (var t = this._geometries.length, e = new Array(t).fill(null), n = 0; n < this._geometries.length; n++)
                        e[n] = this._geometries[n].reverse();
                    return this.getFactory().createGeometryCollection(e)
                }, e.prototype.compareToSameClass = function() {
                    var t = this;
                    if (1 === arguments.length) {
                        var e = arguments[0],
                            n = new Lh(Nh.asList(this._geometries)),
                            r = new Lh(Nh.asList(e._geometries));
                        return this.compare(n, r)
                    }
                    if (2 === arguments.length) {
                        for (var i = arguments[1], o = arguments[0], s = this.getNumGeometries(), a = o.getNumGeometries(), u = 0; u < s && u < a;) {
                            var l = t.getGeometryN(u),
                                h = o.getGeometryN(u),
                                c = l.compareToSameClass(h, i);
                            if (0 !== c)
                                return c;
                            u++
                        }
                        return u < s ? 1 : u < a ? -1 : 0
                    }
                }, e.prototype.apply = function() {
                    var t = this;
                    if (dl(arguments[0], Zl))
                        for (var e = arguments[0], n = 0; n < this._geometries.length; n++)
                            t._geometries[n].apply(e);
                    else if (dl(arguments[0], Fh)) {
                        var r = arguments[0];
                        if (0 === this._geometries.length)
                            return null;
                        for (var i = 0; i < this._geometries.length && (t._geometries[i].apply(r), !r.isDone()); i++)
                            ;
                        r.isGeometryChanged() && this.geometryChanged()
                    } else if (dl(arguments[0], Dh)) {
                        var o = arguments[0];
                        o.filter(this);
                        for (var s = 0; s < this._geometries.length; s++)
                            t._geometries[s].apply(o)
                    } else if (dl(arguments[0], Yl)) {
                        var a = arguments[0];
                        a.filter(this);
                        for (var u = 0; u < this._geometries.length; u++)
                            t._geometries[u].apply(a)
                    }
                }, e.prototype.getBoundary = function() {
                    return this.checkNotGeometryCollection(this), Gl.shouldNeverReachHere(), null
                }, e.prototype.clone = function() {
                    var e = t.prototype.clone.call(this);
                    e._geometries = new Array(this._geometries.length).fill(null);
                    for (var n = 0; n < this._geometries.length; n++)
                        e._geometries[n] = this._geometries[n].clone();
                    return e
                }, e.prototype.getGeometryType = function() {
                    return "GeometryCollection"
                }, e.prototype.copy = function() {
                    for (var t = new Array(this._geometries.length).fill(null), n = 0; n < t.length; n++)
                        t[n] = this._geometries[n].copy();
                    return new e(t, this._factory)
                }, e.prototype.isEmpty = function() {
                    for (var t = 0; t < this._geometries.length; t++)
                        if (!this._geometries[t].isEmpty())
                            return !1;
                    return !0
                }, e.prototype.interfaces_ = function() {
                    return []
                }, e.prototype.getClass = function() {
                    return e
                }, n.serialVersionUID.get = function() {
                    return -0x4f07bcb1f857d800
                }, Object.defineProperties(e, n), e
            }(Wl),
            jh = function(t) {
                function e() {
                    t.apply(this, arguments)
                }
                t && (e.__proto__ = t),
                e.prototype = Object.create(t && t.prototype),
                e.prototype.constructor = e;
                var n = {
                    serialVersionUID: {
                        configurable: !0
                    }
                };
                return e.prototype.getSortIndex = function() {
                    return Wl.SORTINDEX_MULTILINESTRING
                }, e.prototype.equalsExact = function() {
                    if (2 === arguments.length) {
                        var e = arguments[0],
                            n = arguments[1];
                        return !!this.isEquivalentClass(e) && t.prototype.equalsExact.call(this, e, n)
                    }
                    return t.prototype.equalsExact.apply(this, arguments)
                }, e.prototype.getBoundaryDimension = function() {
                    return this.isClosed() ? Rh.FALSE : 0
                }, e.prototype.isClosed = function() {
                    if (this.isEmpty())
                        return !1;
                    for (var t = 0; t < this._geometries.length; t++)
                        if (!this._geometries[t].isClosed())
                            return !1;
                    return !0
                }, e.prototype.getDimension = function() {
                    return 1
                }, e.prototype.reverse = function() {
                    for (var t = this._geometries.length, e = new Array(t).fill(null), n = 0; n < this._geometries.length; n++)
                        e[t - 1 - n] = this._geometries[n].reverse();
                    return this.getFactory().createMultiLineString(e)
                }, e.prototype.getBoundary = function() {
                    return new Gh(this).getBoundary()
                }, e.prototype.getGeometryType = function() {
                    return "MultiLineString"
                }, e.prototype.copy = function() {
                    for (var t = new Array(this._geometries.length).fill(null), n = 0; n < t.length; n++)
                        t[n] = this._geometries[n].copy();
                    return new e(t, this._factory)
                }, e.prototype.interfaces_ = function() {
                    return [Th]
                }, e.prototype.getClass = function() {
                    return e
                }, n.serialVersionUID.get = function() {
                    return 0x7155d2ab4afa8000
                }, Object.defineProperties(e, n), e
            }(kh),
            Gh = function() {
                if (this._geom = null, this._geomFact = null, this._bnRule = null, this._endpointMap = null, 1 === arguments.length) {
                    var t = arguments[0],
                        e = Jl.MOD2_BOUNDARY_RULE;
                    this._geom = t,
                    this._geomFact = t.getFactory(),
                    this._bnRule = e
                } else if (2 === arguments.length) {
                    var n = arguments[0],
                        r = arguments[1];
                    this._geom = n,
                    this._geomFact = n.getFactory(),
                    this._bnRule = r
                }
            };
        Gh.prototype.boundaryMultiLineString = function(t) {
            if (this._geom.isEmpty())
                return this.getEmptyMultiPoint();
            var e = this.computeBoundaryCoordinates(t);
            return 1 === e.length ? this._geomFact.createPoint(e[0]) : this._geomFact.createMultiPointFromCoords(e)
        },
        Gh.prototype.getBoundary = function() {
            return this._geom instanceof Kh ? this.boundaryLineString(this._geom) : this._geom instanceof jh ? this.boundaryMultiLineString(this._geom) : this._geom.getBoundary()
        },
        Gh.prototype.boundaryLineString = function(t) {
            return this._geom.isEmpty() ? this.getEmptyMultiPoint() : t.isClosed() ? this._bnRule.isInBoundary(2) ? t.getStartPoint() : this._geomFact.createMultiPoint() : this._geomFact.createMultiPoint([t.getStartPoint(), t.getEndPoint()])
        },
        Gh.prototype.getEmptyMultiPoint = function() {
            return this._geomFact.createMultiPoint()
        },
        Gh.prototype.computeBoundaryCoordinates = function(t) {
            var e = this,
                n = new lh;
            this._endpointMap = new Ih;
            for (var r = 0; r < t.getNumGeometries(); r++) {
                var i = t.getGeometryN(r);
                0 !== i.getNumPoints() && (e.addEndpoint(i.getCoordinateN(0)), e.addEndpoint(i.getCoordinateN(i.getNumPoints() - 1)))
            }
            for (var o = this._endpointMap.entrySet().iterator(); o.hasNext();) {
                var s = o.next(),
                    a = s.getValue().count;
                e._bnRule.isInBoundary(a) && n.add(s.getKey())
            }
            return ph.toCoordinateArray(n)
        },
        Gh.prototype.addEndpoint = function(t) {
            var e = this._endpointMap.get(t);
            null === e && (e = new Bh, this._endpointMap.put(t, e)),
            e.count++
        },
        Gh.prototype.interfaces_ = function() {
            return []
        },
        Gh.prototype.getClass = function() {
            return Gh
        },
        Gh.getBoundary = function() {
            return 1 === arguments.length ? new Gh(arguments[0]).getBoundary() : 2 === arguments.length ? new Gh(arguments[0], arguments[1]).getBoundary() : void 0
        };
        var Bh = function() {
            this.count = null
        };
        function qh() {}
        function zh() {}
        Bh.prototype.interfaces_ = function() {
            return []
        },
        Bh.prototype.getClass = function() {
            return Bh
        };
        var Uh = function() {};
        function Vh() {}
        function Xh() {}
        function Hh() {}
        var Yh = function() {},
            Wh = {
                NEWLINE: {
                    configurable: !0
                },
                SIMPLE_ORDINATE_FORMAT: {
                    configurable: !0
                }
            };
        Yh.prototype.interfaces_ = function() {
            return []
        },
        Yh.prototype.getClass = function() {
            return Yh
        },
        Yh.chars = function(t, e) {
            for (var n = new Array(e).fill(null), r = 0; r < e; r++)
                n[r] = t;
            return String(n)
        },
        Yh.getStackTrace = function() {
            if (1 === arguments.length) {
                var t = arguments[0],
                    e = new Vh,
                    n = new qh(e);
                return t.printStackTrace(n), e.toString()
            }
            if (2 === arguments.length) {
                for (var r = arguments[0], i = arguments[1], o = "", s = new Hh(new zh(Yh.getStackTrace(r))), a = 0; a < i; a++)
                    try {
                        o += s.readLine() + Yh.NEWLINE
                    } catch (t) {
                        if (!(t instanceof Xh))
                            throw t;
                        Gl.shouldNeverReachHere()
                    }
                return o
            }
        },
        Yh.split = function(t, e) {
            for (var n = e.length, r = new lh, i = "" + t, o = i.indexOf(e); o >= 0;) {
                var s = i.substring(0, o);
                r.add(s),
                o = (i = i.substring(o + n)).indexOf(e)
            }
            i.length > 0 && r.add(i);
            for (var a = new Array(r.size()).fill(null), u = 0; u < a.length; u++)
                a[u] = r.get(u);
            return a
        },
        Yh.toString = function() {
            if (1 === arguments.length) {
                var t = arguments[0];
                return Yh.SIMPLE_ORDINATE_FORMAT.format(t)
            }
        },
        Yh.spaces = function(t) {
            return Yh.chars(" ", t)
        },
        Wh.NEWLINE.get = function() {
            return Tl.getProperty("line.separator")
        },
        Wh.SIMPLE_ORDINATE_FORMAT.get = function() {
            return new Uh("0.#")
        },
        Object.defineProperties(Yh, Wh);
        var $h = function() {};
        $h.prototype.interfaces_ = function() {
            return []
        },
        $h.prototype.getClass = function() {
            return $h
        },
        $h.copyCoord = function(t, e, n, r) {
            for (var i = Math.min(t.getDimension(), n.getDimension()), o = 0; o < i; o++)
                n.setOrdinate(r, o, t.getOrdinate(e, o))
        },
        $h.isRing = function(t) {
            var e = t.size();
            return 0 === e || !(e <= 3) && t.getOrdinate(0, Cl.X) === t.getOrdinate(e - 1, Cl.X) && t.getOrdinate(0, Cl.Y) === t.getOrdinate(e - 1, Cl.Y)
        },
        $h.isEqual = function(t, e) {
            var n = t.size();
            if (n !== e.size())
                return !1;
            for (var r = Math.min(t.getDimension(), e.getDimension()), i = 0; i < n; i++)
                for (var o = 0; o < r; o++) {
                    var s = t.getOrdinate(i, o),
                        a = e.getOrdinate(i, o);
                    if (!(t.getOrdinate(i, o) === e.getOrdinate(i, o) || nl.isNaN(s) && nl.isNaN(a)))
                        return !1
                }
            return !0
        },
        $h.extend = function(t, e, n) {
            var r = t.create(n, e.getDimension()),
                i = e.size();
            if ($h.copy(e, 0, r, 0, i), i > 0)
                for (var o = i; o < n; o++)
                    $h.copy(e, i - 1, r, o, 1);
            return r
        },
        $h.reverse = function(t) {
            for (var e = t.size() - 1, n = Math.trunc(e / 2), r = 0; r <= n; r++)
                $h.swap(t, r, e - r)
        },
        $h.swap = function(t, e, n) {
            if (e === n)
                return null;
            for (var r = 0; r < t.getDimension(); r++) {
                var i = t.getOrdinate(e, r);
                t.setOrdinate(e, r, t.getOrdinate(n, r)),
                t.setOrdinate(n, r, i)
            }
        },
        $h.copy = function(t, e, n, r, i) {
            for (var o = 0; o < i; o++)
                $h.copyCoord(t, e + o, n, r + o)
        },
        $h.toString = function() {
            if (1 === arguments.length) {
                var t = arguments[0],
                    e = t.size();
                if (0 === e)
                    return "()";
                var n = t.getDimension(),
                    r = new vl;
                r.append("(");
                for (var i = 0; i < e; i++) {
                    i > 0 && r.append(" ");
                    for (var o = 0; o < n; o++)
                        o > 0 && r.append(","),
                        r.append(Yh.toString(t.getOrdinate(i, o)))
                }
                return r.append(")"), r.toString()
            }
        },
        $h.ensureValidRing = function(t, e) {
            var n = e.size();
            return 0 === n ? e : n <= 3 ? $h.createClosedRing(t, e, 4) : e.getOrdinate(0, Cl.X) === e.getOrdinate(n - 1, Cl.X) && e.getOrdinate(0, Cl.Y) === e.getOrdinate(n - 1, Cl.Y) ? e : $h.createClosedRing(t, e, n + 1)
        },
        $h.createClosedRing = function(t, e, n) {
            var r = t.create(n, e.getDimension()),
                i = e.size();
            $h.copy(e, 0, r, 0, i);
            for (var o = i; o < n; o++)
                $h.copy(e, 0, r, o, 1);
            return r
        };
        var Kh = function(t) {
                function e(e, n) {
                    t.call(this, n),
                    this._points = null,
                    this.init(e)
                }
                t && (e.__proto__ = t),
                e.prototype = Object.create(t && t.prototype),
                e.prototype.constructor = e;
                var n = {
                    serialVersionUID: {
                        configurable: !0
                    }
                };
                return e.prototype.computeEnvelopeInternal = function() {
                    return this.isEmpty() ? new Ll : this._points.expandEnvelope(new Ll)
                }, e.prototype.isRing = function() {
                    return this.isClosed() && this.isSimple()
                }, e.prototype.getSortIndex = function() {
                    return t.SORTINDEX_LINESTRING
                }, e.prototype.getCoordinates = function() {
                    return this._points.toCoordinateArray()
                }, e.prototype.equalsExact = function() {
                    var e = this;
                    if (2 === arguments.length) {
                        var n = arguments[0],
                            r = arguments[1];
                        if (!this.isEquivalentClass(n))
                            return !1;
                        var i = n;
                        if (this._points.size() !== i._points.size())
                            return !1;
                        for (var o = 0; o < this._points.size(); o++)
                            if (!e.equal(e._points.getCoordinate(o), i._points.getCoordinate(o), r))
                                return !1;
                        return !0
                    }
                    return t.prototype.equalsExact.apply(this, arguments)
                }, e.prototype.normalize = function() {
                    for (var t = this, e = 0; e < Math.trunc(this._points.size() / 2); e++) {
                        var n = t._points.size() - 1 - e;
                        if (!t._points.getCoordinate(e).equals(t._points.getCoordinate(n)))
                            return t._points.getCoordinate(e).compareTo(t._points.getCoordinate(n)) > 0 && $h.reverse(t._points), null
                    }
                }, e.prototype.getCoordinate = function() {
                    return this.isEmpty() ? null : this._points.getCoordinate(0)
                }, e.prototype.getBoundaryDimension = function() {
                    return this.isClosed() ? Rh.FALSE : 0
                }, e.prototype.isClosed = function() {
                    return !this.isEmpty() && this.getCoordinateN(0).equals2D(this.getCoordinateN(this.getNumPoints() - 1))
                }, e.prototype.getEndPoint = function() {
                    return this.isEmpty() ? null : this.getPointN(this.getNumPoints() - 1)
                }, e.prototype.getDimension = function() {
                    return 1
                }, e.prototype.getLength = function() {
                    return Xl.computeLength(this._points)
                }, e.prototype.getNumPoints = function() {
                    return this._points.size()
                }, e.prototype.reverse = function() {
                    var t = this._points.copy();
                    return $h.reverse(t), this.getFactory().createLineString(t)
                }, e.prototype.compareToSameClass = function() {
                    var t = this;
                    if (1 === arguments.length) {
                        for (var e = arguments[0], n = 0, r = 0; n < this._points.size() && r < e._points.size();) {
                            var i = t._points.getCoordinate(n).compareTo(e._points.getCoordinate(r));
                            if (0 !== i)
                                return i;
                            n++,
                            r++
                        }
                        return n < this._points.size() ? 1 : r < e._points.size() ? -1 : 0
                    }
                    if (2 === arguments.length) {
                        var o = arguments[0];
                        return arguments[1].compare(this._points, o._points)
                    }
                }, e.prototype.apply = function() {
                    var t = this;
                    if (dl(arguments[0], Zl))
                        for (var e = arguments[0], n = 0; n < this._points.size(); n++)
                            e.filter(t._points.getCoordinate(n));
                    else if (dl(arguments[0], Fh)) {
                        var r = arguments[0];
                        if (0 === this._points.size())
                            return null;
                        for (var i = 0; i < this._points.size() && (r.filter(t._points, i), !r.isDone()); i++)
                            ;
                        r.isGeometryChanged() && this.geometryChanged()
                    } else
                        (dl(arguments[0], Dh) || dl(arguments[0], Yl)) && arguments[0].filter(this)
                }, e.prototype.getBoundary = function() {
                    return new Gh(this).getBoundary()
                }, e.prototype.isEquivalentClass = function(t) {
                    return t instanceof e
                }, e.prototype.clone = function() {
                    var e = t.prototype.clone.call(this);
                    return e._points = this._points.clone(), e
                }, e.prototype.getCoordinateN = function(t) {
                    return this._points.getCoordinate(t)
                }, e.prototype.getGeometryType = function() {
                    return "LineString"
                }, e.prototype.copy = function() {
                    return new e(this._points.copy(), this._factory)
                }, e.prototype.getCoordinateSequence = function() {
                    return this._points
                }, e.prototype.isEmpty = function() {
                    return 0 === this._points.size()
                }, e.prototype.init = function(t) {
                    if (null === t && (t = this.getFactory().getCoordinateSequenceFactory().create([])), 1 === t.size())
                        throw new el("Invalid number of points in LineString (found " + t.size() + " - must be 0 or >= 2)");
                    this._points = t
                }, e.prototype.isCoordinate = function(t) {
                    for (var e = 0; e < this._points.size(); e++)
                        if (this._points.getCoordinate(e).equals(t))
                            return !0;
                    return !1
                }, e.prototype.getStartPoint = function() {
                    return this.isEmpty() ? null : this.getPointN(0)
                }, e.prototype.getPointN = function(t) {
                    return this.getFactory().createPoint(this._points.getCoordinate(t))
                }, e.prototype.interfaces_ = function() {
                    return [Th]
                }, e.prototype.getClass = function() {
                    return e
                }, n.serialVersionUID.get = function() {
                    return 0x2b2b51ba435c8e00
                }, Object.defineProperties(e, n), e
            }(Wl),
            Zh = function() {};
        Zh.prototype.interfaces_ = function() {
            return []
        },
        Zh.prototype.getClass = function() {
            return Zh
        };
        var Jh = function(t) {
                function e(e, n) {
                    t.call(this, n),
                    this._coordinates = e || null,
                    this.init(this._coordinates)
                }
                t && (e.__proto__ = t),
                e.prototype = Object.create(t && t.prototype),
                e.prototype.constructor = e;
                var n = {
                    serialVersionUID: {
                        configurable: !0
                    }
                };
                return e.prototype.computeEnvelopeInternal = function() {
                    if (this.isEmpty())
                        return new Ll;
                    var t = new Ll;
                    return t.expandToInclude(this._coordinates.getX(0), this._coordinates.getY(0)), t
                }, e.prototype.getSortIndex = function() {
                    return t.SORTINDEX_POINT
                }, e.prototype.getCoordinates = function() {
                    return this.isEmpty() ? [] : [this.getCoordinate()]
                }, e.prototype.equalsExact = function() {
                    if (2 === arguments.length) {
                        var e = arguments[0],
                            n = arguments[1];
                        return !!this.isEquivalentClass(e) && (!(!this.isEmpty() || !e.isEmpty()) || this.isEmpty() === e.isEmpty() && this.equal(e.getCoordinate(), this.getCoordinate(), n))
                    }
                    return t.prototype.equalsExact.apply(this, arguments)
                }, e.prototype.normalize = function() {}, e.prototype.getCoordinate = function() {
                    return 0 !== this._coordinates.size() ? this._coordinates.getCoordinate(0) : null
                }, e.prototype.getBoundaryDimension = function() {
                    return Rh.FALSE
                }, e.prototype.getDimension = function() {
                    return 0
                }, e.prototype.getNumPoints = function() {
                    return this.isEmpty() ? 0 : 1
                }, e.prototype.reverse = function() {
                    return this.copy()
                }, e.prototype.getX = function() {
                    if (null === this.getCoordinate())
                        throw new Error("getX called on empty Point");
                    return this.getCoordinate().x
                }, e.prototype.compareToSameClass = function() {
                    if (1 === arguments.length) {
                        var t = arguments[0];
                        return this.getCoordinate().compareTo(t.getCoordinate())
                    }
                    if (2 === arguments.length) {
                        var e = arguments[0];
                        return arguments[1].compare(this._coordinates, e._coordinates)
                    }
                }, e.prototype.apply = function() {
                    if (dl(arguments[0], Zl)) {
                        var t = arguments[0];
                        if (this.isEmpty())
                            return null;
                        t.filter(this.getCoordinate())
                    } else if (dl(arguments[0], Fh)) {
                        var e = arguments[0];
                        if (this.isEmpty())
                            return null;
                        e.filter(this._coordinates, 0),
                        e.isGeometryChanged() && this.geometryChanged()
                    } else
                        (dl(arguments[0], Dh) || dl(arguments[0], Yl)) && arguments[0].filter(this)
                }, e.prototype.getBoundary = function() {
                    return this.getFactory().createGeometryCollection(null)
                }, e.prototype.clone = function() {
                    var e = t.prototype.clone.call(this);
                    return e._coordinates = this._coordinates.clone(), e
                }, e.prototype.getGeometryType = function() {
                    return "Point"
                }, e.prototype.copy = function() {
                    return new e(this._coordinates.copy(), this._factory)
                }, e.prototype.getCoordinateSequence = function() {
                    return this._coordinates
                }, e.prototype.getY = function() {
                    if (null === this.getCoordinate())
                        throw new Error("getY called on empty Point");
                    return this.getCoordinate().y
                }, e.prototype.isEmpty = function() {
                    return 0 === this._coordinates.size()
                }, e.prototype.init = function(t) {
                    null === t && (t = this.getFactory().getCoordinateSequenceFactory().create([])),
                    Gl.isTrue(t.size() <= 1),
                    this._coordinates = t
                }, e.prototype.isSimple = function() {
                    return !0
                }, e.prototype.interfaces_ = function() {
                    return [Zh]
                }, e.prototype.getClass = function() {
                    return e
                }, n.serialVersionUID.get = function() {
                    return 0x44077bad161cbc00
                }, Object.defineProperties(e, n), e
            }(Wl),
            Qh = function() {};
        Qh.prototype.interfaces_ = function() {
            return []
        },
        Qh.prototype.getClass = function() {
            return Qh
        };
        var tc = function(t) {
                function e(e, n, r) {
                    if (t.call(this, r), this._shell = null, this._holes = null, null === e && (e = this.getFactory().createLinearRing()), null === n && (n = []), t.hasNullElements(n))
                        throw new el("holes must not contain null elements");
                    if (e.isEmpty() && t.hasNonEmptyElements(n))
                        throw new el("shell is empty but holes are not");
                    this._shell = e,
                    this._holes = n
                }
                t && (e.__proto__ = t),
                e.prototype = Object.create(t && t.prototype),
                e.prototype.constructor = e;
                var n = {
                    serialVersionUID: {
                        configurable: !0
                    }
                };
                return e.prototype.computeEnvelopeInternal = function() {
                    return this._shell.getEnvelopeInternal()
                }, e.prototype.getSortIndex = function() {
                    return t.SORTINDEX_POLYGON
                }, e.prototype.getCoordinates = function() {
                    if (this.isEmpty())
                        return [];
                    for (var t = new Array(this.getNumPoints()).fill(null), e = -1, n = this._shell.getCoordinates(), r = 0; r < n.length; r++)
                        t[++e] = n[r];
                    for (var i = 0; i < this._holes.length; i++)
                        for (var o = this._holes[i].getCoordinates(), s = 0; s < o.length; s++)
                            t[++e] = o[s];
                    return t
                }, e.prototype.getArea = function() {
                    var t = 0;
                    t += Math.abs(Xl.signedArea(this._shell.getCoordinateSequence()));
                    for (var e = 0; e < this._holes.length; e++)
                        t -= Math.abs(Xl.signedArea(this._holes[e].getCoordinateSequence()));
                    return t
                }, e.prototype.isRectangle = function() {
                    if (0 !== this.getNumInteriorRing())
                        return !1;
                    if (null === this._shell)
                        return !1;
                    if (5 !== this._shell.getNumPoints())
                        return !1;
                    for (var t = this._shell.getCoordinateSequence(), e = this.getEnvelopeInternal(), n = 0; n < 5; n++) {
                        var r = t.getX(n);
                        if (r !== e.getMinX() && r !== e.getMaxX())
                            return !1;
                        var i = t.getY(n);
                        if (i !== e.getMinY() && i !== e.getMaxY())
                            return !1
                    }
                    for (var o = t.getX(0), s = t.getY(0), a = 1; a <= 4; a++) {
                        var u = t.getX(a),
                            l = t.getY(a);
                        if (u !== o == (l !== s))
                            return !1;
                        o = u,
                        s = l
                    }
                    return !0
                }, e.prototype.equalsExact = function() {
                    var e = this;
                    if (2 === arguments.length) {
                        var n = arguments[0],
                            r = arguments[1];
                        if (!this.isEquivalentClass(n))
                            return !1;
                        var i = n,
                            o = this._shell,
                            s = i._shell;
                        if (!o.equalsExact(s, r))
                            return !1;
                        if (this._holes.length !== i._holes.length)
                            return !1;
                        for (var a = 0; a < this._holes.length; a++)
                            if (!e._holes[a].equalsExact(i._holes[a], r))
                                return !1;
                        return !0
                    }
                    return t.prototype.equalsExact.apply(this, arguments)
                }, e.prototype.normalize = function() {
                    var t = this;
                    if (0 === arguments.length) {
                        this.normalize(this._shell, !0);
                        for (var e = 0; e < this._holes.length; e++)
                            t.normalize(t._holes[e], !1);
                        Nh.sort(this._holes)
                    } else if (2 === arguments.length) {
                        var n = arguments[0],
                            r = arguments[1];
                        if (n.isEmpty())
                            return null;
                        var i = new Array(n.getCoordinates().length - 1).fill(null);
                        Tl.arraycopy(n.getCoordinates(), 0, i, 0, i.length);
                        var o = ph.minCoordinate(n.getCoordinates());
                        ph.scroll(i, o),
                        Tl.arraycopy(i, 0, n.getCoordinates(), 0, i.length),
                        n.getCoordinates()[i.length] = i[0],
                        Xl.isCCW(n.getCoordinates()) === r && ph.reverse(n.getCoordinates())
                    }
                }, e.prototype.getCoordinate = function() {
                    return this._shell.getCoordinate()
                }, e.prototype.getNumInteriorRing = function() {
                    return this._holes.length
                }, e.prototype.getBoundaryDimension = function() {
                    return 1
                }, e.prototype.getDimension = function() {
                    return 2
                }, e.prototype.getLength = function() {
                    var t = 0;
                    t += this._shell.getLength();
                    for (var e = 0; e < this._holes.length; e++)
                        t += this._holes[e].getLength();
                    return t
                }, e.prototype.getNumPoints = function() {
                    for (var t = this._shell.getNumPoints(), e = 0; e < this._holes.length; e++)
                        t += this._holes[e].getNumPoints();
                    return t
                }, e.prototype.reverse = function() {
                    var t = this.copy();
                    t._shell = this._shell.copy().reverse(),
                    t._holes = new Array(this._holes.length).fill(null);
                    for (var e = 0; e < this._holes.length; e++)
                        t._holes[e] = this._holes[e].copy().reverse();
                    return t
                }, e.prototype.convexHull = function() {
                    return this.getExteriorRing().convexHull()
                }, e.prototype.compareToSameClass = function() {
                    var t = this;
                    if (1 === arguments.length) {
                        var e = arguments[0],
                            n = this._shell,
                            r = e._shell;
                        return n.compareToSameClass(r)
                    }
                    if (2 === arguments.length) {
                        var i = arguments[1],
                            o = arguments[0],
                            s = this._shell,
                            a = o._shell,
                            u = s.compareToSameClass(a, i);
                        if (0 !== u)
                            return u;
                        for (var l = this.getNumInteriorRing(), h = o.getNumInteriorRing(), c = 0; c < l && c < h;) {
                            var p = t.getInteriorRingN(c),
                                f = o.getInteriorRingN(c),
                                d = p.compareToSameClass(f, i);
                            if (0 !== d)
                                return d;
                            c++
                        }
                        return c < l ? 1 : c < h ? -1 : 0
                    }
                }, e.prototype.apply = function(t) {
                    var e = this;
                    if (dl(t, Zl)) {
                        this._shell.apply(t);
                        for (var n = 0; n < this._holes.length; n++)
                            e._holes[n].apply(t)
                    } else if (dl(t, Fh)) {
                        if (this._shell.apply(t), !t.isDone())
                            for (var r = 0; r < this._holes.length && (e._holes[r].apply(t), !t.isDone()); r++)
                                ;
                        t.isGeometryChanged() && this.geometryChanged()
                    } else if (dl(t, Dh))
                        t.filter(this);
                    else if (dl(t, Yl)) {
                        t.filter(this),
                        this._shell.apply(t);
                        for (var i = 0; i < this._holes.length; i++)
                            e._holes[i].apply(t)
                    }
                }, e.prototype.getBoundary = function() {
                    if (this.isEmpty())
                        return this.getFactory().createMultiLineString();
                    var t = new Array(this._holes.length + 1).fill(null);
                    t[0] = this._shell;
                    for (var e = 0; e < this._holes.length; e++)
                        t[e + 1] = this._holes[e];
                    return t.length <= 1 ? this.getFactory().createLinearRing(t[0].getCoordinateSequence()) : this.getFactory().createMultiLineString(t)
                }, e.prototype.clone = function() {
                    var e = t.prototype.clone.call(this);
                    e._shell = this._shell.clone(),
                    e._holes = new Array(this._holes.length).fill(null);
                    for (var n = 0; n < this._holes.length; n++)
                        e._holes[n] = this._holes[n].clone();
                    return e
                }, e.prototype.getGeometryType = function() {
                    return "Polygon"
                }, e.prototype.copy = function() {
                    for (var t = this._shell.copy(), n = new Array(this._holes.length).fill(null), r = 0; r < n.length; r++)
                        n[r] = this._holes[r].copy();
                    return new e(t, n, this._factory)
                }, e.prototype.getExteriorRing = function() {
                    return this._shell
                }, e.prototype.isEmpty = function() {
                    return this._shell.isEmpty()
                }, e.prototype.getInteriorRingN = function(t) {
                    return this._holes[t]
                }, e.prototype.interfaces_ = function() {
                    return [Qh]
                }, e.prototype.getClass = function() {
                    return e
                }, n.serialVersionUID.get = function() {
                    return -0x307ffefd8dc97200
                }, Object.defineProperties(e, n), e
            }(Wl),
            ec = function(t) {
                function e() {
                    t.apply(this, arguments)
                }
                t && (e.__proto__ = t),
                e.prototype = Object.create(t && t.prototype),
                e.prototype.constructor = e;
                var n = {
                    serialVersionUID: {
                        configurable: !0
                    }
                };
                return e.prototype.getSortIndex = function() {
                    return Wl.SORTINDEX_MULTIPOINT
                }, e.prototype.isValid = function() {
                    return !0
                }, e.prototype.equalsExact = function() {
                    if (2 === arguments.length) {
                        var e = arguments[0],
                            n = arguments[1];
                        return !!this.isEquivalentClass(e) && t.prototype.equalsExact.call(this, e, n)
                    }
                    return t.prototype.equalsExact.apply(this, arguments)
                }, e.prototype.getCoordinate = function() {
                    if (1 === arguments.length) {
                        var e = arguments[0];
                        return this._geometries[e].getCoordinate()
                    }
                    return t.prototype.getCoordinate.apply(this, arguments)
                }, e.prototype.getBoundaryDimension = function() {
                    return Rh.FALSE
                }, e.prototype.getDimension = function() {
                    return 0
                }, e.prototype.getBoundary = function() {
                    return this.getFactory().createGeometryCollection(null)
                }, e.prototype.getGeometryType = function() {
                    return "MultiPoint"
                }, e.prototype.copy = function() {
                    for (var t = new Array(this._geometries.length).fill(null), n = 0; n < t.length; n++)
                        t[n] = this._geometries[n].copy();
                    return new e(t, this._factory)
                }, e.prototype.interfaces_ = function() {
                    return [Zh]
                }, e.prototype.getClass = function() {
                    return e
                }, n.serialVersionUID.get = function() {
                    return -0x6fb1ed4162e0fc00
                }, Object.defineProperties(e, n), e
            }(kh),
            nc = function(t) {
                function e(e, n) {
                    e instanceof ul && n instanceof mc && (e = n.getCoordinateSequenceFactory().create(e)),
                    t.call(this, e, n),
                    this.validateConstruction()
                }
                t && (e.__proto__ = t),
                e.prototype = Object.create(t && t.prototype),
                e.prototype.constructor = e;
                var n = {
                    MINIMUM_VALID_SIZE: {
                        configurable: !0
                    },
                    serialVersionUID: {
                        configurable: !0
                    }
                };
                return e.prototype.getSortIndex = function() {
                    return Wl.SORTINDEX_LINEARRING
                }, e.prototype.getBoundaryDimension = function() {
                    return Rh.FALSE
                }, e.prototype.isClosed = function() {
                    return !!this.isEmpty() || t.prototype.isClosed.call(this)
                }, e.prototype.reverse = function() {
                    var t = this._points.copy();
                    return $h.reverse(t), this.getFactory().createLinearRing(t)
                }, e.prototype.validateConstruction = function() {
                    if (!this.isEmpty() && !t.prototype.isClosed.call(this))
                        throw new el("Points of LinearRing do not form a closed linestring");
                    if (this.getCoordinateSequence().size() >= 1 && this.getCoordinateSequence().size() < e.MINIMUM_VALID_SIZE)
                        throw new el("Invalid number of points in LinearRing (found " + this.getCoordinateSequence().size() + " - must be 0 or >= 4)")
                }, e.prototype.getGeometryType = function() {
                    return "LinearRing"
                }, e.prototype.copy = function() {
                    return new e(this._points.copy(), this._factory)
                }, e.prototype.interfaces_ = function() {
                    return []
                }, e.prototype.getClass = function() {
                    return e
                }, n.MINIMUM_VALID_SIZE.get = function() {
                    return 4
                }, n.serialVersionUID.get = function() {
                    return -0x3b229e262367a600
                }, Object.defineProperties(e, n), e
            }(Kh),
            rc = function(t) {
                function e() {
                    t.apply(this, arguments)
                }
                t && (e.__proto__ = t),
                e.prototype = Object.create(t && t.prototype),
                e.prototype.constructor = e;
                var n = {
                    serialVersionUID: {
                        configurable: !0
                    }
                };
                return e.prototype.getSortIndex = function() {
                    return Wl.SORTINDEX_MULTIPOLYGON
                }, e.prototype.equalsExact = function() {
                    if (2 === arguments.length) {
                        var e = arguments[0],
                            n = arguments[1];
                        return !!this.isEquivalentClass(e) && t.prototype.equalsExact.call(this, e, n)
                    }
                    return t.prototype.equalsExact.apply(this, arguments)
                }, e.prototype.getBoundaryDimension = function() {
                    return 1
                }, e.prototype.getDimension = function() {
                    return 2
                }, e.prototype.reverse = function() {
                    for (var t = this._geometries.length, e = new Array(t).fill(null), n = 0; n < this._geometries.length; n++)
                        e[n] = this._geometries[n].reverse();
                    return this.getFactory().createMultiPolygon(e)
                }, e.prototype.getBoundary = function() {
                    if (this.isEmpty())
                        return this.getFactory().createMultiLineString();
                    for (var t = new lh, e = 0; e < this._geometries.length; e++)
                        for (var n = this._geometries[e].getBoundary(), r = 0; r < n.getNumGeometries(); r++)
                            t.add(n.getGeometryN(r));
                    var i = new Array(t.size()).fill(null);
                    return this.getFactory().createMultiLineString(t.toArray(i))
                }, e.prototype.getGeometryType = function() {
                    return "MultiPolygon"
                }, e.prototype.copy = function() {
                    for (var t = new Array(this._geometries.length).fill(null), n = 0; n < t.length; n++)
                        t[n] = this._geometries[n].copy();
                    return new e(t, this._factory)
                }, e.prototype.interfaces_ = function() {
                    return [Qh]
                }, e.prototype.getClass = function() {
                    return e
                }, n.serialVersionUID.get = function() {
                    return -0x7a5aa1369171980
                }, Object.defineProperties(e, n), e
            }(kh),
            ic = function(t) {
                this._factory = t || null,
                this._isUserDataCopied = !1
            },
            oc = {
                NoOpGeometryOperation: {
                    configurable: !0
                },
                CoordinateOperation: {
                    configurable: !0
                },
                CoordinateSequenceOperation: {
                    configurable: !0
                }
            };
        ic.prototype.setCopyUserData = function(t) {
            this._isUserDataCopied = t
        },
        ic.prototype.edit = function(t, e) {
            if (null === t)
                return null;
            var n = this.editInternal(t, e);
            return this._isUserDataCopied && n.setUserData(t.getUserData()), n
        },
        ic.prototype.editInternal = function(t, e) {
            return null === this._factory && (this._factory = t.getFactory()), t instanceof kh ? this.editGeometryCollection(t, e) : t instanceof tc ? this.editPolygon(t, e) : t instanceof Jh || t instanceof Kh ? e.edit(t, this._factory) : (Gl.shouldNeverReachHere("Unsupported Geometry class: " + t.getClass().getName()), null)
        },
        ic.prototype.editGeometryCollection = function(t, e) {
            for (var n = e.edit(t, this._factory), r = new lh, i = 0; i < n.getNumGeometries(); i++) {
                var o = this.edit(n.getGeometryN(i), e);
                null === o || o.isEmpty() || r.add(o)
            }
            return n.getClass() === ec ? this._factory.createMultiPoint(r.toArray([])) : n.getClass() === jh ? this._factory.createMultiLineString(r.toArray([])) : n.getClass() === rc ? this._factory.createMultiPolygon(r.toArray([])) : this._factory.createGeometryCollection(r.toArray([]))
        },
        ic.prototype.editPolygon = function(t, e) {
            var n = e.edit(t, this._factory);
            if (null === n && (n = this._factory.createPolygon(null)), n.isEmpty())
                return n;
            var r = this.edit(n.getExteriorRing(), e);
            if (null === r || r.isEmpty())
                return this._factory.createPolygon();
            for (var i = new lh, o = 0; o < n.getNumInteriorRing(); o++) {
                var s = this.edit(n.getInteriorRingN(o), e);
                null === s || s.isEmpty() || i.add(s)
            }
            return this._factory.createPolygon(r, i.toArray([]))
        },
        ic.prototype.interfaces_ = function() {
            return []
        },
        ic.prototype.getClass = function() {
            return ic
        },
        ic.GeometryEditorOperation = function() {},
        oc.NoOpGeometryOperation.get = function() {
            return sc
        },
        oc.CoordinateOperation.get = function() {
            return ac
        },
        oc.CoordinateSequenceOperation.get = function() {
            return uc
        },
        Object.defineProperties(ic, oc);
        var sc = function() {};
        sc.prototype.edit = function(t, e) {
            return t
        },
        sc.prototype.interfaces_ = function() {
            return [ic.GeometryEditorOperation]
        },
        sc.prototype.getClass = function() {
            return sc
        };
        var ac = function() {};
        ac.prototype.edit = function(t, e) {
            var n = this.editCoordinates(t.getCoordinates(), t);
            return null === n ? t : t instanceof nc ? e.createLinearRing(n) : t instanceof Kh ? e.createLineString(n) : t instanceof Jh ? n.length > 0 ? e.createPoint(n[0]) : e.createPoint() : t
        },
        ac.prototype.interfaces_ = function() {
            return [ic.GeometryEditorOperation]
        },
        ac.prototype.getClass = function() {
            return ac
        };
        var uc = function() {};
        uc.prototype.edit = function(t, e) {
            return t instanceof nc ? e.createLinearRing(this.edit(t.getCoordinateSequence(), t)) : t instanceof Kh ? e.createLineString(this.edit(t.getCoordinateSequence(), t)) : t instanceof Jh ? e.createPoint(this.edit(t.getCoordinateSequence(), t)) : t
        },
        uc.prototype.interfaces_ = function() {
            return [ic.GeometryEditorOperation]
        },
        uc.prototype.getClass = function() {
            return uc
        };
        var lc = function() {
                var t = this;
                if (this._dimension = 3, this._coordinates = null, 1 === arguments.length) {
                    if (arguments[0] instanceof Array)
                        this._coordinates = arguments[0],
                        this._dimension = 3;
                    else if (Number.isInteger(arguments[0])) {
                        var e = arguments[0];
                        this._coordinates = new Array(e).fill(null);
                        for (var n = 0; n < e; n++)
                            t._coordinates[n] = new ul
                    } else if (dl(arguments[0], Cl)) {
                        var r = arguments[0];
                        if (null === r)
                            return this._coordinates = new Array(0).fill(null), null;
                        this._dimension = r.getDimension(),
                        this._coordinates = new Array(r.size()).fill(null);
                        for (var i = 0; i < this._coordinates.length; i++)
                            t._coordinates[i] = r.getCoordinateCopy(i)
                    }
                } else if (2 === arguments.length)
                    if (arguments[0] instanceof Array && Number.isInteger(arguments[1])) {
                        var o = arguments[0],
                            s = arguments[1];
                        this._coordinates = o,
                        this._dimension = s,
                        null === o && (this._coordinates = new Array(0).fill(null))
                    } else if (Number.isInteger(arguments[0]) && Number.isInteger(arguments[1])) {
                        var a = arguments[0],
                            u = arguments[1];
                        this._coordinates = new Array(a).fill(null),
                        this._dimension = u;
                        for (var l = 0; l < a; l++)
                            t._coordinates[l] = new ul
                    }
            },
            hc = {
                serialVersionUID: {
                    configurable: !0
                }
            };
        lc.prototype.setOrdinate = function(t, e, n) {
            switch (e) {
            case Cl.X:
                this._coordinates[t].x = n;
                break;
            case Cl.Y:
                this._coordinates[t].y = n;
                break;
            case Cl.Z:
                this._coordinates[t].z = n;
                break;
            default:
                throw new el("invalid ordinateIndex")
            }
        },
        lc.prototype.size = function() {
            return this._coordinates.length
        },
        lc.prototype.getOrdinate = function(t, e) {
            switch (e) {
            case Cl.X:
                return this._coordinates[t].x;
            case Cl.Y:
                return this._coordinates[t].y;
            case Cl.Z:
                return this._coordinates[t].z
            }
            return nl.NaN
        },
        lc.prototype.getCoordinate = function() {
            if (1 === arguments.length) {
                var t = arguments[0];
                return this._coordinates[t]
            }
            if (2 === arguments.length) {
                var e = arguments[0],
                    n = arguments[1];
                n.x = this._coordinates[e].x,
                n.y = this._coordinates[e].y,
                n.z = this._coordinates[e].z
            }
        },
        lc.prototype.getCoordinateCopy = function(t) {
            return new ul(this._coordinates[t])
        },
        lc.prototype.getDimension = function() {
            return this._dimension
        },
        lc.prototype.getX = function(t) {
            return this._coordinates[t].x
        },
        lc.prototype.clone = function() {
            for (var t = new Array(this.size()).fill(null), e = 0; e < this._coordinates.length; e++)
                t[e] = this._coordinates[e].clone();
            return new lc(t, this._dimension)
        },
        lc.prototype.expandEnvelope = function(t) {
            for (var e = 0; e < this._coordinates.length; e++)
                t.expandToInclude(this._coordinates[e]);
            return t
        },
        lc.prototype.copy = function() {
            for (var t = new Array(this.size()).fill(null), e = 0; e < this._coordinates.length; e++)
                t[e] = this._coordinates[e].copy();
            return new lc(t, this._dimension)
        },
        lc.prototype.toString = function() {
            if (this._coordinates.length > 0) {
                var t = new vl(17 * this._coordinates.length);
                t.append("("),
                t.append(this._coordinates[0]);
                for (var e = 1; e < this._coordinates.length; e++)
                    t.append(", "),
                    t.append(this._coordinates[e]);
                return t.append(")"), t.toString()
            }
            return "()"
        },
        lc.prototype.getY = function(t) {
            return this._coordinates[t].y
        },
        lc.prototype.toCoordinateArray = function() {
            return this._coordinates
        },
        lc.prototype.interfaces_ = function() {
            return [Cl, al]
        },
        lc.prototype.getClass = function() {
            return lc
        },
        hc.serialVersionUID.get = function() {
            return -0xcb44a778db18e00
        },
        Object.defineProperties(lc, hc);
        var cc = function() {},
            pc = {
                serialVersionUID: {
                    configurable: !0
                },
                instanceObject: {
                    configurable: !0
                }
            };
        cc.prototype.readResolve = function() {
            return cc.instance()
        },
        cc.prototype.create = function() {
            if (1 === arguments.length) {
                if (arguments[0] instanceof Array)
                    return new lc(arguments[0]);
                if (dl(arguments[0], Cl))
                    return new lc(arguments[0])
            } else if (2 === arguments.length) {
                var t = arguments[0],
                    e = arguments[1];
                return e > 3 && (e = 3), e < 2 ? new lc(t) : new lc(t, e)
            }
        },
        cc.prototype.interfaces_ = function() {
            return [cl, al]
        },
        cc.prototype.getClass = function() {
            return cc
        },
        cc.instance = function() {
            return cc.instanceObject
        },
        pc.serialVersionUID.get = function() {
            return -0x38e49fa6cf6f2e00
        },
        pc.instanceObject.get = function() {
            return new cc
        },
        Object.defineProperties(cc, pc);
        var fc = function(t) {
                function e() {
                    t.call(this),
                    this.map_ = new Map
                }
                return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.get = function(t) {
                    return this.map_.get(t) || null
                }, e.prototype.put = function(t, e) {
                    return this.map_.set(t, e), e
                }, e.prototype.values = function() {
                    for (var t = new lh, e = this.map_.values(), n = e.next(); !n.done;)
                        t.add(n.value),
                        n = e.next();
                    return t
                }, e.prototype.entrySet = function() {
                    var t = new xh;
                    return this.map_.entries().forEach((function(e) {
                        return t.add(e)
                    })), t
                }, e.prototype.size = function() {
                    return this.map_.size()
                }, e
            }(yh),
            dc = function t() {
                if (this._modelType = null, this._scale = null, 0 === arguments.length)
                    this._modelType = t.FLOATING;
                else if (1 === arguments.length)
                    if (arguments[0] instanceof yc) {
                        var e = arguments[0];
                        this._modelType = e,
                        e === t.FIXED && this.setScale(1)
                    } else if ("number" == typeof arguments[0]) {
                        var n = arguments[0];
                        this._modelType = t.FIXED,
                        this.setScale(n)
                    } else if (arguments[0] instanceof t) {
                        var r = arguments[0];
                        this._modelType = r._modelType,
                        this._scale = r._scale
                    }
            },
            gc = {
                serialVersionUID: {
                    configurable: !0
                },
                maximumPreciseValue: {
                    configurable: !0
                }
            };
        dc.prototype.equals = function(t) {
            if (!(t instanceof dc))
                return !1;
            var e = t;
            return this._modelType === e._modelType && this._scale === e._scale
        },
        dc.prototype.compareTo = function(t) {
            var e = t,
                n = this.getMaximumSignificantDigits(),
                r = e.getMaximumSignificantDigits();
            return new ml(n).compareTo(new ml(r))
        },
        dc.prototype.getScale = function() {
            return this._scale
        },
        dc.prototype.isFloating = function() {
            return this._modelType === dc.FLOATING || this._modelType === dc.FLOATING_SINGLE
        },
        dc.prototype.getType = function() {
            return this._modelType
        },
        dc.prototype.toString = function() {
            var t = "UNKNOWN";
            return this._modelType === dc.FLOATING ? t = "Floating" : this._modelType === dc.FLOATING_SINGLE ? t = "Floating-Single" : this._modelType === dc.FIXED && (t = "Fixed (Scale=" + this.getScale() + ")"), t
        },
        dc.prototype.makePrecise = function() {
            if ("number" == typeof arguments[0]) {
                var t = arguments[0];
                return nl.isNaN(t) || this._modelType === dc.FLOATING_SINGLE ? t : this._modelType === dc.FIXED ? Math.round(t * this._scale) / this._scale : t
            }
            if (arguments[0] instanceof ul) {
                var e = arguments[0];
                if (this._modelType === dc.FLOATING)
                    return null;
                e.x = this.makePrecise(e.x),
                e.y = this.makePrecise(e.y)
            }
        },
        dc.prototype.getMaximumSignificantDigits = function() {
            var t = 16;
            return this._modelType === dc.FLOATING ? t = 16 : this._modelType === dc.FLOATING_SINGLE ? t = 6 : this._modelType === dc.FIXED && (t = 1 + Math.trunc(Math.ceil(Math.log(this.getScale()) / Math.log(10)))), t
        },
        dc.prototype.setScale = function(t) {
            this._scale = Math.abs(t)
        },
        dc.prototype.interfaces_ = function() {
            return [al, il]
        },
        dc.prototype.getClass = function() {
            return dc
        },
        dc.mostPrecise = function(t, e) {
            return t.compareTo(e) >= 0 ? t : e
        },
        gc.serialVersionUID.get = function() {
            return 0x6bee6404e9a25c00
        },
        gc.maximumPreciseValue.get = function() {
            return 9007199254740992
        },
        Object.defineProperties(dc, gc);
        var yc = function t(e) {
                this._name = e || null,
                t.nameToTypeMap.put(e, this)
            },
            vc = {
                serialVersionUID: {
                    configurable: !0
                },
                nameToTypeMap: {
                    configurable: !0
                }
            };
        yc.prototype.readResolve = function() {
            return yc.nameToTypeMap.get(this._name)
        },
        yc.prototype.toString = function() {
            return this._name
        },
        yc.prototype.interfaces_ = function() {
            return [al]
        },
        yc.prototype.getClass = function() {
            return yc
        },
        vc.serialVersionUID.get = function() {
            return -552860263173159e4
        },
        vc.nameToTypeMap.get = function() {
            return new fc
        },
        Object.defineProperties(yc, vc),
        dc.Type = yc,
        dc.FIXED = new yc("FIXED"),
        dc.FLOATING = new yc("FLOATING"),
        dc.FLOATING_SINGLE = new yc("FLOATING SINGLE");
        var mc = function t() {
                this._precisionModel = new dc,
                this._SRID = 0,
                this._coordinateSequenceFactory = t.getDefaultCoordinateSequenceFactory(),
                0 === arguments.length || (1 === arguments.length ? dl(arguments[0], cl) ? this._coordinateSequenceFactory = arguments[0] : arguments[0] instanceof dc && (this._precisionModel = arguments[0]) : 2 === arguments.length ? (this._precisionModel = arguments[0], this._SRID = arguments[1]) : 3 === arguments.length && (this._precisionModel = arguments[0], this._SRID = arguments[1], this._coordinateSequenceFactory = arguments[2]))
            },
            _c = {
                serialVersionUID: {
                    configurable: !0
                }
            };
        mc.prototype.toGeometry = function(t) {
            return t.isNull() ? this.createPoint(null) : t.getMinX() === t.getMaxX() && t.getMinY() === t.getMaxY() ? this.createPoint(new ul(t.getMinX(), t.getMinY())) : t.getMinX() === t.getMaxX() || t.getMinY() === t.getMaxY() ? this.createLineString([new ul(t.getMinX(), t.getMinY()), new ul(t.getMaxX(), t.getMaxY())]) : this.createPolygon(this.createLinearRing([new ul(t.getMinX(), t.getMinY()), new ul(t.getMinX(), t.getMaxY()), new ul(t.getMaxX(), t.getMaxY()), new ul(t.getMaxX(), t.getMinY()), new ul(t.getMinX(), t.getMinY())]), null)
        },
        mc.prototype.createLineString = function(t) {
            return t ? t instanceof Array ? new Kh(this.getCoordinateSequenceFactory().create(t), this) : dl(t, Cl) ? new Kh(t, this) : void 0 : new Kh(this.getCoordinateSequenceFactory().create([]), this)
        },
        mc.prototype.createMultiLineString = function() {
            return 0 === arguments.length ? new jh(null, this) : 1 === arguments.length ? new jh(arguments[0], this) : void 0
        },
        mc.prototype.buildGeometry = function(t) {
            for (var e = null, n = !1, r = !1, i = t.iterator(); i.hasNext();) {
                var o = i.next(),
                    s = o.getClass();
                null === e && (e = s),
                s !== e && (n = !0),
                o.isGeometryCollectionOrDerived() && (r = !0)
            }
            if (null === e)
                return this.createGeometryCollection();
            if (n || r)
                return this.createGeometryCollection(mc.toGeometryArray(t));
            var a = t.iterator().next();
            if (t.size() > 1) {
                if (a instanceof tc)
                    return this.createMultiPolygon(mc.toPolygonArray(t));
                if (a instanceof Kh)
                    return this.createMultiLineString(mc.toLineStringArray(t));
                if (a instanceof Jh)
                    return this.createMultiPoint(mc.toPointArray(t));
                Gl.shouldNeverReachHere("Unhandled class: " + a.getClass().getName())
            }
            return a
        },
        mc.prototype.createMultiPointFromCoords = function(t) {
            return this.createMultiPoint(null !== t ? this.getCoordinateSequenceFactory().create(t) : null)
        },
        mc.prototype.createPoint = function() {
            if (0 === arguments.length)
                return this.createPoint(this.getCoordinateSequenceFactory().create([]));
            if (1 === arguments.length) {
                if (arguments[0] instanceof ul) {
                    var t = arguments[0];
                    return this.createPoint(null !== t ? this.getCoordinateSequenceFactory().create([t]) : null)
                }
                if (dl(arguments[0], Cl))
                    return new Jh(arguments[0], this)
            }
        },
        mc.prototype.getCoordinateSequenceFactory = function() {
            return this._coordinateSequenceFactory
        },
        mc.prototype.createPolygon = function() {
            if (0 === arguments.length)
                return new tc(null, null, this);
            if (1 === arguments.length) {
                if (dl(arguments[0], Cl)) {
                    var t = arguments[0];
                    return this.createPolygon(this.createLinearRing(t))
                }
                if (arguments[0] instanceof Array) {
                    var e = arguments[0];
                    return this.createPolygon(this.createLinearRing(e))
                }
                if (arguments[0] instanceof nc) {
                    var n = arguments[0];
                    return this.createPolygon(n, null)
                }
            } else if (2 === arguments.length)
                return new tc(arguments[0], arguments[1], this)
        },
        mc.prototype.getSRID = function() {
            return this._SRID
        },
        mc.prototype.createGeometryCollection = function() {
            return 0 === arguments.length ? new kh(null, this) : 1 === arguments.length ? new kh(arguments[0], this) : void 0
        },
        mc.prototype.createGeometry = function(t) {
            return new ic(this).edit(t, {
                edit: function() {
                    if (2 === arguments.length) {
                        var t = arguments[0];
                        return this._coordinateSequenceFactory.create(t)
                    }
                }
            })
        },
        mc.prototype.getPrecisionModel = function() {
            return this._precisionModel
        },
        mc.prototype.createLinearRing = function() {
            if (0 === arguments.length)
                return this.createLinearRing(this.getCoordinateSequenceFactory().create([]));
            if (1 === arguments.length) {
                if (arguments[0] instanceof Array) {
                    var t = arguments[0];
                    return this.createLinearRing(null !== t ? this.getCoordinateSequenceFactory().create(t) : null)
                }
                if (dl(arguments[0], Cl))
                    return new nc(arguments[0], this)
            }
        },
        mc.prototype.createMultiPolygon = function() {
            return 0 === arguments.length ? new rc(null, this) : 1 === arguments.length ? new rc(arguments[0], this) : void 0
        },
        mc.prototype.createMultiPoint = function() {
            var t = this;
            if (0 === arguments.length)
                return new ec(null, this);
            if (1 === arguments.length) {
                if (arguments[0] instanceof Array)
                    return new ec(arguments[0], this);
                if (arguments[0] instanceof Array) {
                    var e = arguments[0];
                    return this.createMultiPoint(null !== e ? this.getCoordinateSequenceFactory().create(e) : null)
                }
                if (dl(arguments[0], Cl)) {
                    var n = arguments[0];
                    if (null === n)
                        return this.createMultiPoint(new Array(0).fill(null));
                    for (var r = new Array(n.size()).fill(null), i = 0; i < n.size(); i++) {
                        var o = t.getCoordinateSequenceFactory().create(1, n.getDimension());
                        $h.copy(n, i, o, 0, 1),
                        r[i] = t.createPoint(o)
                    }
                    return this.createMultiPoint(r)
                }
            }
        },
        mc.prototype.interfaces_ = function() {
            return [al]
        },
        mc.prototype.getClass = function() {
            return mc
        },
        mc.toMultiPolygonArray = function(t) {
            var e = new Array(t.size()).fill(null);
            return t.toArray(e)
        },
        mc.toGeometryArray = function(t) {
            if (null === t)
                return null;
            var e = new Array(t.size()).fill(null);
            return t.toArray(e)
        },
        mc.getDefaultCoordinateSequenceFactory = function() {
            return cc.instance()
        },
        mc.toMultiLineStringArray = function(t) {
            var e = new Array(t.size()).fill(null);
            return t.toArray(e)
        },
        mc.toLineStringArray = function(t) {
            var e = new Array(t.size()).fill(null);
            return t.toArray(e)
        },
        mc.toMultiPointArray = function(t) {
            var e = new Array(t.size()).fill(null);
            return t.toArray(e)
        },
        mc.toLinearRingArray = function(t) {
            var e = new Array(t.size()).fill(null);
            return t.toArray(e)
        },
        mc.toPointArray = function(t) {
            var e = new Array(t.size()).fill(null);
            return t.toArray(e)
        },
        mc.toPolygonArray = function(t) {
            var e = new Array(t.size()).fill(null);
            return t.toArray(e)
        },
        mc.createPointFromInternalCoord = function(t, e) {
            return e.getPrecisionModel().makePrecise(t), e.getFactory().createPoint(t)
        },
        _c.serialVersionUID.get = function() {
            return -0x5ea75f2051eeb400
        },
        Object.defineProperties(mc, _c);
        var xc = ["Point", "MultiPoint", "LineString", "MultiLineString", "Polygon", "MultiPolygon"],
            Ec = function(t) {
                this.geometryFactory = t || new mc
            };
        Ec.prototype.read = function(t) {
            var e,
                n = (e = "string" == typeof t ? JSON.parse(t) : t).type;
            if (!wc[n])
                throw new Error("Unknown GeoJSON type: " + e.type);
            return -1 !== xc.indexOf(n) ? wc[n].apply(this, [e.coordinates]) : "GeometryCollection" === n ? wc[n].apply(this, [e.geometries]) : wc[n].apply(this, [e])
        },
        Ec.prototype.write = function(t) {
            var e = t.getGeometryType();
            if (!bc[e])
                throw new Error("Geometry is not supported");
            return bc[e].apply(this, [t])
        };
        var wc = {
                Feature: function(t) {
                    var e = {};
                    for (var n in t)
                        e[n] = t[n];
                    if (t.geometry) {
                        var r = t.geometry.type;
                        if (!wc[r])
                            throw new Error("Unknown GeoJSON type: " + t.type);
                        e.geometry = this.read(t.geometry)
                    }
                    return t.bbox && (e.bbox = wc.bbox.apply(this, [t.bbox])), e
                },
                FeatureCollection: function(t) {
                    var e = {};
                    if (t.features) {
                        e.features = [];
                        for (var n = 0; n < t.features.length; ++n)
                            e.features.push(this.read(t.features[n]))
                    }
                    return t.bbox && (e.bbox = this.parse.bbox.apply(this, [t.bbox])), e
                },
                coordinates: function(t) {
                    for (var e = [], n = 0; n < t.length; ++n) {
                        var r = t[n];
                        e.push(new ul(r[0], r[1]))
                    }
                    return e
                },
                bbox: function(t) {
                    return this.geometryFactory.createLinearRing([new ul(t[0], t[1]), new ul(t[2], t[1]), new ul(t[2], t[3]), new ul(t[0], t[3]), new ul(t[0], t[1])])
                },
                Point: function(t) {
                    var e = new ul(t[0], t[1]);
                    return this.geometryFactory.createPoint(e)
                },
                MultiPoint: function(t) {
                    for (var e = [], n = 0; n < t.length; ++n)
                        e.push(wc.Point.apply(this, [t[n]]));
                    return this.geometryFactory.createMultiPoint(e)
                },
                LineString: function(t) {
                    var e = wc.coordinates.apply(this, [t]);
                    return this.geometryFactory.createLineString(e)
                },
                MultiLineString: function(t) {
                    for (var e = [], n = 0; n < t.length; ++n)
                        e.push(wc.LineString.apply(this, [t[n]]));
                    return this.geometryFactory.createMultiLineString(e)
                },
                Polygon: function(t) {
                    for (var e = wc.coordinates.apply(this, [t[0]]), n = this.geometryFactory.createLinearRing(e), r = [], i = 1; i < t.length; ++i) {
                        var o = t[i],
                            s = wc.coordinates.apply(this, [o]),
                            a = this.geometryFactory.createLinearRing(s);
                        r.push(a)
                    }
                    return this.geometryFactory.createPolygon(n, r)
                },
                MultiPolygon: function(t) {
                    for (var e = [], n = 0; n < t.length; ++n) {
                        var r = t[n];
                        e.push(wc.Polygon.apply(this, [r]))
                    }
                    return this.geometryFactory.createMultiPolygon(e)
                },
                GeometryCollection: function(t) {
                    for (var e = [], n = 0; n < t.length; ++n) {
                        var r = t[n];
                        e.push(this.read(r))
                    }
                    return this.geometryFactory.createGeometryCollection(e)
                }
            },
            bc = {
                coordinate: function(t) {
                    return [t.x, t.y]
                },
                Point: function(t) {
                    return {
                        type: "Point",
                        coordinates: bc.coordinate.apply(this, [t.getCoordinate()])
                    }
                },
                MultiPoint: function(t) {
                    for (var e = [], n = 0; n < t._geometries.length; ++n) {
                        var r = t._geometries[n],
                            i = bc.Point.apply(this, [r]);
                        e.push(i.coordinates)
                    }
                    return {
                        type: "MultiPoint",
                        coordinates: e
                    }
                },
                LineString: function(t) {
                    for (var e = [], n = t.getCoordinates(), r = 0; r < n.length; ++r) {
                        var i = n[r];
                        e.push(bc.coordinate.apply(this, [i]))
                    }
                    return {
                        type: "LineString",
                        coordinates: e
                    }
                },
                MultiLineString: function(t) {
                    for (var e = [], n = 0; n < t._geometries.length; ++n) {
                        var r = t._geometries[n],
                            i = bc.LineString.apply(this, [r]);
                        e.push(i.coordinates)
                    }
                    return {
                        type: "MultiLineString",
                        coordinates: e
                    }
                },
                Polygon: function(t) {
                    var e = [],
                        n = bc.LineString.apply(this, [t._shell]);
                    e.push(n.coordinates);
                    for (var r = 0; r < t._holes.length; ++r) {
                        var i = t._holes[r],
                            o = bc.LineString.apply(this, [i]);
                        e.push(o.coordinates)
                    }
                    return {
                        type: "Polygon",
                        coordinates: e
                    }
                },
                MultiPolygon: function(t) {
                    for (var e = [], n = 0; n < t._geometries.length; ++n) {
                        var r = t._geometries[n],
                            i = bc.Polygon.apply(this, [r]);
                        e.push(i.coordinates)
                    }
                    return {
                        type: "MultiPolygon",
                        coordinates: e
                    }
                },
                GeometryCollection: function(t) {
                    for (var e = [], n = 0; n < t._geometries.length; ++n) {
                        var r = t._geometries[n],
                            i = r.getGeometryType();
                        e.push(bc[i].apply(this, [r]))
                    }
                    return {
                        type: "GeometryCollection",
                        geometries: e
                    }
                }
            },
            Cc = function(t) {
                this.geometryFactory = t || new mc,
                this.precisionModel = this.geometryFactory.getPrecisionModel(),
                this.parser = new Ec(this.geometryFactory)
            };
        Cc.prototype.read = function(t) {
            var e = this.parser.read(t);
            return this.precisionModel.getType() === dc.FIXED && this.reducePrecision(e), e
        },
        Cc.prototype.reducePrecision = function(t) {
            var e,
                n;
            if (t.coordinate)
                this.precisionModel.makePrecise(t.coordinate);
            else if (t.points)
                for (e = 0, n = t.points.length; e < n; e++)
                    this.precisionModel.makePrecise(t.points[e]);
            else if (t.geometries)
                for (e = 0, n = t.geometries.length; e < n; e++)
                    this.reducePrecision(t.geometries[e])
        };
        var Mc = function() {
            this.parser = new Ec(this.geometryFactory)
        };
        Mc.prototype.write = function(t) {
            return this.parser.write(t)
        };
        var Sc = function() {},
            Ic = {
                ON: {
                    configurable: !0
                },
                LEFT: {
                    configurable: !0
                },
                RIGHT: {
                    configurable: !0
                }
            };
        function Tc(t) {
            this.message = t || ""
        }
        function Pc() {
            this.array_ = []
        }
        Sc.prototype.interfaces_ = function() {
            return []
        },
        Sc.prototype.getClass = function() {
            return Sc
        },
        Sc.opposite = function(t) {
            return t === Sc.LEFT ? Sc.RIGHT : t === Sc.RIGHT ? Sc.LEFT : t
        },
        Ic.ON.get = function() {
            return 0
        },
        Ic.LEFT.get = function() {
            return 1
        },
        Ic.RIGHT.get = function() {
            return 2
        },
        Object.defineProperties(Sc, Ic),
        Tc.prototype = new Error,
        Tc.prototype.name = "EmptyStackException",
        Pc.prototype = new ah,
        Pc.prototype.add = function(t) {
            return this.array_.push(t), !0
        },
        Pc.prototype.get = function(t) {
            if (t < 0 || t >= this.size())
                throw new Error;
            return this.array_[t]
        },
        Pc.prototype.push = function(t) {
            return this.array_.push(t), t
        },
        Pc.prototype.pop = function(t) {
            if (0 === this.array_.length)
                throw new Tc;
            return this.array_.pop()
        },
        Pc.prototype.peek = function() {
            if (0 === this.array_.length)
                throw new Tc;
            return this.array_[this.array_.length - 1]
        },
        Pc.prototype.empty = function() {
            return 0 === this.array_.length
        },
        Pc.prototype.isEmpty = function() {
            return this.empty()
        },
        Pc.prototype.search = function(t) {
            return this.array_.indexOf(t)
        },
        Pc.prototype.size = function() {
            return this.array_.length
        },
        Pc.prototype.toArray = function() {
            for (var t = [], e = 0, n = this.array_.length; e < n; e++)
                t.push(this.array_[e]);
            return t
        };
        var Lc = function() {
            this._minIndex = -1,
            this._minCoord = null,
            this._minDe = null,
            this._orientedDe = null
        };
        Lc.prototype.getCoordinate = function() {
            return this._minCoord
        },
        Lc.prototype.getRightmostSide = function(t, e) {
            var n = this.getRightmostSideOfSegment(t, e);
            return n < 0 && (n = this.getRightmostSideOfSegment(t, e - 1)), n < 0 && (this._minCoord = null, this.checkForRightmostCoordinate(t)), n
        },
        Lc.prototype.findRightmostEdgeAtVertex = function() {
            var t = this._minDe.getEdge().getCoordinates();
            Gl.isTrue(this._minIndex > 0 && this._minIndex < t.length, "rightmost point expected to be interior vertex of edge");
            var e = t[this._minIndex - 1],
                n = t[this._minIndex + 1],
                r = Xl.computeOrientation(this._minCoord, n, e),
                i = !1;
            (e.y < this._minCoord.y && n.y < this._minCoord.y && r === Xl.COUNTERCLOCKWISE || e.y > this._minCoord.y && n.y > this._minCoord.y && r === Xl.CLOCKWISE) && (i = !0),
            i && (this._minIndex = this._minIndex - 1)
        },
        Lc.prototype.getRightmostSideOfSegment = function(t, e) {
            var n = t.getEdge().getCoordinates();
            if (e < 0 || e + 1 >= n.length)
                return -1;
            if (n[e].y === n[e + 1].y)
                return -1;
            var r = Sc.LEFT;
            return n[e].y < n[e + 1].y && (r = Sc.RIGHT), r
        },
        Lc.prototype.getEdge = function() {
            return this._orientedDe
        },
        Lc.prototype.checkForRightmostCoordinate = function(t) {
            for (var e = this, n = t.getEdge().getCoordinates(), r = 0; r < n.length - 1; r++)
                (null === e._minCoord || n[r].x > e._minCoord.x) && (e._minDe = t, e._minIndex = r, e._minCoord = n[r])
        },
        Lc.prototype.findRightmostEdgeAtNode = function() {
            var t = this._minDe.getNode().getEdges();
            this._minDe = t.getRightmostEdge(),
            this._minDe.isForward() || (this._minDe = this._minDe.getSym(), this._minIndex = this._minDe.getEdge().getCoordinates().length - 1)
        },
        Lc.prototype.findEdge = function(t) {
            for (var e = t.iterator(); e.hasNext();) {
                var n = e.next();
                n.isForward() && this.checkForRightmostCoordinate(n)
            }
            Gl.isTrue(0 !== this._minIndex || this._minCoord.equals(this._minDe.getCoordinate()), "inconsistency in rightmost processing"),
            0 === this._minIndex ? this.findRightmostEdgeAtNode() : this.findRightmostEdgeAtVertex(),
            this._orientedDe = this._minDe,
            this.getRightmostSide(this._minDe, this._minIndex) === Sc.LEFT && (this._orientedDe = this._minDe.getSym())
        },
        Lc.prototype.interfaces_ = function() {
            return []
        },
        Lc.prototype.getClass = function() {
            return Lc
        };
        var Oc = function(t) {
                function e(n, r) {
                    t.call(this, e.msgWithCoord(n, r)),
                    this.pt = r ? new ul(r) : null,
                    this.name = "TopologyException"
                }
                return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.getCoordinate = function() {
                    return this.pt
                }, e.prototype.interfaces_ = function() {
                    return []
                }, e.prototype.getClass = function() {
                    return e
                }, e.msgWithCoord = function(t, e) {
                    return e ? t : t + " [ " + e + " ]"
                }, e
            }(kl),
            Nc = function() {
                this.array_ = []
            };
        Nc.prototype.addLast = function(t) {
            this.array_.push(t)
        },
        Nc.prototype.removeFirst = function() {
            return this.array_.shift()
        },
        Nc.prototype.isEmpty = function() {
            return 0 === this.array_.length
        };
        var Rc = function() {
            this._finder = null,
            this._dirEdgeList = new lh,
            this._nodes = new lh,
            this._rightMostCoord = null,
            this._env = null,
            this._finder = new Lc
        };
        Rc.prototype.clearVisitedEdges = function() {
            for (var t = this._dirEdgeList.iterator(); t.hasNext();)
                t.next().setVisited(!1)
        },
        Rc.prototype.getRightmostCoordinate = function() {
            return this._rightMostCoord
        },
        Rc.prototype.computeNodeDepth = function(t) {
            for (var e = null, n = t.getEdges().iterator(); n.hasNext();) {
                var r = n.next();
                if (r.isVisited() || r.getSym().isVisited()) {
                    e = r;
                    break
                }
            }
            if (null === e)
                throw new Oc("unable to find edge to compute depths at " + t.getCoordinate());
            t.getEdges().computeDepths(e);
            for (var i = t.getEdges().iterator(); i.hasNext();) {
                var o = i.next();
                o.setVisited(!0),
                this.copySymDepths(o)
            }
        },
        Rc.prototype.computeDepth = function(t) {
            this.clearVisitedEdges();
            var e = this._finder.getEdge();
            e.setEdgeDepths(Sc.RIGHT, t),
            this.copySymDepths(e),
            this.computeDepths(e)
        },
        Rc.prototype.create = function(t) {
            this.addReachable(t),
            this._finder.findEdge(this._dirEdgeList),
            this._rightMostCoord = this._finder.getCoordinate()
        },
        Rc.prototype.findResultEdges = function() {
            for (var t = this._dirEdgeList.iterator(); t.hasNext();) {
                var e = t.next();
                e.getDepth(Sc.RIGHT) >= 1 && e.getDepth(Sc.LEFT) <= 0 && !e.isInteriorAreaEdge() && e.setInResult(!0)
            }
        },
        Rc.prototype.computeDepths = function(t) {
            var e = new xh,
                n = new Nc,
                r = t.getNode();
            for (n.addLast(r), e.add(r), t.setVisited(!0); !n.isEmpty();) {
                var i = n.removeFirst();
                e.add(i),
                this.computeNodeDepth(i);
                for (var o = i.getEdges().iterator(); o.hasNext();) {
                    var s = o.next().getSym();
                    if (!s.isVisited()) {
                        var a = s.getNode();
                        e.contains(a) || (n.addLast(a), e.add(a))
                    }
                }
            }
        },
        Rc.prototype.compareTo = function(t) {
            var e = t;
            return this._rightMostCoord.x < e._rightMostCoord.x ? -1 : this._rightMostCoord.x > e._rightMostCoord.x ? 1 : 0
        },
        Rc.prototype.getEnvelope = function() {
            if (null === this._env) {
                for (var t = new Ll, e = this._dirEdgeList.iterator(); e.hasNext();)
                    for (var n = e.next().getEdge().getCoordinates(), r = 0; r < n.length - 1; r++)
                        t.expandToInclude(n[r]);
                this._env = t
            }
            return this._env
        },
        Rc.prototype.addReachable = function(t) {
            var e = new Pc;
            for (e.add(t); !e.empty();) {
                var n = e.pop();
                this.add(n, e)
            }
        },
        Rc.prototype.copySymDepths = function(t) {
            var e = t.getSym();
            e.setDepth(Sc.LEFT, t.getDepth(Sc.RIGHT)),
            e.setDepth(Sc.RIGHT, t.getDepth(Sc.LEFT))
        },
        Rc.prototype.add = function(t, e) {
            t.setVisited(!0),
            this._nodes.add(t);
            for (var n = t.getEdges().iterator(); n.hasNext();) {
                var r = n.next();
                this._dirEdgeList.add(r);
                var i = r.getSym().getNode();
                i.isVisited() || e.push(i)
            }
        },
        Rc.prototype.getNodes = function() {
            return this._nodes
        },
        Rc.prototype.getDirectedEdges = function() {
            return this._dirEdgeList
        },
        Rc.prototype.interfaces_ = function() {
            return [il]
        },
        Rc.prototype.getClass = function() {
            return Rc
        };
        var Ac = function t() {
            var e = this;
            if (this.location = null, 1 === arguments.length) {
                if (arguments[0] instanceof Array) {
                    var n = arguments[0];
                    this.init(n.length)
                } else if (Number.isInteger(arguments[0])) {
                    var r = arguments[0];
                    this.init(1),
                    this.location[Sc.ON] = r
                } else if (arguments[0] instanceof t) {
                    var i = arguments[0];
                    if (this.init(i.location.length), null !== i)
                        for (var o = 0; o < this.location.length; o++)
                            e.location[o] = i.location[o]
                }
            } else if (3 === arguments.length) {
                var s = arguments[0],
                    a = arguments[1],
                    u = arguments[2];
                this.init(3),
                this.location[Sc.ON] = s,
                this.location[Sc.LEFT] = a,
                this.location[Sc.RIGHT] = u
            }
        };
        Ac.prototype.setAllLocations = function(t) {
            for (var e = 0; e < this.location.length; e++)
                this.location[e] = t
        },
        Ac.prototype.isNull = function() {
            for (var t = 0; t < this.location.length; t++)
                if (this.location[t] !== pl.NONE)
                    return !1;
            return !0
        },
        Ac.prototype.setAllLocationsIfNull = function(t) {
            for (var e = 0; e < this.location.length; e++)
                this.location[e] === pl.NONE && (this.location[e] = t)
        },
        Ac.prototype.isLine = function() {
            return 1 === this.location.length
        },
        Ac.prototype.merge = function(t) {
            if (t.location.length > this.location.length) {
                var e = new Array(3).fill(null);
                e[Sc.ON] = this.location[Sc.ON],
                e[Sc.LEFT] = pl.NONE,
                e[Sc.RIGHT] = pl.NONE,
                this.location = e
            }
            for (var n = 0; n < this.location.length; n++)
                this.location[n] === pl.NONE && n < t.location.length && (this.location[n] = t.location[n])
        },
        Ac.prototype.getLocations = function() {
            return this.location
        },
        Ac.prototype.flip = function() {
            if (this.location.length <= 1)
                return null;
            var t = this.location[Sc.LEFT];
            this.location[Sc.LEFT] = this.location[Sc.RIGHT],
            this.location[Sc.RIGHT] = t
        },
        Ac.prototype.toString = function() {
            var t = new vl;
            return this.location.length > 1 && t.append(pl.toLocationSymbol(this.location[Sc.LEFT])), t.append(pl.toLocationSymbol(this.location[Sc.ON])), this.location.length > 1 && t.append(pl.toLocationSymbol(this.location[Sc.RIGHT])), t.toString()
        },
        Ac.prototype.setLocations = function(t, e, n) {
            this.location[Sc.ON] = t,
            this.location[Sc.LEFT] = e,
            this.location[Sc.RIGHT] = n
        },
        Ac.prototype.get = function(t) {
            return t < this.location.length ? this.location[t] : pl.NONE
        },
        Ac.prototype.isArea = function() {
            return this.location.length > 1
        },
        Ac.prototype.isAnyNull = function() {
            for (var t = 0; t < this.location.length; t++)
                if (this.location[t] === pl.NONE)
                    return !0;
            return !1
        },
        Ac.prototype.setLocation = function() {
            if (1 === arguments.length) {
                var t = arguments[0];
                this.setLocation(Sc.ON, t)
            } else if (2 === arguments.length) {
                var e = arguments[0],
                    n = arguments[1];
                this.location[e] = n
            }
        },
        Ac.prototype.init = function(t) {
            this.location = new Array(t).fill(null),
            this.setAllLocations(pl.NONE)
        },
        Ac.prototype.isEqualOnSide = function(t, e) {
            return this.location[e] === t.location[e]
        },
        Ac.prototype.allPositionsEqual = function(t) {
            for (var e = 0; e < this.location.length; e++)
                if (this.location[e] !== t)
                    return !1;
            return !0
        },
        Ac.prototype.interfaces_ = function() {
            return []
        },
        Ac.prototype.getClass = function() {
            return Ac
        };
        var Dc = function t() {
            if (this.elt = new Array(2).fill(null), 1 === arguments.length) {
                if (Number.isInteger(arguments[0])) {
                    var e = arguments[0];
                    this.elt[0] = new Ac(e),
                    this.elt[1] = new Ac(e)
                } else if (arguments[0] instanceof t) {
                    var n = arguments[0];
                    this.elt[0] = new Ac(n.elt[0]),
                    this.elt[1] = new Ac(n.elt[1])
                }
            } else if (2 === arguments.length) {
                var r = arguments[0],
                    i = arguments[1];
                this.elt[0] = new Ac(pl.NONE),
                this.elt[1] = new Ac(pl.NONE),
                this.elt[r].setLocation(i)
            } else if (3 === arguments.length) {
                var o = arguments[0],
                    s = arguments[1],
                    a = arguments[2];
                this.elt[0] = new Ac(o, s, a),
                this.elt[1] = new Ac(o, s, a)
            } else if (4 === arguments.length) {
                var u = arguments[0],
                    l = arguments[1],
                    h = arguments[2],
                    c = arguments[3];
                this.elt[0] = new Ac(pl.NONE, pl.NONE, pl.NONE),
                this.elt[1] = new Ac(pl.NONE, pl.NONE, pl.NONE),
                this.elt[u].setLocations(l, h, c)
            }
        };
        Dc.prototype.getGeometryCount = function() {
            var t = 0;
            return this.elt[0].isNull() || t++, this.elt[1].isNull() || t++, t
        },
        Dc.prototype.setAllLocations = function(t, e) {
            this.elt[t].setAllLocations(e)
        },
        Dc.prototype.isNull = function(t) {
            return this.elt[t].isNull()
        },
        Dc.prototype.setAllLocationsIfNull = function() {
            if (1 === arguments.length) {
                var t = arguments[0];
                this.setAllLocationsIfNull(0, t),
                this.setAllLocationsIfNull(1, t)
            } else if (2 === arguments.length) {
                var e = arguments[0],
                    n = arguments[1];
                this.elt[e].setAllLocationsIfNull(n)
            }
        },
        Dc.prototype.isLine = function(t) {
            return this.elt[t].isLine()
        },
        Dc.prototype.merge = function(t) {
            for (var e = this, n = 0; n < 2; n++)
                null === e.elt[n] && null !== t.elt[n] ? e.elt[n] = new Ac(t.elt[n]) : e.elt[n].merge(t.elt[n])
        },
        Dc.prototype.flip = function() {
            this.elt[0].flip(),
            this.elt[1].flip()
        },
        Dc.prototype.getLocation = function() {
            if (1 === arguments.length) {
                var t = arguments[0];
                return this.elt[t].get(Sc.ON)
            }
            if (2 === arguments.length) {
                var e = arguments[0],
                    n = arguments[1];
                return this.elt[e].get(n)
            }
        },
        Dc.prototype.toString = function() {
            var t = new vl;
            return null !== this.elt[0] && (t.append("A:"), t.append(this.elt[0].toString())), null !== this.elt[1] && (t.append(" B:"), t.append(this.elt[1].toString())), t.toString()
        },
        Dc.prototype.isArea = function() {
            if (0 === arguments.length)
                return this.elt[0].isArea() || this.elt[1].isArea();
            if (1 === arguments.length) {
                var t = arguments[0];
                return this.elt[t].isArea()
            }
        },
        Dc.prototype.isAnyNull = function(t) {
            return this.elt[t].isAnyNull()
        },
        Dc.prototype.setLocation = function() {
            if (2 === arguments.length) {
                var t = arguments[0],
                    e = arguments[1];
                this.elt[t].setLocation(Sc.ON, e)
            } else if (3 === arguments.length) {
                var n = arguments[0],
                    r = arguments[1],
                    i = arguments[2];
                this.elt[n].setLocation(r, i)
            }
        },
        Dc.prototype.isEqualOnSide = function(t, e) {
            return this.elt[0].isEqualOnSide(t.elt[0], e) && this.elt[1].isEqualOnSide(t.elt[1], e)
        },
        Dc.prototype.allPositionsEqual = function(t, e) {
            return this.elt[t].allPositionsEqual(e)
        },
        Dc.prototype.toLine = function(t) {
            this.elt[t].isArea() && (this.elt[t] = new Ac(this.elt[t].location[0]))
        },
        Dc.prototype.interfaces_ = function() {
            return []
        },
        Dc.prototype.getClass = function() {
            return Dc
        },
        Dc.toLineLabel = function(t) {
            for (var e = new Dc(pl.NONE), n = 0; n < 2; n++)
                e.setLocation(n, t.getLocation(n));
            return e
        };
        var Fc = function() {
            this._startDe = null,
            this._maxNodeDegree = -1,
            this._edges = new lh,
            this._pts = new lh,
            this._label = new Dc(pl.NONE),
            this._ring = null,
            this._isHole = null,
            this._shell = null,
            this._holes = new lh,
            this._geometryFactory = null;
            var t = arguments[0],
                e = arguments[1];
            this._geometryFactory = e,
            this.computePoints(t),
            this.computeRing()
        };
        Fc.prototype.computeRing = function() {
            if (null !== this._ring)
                return null;
            for (var t = new Array(this._pts.size()).fill(null), e = 0; e < this._pts.size(); e++)
                t[e] = this._pts.get(e);
            this._ring = this._geometryFactory.createLinearRing(t),
            this._isHole = Xl.isCCW(this._ring.getCoordinates())
        },
        Fc.prototype.isIsolated = function() {
            return 1 === this._label.getGeometryCount()
        },
        Fc.prototype.computePoints = function(t) {
            var e = this;
            this._startDe = t;
            var n = t,
                r = !0;
            do {
                if (null === n)
                    throw new Oc("Found null DirectedEdge");
                if (n.getEdgeRing() === e)
                    throw new Oc("Directed Edge visited twice during ring-building at " + n.getCoordinate());
                e._edges.add(n);
                var i = n.getLabel();
                Gl.isTrue(i.isArea()),
                e.mergeLabel(i),
                e.addPoints(n.getEdge(), n.isForward(), r),
                r = !1,
                e.setEdgeRing(n, e),
                n = e.getNext(n)
            } while (n !== this._startDe)
        },
        Fc.prototype.getLinearRing = function() {
            return this._ring
        },
        Fc.prototype.getCoordinate = function(t) {
            return this._pts.get(t)
        },
        Fc.prototype.computeMaxNodeDegree = function() {
            var t = this;
            this._maxNodeDegree = 0;
            var e = this._startDe;
            do {
                var n = e.getNode().getEdges().getOutgoingDegree(t);
                n > t._maxNodeDegree && (t._maxNodeDegree = n),
                e = t.getNext(e)
            } while (e !== this._startDe);
            this._maxNodeDegree *= 2
        },
        Fc.prototype.addPoints = function(t, e, n) {
            var r = t.getCoordinates();
            if (e) {
                var i = 1;
                n && (i = 0);
                for (var o = i; o < r.length; o++)
                    this._pts.add(r[o])
            } else {
                var s = r.length - 2;
                n && (s = r.length - 1);
                for (var a = s; a >= 0; a--)
                    this._pts.add(r[a])
            }
        },
        Fc.prototype.isHole = function() {
            return this._isHole
        },
        Fc.prototype.setInResult = function() {
            var t = this._startDe;
            do {
                t.getEdge().setInResult(!0),
                t = t.getNext()
            } while (t !== this._startDe)
        },
        Fc.prototype.containsPoint = function(t) {
            var e = this.getLinearRing();
            if (!e.getEnvelopeInternal().contains(t))
                return !1;
            if (!Xl.isPointInRing(t, e.getCoordinates()))
                return !1;
            for (var n = this._holes.iterator(); n.hasNext();)
                if (n.next().containsPoint(t))
                    return !1;
            return !0
        },
        Fc.prototype.addHole = function(t) {
            this._holes.add(t)
        },
        Fc.prototype.isShell = function() {
            return null === this._shell
        },
        Fc.prototype.getLabel = function() {
            return this._label
        },
        Fc.prototype.getEdges = function() {
            return this._edges
        },
        Fc.prototype.getMaxNodeDegree = function() {
            return this._maxNodeDegree < 0 && this.computeMaxNodeDegree(), this._maxNodeDegree
        },
        Fc.prototype.getShell = function() {
            return this._shell
        },
        Fc.prototype.mergeLabel = function() {
            if (1 === arguments.length) {
                var t = arguments[0];
                this.mergeLabel(t, 0),
                this.mergeLabel(t, 1)
            } else if (2 === arguments.length) {
                var e = arguments[1],
                    n = arguments[0].getLocation(e, Sc.RIGHT);
                if (n === pl.NONE)
                    return null;
                if (this._label.getLocation(e) === pl.NONE)
                    return this._label.setLocation(e, n), null
            }
        },
        Fc.prototype.setShell = function(t) {
            this._shell = t,
            null !== t && t.addHole(this)
        },
        Fc.prototype.toPolygon = function(t) {
            for (var e = new Array(this._holes.size()).fill(null), n = 0; n < this._holes.size(); n++)
                e[n] = this._holes.get(n).getLinearRing();
            return t.createPolygon(this.getLinearRing(), e)
        },
        Fc.prototype.interfaces_ = function() {
            return []
        },
        Fc.prototype.getClass = function() {
            return Fc
        };
        var kc = function(t) {
                function e() {
                    var e = arguments[0],
                        n = arguments[1];
                    t.call(this, e, n)
                }
                return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.setEdgeRing = function(t, e) {
                    t.setMinEdgeRing(e)
                }, e.prototype.getNext = function(t) {
                    return t.getNextMin()
                }, e.prototype.interfaces_ = function() {
                    return []
                }, e.prototype.getClass = function() {
                    return e
                }, e
            }(Fc),
            jc = function(t) {
                function e() {
                    var e = arguments[0],
                        n = arguments[1];
                    t.call(this, e, n)
                }
                return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.buildMinimalRings = function() {
                    var t = new lh,
                        e = this._startDe;
                    do {
                        if (null === e.getMinEdgeRing()) {
                            var n = new kc(e, this._geometryFactory);
                            t.add(n)
                        }
                        e = e.getNext()
                    } while (e !== this._startDe);
                    return t
                }, e.prototype.setEdgeRing = function(t, e) {
                    t.setEdgeRing(e)
                }, e.prototype.linkDirectedEdgesForMinimalEdgeRings = function() {
                    var t = this._startDe;
                    do {
                        t.getNode().getEdges().linkMinimalDirectedEdges(this),
                        t = t.getNext()
                    } while (t !== this._startDe)
                }, e.prototype.getNext = function(t) {
                    return t.getNext()
                }, e.prototype.interfaces_ = function() {
                    return []
                }, e.prototype.getClass = function() {
                    return e
                }, e
            }(Fc),
            Gc = function() {
                if (this._label = null, this._isInResult = !1, this._isCovered = !1, this._isCoveredSet = !1, this._isVisited = !1, 0 === arguments.length)
                    ;
                else if (1 === arguments.length) {
                    var t = arguments[0];
                    this._label = t
                }
            };
        Gc.prototype.setVisited = function(t) {
            this._isVisited = t
        },
        Gc.prototype.setInResult = function(t) {
            this._isInResult = t
        },
        Gc.prototype.isCovered = function() {
            return this._isCovered
        },
        Gc.prototype.isCoveredSet = function() {
            return this._isCoveredSet
        },
        Gc.prototype.setLabel = function(t) {
            this._label = t
        },
        Gc.prototype.getLabel = function() {
            return this._label
        },
        Gc.prototype.setCovered = function(t) {
            this._isCovered = t,
            this._isCoveredSet = !0
        },
        Gc.prototype.updateIM = function(t) {
            Gl.isTrue(this._label.getGeometryCount() >= 2, "found partial label"),
            this.computeIM(t)
        },
        Gc.prototype.isInResult = function() {
            return this._isInResult
        },
        Gc.prototype.isVisited = function() {
            return this._isVisited
        },
        Gc.prototype.interfaces_ = function() {
            return []
        },
        Gc.prototype.getClass = function() {
            return Gc
        };
        var Bc = function(t) {
                function e() {
                    t.call(this),
                    this._coord = null,
                    this._edges = null;
                    var e = arguments[0],
                        n = arguments[1];
                    this._coord = e,
                    this._edges = n,
                    this._label = new Dc(0, pl.NONE)
                }
                return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.isIncidentEdgeInResult = function() {
                    for (var t = this.getEdges().getEdges().iterator(); t.hasNext();)
                        if (t.next().getEdge().isInResult())
                            return !0;
                    return !1
                }, e.prototype.isIsolated = function() {
                    return 1 === this._label.getGeometryCount()
                }, e.prototype.getCoordinate = function() {
                    return this._coord
                }, e.prototype.print = function(t) {
                    t.println("node " + this._coord + " lbl: " + this._label)
                }, e.prototype.computeIM = function(t) {}, e.prototype.computeMergedLocation = function(t, e) {
                    var n = pl.NONE;
                    if (n = this._label.getLocation(e), !t.isNull(e)) {
                        var r = t.getLocation(e);
                        n !== pl.BOUNDARY && (n = r)
                    }
                    return n
                }, e.prototype.setLabel = function() {
                    if (2 !== arguments.length)
                        return t.prototype.setLabel.apply(this, arguments);
                    var e = arguments[0],
                        n = arguments[1];
                    null === this._label ? this._label = new Dc(e, n) : this._label.setLocation(e, n)
                }, e.prototype.getEdges = function() {
                    return this._edges
                }, e.prototype.mergeLabel = function() {
                    var t = this;
                    if (arguments[0] instanceof e) {
                        var n = arguments[0];
                        this.mergeLabel(n._label)
                    } else if (arguments[0] instanceof Dc)
                        for (var r = arguments[0], i = 0; i < 2; i++) {
                            var o = t.computeMergedLocation(r, i);
                            t._label.getLocation(i) === pl.NONE && t._label.setLocation(i, o)
                        }
                }, e.prototype.add = function(t) {
                    this._edges.insert(t),
                    t.setNode(this)
                }, e.prototype.setLabelBoundary = function(t) {
                    if (null === this._label)
                        return null;
                    var e = pl.NONE;
                    null !== this._label && (e = this._label.getLocation(t));
                    var n = null;
                    switch (e) {
                    case pl.BOUNDARY:
                        n = pl.INTERIOR;
                        break;
                    case pl.INTERIOR:
                    default:
                        n = pl.BOUNDARY
                    }
                    this._label.setLocation(t, n)
                }, e.prototype.interfaces_ = function() {
                    return []
                }, e.prototype.getClass = function() {
                    return e
                }, e
            }(Gc),
            qc = function() {
                this.nodeMap = new Ih,
                this.nodeFact = null;
                var t = arguments[0];
                this.nodeFact = t
            };
        qc.prototype.find = function(t) {
            return this.nodeMap.get(t)
        },
        qc.prototype.addNode = function() {
            if (arguments[0] instanceof ul) {
                var t = arguments[0],
                    e = this.nodeMap.get(t);
                return null === e && (e = this.nodeFact.createNode(t), this.nodeMap.put(t, e)), e
            }
            if (arguments[0] instanceof Bc) {
                var n = arguments[0],
                    r = this.nodeMap.get(n.getCoordinate());
                return null === r ? (this.nodeMap.put(n.getCoordinate(), n), n) : (r.mergeLabel(n), r)
            }
        },
        qc.prototype.print = function(t) {
            for (var e = this.iterator(); e.hasNext();)
                e.next().print(t)
        },
        qc.prototype.iterator = function() {
            return this.nodeMap.values().iterator()
        },
        qc.prototype.values = function() {
            return this.nodeMap.values()
        },
        qc.prototype.getBoundaryNodes = function(t) {
            for (var e = new lh, n = this.iterator(); n.hasNext();) {
                var r = n.next();
                r.getLabel().getLocation(t) === pl.BOUNDARY && e.add(r)
            }
            return e
        },
        qc.prototype.add = function(t) {
            var e = t.getCoordinate();
            this.addNode(e).add(t)
        },
        qc.prototype.interfaces_ = function() {
            return []
        },
        qc.prototype.getClass = function() {
            return qc
        };
        var zc = function() {},
            Uc = {
                NE: {
                    configurable: !0
                },
                NW: {
                    configurable: !0
                },
                SW: {
                    configurable: !0
                },
                SE: {
                    configurable: !0
                }
            };
        zc.prototype.interfaces_ = function() {
            return []
        },
        zc.prototype.getClass = function() {
            return zc
        },
        zc.isNorthern = function(t) {
            return t === zc.NE || t === zc.NW
        },
        zc.isOpposite = function(t, e) {
            return t !== e && 2 == (t - e + 4) % 4
        },
        zc.commonHalfPlane = function(t, e) {
            if (t === e)
                return t;
            if (2 == (t - e + 4) % 4)
                return -1;
            var n = t < e ? t : e;
            return 0 === n && 3 === (t > e ? t : e) ? 3 : n
        },
        zc.isInHalfPlane = function(t, e) {
            return e === zc.SE ? t === zc.SE || t === zc.SW : t === e || t === e + 1
        },
        zc.quadrant = function() {
            if ("number" == typeof arguments[0] && "number" == typeof arguments[1]) {
                var t = arguments[0],
                    e = arguments[1];
                if (0 === t && 0 === e)
                    throw new el("Cannot compute the quadrant for point ( " + t + ", " + e + " )");
                return t >= 0 ? e >= 0 ? zc.NE : zc.SE : e >= 0 ? zc.NW : zc.SW
            }
            if (arguments[0] instanceof ul && arguments[1] instanceof ul) {
                var n = arguments[0],
                    r = arguments[1];
                if (r.x === n.x && r.y === n.y)
                    throw new el("Cannot compute the quadrant for two identical points " + n);
                return r.x >= n.x ? r.y >= n.y ? zc.NE : zc.SE : r.y >= n.y ? zc.NW : zc.SW
            }
        },
        Uc.NE.get = function() {
            return 0
        },
        Uc.NW.get = function() {
            return 1
        },
        Uc.SW.get = function() {
            return 2
        },
        Uc.SE.get = function() {
            return 3
        },
        Object.defineProperties(zc, Uc);
        var Vc = function() {
            if (this._edge = null, this._label = null, this._node = null, this._p0 = null, this._p1 = null, this._dx = null, this._dy = null, this._quadrant = null, 1 === arguments.length) {
                var t = arguments[0];
                this._edge = t
            } else if (3 === arguments.length) {
                var e = arguments[0],
                    n = arguments[1],
                    r = arguments[2],
                    i = null;
                this._edge = e,
                this.init(n, r),
                this._label = i
            } else if (4 === arguments.length) {
                var o = arguments[0],
                    s = arguments[1],
                    a = arguments[2],
                    u = arguments[3];
                this._edge = o,
                this.init(s, a),
                this._label = u
            }
        };
        Vc.prototype.compareDirection = function(t) {
            return this._dx === t._dx && this._dy === t._dy ? 0 : this._quadrant > t._quadrant ? 1 : this._quadrant < t._quadrant ? -1 : Xl.computeOrientation(t._p0, t._p1, this._p1)
        },
        Vc.prototype.getDy = function() {
            return this._dy
        },
        Vc.prototype.getCoordinate = function() {
            return this._p0
        },
        Vc.prototype.setNode = function(t) {
            this._node = t
        },
        Vc.prototype.print = function(t) {
            var e = Math.atan2(this._dy, this._dx),
                n = this.getClass().getName(),
                r = n.lastIndexOf("."),
                i = n.substring(r + 1);
            t.print("  " + i + ": " + this._p0 + " - " + this._p1 + " " + this._quadrant + ":" + e + "   " + this._label)
        },
        Vc.prototype.compareTo = function(t) {
            var e = t;
            return this.compareDirection(e)
        },
        Vc.prototype.getDirectedCoordinate = function() {
            return this._p1
        },
        Vc.prototype.getDx = function() {
            return this._dx
        },
        Vc.prototype.getLabel = function() {
            return this._label
        },
        Vc.prototype.getEdge = function() {
            return this._edge
        },
        Vc.prototype.getQuadrant = function() {
            return this._quadrant
        },
        Vc.prototype.getNode = function() {
            return this._node
        },
        Vc.prototype.toString = function() {
            var t = Math.atan2(this._dy, this._dx),
                e = this.getClass().getName(),
                n = e.lastIndexOf(".");
            return "  " + e.substring(n + 1) + ": " + this._p0 + " - " + this._p1 + " " + this._quadrant + ":" + t + "   " + this._label
        },
        Vc.prototype.computeLabel = function(t) {},
        Vc.prototype.init = function(t, e) {
            this._p0 = t,
            this._p1 = e,
            this._dx = e.x - t.x,
            this._dy = e.y - t.y,
            this._quadrant = zc.quadrant(this._dx, this._dy),
            Gl.isTrue(!(0 === this._dx && 0 === this._dy), "EdgeEnd with identical endpoints found")
        },
        Vc.prototype.interfaces_ = function() {
            return [il]
        },
        Vc.prototype.getClass = function() {
            return Vc
        };
        var Xc = function(t) {
                function e() {
                    var e = arguments[0],
                        n = arguments[1];
                    if (t.call(this, e), this._isForward = null, this._isInResult = !1, this._isVisited = !1, this._sym = null, this._next = null, this._nextMin = null, this._edgeRing = null, this._minEdgeRing = null, this._depth = [0, -999, -999], this._isForward = n, n)
                        this.init(e.getCoordinate(0), e.getCoordinate(1));
                    else {
                        var r = e.getNumPoints() - 1;
                        this.init(e.getCoordinate(r), e.getCoordinate(r - 1))
                    }
                    this.computeDirectedLabel()
                }
                return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.getNextMin = function() {
                    return this._nextMin
                }, e.prototype.getDepth = function(t) {
                    return this._depth[t]
                }, e.prototype.setVisited = function(t) {
                    this._isVisited = t
                }, e.prototype.computeDirectedLabel = function() {
                    this._label = new Dc(this._edge.getLabel()),
                    this._isForward || this._label.flip()
                }, e.prototype.getNext = function() {
                    return this._next
                }, e.prototype.setDepth = function(t, e) {
                    if (-999 !== this._depth[t] && this._depth[t] !== e)
                        throw new Oc("assigned depths do not match", this.getCoordinate());
                    this._depth[t] = e
                }, e.prototype.isInteriorAreaEdge = function() {
                    for (var t = this, e = !0, n = 0; n < 2; n++)
                        t._label.isArea(n) && t._label.getLocation(n, Sc.LEFT) === pl.INTERIOR && t._label.getLocation(n, Sc.RIGHT) === pl.INTERIOR || (e = !1);
                    return e
                }, e.prototype.setNextMin = function(t) {
                    this._nextMin = t
                }, e.prototype.print = function(e) {
                    t.prototype.print.call(this, e),
                    e.print(" " + this._depth[Sc.LEFT] + "/" + this._depth[Sc.RIGHT]),
                    e.print(" (" + this.getDepthDelta() + ")"),
                    this._isInResult && e.print(" inResult")
                }, e.prototype.setMinEdgeRing = function(t) {
                    this._minEdgeRing = t
                }, e.prototype.isLineEdge = function() {
                    var t = this._label.isLine(0) || this._label.isLine(1),
                        e = !this._label.isArea(0) || this._label.allPositionsEqual(0, pl.EXTERIOR),
                        n = !this._label.isArea(1) || this._label.allPositionsEqual(1, pl.EXTERIOR);
                    return t && e && n
                }, e.prototype.setEdgeRing = function(t) {
                    this._edgeRing = t
                }, e.prototype.getMinEdgeRing = function() {
                    return this._minEdgeRing
                }, e.prototype.getDepthDelta = function() {
                    var t = this._edge.getDepthDelta();
                    return this._isForward || (t = -t), t
                }, e.prototype.setInResult = function(t) {
                    this._isInResult = t
                }, e.prototype.getSym = function() {
                    return this._sym
                }, e.prototype.isForward = function() {
                    return this._isForward
                }, e.prototype.getEdge = function() {
                    return this._edge
                }, e.prototype.printEdge = function(t) {
                    this.print(t),
                    t.print(" "),
                    this._isForward ? this._edge.print(t) : this._edge.printReverse(t)
                }, e.prototype.setSym = function(t) {
                    this._sym = t
                }, e.prototype.setVisitedEdge = function(t) {
                    this.setVisited(t),
                    this._sym.setVisited(t)
                }, e.prototype.setEdgeDepths = function(t, e) {
                    var n = this.getEdge().getDepthDelta();
                    this._isForward || (n = -n);
                    var r = 1;
                    t === Sc.LEFT && (r = -1);
                    var i = Sc.opposite(t),
                        o = e + n * r;
                    this.setDepth(t, e),
                    this.setDepth(i, o)
                }, e.prototype.getEdgeRing = function() {
                    return this._edgeRing
                }, e.prototype.isInResult = function() {
                    return this._isInResult
                }, e.prototype.setNext = function(t) {
                    this._next = t
                }, e.prototype.isVisited = function() {
                    return this._isVisited
                }, e.prototype.interfaces_ = function() {
                    return []
                }, e.prototype.getClass = function() {
                    return e
                }, e.depthFactor = function(t, e) {
                    return t === pl.EXTERIOR && e === pl.INTERIOR ? 1 : t === pl.INTERIOR && e === pl.EXTERIOR ? -1 : 0
                }, e
            }(Vc),
            Hc = function() {};
        Hc.prototype.createNode = function(t) {
            return new Bc(t, null)
        },
        Hc.prototype.interfaces_ = function() {
            return []
        },
        Hc.prototype.getClass = function() {
            return Hc
        };
        var Yc = function() {
            if (this._edges = new lh, this._nodes = null, this._edgeEndList = new lh, 0 === arguments.length)
                this._nodes = new qc(new Hc);
            else if (1 === arguments.length) {
                var t = arguments[0];
                this._nodes = new qc(t)
            }
        };
        Yc.prototype.printEdges = function(t) {
            t.println("Edges:");
            for (var e = 0; e < this._edges.size(); e++) {
                t.println("edge " + e + ":");
                var n = this._edges.get(e);
                n.print(t),
                n.eiList.print(t)
            }
        },
        Yc.prototype.find = function(t) {
            return this._nodes.find(t)
        },
        Yc.prototype.addNode = function() {
            if (arguments[0] instanceof Bc) {
                var t = arguments[0];
                return this._nodes.addNode(t)
            }
            if (arguments[0] instanceof ul) {
                var e = arguments[0];
                return this._nodes.addNode(e)
            }
        },
        Yc.prototype.getNodeIterator = function() {
            return this._nodes.iterator()
        },
        Yc.prototype.linkResultDirectedEdges = function() {
            for (var t = this._nodes.iterator(); t.hasNext();)
                t.next().getEdges().linkResultDirectedEdges()
        },
        Yc.prototype.debugPrintln = function(t) {
            Tl.out.println(t)
        },
        Yc.prototype.isBoundaryNode = function(t, e) {
            var n = this._nodes.find(e);
            if (null === n)
                return !1;
            var r = n.getLabel();
            return null !== r && r.getLocation(t) === pl.BOUNDARY
        },
        Yc.prototype.linkAllDirectedEdges = function() {
            for (var t = this._nodes.iterator(); t.hasNext();)
                t.next().getEdges().linkAllDirectedEdges()
        },
        Yc.prototype.matchInSameDirection = function(t, e, n, r) {
            return !!t.equals(n) && Xl.computeOrientation(t, e, r) === Xl.COLLINEAR && zc.quadrant(t, e) === zc.quadrant(n, r)
        },
        Yc.prototype.getEdgeEnds = function() {
            return this._edgeEndList
        },
        Yc.prototype.debugPrint = function(t) {
            Tl.out.print(t)
        },
        Yc.prototype.getEdgeIterator = function() {
            return this._edges.iterator()
        },
        Yc.prototype.findEdgeInSameDirection = function(t, e) {
            for (var n = this, r = 0; r < this._edges.size(); r++) {
                var i = n._edges.get(r),
                    o = i.getCoordinates();
                if (n.matchInSameDirection(t, e, o[0], o[1]))
                    return i;
                if (n.matchInSameDirection(t, e, o[o.length - 1], o[o.length - 2]))
                    return i
            }
            return null
        },
        Yc.prototype.insertEdge = function(t) {
            this._edges.add(t)
        },
        Yc.prototype.findEdgeEnd = function(t) {
            for (var e = this.getEdgeEnds().iterator(); e.hasNext();) {
                var n = e.next();
                if (n.getEdge() === t)
                    return n
            }
            return null
        },
        Yc.prototype.addEdges = function(t) {
            for (var e = this, n = t.iterator(); n.hasNext();) {
                var r = n.next();
                e._edges.add(r);
                var i = new Xc(r, !0),
                    o = new Xc(r, !1);
                i.setSym(o),
                o.setSym(i),
                e.add(i),
                e.add(o)
            }
        },
        Yc.prototype.add = function(t) {
            this._nodes.add(t),
            this._edgeEndList.add(t)
        },
        Yc.prototype.getNodes = function() {
            return this._nodes.values()
        },
        Yc.prototype.findEdge = function(t, e) {
            for (var n = 0; n < this._edges.size(); n++) {
                var r = this._edges.get(n),
                    i = r.getCoordinates();
                if (t.equals(i[0]) && e.equals(i[1]))
                    return r
            }
            return null
        },
        Yc.prototype.interfaces_ = function() {
            return []
        },
        Yc.prototype.getClass = function() {
            return Yc
        },
        Yc.linkResultDirectedEdges = function(t) {
            for (var e = t.iterator(); e.hasNext();)
                e.next().getEdges().linkResultDirectedEdges()
        };
        var Wc = function() {
            this._geometryFactory = null,
            this._shellList = new lh;
            var t = arguments[0];
            this._geometryFactory = t
        };
        Wc.prototype.sortShellsAndHoles = function(t, e, n) {
            for (var r = t.iterator(); r.hasNext();) {
                var i = r.next();
                i.isHole() ? n.add(i) : e.add(i)
            }
        },
        Wc.prototype.computePolygons = function(t) {
            for (var e = new lh, n = t.iterator(); n.hasNext();) {
                var r = n.next().toPolygon(this._geometryFactory);
                e.add(r)
            }
            return e
        },
        Wc.prototype.placeFreeHoles = function(t, e) {
            for (var n = e.iterator(); n.hasNext();) {
                var r = n.next();
                if (null === r.getShell()) {
                    var i = this.findEdgeRingContaining(r, t);
                    if (null === i)
                        throw new Oc("unable to assign hole to a shell", r.getCoordinate(0));
                    r.setShell(i)
                }
            }
        },
        Wc.prototype.buildMinimalEdgeRings = function(t, e, n) {
            for (var r = new lh, i = t.iterator(); i.hasNext();) {
                var o = i.next();
                if (o.getMaxNodeDegree() > 2) {
                    o.linkDirectedEdgesForMinimalEdgeRings();
                    var s = o.buildMinimalRings(),
                        a = this.findShell(s);
                    null !== a ? (this.placePolygonHoles(a, s), e.add(a)) : n.addAll(s)
                } else
                    r.add(o)
            }
            return r
        },
        Wc.prototype.containsPoint = function(t) {
            for (var e = this._shellList.iterator(); e.hasNext();)
                if (e.next().containsPoint(t))
                    return !0;
            return !1
        },
        Wc.prototype.buildMaximalEdgeRings = function(t) {
            for (var e = new lh, n = t.iterator(); n.hasNext();) {
                var r = n.next();
                if (r.isInResult() && r.getLabel().isArea() && null === r.getEdgeRing()) {
                    var i = new jc(r, this._geometryFactory);
                    e.add(i),
                    i.setInResult()
                }
            }
            return e
        },
        Wc.prototype.placePolygonHoles = function(t, e) {
            for (var n = e.iterator(); n.hasNext();) {
                var r = n.next();
                r.isHole() && r.setShell(t)
            }
        },
        Wc.prototype.getPolygons = function() {
            return this.computePolygons(this._shellList)
        },
        Wc.prototype.findEdgeRingContaining = function(t, e) {
            for (var n = t.getLinearRing(), r = n.getEnvelopeInternal(), i = n.getCoordinateN(0), o = null, s = null, a = e.iterator(); a.hasNext();) {
                var u = a.next(),
                    l = u.getLinearRing(),
                    h = l.getEnvelopeInternal();
                null !== o && (s = o.getLinearRing().getEnvelopeInternal());
                var c = !1;
                h.contains(r) && Xl.isPointInRing(i, l.getCoordinates()) && (c = !0),
                c && (null === o || s.contains(h)) && (o = u)
            }
            return o
        },
        Wc.prototype.findShell = function(t) {
            for (var e = 0, n = null, r = t.iterator(); r.hasNext();) {
                var i = r.next();
                i.isHole() || (n = i, e++)
            }
            return Gl.isTrue(e <= 1, "found two shells in MinimalEdgeRing list"), n
        },
        Wc.prototype.add = function() {
            if (1 === arguments.length) {
                var t = arguments[0];
                this.add(t.getEdgeEnds(), t.getNodes())
            } else if (2 === arguments.length) {
                var e = arguments[0],
                    n = arguments[1];
                Yc.linkResultDirectedEdges(n);
                var r = this.buildMaximalEdgeRings(e),
                    i = new lh,
                    o = this.buildMinimalEdgeRings(r, this._shellList, i);
                this.sortShellsAndHoles(o, this._shellList, i),
                this.placeFreeHoles(this._shellList, i)
            }
        },
        Wc.prototype.interfaces_ = function() {
            return []
        },
        Wc.prototype.getClass = function() {
            return Wc
        };
        var $c = function() {};
        $c.prototype.getBounds = function() {},
        $c.prototype.interfaces_ = function() {
            return []
        },
        $c.prototype.getClass = function() {
            return $c
        };
        var Kc = function() {
            this._bounds = null,
            this._item = null;
            var t = arguments[0],
                e = arguments[1];
            this._bounds = t,
            this._item = e
        };
        Kc.prototype.getItem = function() {
            return this._item
        },
        Kc.prototype.getBounds = function() {
            return this._bounds
        },
        Kc.prototype.interfaces_ = function() {
            return [$c, al]
        },
        Kc.prototype.getClass = function() {
            return Kc
        };
        var Zc = function() {
            this._size = null,
            this._items = null,
            this._size = 0,
            this._items = new lh,
            this._items.add(null)
        };
        Zc.prototype.poll = function() {
            if (this.isEmpty())
                return null;
            var t = this._items.get(1);
            return this._items.set(1, this._items.get(this._size)), this._size -= 1, this.reorder(1), t
        },
        Zc.prototype.size = function() {
            return this._size
        },
        Zc.prototype.reorder = function(t) {
            for (var e = this, n = null, r = this._items.get(t); 2 * t <= this._size && ((n = 2 * t) !== e._size && e._items.get(n + 1).compareTo(e._items.get(n)) < 0 && n++, e._items.get(n).compareTo(r) < 0); t = n)
                e._items.set(t, e._items.get(n));
            this._items.set(t, r)
        },
        Zc.prototype.clear = function() {
            this._size = 0,
            this._items.clear()
        },
        Zc.prototype.isEmpty = function() {
            return 0 === this._size
        },
        Zc.prototype.add = function(t) {
            this._items.add(null),
            this._size += 1;
            var e = this._size;
            for (this._items.set(0, t); t.compareTo(this._items.get(Math.trunc(e / 2))) < 0; e /= 2)
                this._items.set(e, this._items.get(Math.trunc(e / 2)));
            this._items.set(e, t)
        },
        Zc.prototype.interfaces_ = function() {
            return []
        },
        Zc.prototype.getClass = function() {
            return Zc
        };
        var Jc = function() {};
        Jc.prototype.visitItem = function(t) {},
        Jc.prototype.interfaces_ = function() {
            return []
        },
        Jc.prototype.getClass = function() {
            return Jc
        };
        var Qc = function() {};
        Qc.prototype.insert = function(t, e) {},
        Qc.prototype.remove = function(t, e) {},
        Qc.prototype.query = function() {},
        Qc.prototype.interfaces_ = function() {
            return []
        },
        Qc.prototype.getClass = function() {
            return Qc
        };
        var tp = function() {
                if (this._childBoundables = new lh, this._bounds = null, this._level = null, 0 === arguments.length)
                    ;
                else if (1 === arguments.length) {
                    var t = arguments[0];
                    this._level = t
                }
            },
            ep = {
                serialVersionUID: {
                    configurable: !0
                }
            };
        tp.prototype.getLevel = function() {
            return this._level
        },
        tp.prototype.size = function() {
            return this._childBoundables.size()
        },
        tp.prototype.getChildBoundables = function() {
            return this._childBoundables
        },
        tp.prototype.addChildBoundable = function(t) {
            Gl.isTrue(null === this._bounds),
            this._childBoundables.add(t)
        },
        tp.prototype.isEmpty = function() {
            return this._childBoundables.isEmpty()
        },
        tp.prototype.getBounds = function() {
            return null === this._bounds && (this._bounds = this.computeBounds()), this._bounds
        },
        tp.prototype.interfaces_ = function() {
            return [$c, al]
        },
        tp.prototype.getClass = function() {
            return tp
        },
        ep.serialVersionUID.get = function() {
            return 0x5a1e55ec41369800
        },
        Object.defineProperties(tp, ep);
        var np = function() {};
        np.reverseOrder = function() {
            return {
                compare: function(t, e) {
                    return e.compareTo(t)
                }
            }
        },
        np.min = function(t) {
            return np.sort(t), t.get(0)
        },
        np.sort = function(t, e) {
            var n = t.toArray();
            e ? Nh.sort(n, e) : Nh.sort(n);
            for (var r = t.iterator(), i = 0, o = n.length; i < o; i++)
                r.next(),
                r.set(n[i])
        },
        np.singletonList = function(t) {
            var e = new lh;
            return e.add(t), e
        };
        var rp = function() {
            this._boundable1 = null,
            this._boundable2 = null,
            this._distance = null,
            this._itemDistance = null;
            var t = arguments[0],
                e = arguments[1],
                n = arguments[2];
            this._boundable1 = t,
            this._boundable2 = e,
            this._itemDistance = n,
            this._distance = this.distance()
        };
        rp.prototype.expandToQueue = function(t, e) {
            var n = rp.isComposite(this._boundable1),
                r = rp.isComposite(this._boundable2);
            if (n && r)
                return rp.area(this._boundable1) > rp.area(this._boundable2) ? (this.expand(this._boundable1, this._boundable2, t, e), null) : (this.expand(this._boundable2, this._boundable1, t, e), null);
            if (n)
                return this.expand(this._boundable1, this._boundable2, t, e), null;
            if (r)
                return this.expand(this._boundable2, this._boundable1, t, e), null;
            throw new el("neither boundable is composite")
        },
        rp.prototype.isLeaves = function() {
            return !(rp.isComposite(this._boundable1) || rp.isComposite(this._boundable2))
        },
        rp.prototype.compareTo = function(t) {
            var e = t;
            return this._distance < e._distance ? -1 : this._distance > e._distance ? 1 : 0
        },
        rp.prototype.expand = function(t, e, n, r) {
            for (var i = t.getChildBoundables().iterator(); i.hasNext();) {
                var o = i.next(),
                    s = new rp(o, e, this._itemDistance);
                s.getDistance() < r && n.add(s)
            }
        },
        rp.prototype.getBoundable = function(t) {
            return 0 === t ? this._boundable1 : this._boundable2
        },
        rp.prototype.getDistance = function() {
            return this._distance
        },
        rp.prototype.distance = function() {
            return this.isLeaves() ? this._itemDistance.distance(this._boundable1, this._boundable2) : this._boundable1.getBounds().distance(this._boundable2.getBounds())
        },
        rp.prototype.interfaces_ = function() {
            return [il]
        },
        rp.prototype.getClass = function() {
            return rp
        },
        rp.area = function(t) {
            return t.getBounds().getArea()
        },
        rp.isComposite = function(t) {
            return t instanceof tp
        };
        var ip = function t() {
                if (this._root = null, this._built = !1, this._itemBoundables = new lh, this._nodeCapacity = null, 0 === arguments.length) {
                    var e = t.DEFAULT_NODE_CAPACITY;
                    this._nodeCapacity = e
                } else if (1 === arguments.length) {
                    var n = arguments[0];
                    Gl.isTrue(n > 1, "Node capacity must be greater than 1"),
                    this._nodeCapacity = n
                }
            },
            op = {
                IntersectsOp: {
                    configurable: !0
                },
                serialVersionUID: {
                    configurable: !0
                },
                DEFAULT_NODE_CAPACITY: {
                    configurable: !0
                }
            };
        ip.prototype.getNodeCapacity = function() {
            return this._nodeCapacity
        },
        ip.prototype.lastNode = function(t) {
            return t.get(t.size() - 1)
        },
        ip.prototype.size = function() {
            var t = this;
            if (0 === arguments.length)
                return this.isEmpty() ? 0 : (this.build(), this.size(this._root));
            if (1 === arguments.length) {
                for (var e = 0, n = arguments[0].getChildBoundables().iterator(); n.hasNext();) {
                    var r = n.next();
                    r instanceof tp ? e += t.size(r) : r instanceof Kc && (e += 1)
                }
                return e
            }
        },
        ip.prototype.removeItem = function(t, e) {
            for (var n = null, r = t.getChildBoundables().iterator(); r.hasNext();) {
                var i = r.next();
                i instanceof Kc && i.getItem() === e && (n = i)
            }
            return null !== n && (t.getChildBoundables().remove(n), !0)
        },
        ip.prototype.itemsTree = function() {
            var t = this;
            if (0 === arguments.length) {
                this.build();
                var e = this.itemsTree(this._root);
                return null === e ? new lh : e
            }
            if (1 === arguments.length) {
                for (var n = arguments[0], r = new lh, i = n.getChildBoundables().iterator(); i.hasNext();) {
                    var o = i.next();
                    if (o instanceof tp) {
                        var s = t.itemsTree(o);
                        null !== s && r.add(s)
                    } else
                        o instanceof Kc ? r.add(o.getItem()) : Gl.shouldNeverReachHere()
                }
                return r.size() <= 0 ? null : r
            }
        },
        ip.prototype.insert = function(t, e) {
            Gl.isTrue(!this._built, "Cannot insert items into an STR packed R-tree after it has been built."),
            this._itemBoundables.add(new Kc(t, e))
        },
        ip.prototype.boundablesAtLevel = function() {
            var t = this;
            if (1 === arguments.length) {
                var e = arguments[0],
                    n = new lh;
                return this.boundablesAtLevel(e, this._root, n), n
            }
            if (3 === arguments.length) {
                var r = arguments[0],
                    i = arguments[1],
                    o = arguments[2];
                if (Gl.isTrue(r > -2), i.getLevel() === r)
                    return o.add(i), null;
                for (var s = i.getChildBoundables().iterator(); s.hasNext();) {
                    var a = s.next();
                    a instanceof tp ? t.boundablesAtLevel(r, a, o) : (Gl.isTrue(a instanceof Kc), -1 === r && o.add(a))
                }
                return null
            }
        },
        ip.prototype.query = function() {
            var t = this;
            if (1 === arguments.length) {
                var e = arguments[0];
                this.build();
                var n = new lh;
                return this.isEmpty() || this.getIntersectsOp().intersects(this._root.getBounds(), e) && this.query(e, this._root, n), n
            }
            if (2 === arguments.length) {
                var r = arguments[0],
                    i = arguments[1];
                if (this.build(), this.isEmpty())
                    return null;
                this.getIntersectsOp().intersects(this._root.getBounds(), r) && this.query(r, this._root, i)
            } else if (3 === arguments.length)
                if (dl(arguments[2], Jc) && arguments[0] instanceof Object && arguments[1] instanceof tp)
                    for (var o = arguments[0], s = arguments[2], a = arguments[1].getChildBoundables(), u = 0; u < a.size(); u++) {
                        var l = a.get(u);
                        t.getIntersectsOp().intersects(l.getBounds(), o) && (l instanceof tp ? t.query(o, l, s) : l instanceof Kc ? s.visitItem(l.getItem()) : Gl.shouldNeverReachHere())
                    }
                else if (dl(arguments[2], ah) && arguments[0] instanceof Object && arguments[1] instanceof tp)
                    for (var h = arguments[0], c = arguments[2], p = arguments[1].getChildBoundables(), f = 0; f < p.size(); f++) {
                        var d = p.get(f);
                        t.getIntersectsOp().intersects(d.getBounds(), h) && (d instanceof tp ? t.query(h, d, c) : d instanceof Kc ? c.add(d.getItem()) : Gl.shouldNeverReachHere())
                    }
        },
        ip.prototype.build = function() {
            if (this._built)
                return null;
            this._root = this._itemBoundables.isEmpty() ? this.createNode(0) : this.createHigherLevels(this._itemBoundables, -1),
            this._itemBoundables = null,
            this._built = !0
        },
        ip.prototype.getRoot = function() {
            return this.build(), this._root
        },
        ip.prototype.remove = function() {
            var t = this;
            if (2 === arguments.length) {
                var e = arguments[0],
                    n = arguments[1];
                return this.build(), !!this.getIntersectsOp().intersects(this._root.getBounds(), e) && this.remove(e, this._root, n)
            }
            if (3 === arguments.length) {
                var r = arguments[0],
                    i = arguments[1],
                    o = arguments[2],
                    s = this.removeItem(i, o);
                if (s)
                    return !0;
                for (var a = null, u = i.getChildBoundables().iterator(); u.hasNext();) {
                    var l = u.next();
                    if (t.getIntersectsOp().intersects(l.getBounds(), r) && l instanceof tp && (s = t.remove(r, l, o))) {
                        a = l;
                        break
                    }
                }
                return null !== a && a.getChildBoundables().isEmpty() && i.getChildBoundables().remove(a), s
            }
        },
        ip.prototype.createHigherLevels = function(t, e) {
            Gl.isTrue(!t.isEmpty());
            var n = this.createParentBoundables(t, e + 1);
            return 1 === n.size() ? n.get(0) : this.createHigherLevels(n, e + 1)
        },
        ip.prototype.depth = function() {
            var t = this;
            if (0 === arguments.length)
                return this.isEmpty() ? 0 : (this.build(), this.depth(this._root));
            if (1 === arguments.length) {
                for (var e = 0, n = arguments[0].getChildBoundables().iterator(); n.hasNext();) {
                    var r = n.next();
                    if (r instanceof tp) {
                        var i = t.depth(r);
                        i > e && (e = i)
                    }
                }
                return e + 1
            }
        },
        ip.prototype.createParentBoundables = function(t, e) {
            var n = this;
            Gl.isTrue(!t.isEmpty());
            var r = new lh;
            r.add(this.createNode(e));
            var i = new lh(t);
            np.sort(i, this.getComparator());
            for (var o = i.iterator(); o.hasNext();) {
                var s = o.next();
                n.lastNode(r).getChildBoundables().size() === n.getNodeCapacity() && r.add(n.createNode(e)),
                n.lastNode(r).addChildBoundable(s)
            }
            return r
        },
        ip.prototype.isEmpty = function() {
            return this._built ? this._root.isEmpty() : this._itemBoundables.isEmpty()
        },
        ip.prototype.interfaces_ = function() {
            return [al]
        },
        ip.prototype.getClass = function() {
            return ip
        },
        ip.compareDoubles = function(t, e) {
            return t > e ? 1 : t < e ? -1 : 0
        },
        op.IntersectsOp.get = function() {
            return sp
        },
        op.serialVersionUID.get = function() {
            return -0x35ef64c82d4c5400
        },
        op.DEFAULT_NODE_CAPACITY.get = function() {
            return 10
        },
        Object.defineProperties(ip, op);
        var sp = function() {},
            ap = function() {};
        ap.prototype.distance = function(t, e) {},
        ap.prototype.interfaces_ = function() {
            return []
        },
        ap.prototype.getClass = function() {
            return ap
        };
        var up = function(t) {
                function e(n) {
                    n = n || e.DEFAULT_NODE_CAPACITY,
                    t.call(this, n)
                }
                t && (e.__proto__ = t),
                e.prototype = Object.create(t && t.prototype),
                e.prototype.constructor = e;
                var n = {
                    STRtreeNode: {
                        configurable: !0
                    },
                    serialVersionUID: {
                        configurable: !0
                    },
                    xComparator: {
                        configurable: !0
                    },
                    yComparator: {
                        configurable: !0
                    },
                    intersectsOp: {
                        configurable: !0
                    },
                    DEFAULT_NODE_CAPACITY: {
                        configurable: !0
                    }
                };
                return e.prototype.createParentBoundablesFromVerticalSlices = function(t, e) {
                    Gl.isTrue(t.length > 0);
                    for (var n = new lh, r = 0; r < t.length; r++)
                        n.addAll(this.createParentBoundablesFromVerticalSlice(t[r], e));
                    return n
                }, e.prototype.createNode = function(t) {
                    return new lp(t)
                }, e.prototype.size = function() {
                    return 0 === arguments.length ? t.prototype.size.call(this) : t.prototype.size.apply(this, arguments)
                }, e.prototype.insert = function() {
                    if (2 !== arguments.length)
                        return t.prototype.insert.apply(this, arguments);
                    var e = arguments[0],
                        n = arguments[1];
                    if (e.isNull())
                        return null;
                    t.prototype.insert.call(this, e, n)
                }, e.prototype.getIntersectsOp = function() {
                    return e.intersectsOp
                }, e.prototype.verticalSlices = function(t, e) {
                    for (var n = Math.trunc(Math.ceil(t.size() / e)), r = new Array(e).fill(null), i = t.iterator(), o = 0; o < e; o++) {
                        r[o] = new lh;
                        for (var s = 0; i.hasNext() && s < n;) {
                            var a = i.next();
                            r[o].add(a),
                            s++
                        }
                    }
                    return r
                }, e.prototype.query = function() {
                    if (1 === arguments.length) {
                        var e = arguments[0];
                        return t.prototype.query.call(this, e)
                    }
                    if (2 === arguments.length) {
                        var n = arguments[0],
                            r = arguments[1];
                        t.prototype.query.call(this, n, r)
                    } else if (3 === arguments.length)
                        if (dl(arguments[2], Jc) && arguments[0] instanceof Object && arguments[1] instanceof tp) {
                            var i = arguments[0],
                                o = arguments[1],
                                s = arguments[2];
                            t.prototype.query.call(this, i, o, s)
                        } else if (dl(arguments[2], ah) && arguments[0] instanceof Object && arguments[1] instanceof tp) {
                            var a = arguments[0],
                                u = arguments[1],
                                l = arguments[2];
                            t.prototype.query.call(this, a, u, l)
                        }
                }, e.prototype.getComparator = function() {
                    return e.yComparator
                }, e.prototype.createParentBoundablesFromVerticalSlice = function(e, n) {
                    return t.prototype.createParentBoundables.call(this, e, n)
                }, e.prototype.remove = function() {
                    if (2 === arguments.length) {
                        var e = arguments[0],
                            n = arguments[1];
                        return t.prototype.remove.call(this, e, n)
                    }
                    return t.prototype.remove.apply(this, arguments)
                }, e.prototype.depth = function() {
                    return 0 === arguments.length ? t.prototype.depth.call(this) : t.prototype.depth.apply(this, arguments)
                }, e.prototype.createParentBoundables = function(t, n) {
                    Gl.isTrue(!t.isEmpty());
                    var r = Math.trunc(Math.ceil(t.size() / this.getNodeCapacity())),
                        i = new lh(t);
                    np.sort(i, e.xComparator);
                    var o = this.verticalSlices(i, Math.trunc(Math.ceil(Math.sqrt(r))));
                    return this.createParentBoundablesFromVerticalSlices(o, n)
                }, e.prototype.nearestNeighbour = function() {
                    if (1 === arguments.length) {
                        if (dl(arguments[0], ap)) {
                            var t = arguments[0],
                                n = new rp(this.getRoot(), this.getRoot(), t);
                            return this.nearestNeighbour(n)
                        }
                        if (arguments[0] instanceof rp) {
                            var r = arguments[0];
                            return this.nearestNeighbour(r, nl.POSITIVE_INFINITY)
                        }
                    } else if (2 === arguments.length) {
                        if (arguments[0] instanceof e && dl(arguments[1], ap)) {
                            var i = arguments[0],
                                o = arguments[1],
                                s = new rp(this.getRoot(), i.getRoot(), o);
                            return this.nearestNeighbour(s)
                        }
                        if (arguments[0] instanceof rp && "number" == typeof arguments[1]) {
                            var a = arguments[0],
                                u = arguments[1],
                                l = null,
                                h = new Zc;
                            for (h.add(a); !h.isEmpty() && u > 0;) {
                                var c = h.poll(),
                                    p = c.getDistance();
                                if (p >= u)
                                    break;
                                c.isLeaves() ? (u = p, l = c) : c.expandToQueue(h, u)
                            }
                            return [l.getBoundable(0).getItem(), l.getBoundable(1).getItem()]
                        }
                    } else if (3 === arguments.length) {
                        var f = arguments[2],
                            d = new Kc(arguments[0], arguments[1]),
                            g = new rp(this.getRoot(), d, f);
                        return this.nearestNeighbour(g)[0]
                    }
                }, e.prototype.interfaces_ = function() {
                    return [Qc, al]
                }, e.prototype.getClass = function() {
                    return e
                }, e.centreX = function(t) {
                    return e.avg(t.getMinX(), t.getMaxX())
                }, e.avg = function(t, e) {
                    return (t + e) / 2
                }, e.centreY = function(t) {
                    return e.avg(t.getMinY(), t.getMaxY())
                }, n.STRtreeNode.get = function() {
                    return lp
                }, n.serialVersionUID.get = function() {
                    return 0x39920f7d5f261e0
                }, n.xComparator.get = function() {
                    return {
                        interfaces_: function() {
                            return [sl]
                        },
                        compare: function(n, r) {
                            return t.compareDoubles(e.centreX(n.getBounds()), e.centreX(r.getBounds()))
                        }
                    }
                }, n.yComparator.get = function() {
                    return {
                        interfaces_: function() {
                            return [sl]
                        },
                        compare: function(n, r) {
                            return t.compareDoubles(e.centreY(n.getBounds()), e.centreY(r.getBounds()))
                        }
                    }
                }, n.intersectsOp.get = function() {
                    return {
                        interfaces_: function() {
                            return [t.IntersectsOp]
                        },
                        intersects: function(t, e) {
                            return t.intersects(e)
                        }
                    }
                }, n.DEFAULT_NODE_CAPACITY.get = function() {
                    return 10
                }, Object.defineProperties(e, n), e
            }(ip),
            lp = function(t) {
                function e() {
                    var e = arguments[0];
                    t.call(this, e)
                }
                return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.computeBounds = function() {
                    for (var t = null, e = this.getChildBoundables().iterator(); e.hasNext();) {
                        var n = e.next();
                        null === t ? t = new Ll(n.getBounds()) : t.expandToInclude(n.getBounds())
                    }
                    return t
                }, e.prototype.interfaces_ = function() {
                    return []
                }, e.prototype.getClass = function() {
                    return e
                }, e
            }(tp),
            hp = function() {};
        hp.prototype.interfaces_ = function() {
            return []
        },
        hp.prototype.getClass = function() {
            return hp
        },
        hp.relativeSign = function(t, e) {
            return t < e ? -1 : t > e ? 1 : 0
        },
        hp.compare = function(t, e, n) {
            if (e.equals2D(n))
                return 0;
            var r = hp.relativeSign(e.x, n.x),
                i = hp.relativeSign(e.y, n.y);
            switch (t) {
            case 0:
                return hp.compareValue(r, i);
            case 1:
                return hp.compareValue(i, r);
            case 2:
                return hp.compareValue(i, -r);
            case 3:
                return hp.compareValue(-r, i);
            case 4:
                return hp.compareValue(-r, -i);
            case 5:
                return hp.compareValue(-i, -r);
            case 6:
                return hp.compareValue(-i, r);
            case 7:
                return hp.compareValue(r, -i)
            }
            return Gl.shouldNeverReachHere("invalid octant value"), 0
        },
        hp.compareValue = function(t, e) {
            return t < 0 ? -1 : t > 0 ? 1 : e < 0 ? -1 : e > 0 ? 1 : 0
        };
        var cp = function() {
            this._segString = null,
            this.coord = null,
            this.segmentIndex = null,
            this._segmentOctant = null,
            this._isInterior = null;
            var t = arguments[0],
                e = arguments[1],
                n = arguments[2],
                r = arguments[3];
            this._segString = t,
            this.coord = new ul(e),
            this.segmentIndex = n,
            this._segmentOctant = r,
            this._isInterior = !e.equals2D(t.getCoordinate(n))
        };
        cp.prototype.getCoordinate = function() {
            return this.coord
        },
        cp.prototype.print = function(t) {
            t.print(this.coord),
            t.print(" seg # = " + this.segmentIndex)
        },
        cp.prototype.compareTo = function(t) {
            var e = t;
            return this.segmentIndex < e.segmentIndex ? -1 : this.segmentIndex > e.segmentIndex ? 1 : this.coord.equals2D(e.coord) ? 0 : hp.compare(this._segmentOctant, this.coord, e.coord)
        },
        cp.prototype.isEndPoint = function(t) {
            return 0 === this.segmentIndex && !this._isInterior || this.segmentIndex === t
        },
        cp.prototype.isInterior = function() {
            return this._isInterior
        },
        cp.prototype.interfaces_ = function() {
            return [il]
        },
        cp.prototype.getClass = function() {
            return cp
        };
        var pp = function() {
            this._nodeMap = new Ih,
            this._edge = null;
            var t = arguments[0];
            this._edge = t
        };
        pp.prototype.getSplitCoordinates = function() {
            var t = new ch;
            this.addEndpoints();
            for (var e = this.iterator(), n = e.next(); e.hasNext();) {
                var r = e.next();
                this.addEdgeCoordinates(n, r, t),
                n = r
            }
            return t.toCoordinateArray()
        },
        pp.prototype.addCollapsedNodes = function() {
            var t = new lh;
            this.findCollapsesFromInsertedNodes(t),
            this.findCollapsesFromExistingVertices(t);
            for (var e = t.iterator(); e.hasNext();) {
                var n = e.next().intValue();
                this.add(this._edge.getCoordinate(n), n)
            }
        },
        pp.prototype.print = function(t) {
            t.println("Intersections:");
            for (var e = this.iterator(); e.hasNext();)
                e.next().print(t)
        },
        pp.prototype.findCollapsesFromExistingVertices = function(t) {
            for (var e = 0; e < this._edge.size() - 2; e++) {
                var n = this._edge.getCoordinate(e),
                    r = this._edge.getCoordinate(e + 2);
                n.equals2D(r) && t.add(new ml(e + 1))
            }
        },
        pp.prototype.addEdgeCoordinates = function(t, e, n) {
            var r = this._edge.getCoordinate(e.segmentIndex),
                i = e.isInterior() || !e.coord.equals2D(r);
            n.add(new ul(t.coord), !1);
            for (var o = t.segmentIndex + 1; o <= e.segmentIndex; o++)
                n.add(this._edge.getCoordinate(o));
            i && n.add(new ul(e.coord))
        },
        pp.prototype.iterator = function() {
            return this._nodeMap.values().iterator()
        },
        pp.prototype.addSplitEdges = function(t) {
            this.addEndpoints(),
            this.addCollapsedNodes();
            for (var e = this.iterator(), n = e.next(); e.hasNext();) {
                var r = e.next(),
                    i = this.createSplitEdge(n, r);
                t.add(i),
                n = r
            }
        },
        pp.prototype.findCollapseIndex = function(t, e, n) {
            if (!t.coord.equals2D(e.coord))
                return !1;
            var r = e.segmentIndex - t.segmentIndex;
            return e.isInterior() || r--, 1 === r && (n[0] = t.segmentIndex + 1, !0)
        },
        pp.prototype.findCollapsesFromInsertedNodes = function(t) {
            for (var e = new Array(1).fill(null), n = this.iterator(), r = n.next(); n.hasNext();) {
                var i = n.next();
                this.findCollapseIndex(r, i, e) && t.add(new ml(e[0])),
                r = i
            }
        },
        pp.prototype.getEdge = function() {
            return this._edge
        },
        pp.prototype.addEndpoints = function() {
            var t = this._edge.size() - 1;
            this.add(this._edge.getCoordinate(0), 0),
            this.add(this._edge.getCoordinate(t), t)
        },
        pp.prototype.createSplitEdge = function(t, e) {
            var n = e.segmentIndex - t.segmentIndex + 2,
                r = this._edge.getCoordinate(e.segmentIndex),
                i = e.isInterior() || !e.coord.equals2D(r);
            i || n--;
            var o = new Array(n).fill(null),
                s = 0;
            o[s++] = new ul(t.coord);
            for (var a = t.segmentIndex + 1; a <= e.segmentIndex; a++)
                o[s++] = this._edge.getCoordinate(a);
            return i && (o[s] = new ul(e.coord)), new yp(o, this._edge.getData())
        },
        pp.prototype.add = function(t, e) {
            var n = new cp(this._edge, t, e, this._edge.getSegmentOctant(e)),
                r = this._nodeMap.get(n);
            return null !== r ? (Gl.isTrue(r.coord.equals2D(t), "Found equal nodes with different coordinates"), r) : (this._nodeMap.put(n, n), n)
        },
        pp.prototype.checkSplitEdgesCorrectness = function(t) {
            var e = this._edge.getCoordinates(),
                n = t.get(0).getCoordinate(0);
            if (!n.equals2D(e[0]))
                throw new kl("bad split edge start point at " + n);
            var r = t.get(t.size() - 1).getCoordinates(),
                i = r[r.length - 1];
            if (!i.equals2D(e[e.length - 1]))
                throw new kl("bad split edge end point at " + i)
        },
        pp.prototype.interfaces_ = function() {
            return []
        },
        pp.prototype.getClass = function() {
            return pp
        };
        var fp = function() {};
        fp.prototype.interfaces_ = function() {
            return []
        },
        fp.prototype.getClass = function() {
            return fp
        },
        fp.octant = function() {
            if ("number" == typeof arguments[0] && "number" == typeof arguments[1]) {
                var t = arguments[0],
                    e = arguments[1];
                if (0 === t && 0 === e)
                    throw new el("Cannot compute the octant for point ( " + t + ", " + e + " )");
                var n = Math.abs(t),
                    r = Math.abs(e);
                return t >= 0 ? e >= 0 ? n >= r ? 0 : 1 : n >= r ? 7 : 6 : e >= 0 ? n >= r ? 3 : 2 : n >= r ? 4 : 5
            }
            if (arguments[0] instanceof ul && arguments[1] instanceof ul) {
                var i = arguments[0],
                    o = arguments[1],
                    s = o.x - i.x,
                    a = o.y - i.y;
                if (0 === s && 0 === a)
                    throw new el("Cannot compute the octant for two identical points " + i);
                return fp.octant(s, a)
            }
        };
        var dp = function() {};
        dp.prototype.getCoordinates = function() {},
        dp.prototype.size = function() {},
        dp.prototype.getCoordinate = function(t) {},
        dp.prototype.isClosed = function() {},
        dp.prototype.setData = function(t) {},
        dp.prototype.getData = function() {},
        dp.prototype.interfaces_ = function() {
            return []
        },
        dp.prototype.getClass = function() {
            return dp
        };
        var gp = function() {};
        gp.prototype.addIntersection = function(t, e) {},
        gp.prototype.interfaces_ = function() {
            return [dp]
        },
        gp.prototype.getClass = function() {
            return gp
        };
        var yp = function() {
            this._nodeList = new pp(this),
            this._pts = null,
            this._data = null;
            var t = arguments[0],
                e = arguments[1];
            this._pts = t,
            this._data = e
        };
        yp.prototype.getCoordinates = function() {
            return this._pts
        },
        yp.prototype.size = function() {
            return this._pts.length
        },
        yp.prototype.getCoordinate = function(t) {
            return this._pts[t]
        },
        yp.prototype.isClosed = function() {
            return this._pts[0].equals(this._pts[this._pts.length - 1])
        },
        yp.prototype.getSegmentOctant = function(t) {
            return t === this._pts.length - 1 ? -1 : this.safeOctant(this.getCoordinate(t), this.getCoordinate(t + 1))
        },
        yp.prototype.setData = function(t) {
            this._data = t
        },
        yp.prototype.safeOctant = function(t, e) {
            return t.equals2D(e) ? 0 : fp.octant(t, e)
        },
        yp.prototype.getData = function() {
            return this._data
        },
        yp.prototype.addIntersection = function() {
            if (2 === arguments.length) {
                var t = arguments[0],
                    e = arguments[1];
                this.addIntersectionNode(t, e)
            } else if (4 === arguments.length) {
                var n = arguments[1],
                    r = arguments[3],
                    i = new ul(arguments[0].getIntersection(r));
                this.addIntersection(i, n)
            }
        },
        yp.prototype.toString = function() {
            return Fl.toLineString(new lc(this._pts))
        },
        yp.prototype.getNodeList = function() {
            return this._nodeList
        },
        yp.prototype.addIntersectionNode = function(t, e) {
            var n = e,
                r = n + 1;
            if (r < this._pts.length) {
                var i = this._pts[r];
                t.equals2D(i) && (n = r)
            }
            return this._nodeList.add(t, n)
        },
        yp.prototype.addIntersections = function(t, e, n) {
            for (var r = 0; r < t.getIntersectionNum(); r++)
                this.addIntersection(t, e, n, r)
        },
        yp.prototype.interfaces_ = function() {
            return [gp]
        },
        yp.prototype.getClass = function() {
            return yp
        },
        yp.getNodedSubstrings = function() {
            if (1 === arguments.length) {
                var t = arguments[0],
                    e = new lh;
                return yp.getNodedSubstrings(t, e), e
            }
            if (2 === arguments.length)
                for (var n = arguments[1], r = arguments[0].iterator(); r.hasNext();)
                    r.next().getNodeList().addSplitEdges(n)
        };
        var vp = function() {
                if (this.p0 = null, this.p1 = null, 0 === arguments.length)
                    this.p0 = new ul,
                    this.p1 = new ul;
                else if (1 === arguments.length) {
                    var t = arguments[0];
                    this.p0 = new ul(t.p0),
                    this.p1 = new ul(t.p1)
                } else if (2 === arguments.length)
                    this.p0 = arguments[0],
                    this.p1 = arguments[1];
                else if (4 === arguments.length) {
                    var e = arguments[0],
                        n = arguments[1],
                        r = arguments[2],
                        i = arguments[3];
                    this.p0 = new ul(e, n),
                    this.p1 = new ul(r, i)
                }
            },
            mp = {
                serialVersionUID: {
                    configurable: !0
                }
            };
        vp.prototype.minX = function() {
            return Math.min(this.p0.x, this.p1.x)
        },
        vp.prototype.orientationIndex = function() {
            if (arguments[0] instanceof vp) {
                var t = arguments[0],
                    e = Xl.orientationIndex(this.p0, this.p1, t.p0),
                    n = Xl.orientationIndex(this.p0, this.p1, t.p1);
                return e >= 0 && n >= 0 || e <= 0 && n <= 0 ? Math.max(e, n) : 0
            }
            if (arguments[0] instanceof ul) {
                var r = arguments[0];
                return Xl.orientationIndex(this.p0, this.p1, r)
            }
        },
        vp.prototype.toGeometry = function(t) {
            return t.createLineString([this.p0, this.p1])
        },
        vp.prototype.isVertical = function() {
            return this.p0.x === this.p1.x
        },
        vp.prototype.equals = function(t) {
            if (!(t instanceof vp))
                return !1;
            var e = t;
            return this.p0.equals(e.p0) && this.p1.equals(e.p1)
        },
        vp.prototype.intersection = function(t) {
            var e = new zl;
            return e.computeIntersection(this.p0, this.p1, t.p0, t.p1), e.hasIntersection() ? e.getIntersection(0) : null
        },
        vp.prototype.project = function() {
            if (arguments[0] instanceof ul) {
                var t = arguments[0];
                if (t.equals(this.p0) || t.equals(this.p1))
                    return new ul(t);
                var e = this.projectionFactor(t),
                    n = new ul;
                return n.x = this.p0.x + e * (this.p1.x - this.p0.x), n.y = this.p0.y + e * (this.p1.y - this.p0.y), n
            }
            if (arguments[0] instanceof vp) {
                var r = arguments[0],
                    i = this.projectionFactor(r.p0),
                    o = this.projectionFactor(r.p1);
                if (i >= 1 && o >= 1)
                    return null;
                if (i <= 0 && o <= 0)
                    return null;
                var s = this.project(r.p0);
                i < 0 && (s = this.p0),
                i > 1 && (s = this.p1);
                var a = this.project(r.p1);
                return o < 0 && (a = this.p0), o > 1 && (a = this.p1), new vp(s, a)
            }
        },
        vp.prototype.normalize = function() {
            this.p1.compareTo(this.p0) < 0 && this.reverse()
        },
        vp.prototype.angle = function() {
            return Math.atan2(this.p1.y - this.p0.y, this.p1.x - this.p0.x)
        },
        vp.prototype.getCoordinate = function(t) {
            return 0 === t ? this.p0 : this.p1
        },
        vp.prototype.distancePerpendicular = function(t) {
            return Xl.distancePointLinePerpendicular(t, this.p0, this.p1)
        },
        vp.prototype.minY = function() {
            return Math.min(this.p0.y, this.p1.y)
        },
        vp.prototype.midPoint = function() {
            return vp.midPoint(this.p0, this.p1)
        },
        vp.prototype.projectionFactor = function(t) {
            if (t.equals(this.p0))
                return 0;
            if (t.equals(this.p1))
                return 1;
            var e = this.p1.x - this.p0.x,
                n = this.p1.y - this.p0.y,
                r = e * e + n * n;
            return r <= 0 ? nl.NaN : ((t.x - this.p0.x) * e + (t.y - this.p0.y) * n) / r
        },
        vp.prototype.closestPoints = function(t) {
            var e = this.intersection(t);
            if (null !== e)
                return [e, e];
            var n = new Array(2).fill(null),
                r = nl.MAX_VALUE,
                i = null,
                o = this.closestPoint(t.p0);
            r = o.distance(t.p0),
            n[0] = o,
            n[1] = t.p0;
            var s = this.closestPoint(t.p1);
            (i = s.distance(t.p1)) < r && (r = i, n[0] = s, n[1] = t.p1);
            var a = t.closestPoint(this.p0);
            (i = a.distance(this.p0)) < r && (r = i, n[0] = this.p0, n[1] = a);
            var u = t.closestPoint(this.p1);
            return (i = u.distance(this.p1)) < r && (r = i, n[0] = this.p1, n[1] = u), n
        },
        vp.prototype.closestPoint = function(t) {
            var e = this.projectionFactor(t);
            return e > 0 && e < 1 ? this.project(t) : this.p0.distance(t) < this.p1.distance(t) ? this.p0 : this.p1
        },
        vp.prototype.maxX = function() {
            return Math.max(this.p0.x, this.p1.x)
        },
        vp.prototype.getLength = function() {
            return this.p0.distance(this.p1)
        },
        vp.prototype.compareTo = function(t) {
            var e = t,
                n = this.p0.compareTo(e.p0);
            return 0 !== n ? n : this.p1.compareTo(e.p1)
        },
        vp.prototype.reverse = function() {
            var t = this.p0;
            this.p0 = this.p1,
            this.p1 = t
        },
        vp.prototype.equalsTopo = function(t) {
            return this.p0.equals(t.p0) && (this.p1.equals(t.p1) || this.p0.equals(t.p1)) && this.p1.equals(t.p0)
        },
        vp.prototype.lineIntersection = function(t) {
            try {
                return Pl.intersection(this.p0, this.p1, t.p0, t.p1)
            } catch (t) {
                if (!(t instanceof Il))
                    throw t
            }
            return null
        },
        vp.prototype.maxY = function() {
            return Math.max(this.p0.y, this.p1.y)
        },
        vp.prototype.pointAlongOffset = function(t, e) {
            var n = this.p0.x + t * (this.p1.x - this.p0.x),
                r = this.p0.y + t * (this.p1.y - this.p0.y),
                i = this.p1.x - this.p0.x,
                o = this.p1.y - this.p0.y,
                s = Math.sqrt(i * i + o * o),
                a = 0,
                u = 0;
            if (0 !== e) {
                if (s <= 0)
                    throw new Error("Cannot compute offset from zero-length line segment");
                a = e * i / s,
                u = e * o / s
            }
            return new ul(n - u, r + a)
        },
        vp.prototype.setCoordinates = function() {
            if (1 === arguments.length) {
                var t = arguments[0];
                this.setCoordinates(t.p0, t.p1)
            } else if (2 === arguments.length) {
                var e = arguments[0],
                    n = arguments[1];
                this.p0.x = e.x,
                this.p0.y = e.y,
                this.p1.x = n.x,
                this.p1.y = n.y
            }
        },
        vp.prototype.segmentFraction = function(t) {
            var e = this.projectionFactor(t);
            return e < 0 ? e = 0 : (e > 1 || nl.isNaN(e)) && (e = 1), e
        },
        vp.prototype.toString = function() {
            return "LINESTRING( " + this.p0.x + " " + this.p0.y + ", " + this.p1.x + " " + this.p1.y + ")"
        },
        vp.prototype.isHorizontal = function() {
            return this.p0.y === this.p1.y
        },
        vp.prototype.distance = function() {
            if (arguments[0] instanceof vp) {
                var t = arguments[0];
                return Xl.distanceLineLine(this.p0, this.p1, t.p0, t.p1)
            }
            if (arguments[0] instanceof ul) {
                var e = arguments[0];
                return Xl.distancePointLine(e, this.p0, this.p1)
            }
        },
        vp.prototype.pointAlong = function(t) {
            var e = new ul;
            return e.x = this.p0.x + t * (this.p1.x - this.p0.x), e.y = this.p0.y + t * (this.p1.y - this.p0.y), e
        },
        vp.prototype.hashCode = function() {
            var t = nl.doubleToLongBits(this.p0.x);
            t ^= 31 * nl.doubleToLongBits(this.p0.y);
            var e = Math.trunc(t) ^ Math.trunc(t >> 32),
                n = nl.doubleToLongBits(this.p1.x);
            return n ^= 31 * nl.doubleToLongBits(this.p1.y), e ^ Math.trunc(n) ^ Math.trunc(n >> 32)
        },
        vp.prototype.interfaces_ = function() {
            return [il, al]
        },
        vp.prototype.getClass = function() {
            return vp
        },
        vp.midPoint = function(t, e) {
            return new ul((t.x + e.x) / 2, (t.y + e.y) / 2)
        },
        mp.serialVersionUID.get = function() {
            return 0x2d2172135f411c00
        },
        Object.defineProperties(vp, mp);
        var _p = function() {
            this.tempEnv1 = new Ll,
            this.tempEnv2 = new Ll,
            this._overlapSeg1 = new vp,
            this._overlapSeg2 = new vp
        };
        _p.prototype.overlap = function() {
            if (2 === arguments.length)
                ;
            else if (4 === arguments.length) {
                var t = arguments[1],
                    e = arguments[2],
                    n = arguments[3];
                arguments[0].getLineSegment(t, this._overlapSeg1),
                e.getLineSegment(n, this._overlapSeg2),
                this.overlap(this._overlapSeg1, this._overlapSeg2)
            }
        },
        _p.prototype.interfaces_ = function() {
            return []
        },
        _p.prototype.getClass = function() {
            return _p
        };
        var xp = function() {
            this._pts = null,
            this._start = null,
            this._end = null,
            this._env = null,
            this._context = null,
            this._id = null;
            var t = arguments[0],
                e = arguments[1],
                n = arguments[2],
                r = arguments[3];
            this._pts = t,
            this._start = e,
            this._end = n,
            this._context = r
        };
        xp.prototype.getLineSegment = function(t, e) {
            e.p0 = this._pts[t],
            e.p1 = this._pts[t + 1]
        },
        xp.prototype.computeSelect = function(t, e, n, r) {
            var i = this._pts[e],
                o = this._pts[n];
            if (r.tempEnv1.init(i, o), n - e == 1)
                return r.select(this, e), null;
            if (!t.intersects(r.tempEnv1))
                return null;
            var s = Math.trunc((e + n) / 2);
            e < s && this.computeSelect(t, e, s, r),
            s < n && this.computeSelect(t, s, n, r)
        },
        xp.prototype.getCoordinates = function() {
            for (var t = new Array(this._end - this._start + 1).fill(null), e = 0, n = this._start; n <= this._end; n++)
                t[e++] = this._pts[n];
            return t
        },
        xp.prototype.computeOverlaps = function(t, e) {
            this.computeOverlapsInternal(this._start, this._end, t, t._start, t._end, e)
        },
        xp.prototype.setId = function(t) {
            this._id = t
        },
        xp.prototype.select = function(t, e) {
            this.computeSelect(t, this._start, this._end, e)
        },
        xp.prototype.getEnvelope = function() {
            if (null === this._env) {
                var t = this._pts[this._start],
                    e = this._pts[this._end];
                this._env = new Ll(t, e)
            }
            return this._env
        },
        xp.prototype.getEndIndex = function() {
            return this._end
        },
        xp.prototype.getStartIndex = function() {
            return this._start
        },
        xp.prototype.getContext = function() {
            return this._context
        },
        xp.prototype.getId = function() {
            return this._id
        },
        xp.prototype.computeOverlapsInternal = function(t, e, n, r, i, o) {
            var s = this._pts[t],
                a = this._pts[e],
                u = n._pts[r],
                l = n._pts[i];
            if (e - t == 1 && i - r == 1)
                return o.overlap(this, t, n, r), null;
            if (o.tempEnv1.init(s, a), o.tempEnv2.init(u, l), !o.tempEnv1.intersects(o.tempEnv2))
                return null;
            var h = Math.trunc((t + e) / 2),
                c = Math.trunc((r + i) / 2);
            t < h && (r < c && this.computeOverlapsInternal(t, h, n, r, c, o), c < i && this.computeOverlapsInternal(t, h, n, c, i, o)),
            h < e && (r < c && this.computeOverlapsInternal(h, e, n, r, c, o), c < i && this.computeOverlapsInternal(h, e, n, c, i, o))
        },
        xp.prototype.interfaces_ = function() {
            return []
        },
        xp.prototype.getClass = function() {
            return xp
        };
        var Ep = function() {};
        Ep.prototype.interfaces_ = function() {
            return []
        },
        Ep.prototype.getClass = function() {
            return Ep
        },
        Ep.getChainStartIndices = function(t) {
            var e = 0,
                n = new lh;
            n.add(new ml(e));
            do {
                var r = Ep.findChainEnd(t, e);
                n.add(new ml(r)),
                e = r
            } while (e < t.length - 1);
            return Ep.toIntArray(n)
        },
        Ep.findChainEnd = function(t, e) {
            for (var n = e; n < t.length - 1 && t[n].equals2D(t[n + 1]);)
                n++;
            if (n >= t.length - 1)
                return t.length - 1;
            for (var r = zc.quadrant(t[n], t[n + 1]), i = e + 1; i < t.length && (t[i - 1].equals2D(t[i]) || zc.quadrant(t[i - 1], t[i]) === r);)
                i++;
            return i - 1
        },
        Ep.getChains = function() {
            if (1 === arguments.length) {
                var t = arguments[0];
                return Ep.getChains(t, null)
            }
            if (2 === arguments.length) {
                for (var e = arguments[0], n = arguments[1], r = new lh, i = Ep.getChainStartIndices(e), o = 0; o < i.length - 1; o++) {
                    var s = new xp(e, i[o], i[o + 1], n);
                    r.add(s)
                }
                return r
            }
        },
        Ep.toIntArray = function(t) {
            for (var e = new Array(t.size()).fill(null), n = 0; n < e.length; n++)
                e[n] = t.get(n).intValue();
            return e
        };
        var wp = function() {};
        wp.prototype.computeNodes = function(t) {},
        wp.prototype.getNodedSubstrings = function() {},
        wp.prototype.interfaces_ = function() {
            return []
        },
        wp.prototype.getClass = function() {
            return wp
        };
        var bp = function() {
            if (this._segInt = null, 0 === arguments.length)
                ;
            else if (1 === arguments.length) {
                var t = arguments[0];
                this.setSegmentIntersector(t)
            }
        };
        bp.prototype.setSegmentIntersector = function(t) {
            this._segInt = t
        },
        bp.prototype.interfaces_ = function() {
            return [wp]
        },
        bp.prototype.getClass = function() {
            return bp
        };
        var Cp = function(t) {
                function e(e) {
                    e ? t.call(this, e) : t.call(this),
                    this._monoChains = new lh,
                    this._index = new up,
                    this._idCounter = 0,
                    this._nodedSegStrings = null,
                    this._nOverlaps = 0
                }
                t && (e.__proto__ = t),
                e.prototype = Object.create(t && t.prototype),
                e.prototype.constructor = e;
                var n = {
                    SegmentOverlapAction: {
                        configurable: !0
                    }
                };
                return e.prototype.getMonotoneChains = function() {
                    return this._monoChains
                }, e.prototype.getNodedSubstrings = function() {
                    return yp.getNodedSubstrings(this._nodedSegStrings)
                }, e.prototype.getIndex = function() {
                    return this._index
                }, e.prototype.add = function(t) {
                    for (var e = this, n = Ep.getChains(t.getCoordinates(), t).iterator(); n.hasNext();) {
                        var r = n.next();
                        r.setId(e._idCounter++),
                        e._index.insert(r.getEnvelope(), r),
                        e._monoChains.add(r)
                    }
                }, e.prototype.computeNodes = function(t) {
                    this._nodedSegStrings = t;
                    for (var e = t.iterator(); e.hasNext();)
                        this.add(e.next());
                    this.intersectChains()
                }, e.prototype.intersectChains = function() {
                    for (var t = this, e = new Mp(this._segInt), n = this._monoChains.iterator(); n.hasNext();)
                        for (var r = n.next(), i = t._index.query(r.getEnvelope()).iterator(); i.hasNext();) {
                            var o = i.next();
                            if (o.getId() > r.getId() && (r.computeOverlaps(o, e), t._nOverlaps++), t._segInt.isDone())
                                return null
                        }
                }, e.prototype.interfaces_ = function() {
                    return []
                }, e.prototype.getClass = function() {
                    return e
                }, n.SegmentOverlapAction.get = function() {
                    return Mp
                }, Object.defineProperties(e, n), e
            }(bp),
            Mp = function(t) {
                function e() {
                    t.call(this),
                    this._si = null;
                    var e = arguments[0];
                    this._si = e
                }
                return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.overlap = function() {
                    if (4 !== arguments.length)
                        return t.prototype.overlap.apply(this, arguments);
                    var e = arguments[1],
                        n = arguments[2],
                        r = arguments[3],
                        i = arguments[0].getContext(),
                        o = n.getContext();
                    this._si.processIntersections(i, e, o, r)
                }, e.prototype.interfaces_ = function() {
                    return []
                }, e.prototype.getClass = function() {
                    return e
                }, e
            }(_p),
            Sp = function t() {
                if (this._quadrantSegments = t.DEFAULT_QUADRANT_SEGMENTS, this._endCapStyle = t.CAP_ROUND, this._joinStyle = t.JOIN_ROUND, this._mitreLimit = t.DEFAULT_MITRE_LIMIT, this._isSingleSided = !1, this._simplifyFactor = t.DEFAULT_SIMPLIFY_FACTOR, 0 === arguments.length)
                    ;
                else if (1 === arguments.length) {
                    var e = arguments[0];
                    this.setQuadrantSegments(e)
                } else if (2 === arguments.length) {
                    var n = arguments[0],
                        r = arguments[1];
                    this.setQuadrantSegments(n),
                    this.setEndCapStyle(r)
                } else if (4 === arguments.length) {
                    var i = arguments[0],
                        o = arguments[1],
                        s = arguments[2],
                        a = arguments[3];
                    this.setQuadrantSegments(i),
                    this.setEndCapStyle(o),
                    this.setJoinStyle(s),
                    this.setMitreLimit(a)
                }
            },
            Ip = {
                CAP_ROUND: {
                    configurable: !0
                },
                CAP_FLAT: {
                    configurable: !0
                },
                CAP_SQUARE: {
                    configurable: !0
                },
                JOIN_ROUND: {
                    configurable: !0
                },
                JOIN_MITRE: {
                    configurable: !0
                },
                JOIN_BEVEL: {
                    configurable: !0
                },
                DEFAULT_QUADRANT_SEGMENTS: {
                    configurable: !0
                },
                DEFAULT_MITRE_LIMIT: {
                    configurable: !0
                },
                DEFAULT_SIMPLIFY_FACTOR: {
                    configurable: !0
                }
            };
        Sp.prototype.getEndCapStyle = function() {
            return this._endCapStyle
        },
        Sp.prototype.isSingleSided = function() {
            return this._isSingleSided
        },
        Sp.prototype.setQuadrantSegments = function(t) {
            this._quadrantSegments = t,
            0 === this._quadrantSegments && (this._joinStyle = Sp.JOIN_BEVEL),
            this._quadrantSegments < 0 && (this._joinStyle = Sp.JOIN_MITRE, this._mitreLimit = Math.abs(this._quadrantSegments)),
            t <= 0 && (this._quadrantSegments = 1),
            this._joinStyle !== Sp.JOIN_ROUND && (this._quadrantSegments = Sp.DEFAULT_QUADRANT_SEGMENTS)
        },
        Sp.prototype.getJoinStyle = function() {
            return this._joinStyle
        },
        Sp.prototype.setJoinStyle = function(t) {
            this._joinStyle = t
        },
        Sp.prototype.setSimplifyFactor = function(t) {
            this._simplifyFactor = t < 0 ? 0 : t
        },
        Sp.prototype.getSimplifyFactor = function() {
            return this._simplifyFactor
        },
        Sp.prototype.getQuadrantSegments = function() {
            return this._quadrantSegments
        },
        Sp.prototype.setEndCapStyle = function(t) {
            this._endCapStyle = t
        },
        Sp.prototype.getMitreLimit = function() {
            return this._mitreLimit
        },
        Sp.prototype.setMitreLimit = function(t) {
            this._mitreLimit = t
        },
        Sp.prototype.setSingleSided = function(t) {
            this._isSingleSided = t
        },
        Sp.prototype.interfaces_ = function() {
            return []
        },
        Sp.prototype.getClass = function() {
            return Sp
        },
        Sp.bufferDistanceError = function(t) {
            var e = Math.PI / 2 / t;
            return 1 - Math.cos(e / 2)
        },
        Ip.CAP_ROUND.get = function() {
            return 1
        },
        Ip.CAP_FLAT.get = function() {
            return 2
        },
        Ip.CAP_SQUARE.get = function() {
            return 3
        },
        Ip.JOIN_ROUND.get = function() {
            return 1
        },
        Ip.JOIN_MITRE.get = function() {
            return 2
        },
        Ip.JOIN_BEVEL.get = function() {
            return 3
        },
        Ip.DEFAULT_QUADRANT_SEGMENTS.get = function() {
            return 8
        },
        Ip.DEFAULT_MITRE_LIMIT.get = function() {
            return 5
        },
        Ip.DEFAULT_SIMPLIFY_FACTOR.get = function() {
            return .01
        },
        Object.defineProperties(Sp, Ip);
        var Tp = function(t) {
                this._distanceTol = null,
                this._isDeleted = null,
                this._angleOrientation = Xl.COUNTERCLOCKWISE,
                this._inputLine = t || null
            },
            Pp = {
                INIT: {
                    configurable: !0
                },
                DELETE: {
                    configurable: !0
                },
                KEEP: {
                    configurable: !0
                },
                NUM_PTS_TO_CHECK: {
                    configurable: !0
                }
            };
        Tp.prototype.isDeletable = function(t, e, n, r) {
            var i = this._inputLine[t],
                o = this._inputLine[e],
                s = this._inputLine[n];
            return !!this.isConcave(i, o, s) && !!this.isShallow(i, o, s, r) && this.isShallowSampled(i, o, t, n, r)
        },
        Tp.prototype.deleteShallowConcavities = function() {
            for (var t = this, e = 1, n = this.findNextNonDeletedIndex(e), r = this.findNextNonDeletedIndex(n), i = !1; r < this._inputLine.length;) {
                var o = !1;
                t.isDeletable(e, n, r, t._distanceTol) && (t._isDeleted[n] = Tp.DELETE, o = !0, i = !0),
                e = o ? r : n,
                n = t.findNextNonDeletedIndex(e),
                r = t.findNextNonDeletedIndex(n)
            }
            return i
        },
        Tp.prototype.isShallowConcavity = function(t, e, n, r) {
            return Xl.computeOrientation(t, e, n) === this._angleOrientation && Xl.distancePointLine(e, t, n) < r
        },
        Tp.prototype.isShallowSampled = function(t, e, n, r, i) {
            var o = Math.trunc((r - n) / Tp.NUM_PTS_TO_CHECK);
            o <= 0 && (o = 1);
            for (var s = n; s < r; s += o)
                if (!this.isShallow(t, e, this._inputLine[s], i))
                    return !1;
            return !0
        },
        Tp.prototype.isConcave = function(t, e, n) {
            return Xl.computeOrientation(t, e, n) === this._angleOrientation
        },
        Tp.prototype.simplify = function(t) {
            this._distanceTol = Math.abs(t),
            t < 0 && (this._angleOrientation = Xl.CLOCKWISE),
            this._isDeleted = new Array(this._inputLine.length).fill(null);
            var e = !1;
            do {
                e = this.deleteShallowConcavities()
            } while (e);
            return this.collapseLine()
        },
        Tp.prototype.findNextNonDeletedIndex = function(t) {
            for (var e = t + 1; e < this._inputLine.length && this._isDeleted[e] === Tp.DELETE;)
                e++;
            return e
        },
        Tp.prototype.isShallow = function(t, e, n, r) {
            return Xl.distancePointLine(e, t, n) < r
        },
        Tp.prototype.collapseLine = function() {
            for (var t = new ch, e = 0; e < this._inputLine.length; e++)
                this._isDeleted[e] !== Tp.DELETE && t.add(this._inputLine[e]);
            return t.toCoordinateArray()
        },
        Tp.prototype.interfaces_ = function() {
            return []
        },
        Tp.prototype.getClass = function() {
            return Tp
        },
        Tp.simplify = function(t, e) {
            return new Tp(t).simplify(e)
        },
        Pp.INIT.get = function() {
            return 0
        },
        Pp.DELETE.get = function() {
            return 1
        },
        Pp.KEEP.get = function() {
            return 1
        },
        Pp.NUM_PTS_TO_CHECK.get = function() {
            return 10
        },
        Object.defineProperties(Tp, Pp);
        var Lp = function() {
                this._ptList = null,
                this._precisionModel = null,
                this._minimimVertexDistance = 0,
                this._ptList = new lh
            },
            Op = {
                COORDINATE_ARRAY_TYPE: {
                    configurable: !0
                }
            };
        Lp.prototype.getCoordinates = function() {
            return this._ptList.toArray(Lp.COORDINATE_ARRAY_TYPE)
        },
        Lp.prototype.setPrecisionModel = function(t) {
            this._precisionModel = t
        },
        Lp.prototype.addPt = function(t) {
            var e = new ul(t);
            if (this._precisionModel.makePrecise(e), this.isRedundant(e))
                return null;
            this._ptList.add(e)
        },
        Lp.prototype.revere = function() {},
        Lp.prototype.addPts = function(t, e) {
            if (e)
                for (var n = 0; n < t.length; n++)
                    this.addPt(t[n]);
            else
                for (var r = t.length - 1; r >= 0; r--)
                    this.addPt(t[r])
        },
        Lp.prototype.isRedundant = function(t) {
            if (this._ptList.size() < 1)
                return !1;
            var e = this._ptList.get(this._ptList.size() - 1);
            return t.distance(e) < this._minimimVertexDistance
        },
        Lp.prototype.toString = function() {
            return (new mc).createLineString(this.getCoordinates()).toString()
        },
        Lp.prototype.closeRing = function() {
            if (this._ptList.size() < 1)
                return null;
            var t = new ul(this._ptList.get(0)),
                e = this._ptList.get(this._ptList.size() - 1);
            if (t.equals(e))
                return null;
            this._ptList.add(t)
        },
        Lp.prototype.setMinimumVertexDistance = function(t) {
            this._minimimVertexDistance = t
        },
        Lp.prototype.interfaces_ = function() {
            return []
        },
        Lp.prototype.getClass = function() {
            return Lp
        },
        Op.COORDINATE_ARRAY_TYPE.get = function() {
            return new Array(0).fill(null)
        },
        Object.defineProperties(Lp, Op);
        var Np = function() {},
            Rp = {
                PI_TIMES_2: {
                    configurable: !0
                },
                PI_OVER_2: {
                    configurable: !0
                },
                PI_OVER_4: {
                    configurable: !0
                },
                COUNTERCLOCKWISE: {
                    configurable: !0
                },
                CLOCKWISE: {
                    configurable: !0
                },
                NONE: {
                    configurable: !0
                }
            };
        Np.prototype.interfaces_ = function() {
            return []
        },
        Np.prototype.getClass = function() {
            return Np
        },
        Np.toDegrees = function(t) {
            return 180 * t / Math.PI
        },
        Np.normalize = function(t) {
            for (; t > Math.PI;)
                t -= Np.PI_TIMES_2;
            for (; t <= -Math.PI;)
                t += Np.PI_TIMES_2;
            return t
        },
        Np.angle = function() {
            if (1 === arguments.length) {
                var t = arguments[0];
                return Math.atan2(t.y, t.x)
            }
            if (2 === arguments.length) {
                var e = arguments[0],
                    n = arguments[1],
                    r = n.x - e.x,
                    i = n.y - e.y;
                return Math.atan2(i, r)
            }
        },
        Np.isAcute = function(t, e, n) {
            var r = t.x - e.x,
                i = t.y - e.y;
            return r * (n.x - e.x) + i * (n.y - e.y) > 0
        },
        Np.isObtuse = function(t, e, n) {
            var r = t.x - e.x,
                i = t.y - e.y;
            return r * (n.x - e.x) + i * (n.y - e.y) < 0
        },
        Np.interiorAngle = function(t, e, n) {
            var r = Np.angle(e, t),
                i = Np.angle(e, n);
            return Math.abs(i - r)
        },
        Np.normalizePositive = function(t) {
            if (t < 0) {
                for (; t < 0;)
                    t += Np.PI_TIMES_2;
                t >= Np.PI_TIMES_2 && (t = 0)
            } else {
                for (; t >= Np.PI_TIMES_2;)
                    t -= Np.PI_TIMES_2;
                t < 0 && (t = 0)
            }
            return t
        },
        Np.angleBetween = function(t, e, n) {
            var r = Np.angle(e, t),
                i = Np.angle(e, n);
            return Np.diff(r, i)
        },
        Np.diff = function(t, e) {
            var n = null;
            return (n = t < e ? e - t : t - e) > Math.PI && (n = 2 * Math.PI - n), n
        },
        Np.toRadians = function(t) {
            return t * Math.PI / 180
        },
        Np.getTurn = function(t, e) {
            var n = Math.sin(e - t);
            return n > 0 ? Np.COUNTERCLOCKWISE : n < 0 ? Np.CLOCKWISE : Np.NONE
        },
        Np.angleBetweenOriented = function(t, e, n) {
            var r = Np.angle(e, t),
                i = Np.angle(e, n) - r;
            return i <= -Math.PI ? i + Np.PI_TIMES_2 : i > Math.PI ? i - Np.PI_TIMES_2 : i
        },
        Rp.PI_TIMES_2.get = function() {
            return 2 * Math.PI
        },
        Rp.PI_OVER_2.get = function() {
            return Math.PI / 2
        },
        Rp.PI_OVER_4.get = function() {
            return Math.PI / 4
        },
        Rp.COUNTERCLOCKWISE.get = function() {
            return Xl.COUNTERCLOCKWISE
        },
        Rp.CLOCKWISE.get = function() {
            return Xl.CLOCKWISE
        },
        Rp.NONE.get = function() {
            return Xl.COLLINEAR
        },
        Object.defineProperties(Np, Rp);
        var Ap = function t() {
                this._maxCurveSegmentError = 0,
                this._filletAngleQuantum = null,
                this._closingSegLengthFactor = 1,
                this._segList = null,
                this._distance = 0,
                this._precisionModel = null,
                this._bufParams = null,
                this._li = null,
                this._s0 = null,
                this._s1 = null,
                this._s2 = null,
                this._seg0 = new vp,
                this._seg1 = new vp,
                this._offset0 = new vp,
                this._offset1 = new vp,
                this._side = 0,
                this._hasNarrowConcaveAngle = !1;
                var e = arguments[0],
                    n = arguments[1],
                    r = arguments[2];
                this._precisionModel = e,
                this._bufParams = n,
                this._li = new zl,
                this._filletAngleQuantum = Math.PI / 2 / n.getQuadrantSegments(),
                n.getQuadrantSegments() >= 8 && n.getJoinStyle() === Sp.JOIN_ROUND && (this._closingSegLengthFactor = t.MAX_CLOSING_SEG_LEN_FACTOR),
                this.init(r)
            },
            Dp = {
                OFFSET_SEGMENT_SEPARATION_FACTOR: {
                    configurable: !0
                },
                INSIDE_TURN_VERTEX_SNAP_DISTANCE_FACTOR: {
                    configurable: !0
                },
                CURVE_VERTEX_SNAP_DISTANCE_FACTOR: {
                    configurable: !0
                },
                MAX_CLOSING_SEG_LEN_FACTOR: {
                    configurable: !0
                }
            };
        Ap.prototype.addNextSegment = function(t, e) {
            if (this._s0 = this._s1, this._s1 = this._s2, this._s2 = t, this._seg0.setCoordinates(this._s0, this._s1), this.computeOffsetSegment(this._seg0, this._side, this._distance, this._offset0), this._seg1.setCoordinates(this._s1, this._s2), this.computeOffsetSegment(this._seg1, this._side, this._distance, this._offset1), this._s1.equals(this._s2))
                return null;
            var n = Xl.computeOrientation(this._s0, this._s1, this._s2),
                r = n === Xl.CLOCKWISE && this._side === Sc.LEFT || n === Xl.COUNTERCLOCKWISE && this._side === Sc.RIGHT;
            0 === n ? this.addCollinear(e) : r ? this.addOutsideTurn(n, e) : this.addInsideTurn(n, e)
        },
        Ap.prototype.addLineEndCap = function(t, e) {
            var n = new vp(t, e),
                r = new vp;
            this.computeOffsetSegment(n, Sc.LEFT, this._distance, r);
            var i = new vp;
            this.computeOffsetSegment(n, Sc.RIGHT, this._distance, i);
            var o = e.x - t.x,
                s = e.y - t.y,
                a = Math.atan2(s, o);
            switch (this._bufParams.getEndCapStyle()) {
            case Sp.CAP_ROUND:
                this._segList.addPt(r.p1),
                this.addFilletArc(e, a + Math.PI / 2, a - Math.PI / 2, Xl.CLOCKWISE, this._distance),
                this._segList.addPt(i.p1);
                break;
            case Sp.CAP_FLAT:
                this._segList.addPt(r.p1),
                this._segList.addPt(i.p1);
                break;
            case Sp.CAP_SQUARE:
                var u = new ul;
                u.x = Math.abs(this._distance) * Math.cos(a),
                u.y = Math.abs(this._distance) * Math.sin(a);
                var l = new ul(r.p1.x + u.x, r.p1.y + u.y),
                    h = new ul(i.p1.x + u.x, i.p1.y + u.y);
                this._segList.addPt(l),
                this._segList.addPt(h)
            }
        },
        Ap.prototype.getCoordinates = function() {
            return this._segList.getCoordinates()
        },
        Ap.prototype.addMitreJoin = function(t, e, n, r) {
            var i = !0,
                o = null;
            try {
                o = Pl.intersection(e.p0, e.p1, n.p0, n.p1),
                (r <= 0 ? 1 : o.distance(t) / Math.abs(r)) > this._bufParams.getMitreLimit() && (i = !1)
            } catch (t) {
                if (!(t instanceof Il))
                    throw t;
                o = new ul(0, 0),
                i = !1
            }
            i ? this._segList.addPt(o) : this.addLimitedMitreJoin(e, n, r, this._bufParams.getMitreLimit())
        },
        Ap.prototype.addFilletCorner = function(t, e, n, r, i) {
            var o = e.x - t.x,
                s = e.y - t.y,
                a = Math.atan2(s, o),
                u = n.x - t.x,
                l = n.y - t.y,
                h = Math.atan2(l, u);
            r === Xl.CLOCKWISE ? a <= h && (a += 2 * Math.PI) : a >= h && (a -= 2 * Math.PI),
            this._segList.addPt(e),
            this.addFilletArc(t, a, h, r, i),
            this._segList.addPt(n)
        },
        Ap.prototype.addOutsideTurn = function(t, e) {
            if (this._offset0.p1.distance(this._offset1.p0) < this._distance * Ap.OFFSET_SEGMENT_SEPARATION_FACTOR)
                return this._segList.addPt(this._offset0.p1), null;
            this._bufParams.getJoinStyle() === Sp.JOIN_MITRE ? this.addMitreJoin(this._s1, this._offset0, this._offset1, this._distance) : this._bufParams.getJoinStyle() === Sp.JOIN_BEVEL ? this.addBevelJoin(this._offset0, this._offset1) : (e && this._segList.addPt(this._offset0.p1), this.addFilletCorner(this._s1, this._offset0.p1, this._offset1.p0, t, this._distance), this._segList.addPt(this._offset1.p0))
        },
        Ap.prototype.createSquare = function(t) {
            this._segList.addPt(new ul(t.x + this._distance, t.y + this._distance)),
            this._segList.addPt(new ul(t.x + this._distance, t.y - this._distance)),
            this._segList.addPt(new ul(t.x - this._distance, t.y - this._distance)),
            this._segList.addPt(new ul(t.x - this._distance, t.y + this._distance)),
            this._segList.closeRing()
        },
        Ap.prototype.addSegments = function(t, e) {
            this._segList.addPts(t, e)
        },
        Ap.prototype.addFirstSegment = function() {
            this._segList.addPt(this._offset1.p0)
        },
        Ap.prototype.addLastSegment = function() {
            this._segList.addPt(this._offset1.p1)
        },
        Ap.prototype.initSideSegments = function(t, e, n) {
            this._s1 = t,
            this._s2 = e,
            this._side = n,
            this._seg1.setCoordinates(t, e),
            this.computeOffsetSegment(this._seg1, n, this._distance, this._offset1)
        },
        Ap.prototype.addLimitedMitreJoin = function(t, e, n, r) {
            var i = this._seg0.p1,
                o = Np.angle(i, this._seg0.p0),
                s = Np.angleBetweenOriented(this._seg0.p0, i, this._seg1.p1) / 2,
                a = Np.normalize(o + s),
                u = Np.normalize(a + Math.PI),
                l = r * n,
                h = n - l * Math.abs(Math.sin(s)),
                c = i.x + l * Math.cos(u),
                p = i.y + l * Math.sin(u),
                f = new ul(c, p),
                d = new vp(i, f),
                g = d.pointAlongOffset(1, h),
                y = d.pointAlongOffset(1, -h);
            this._side === Sc.LEFT ? (this._segList.addPt(g), this._segList.addPt(y)) : (this._segList.addPt(y), this._segList.addPt(g))
        },
        Ap.prototype.computeOffsetSegment = function(t, e, n, r) {
            var i = e === Sc.LEFT ? 1 : -1,
                o = t.p1.x - t.p0.x,
                s = t.p1.y - t.p0.y,
                a = Math.sqrt(o * o + s * s),
                u = i * n * o / a,
                l = i * n * s / a;
            r.p0.x = t.p0.x - l,
            r.p0.y = t.p0.y + u,
            r.p1.x = t.p1.x - l,
            r.p1.y = t.p1.y + u
        },
        Ap.prototype.addFilletArc = function(t, e, n, r, i) {
            var o = r === Xl.CLOCKWISE ? -1 : 1,
                s = Math.abs(e - n),
                a = Math.trunc(s / this._filletAngleQuantum + .5);
            if (a < 1)
                return null;
            for (var u = s / a, l = 0, h = new ul; l < s;) {
                var c = e + o * l;
                h.x = t.x + i * Math.cos(c),
                h.y = t.y + i * Math.sin(c),
                this._segList.addPt(h),
                l += u
            }
        },
        Ap.prototype.addInsideTurn = function(t, e) {
            if (this._li.computeIntersection(this._offset0.p0, this._offset0.p1, this._offset1.p0, this._offset1.p1), this._li.hasIntersection())
                this._segList.addPt(this._li.getIntersection(0));
            else if (this._hasNarrowConcaveAngle = !0, this._offset0.p1.distance(this._offset1.p0) < this._distance * Ap.INSIDE_TURN_VERTEX_SNAP_DISTANCE_FACTOR)
                this._segList.addPt(this._offset0.p1);
            else {
                if (this._segList.addPt(this._offset0.p1), this._closingSegLengthFactor > 0) {
                    var n = new ul((this._closingSegLengthFactor * this._offset0.p1.x + this._s1.x) / (this._closingSegLengthFactor + 1), (this._closingSegLengthFactor * this._offset0.p1.y + this._s1.y) / (this._closingSegLengthFactor + 1));
                    this._segList.addPt(n);
                    var r = new ul((this._closingSegLengthFactor * this._offset1.p0.x + this._s1.x) / (this._closingSegLengthFactor + 1), (this._closingSegLengthFactor * this._offset1.p0.y + this._s1.y) / (this._closingSegLengthFactor + 1));
                    this._segList.addPt(r)
                } else
                    this._segList.addPt(this._s1);
                this._segList.addPt(this._offset1.p0)
            }
        },
        Ap.prototype.createCircle = function(t) {
            var e = new ul(t.x + this._distance, t.y);
            this._segList.addPt(e),
            this.addFilletArc(t, 0, 2 * Math.PI, -1, this._distance),
            this._segList.closeRing()
        },
        Ap.prototype.addBevelJoin = function(t, e) {
            this._segList.addPt(t.p1),
            this._segList.addPt(e.p0)
        },
        Ap.prototype.init = function(t) {
            this._distance = t,
            this._maxCurveSegmentError = t * (1 - Math.cos(this._filletAngleQuantum / 2)),
            this._segList = new Lp,
            this._segList.setPrecisionModel(this._precisionModel),
            this._segList.setMinimumVertexDistance(t * Ap.CURVE_VERTEX_SNAP_DISTANCE_FACTOR)
        },
        Ap.prototype.addCollinear = function(t) {
            this._li.computeIntersection(this._s0, this._s1, this._s1, this._s2),
            this._li.getIntersectionNum() >= 2 && (this._bufParams.getJoinStyle() === Sp.JOIN_BEVEL || this._bufParams.getJoinStyle() === Sp.JOIN_MITRE ? (t && this._segList.addPt(this._offset0.p1), this._segList.addPt(this._offset1.p0)) : this.addFilletCorner(this._s1, this._offset0.p1, this._offset1.p0, Xl.CLOCKWISE, this._distance))
        },
        Ap.prototype.closeRing = function() {
            this._segList.closeRing()
        },
        Ap.prototype.hasNarrowConcaveAngle = function() {
            return this._hasNarrowConcaveAngle
        },
        Ap.prototype.interfaces_ = function() {
            return []
        },
        Ap.prototype.getClass = function() {
            return Ap
        },
        Dp.OFFSET_SEGMENT_SEPARATION_FACTOR.get = function() {
            return .001
        },
        Dp.INSIDE_TURN_VERTEX_SNAP_DISTANCE_FACTOR.get = function() {
            return .001
        },
        Dp.CURVE_VERTEX_SNAP_DISTANCE_FACTOR.get = function() {
            return 1e-6
        },
        Dp.MAX_CLOSING_SEG_LEN_FACTOR.get = function() {
            return 80
        },
        Object.defineProperties(Ap, Dp);
        var Fp = function() {
            this._distance = 0,
            this._precisionModel = null,
            this._bufParams = null;
            var t = arguments[0],
                e = arguments[1];
            this._precisionModel = t,
            this._bufParams = e
        };
        Fp.prototype.getOffsetCurve = function(t, e) {
            if (this._distance = e, 0 === e)
                return null;
            var n = e < 0,
                r = Math.abs(e),
                i = this.getSegGen(r);
            t.length <= 1 ? this.computePointCurve(t[0], i) : this.computeOffsetCurve(t, n, i);
            var o = i.getCoordinates();
            return n && ph.reverse(o), o
        },
        Fp.prototype.computeSingleSidedBufferCurve = function(t, e, n) {
            var r = this.simplifyTolerance(this._distance);
            if (e) {
                n.addSegments(t, !0);
                var i = Tp.simplify(t, -r),
                    o = i.length - 1;
                n.initSideSegments(i[o], i[o - 1], Sc.LEFT),
                n.addFirstSegment();
                for (var s = o - 2; s >= 0; s--)
                    n.addNextSegment(i[s], !0)
            } else {
                n.addSegments(t, !1);
                var a = Tp.simplify(t, r),
                    u = a.length - 1;
                n.initSideSegments(a[0], a[1], Sc.LEFT),
                n.addFirstSegment();
                for (var l = 2; l <= u; l++)
                    n.addNextSegment(a[l], !0)
            }
            n.addLastSegment(),
            n.closeRing()
        },
        Fp.prototype.computeRingBufferCurve = function(t, e, n) {
            var r = this.simplifyTolerance(this._distance);
            e === Sc.RIGHT && (r = -r);
            var i = Tp.simplify(t, r),
                o = i.length - 1;
            n.initSideSegments(i[o - 1], i[0], e);
            for (var s = 1; s <= o; s++) {
                var a = 1 !== s;
                n.addNextSegment(i[s], a)
            }
            n.closeRing()
        },
        Fp.prototype.computeLineBufferCurve = function(t, e) {
            var n = this.simplifyTolerance(this._distance),
                r = Tp.simplify(t, n),
                i = r.length - 1;
            e.initSideSegments(r[0], r[1], Sc.LEFT);
            for (var o = 2; o <= i; o++)
                e.addNextSegment(r[o], !0);
            e.addLastSegment(),
            e.addLineEndCap(r[i - 1], r[i]);
            var s = Tp.simplify(t, -n),
                a = s.length - 1;
            e.initSideSegments(s[a], s[a - 1], Sc.LEFT);
            for (var u = a - 2; u >= 0; u--)
                e.addNextSegment(s[u], !0);
            e.addLastSegment(),
            e.addLineEndCap(s[1], s[0]),
            e.closeRing()
        },
        Fp.prototype.computePointCurve = function(t, e) {
            switch (this._bufParams.getEndCapStyle()) {
            case Sp.CAP_ROUND:
                e.createCircle(t);
                break;
            case Sp.CAP_SQUARE:
                e.createSquare(t)
            }
        },
        Fp.prototype.getLineCurve = function(t, e) {
            if (this._distance = e, e < 0 && !this._bufParams.isSingleSided())
                return null;
            if (0 === e)
                return null;
            var n = Math.abs(e),
                r = this.getSegGen(n);
            if (t.length <= 1)
                this.computePointCurve(t[0], r);
            else if (this._bufParams.isSingleSided()) {
                var i = e < 0;
                this.computeSingleSidedBufferCurve(t, i, r)
            } else
                this.computeLineBufferCurve(t, r);
            return r.getCoordinates()
        },
        Fp.prototype.getBufferParameters = function() {
            return this._bufParams
        },
        Fp.prototype.simplifyTolerance = function(t) {
            return t * this._bufParams.getSimplifyFactor()
        },
        Fp.prototype.getRingCurve = function(t, e, n) {
            if (this._distance = n, t.length <= 2)
                return this.getLineCurve(t, n);
            if (0 === n)
                return Fp.copyCoordinates(t);
            var r = this.getSegGen(n);
            return this.computeRingBufferCurve(t, e, r), r.getCoordinates()
        },
        Fp.prototype.computeOffsetCurve = function(t, e, n) {
            var r = this.simplifyTolerance(this._distance);
            if (e) {
                var i = Tp.simplify(t, -r),
                    o = i.length - 1;
                n.initSideSegments(i[o], i[o - 1], Sc.LEFT),
                n.addFirstSegment();
                for (var s = o - 2; s >= 0; s--)
                    n.addNextSegment(i[s], !0)
            } else {
                var a = Tp.simplify(t, r),
                    u = a.length - 1;
                n.initSideSegments(a[0], a[1], Sc.LEFT),
                n.addFirstSegment();
                for (var l = 2; l <= u; l++)
                    n.addNextSegment(a[l], !0)
            }
            n.addLastSegment()
        },
        Fp.prototype.getSegGen = function(t) {
            return new Ap(this._precisionModel, this._bufParams, t)
        },
        Fp.prototype.interfaces_ = function() {
            return []
        },
        Fp.prototype.getClass = function() {
            return Fp
        },
        Fp.copyCoordinates = function(t) {
            for (var e = new Array(t.length).fill(null), n = 0; n < e.length; n++)
                e[n] = new ul(t[n]);
            return e
        };
        var kp = function() {
                this._subgraphs = null,
                this._seg = new vp,
                this._cga = new Xl;
                var t = arguments[0];
                this._subgraphs = t
            },
            jp = {
                DepthSegment: {
                    configurable: !0
                }
            };
        kp.prototype.findStabbedSegments = function() {
            var t = this;
            if (1 === arguments.length) {
                for (var e = arguments[0], n = new lh, r = this._subgraphs.iterator(); r.hasNext();) {
                    var i = r.next(),
                        o = i.getEnvelope();
                    e.y < o.getMinY() || e.y > o.getMaxY() || t.findStabbedSegments(e, i.getDirectedEdges(), n)
                }
                return n
            }
            if (3 === arguments.length)
                if (dl(arguments[2], ah) && arguments[0] instanceof ul && arguments[1] instanceof Xc) {
                    for (var s = arguments[0], a = arguments[1], u = arguments[2], l = a.getEdge().getCoordinates(), h = 0; h < l.length - 1; h++)
                        if (t._seg.p0 = l[h], t._seg.p1 = l[h + 1], t._seg.p0.y > t._seg.p1.y && t._seg.reverse(), !(Math.max(t._seg.p0.x, t._seg.p1.x) < s.x || t._seg.isHorizontal() || s.y < t._seg.p0.y || s.y > t._seg.p1.y || Xl.computeOrientation(t._seg.p0, t._seg.p1, s) === Xl.RIGHT)) {
                            var c = a.getDepth(Sc.LEFT);
                            t._seg.p0.equals(l[h]) || (c = a.getDepth(Sc.RIGHT));
                            var p = new Gp(t._seg, c);
                            u.add(p)
                        }
                } else if (dl(arguments[2], ah) && arguments[0] instanceof ul && dl(arguments[1], ah))
                    for (var f = arguments[0], d = arguments[2], g = arguments[1].iterator(); g.hasNext();) {
                        var y = g.next();
                        y.isForward() && t.findStabbedSegments(f, y, d)
                    }
        },
        kp.prototype.getDepth = function(t) {
            var e = this.findStabbedSegments(t);
            return 0 === e.size() ? 0 : np.min(e)._leftDepth
        },
        kp.prototype.interfaces_ = function() {
            return []
        },
        kp.prototype.getClass = function() {
            return kp
        },
        jp.DepthSegment.get = function() {
            return Gp
        },
        Object.defineProperties(kp, jp);
        var Gp = function() {
            this._upwardSeg = null,
            this._leftDepth = null;
            var t = arguments[0],
                e = arguments[1];
            this._upwardSeg = new vp(t),
            this._leftDepth = e
        };
        Gp.prototype.compareTo = function(t) {
            var e = t;
            if (this._upwardSeg.minX() >= e._upwardSeg.maxX())
                return 1;
            if (this._upwardSeg.maxX() <= e._upwardSeg.minX())
                return -1;
            var n = this._upwardSeg.orientationIndex(e._upwardSeg);
            return 0 !== n || 0 != (n = -1 * e._upwardSeg.orientationIndex(this._upwardSeg)) ? n : this._upwardSeg.compareTo(e._upwardSeg)
        },
        Gp.prototype.compareX = function(t, e) {
            var n = t.p0.compareTo(e.p0);
            return 0 !== n ? n : t.p1.compareTo(e.p1)
        },
        Gp.prototype.toString = function() {
            return this._upwardSeg.toString()
        },
        Gp.prototype.interfaces_ = function() {
            return [il]
        },
        Gp.prototype.getClass = function() {
            return Gp
        };
        var Bp = function(t, e, n) {
            this.p0 = t || null,
            this.p1 = e || null,
            this.p2 = n || null
        };
        Bp.prototype.area = function() {
            return Bp.area(this.p0, this.p1, this.p2)
        },
        Bp.prototype.signedArea = function() {
            return Bp.signedArea(this.p0, this.p1, this.p2)
        },
        Bp.prototype.interpolateZ = function(t) {
            if (null === t)
                throw new el("Supplied point is null.");
            return Bp.interpolateZ(t, this.p0, this.p1, this.p2)
        },
        Bp.prototype.longestSideLength = function() {
            return Bp.longestSideLength(this.p0, this.p1, this.p2)
        },
        Bp.prototype.isAcute = function() {
            return Bp.isAcute(this.p0, this.p1, this.p2)
        },
        Bp.prototype.circumcentre = function() {
            return Bp.circumcentre(this.p0, this.p1, this.p2)
        },
        Bp.prototype.area3D = function() {
            return Bp.area3D(this.p0, this.p1, this.p2)
        },
        Bp.prototype.centroid = function() {
            return Bp.centroid(this.p0, this.p1, this.p2)
        },
        Bp.prototype.inCentre = function() {
            return Bp.inCentre(this.p0, this.p1, this.p2)
        },
        Bp.prototype.interfaces_ = function() {
            return []
        },
        Bp.prototype.getClass = function() {
            return Bp
        },
        Bp.area = function(t, e, n) {
            return Math.abs(((n.x - t.x) * (e.y - t.y) - (e.x - t.x) * (n.y - t.y)) / 2)
        },
        Bp.signedArea = function(t, e, n) {
            return ((n.x - t.x) * (e.y - t.y) - (e.x - t.x) * (n.y - t.y)) / 2
        },
        Bp.det = function(t, e, n, r) {
            return t * r - e * n
        },
        Bp.interpolateZ = function(t, e, n, r) {
            var i = e.x,
                o = e.y,
                s = n.x - i,
                a = r.x - i,
                u = n.y - o,
                l = r.y - o,
                h = s * l - a * u,
                c = t.x - i,
                p = t.y - o,
                f = (l * c - a * p) / h,
                d = (-u * c + s * p) / h;
            return e.z + f * (n.z - e.z) + d * (r.z - e.z)
        },
        Bp.longestSideLength = function(t, e, n) {
            var r = t.distance(e),
                i = e.distance(n),
                o = n.distance(t),
                s = r;
            return i > s && (s = i), o > s && (s = o), s
        },
        Bp.isAcute = function(t, e, n) {
            return !!Np.isAcute(t, e, n) && !!Np.isAcute(e, n, t) && !!Np.isAcute(n, t, e)
        },
        Bp.circumcentre = function(t, e, n) {
            var r = n.x,
                i = n.y,
                o = t.x - r,
                s = t.y - i,
                a = e.x - r,
                u = e.y - i,
                l = 2 * Bp.det(o, s, a, u),
                h = Bp.det(s, o * o + s * s, u, a * a + u * u),
                c = Bp.det(o, o * o + s * s, a, a * a + u * u);
            return new ul(r - h / l, i + c / l)
        },
        Bp.perpendicularBisector = function(t, e) {
            var n = e.x - t.x,
                r = e.y - t.y,
                i = new Pl(t.x + n / 2, t.y + r / 2, 1),
                o = new Pl(t.x - r + n / 2, t.y + n + r / 2, 1);
            return new Pl(i, o)
        },
        Bp.angleBisector = function(t, e, n) {
            var r = e.distance(t),
                i = r / (r + e.distance(n)),
                o = n.x - t.x,
                s = n.y - t.y;
            return new ul(t.x + i * o, t.y + i * s)
        },
        Bp.area3D = function(t, e, n) {
            var r = e.x - t.x,
                i = e.y - t.y,
                o = e.z - t.z,
                s = n.x - t.x,
                a = n.y - t.y,
                u = n.z - t.z,
                l = i * u - o * a,
                h = o * s - r * u,
                c = r * a - i * s,
                p = l * l + h * h + c * c;
            return Math.sqrt(p) / 2
        },
        Bp.centroid = function(t, e, n) {
            var r = (t.x + e.x + n.x) / 3,
                i = (t.y + e.y + n.y) / 3;
            return new ul(r, i)
        },
        Bp.inCentre = function(t, e, n) {
            var r = e.distance(n),
                i = t.distance(n),
                o = t.distance(e),
                s = r + i + o,
                a = (r * t.x + i * e.x + o * n.x) / s,
                u = (r * t.y + i * e.y + o * n.y) / s;
            return new ul(a, u)
        };
        var qp = function() {
            this._inputGeom = null,
            this._distance = null,
            this._curveBuilder = null,
            this._curveList = new lh;
            var t = arguments[0],
                e = arguments[1],
                n = arguments[2];
            this._inputGeom = t,
            this._distance = e,
            this._curveBuilder = n
        };
        qp.prototype.addPoint = function(t) {
            if (this._distance <= 0)
                return null;
            var e = t.getCoordinates(),
                n = this._curveBuilder.getLineCurve(e, this._distance);
            this.addCurve(n, pl.EXTERIOR, pl.INTERIOR)
        },
        qp.prototype.addPolygon = function(t) {
            var e = this,
                n = this._distance,
                r = Sc.LEFT;
            this._distance < 0 && (n = -this._distance, r = Sc.RIGHT);
            var i = t.getExteriorRing(),
                o = ph.removeRepeatedPoints(i.getCoordinates());
            if (this._distance < 0 && this.isErodedCompletely(i, this._distance))
                return null;
            if (this._distance <= 0 && o.length < 3)
                return null;
            this.addPolygonRing(o, n, r, pl.EXTERIOR, pl.INTERIOR);
            for (var s = 0; s < t.getNumInteriorRing(); s++) {
                var a = t.getInteriorRingN(s),
                    u = ph.removeRepeatedPoints(a.getCoordinates());
                e._distance > 0 && e.isErodedCompletely(a, -e._distance) || e.addPolygonRing(u, n, Sc.opposite(r), pl.INTERIOR, pl.EXTERIOR)
            }
        },
        qp.prototype.isTriangleErodedCompletely = function(t, e) {
            var n = new Bp(t[0], t[1], t[2]),
                r = n.inCentre();
            return Xl.distancePointLine(r, n.p0, n.p1) < Math.abs(e)
        },
        qp.prototype.addLineString = function(t) {
            if (this._distance <= 0 && !this._curveBuilder.getBufferParameters().isSingleSided())
                return null;
            var e = ph.removeRepeatedPoints(t.getCoordinates()),
                n = this._curveBuilder.getLineCurve(e, this._distance);
            this.addCurve(n, pl.EXTERIOR, pl.INTERIOR)
        },
        qp.prototype.addCurve = function(t, e, n) {
            if (null === t || t.length < 2)
                return null;
            var r = new yp(t, new Dc(0, pl.BOUNDARY, e, n));
            this._curveList.add(r)
        },
        qp.prototype.getCurves = function() {
            return this.add(this._inputGeom), this._curveList
        },
        qp.prototype.addPolygonRing = function(t, e, n, r, i) {
            if (0 === e && t.length < nc.MINIMUM_VALID_SIZE)
                return null;
            var o = r,
                s = i;
            t.length >= nc.MINIMUM_VALID_SIZE && Xl.isCCW(t) && (o = i, s = r, n = Sc.opposite(n));
            var a = this._curveBuilder.getRingCurve(t, n, e);
            this.addCurve(a, o, s)
        },
        qp.prototype.add = function(t) {
            if (t.isEmpty())
                return null;
            t instanceof tc ? this.addPolygon(t) : t instanceof Kh ? this.addLineString(t) : t instanceof Jh ? this.addPoint(t) : (t instanceof ec || t instanceof jh || t instanceof rc || t instanceof kh) && this.addCollection(t)
        },
        qp.prototype.isErodedCompletely = function(t, e) {
            var n = t.getCoordinates();
            if (n.length < 4)
                return e < 0;
            if (4 === n.length)
                return this.isTriangleErodedCompletely(n, e);
            var r = t.getEnvelopeInternal(),
                i = Math.min(r.getHeight(), r.getWidth());
            return e < 0 && 2 * Math.abs(e) > i
        },
        qp.prototype.addCollection = function(t) {
            for (var e = 0; e < t.getNumGeometries(); e++) {
                var n = t.getGeometryN(e);
                this.add(n)
            }
        },
        qp.prototype.interfaces_ = function() {
            return []
        },
        qp.prototype.getClass = function() {
            return qp
        };
        var zp = function() {};
        zp.prototype.locate = function(t) {},
        zp.prototype.interfaces_ = function() {
            return []
        },
        zp.prototype.getClass = function() {
            return zp
        };
        var Up = function() {
            this._parent = null,
            this._atStart = null,
            this._max = null,
            this._index = null,
            this._subcollectionIterator = null;
            var t = arguments[0];
            this._parent = t,
            this._atStart = !0,
            this._index = 0,
            this._max = t.getNumGeometries()
        };
        Up.prototype.next = function() {
            if (this._atStart)
                return this._atStart = !1, Up.isAtomic(this._parent) && this._index++, this._parent;
            if (null !== this._subcollectionIterator) {
                if (this._subcollectionIterator.hasNext())
                    return this._subcollectionIterator.next();
                this._subcollectionIterator = null
            }
            if (this._index >= this._max)
                throw new uh;
            var t = this._parent.getGeometryN(this._index++);
            return t instanceof kh ? (this._subcollectionIterator = new Up(t), this._subcollectionIterator.next()) : t
        },
        Up.prototype.remove = function() {
            throw new Error(this.getClass().getName())
        },
        Up.prototype.hasNext = function() {
            if (this._atStart)
                return !0;
            if (null !== this._subcollectionIterator) {
                if (this._subcollectionIterator.hasNext())
                    return !0;
                this._subcollectionIterator = null
            }
            return !(this._index >= this._max)
        },
        Up.prototype.interfaces_ = function() {
            return [sh]
        },
        Up.prototype.getClass = function() {
            return Up
        },
        Up.isAtomic = function(t) {
            return !(t instanceof kh)
        };
        var Vp = function() {
            this._geom = null;
            var t = arguments[0];
            this._geom = t
        };
        Vp.prototype.locate = function(t) {
            return Vp.locate(t, this._geom)
        },
        Vp.prototype.interfaces_ = function() {
            return [zp]
        },
        Vp.prototype.getClass = function() {
            return Vp
        },
        Vp.isPointInRing = function(t, e) {
            return !!e.getEnvelopeInternal().intersects(t) && Xl.isPointInRing(t, e.getCoordinates())
        },
        Vp.containsPointInPolygon = function(t, e) {
            if (e.isEmpty())
                return !1;
            var n = e.getExteriorRing();
            if (!Vp.isPointInRing(t, n))
                return !1;
            for (var r = 0; r < e.getNumInteriorRing(); r++) {
                var i = e.getInteriorRingN(r);
                if (Vp.isPointInRing(t, i))
                    return !1
            }
            return !0
        },
        Vp.containsPoint = function(t, e) {
            if (e instanceof tc)
                return Vp.containsPointInPolygon(t, e);
            if (e instanceof kh)
                for (var n = new Up(e); n.hasNext();) {
                    var r = n.next();
                    if (r !== e && Vp.containsPoint(t, r))
                        return !0
                }
            return !1
        },
        Vp.locate = function(t, e) {
            return e.isEmpty() ? pl.EXTERIOR : Vp.containsPoint(t, e) ? pl.INTERIOR : pl.EXTERIOR
        };
        var Xp = function() {
            this._edgeMap = new Ih,
            this._edgeList = null,
            this._ptInAreaLocation = [pl.NONE, pl.NONE]
        };
        Xp.prototype.getNextCW = function(t) {
            this.getEdges();
            var e = this._edgeList.indexOf(t),
                n = e - 1;
            return 0 === e && (n = this._edgeList.size() - 1), this._edgeList.get(n)
        },
        Xp.prototype.propagateSideLabels = function(t) {
            for (var e = pl.NONE, n = this.iterator(); n.hasNext();) {
                var r = n.next().getLabel();
                r.isArea(t) && r.getLocation(t, Sc.LEFT) !== pl.NONE && (e = r.getLocation(t, Sc.LEFT))
            }
            if (e === pl.NONE)
                return null;
            for (var i = e, o = this.iterator(); o.hasNext();) {
                var s = o.next(),
                    a = s.getLabel();
                if (a.getLocation(t, Sc.ON) === pl.NONE && a.setLocation(t, Sc.ON, i), a.isArea(t)) {
                    var u = a.getLocation(t, Sc.LEFT),
                        l = a.getLocation(t, Sc.RIGHT);
                    if (l !== pl.NONE) {
                        if (l !== i)
                            throw new Oc("side location conflict", s.getCoordinate());
                        u === pl.NONE && Gl.shouldNeverReachHere("found single null side (at " + s.getCoordinate() + ")"),
                        i = u
                    } else
                        Gl.isTrue(a.getLocation(t, Sc.LEFT) === pl.NONE, "found single null side"),
                        a.setLocation(t, Sc.RIGHT, i),
                        a.setLocation(t, Sc.LEFT, i)
                }
            }
        },
        Xp.prototype.getCoordinate = function() {
            var t = this.iterator();
            return t.hasNext() ? t.next().getCoordinate() : null
        },
        Xp.prototype.print = function(t) {
            Tl.out.println("EdgeEndStar:   " + this.getCoordinate());
            for (var e = this.iterator(); e.hasNext();)
                e.next().print(t)
        },
        Xp.prototype.isAreaLabelsConsistent = function(t) {
            return this.computeEdgeEndLabels(t.getBoundaryNodeRule()), this.checkAreaLabelsConsistent(0)
        },
        Xp.prototype.checkAreaLabelsConsistent = function(t) {
            var e = this.getEdges();
            if (e.size() <= 0)
                return !0;
            var n = e.size() - 1,
                r = e.get(n).getLabel().getLocation(t, Sc.LEFT);
            Gl.isTrue(r !== pl.NONE, "Found unlabelled area edge");
            for (var i = r, o = this.iterator(); o.hasNext();) {
                var s = o.next().getLabel();
                Gl.isTrue(s.isArea(t), "Found non-area edge");
                var a = s.getLocation(t, Sc.LEFT),
                    u = s.getLocation(t, Sc.RIGHT);
                if (a === u)
                    return !1;
                if (u !== i)
                    return !1;
                i = a
            }
            return !0
        },
        Xp.prototype.findIndex = function(t) {
            this.iterator();
            for (var e = 0; e < this._edgeList.size(); e++)
                if (this._edgeList.get(e) === t)
                    return e;
            return -1
        },
        Xp.prototype.iterator = function() {
            return this.getEdges().iterator()
        },
        Xp.prototype.getEdges = function() {
            return null === this._edgeList && (this._edgeList = new lh(this._edgeMap.values())), this._edgeList
        },
        Xp.prototype.getLocation = function(t, e, n) {
            return this._ptInAreaLocation[t] === pl.NONE && (this._ptInAreaLocation[t] = Vp.locate(e, n[t].getGeometry())), this._ptInAreaLocation[t]
        },
        Xp.prototype.toString = function() {
            var t = new vl;
            t.append("EdgeEndStar:   " + this.getCoordinate()),
            t.append("\n");
            for (var e = this.iterator(); e.hasNext();) {
                var n = e.next();
                t.append(n),
                t.append("\n")
            }
            return t.toString()
        },
        Xp.prototype.computeEdgeEndLabels = function(t) {
            for (var e = this.iterator(); e.hasNext();)
                e.next().computeLabel(t)
        },
        Xp.prototype.computeLabelling = function(t) {
            this.computeEdgeEndLabels(t[0].getBoundaryNodeRule()),
            this.propagateSideLabels(0),
            this.propagateSideLabels(1);
            for (var e = [!1, !1], n = this.iterator(); n.hasNext();)
                for (var r = n.next().getLabel(), i = 0; i < 2; i++)
                    r.isLine(i) && r.getLocation(i) === pl.BOUNDARY && (e[i] = !0);
            for (var o = this.iterator(); o.hasNext();)
                for (var s = o.next(), a = s.getLabel(), u = 0; u < 2; u++)
                    if (a.isAnyNull(u)) {
                        var l = pl.NONE;
                        if (e[u])
                            l = pl.EXTERIOR;
                        else {
                            var h = s.getCoordinate();
                            l = this.getLocation(u, h, t)
                        }
                        a.setAllLocationsIfNull(u, l)
                    }
        },
        Xp.prototype.getDegree = function() {
            return this._edgeMap.size()
        },
        Xp.prototype.insertEdgeEnd = function(t, e) {
            this._edgeMap.put(t, e),
            this._edgeList = null
        },
        Xp.prototype.interfaces_ = function() {
            return []
        },
        Xp.prototype.getClass = function() {
            return Xp
        };
        var Hp = function(t) {
                function e() {
                    t.call(this),
                    this._resultAreaEdgeList = null,
                    this._label = null,
                    this._SCANNING_FOR_INCOMING = 1,
                    this._LINKING_TO_OUTGOING = 2
                }
                return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.linkResultDirectedEdges = function() {
                    var t = this;
                    this.getResultAreaEdges();
                    for (var e = null, n = null, r = this._SCANNING_FOR_INCOMING, i = 0; i < this._resultAreaEdgeList.size(); i++) {
                        var o = t._resultAreaEdgeList.get(i),
                            s = o.getSym();
                        if (o.getLabel().isArea())
                            switch (null === e && o.isInResult() && (e = o), r) {
                            case t._SCANNING_FOR_INCOMING:
                                if (!s.isInResult())
                                    continue;
                                n = s,
                                r = t._LINKING_TO_OUTGOING;
                                break;
                            case t._LINKING_TO_OUTGOING:
                                if (!o.isInResult())
                                    continue;
                                n.setNext(o),
                                r = t._SCANNING_FOR_INCOMING
                            }
                    }
                    if (r === this._LINKING_TO_OUTGOING) {
                        if (null === e)
                            throw new Oc("no outgoing dirEdge found", this.getCoordinate());
                        Gl.isTrue(e.isInResult(), "unable to link last incoming dirEdge"),
                        n.setNext(e)
                    }
                }, e.prototype.insert = function(t) {
                    var e = t;
                    this.insertEdgeEnd(e, e)
                }, e.prototype.getRightmostEdge = function() {
                    var t = this.getEdges(),
                        e = t.size();
                    if (e < 1)
                        return null;
                    var n = t.get(0);
                    if (1 === e)
                        return n;
                    var r = t.get(e - 1),
                        i = n.getQuadrant(),
                        o = r.getQuadrant();
                    return zc.isNorthern(i) && zc.isNorthern(o) ? n : zc.isNorthern(i) || zc.isNorthern(o) ? 0 !== n.getDy() ? n : 0 !== r.getDy() ? r : (Gl.shouldNeverReachHere("found two horizontal edges incident on node"), null) : r
                }, e.prototype.print = function(t) {
                    Tl.out.println("DirectedEdgeStar: " + this.getCoordinate());
                    for (var e = this.iterator(); e.hasNext();) {
                        var n = e.next();
                        t.print("out "),
                        n.print(t),
                        t.println(),
                        t.print("in "),
                        n.getSym().print(t),
                        t.println()
                    }
                }, e.prototype.getResultAreaEdges = function() {
                    if (null !== this._resultAreaEdgeList)
                        return this._resultAreaEdgeList;
                    this._resultAreaEdgeList = new lh;
                    for (var t = this.iterator(); t.hasNext();) {
                        var e = t.next();
                        (e.isInResult() || e.getSym().isInResult()) && this._resultAreaEdgeList.add(e)
                    }
                    return this._resultAreaEdgeList
                }, e.prototype.updateLabelling = function(t) {
                    for (var e = this.iterator(); e.hasNext();) {
                        var n = e.next().getLabel();
                        n.setAllLocationsIfNull(0, t.getLocation(0)),
                        n.setAllLocationsIfNull(1, t.getLocation(1))
                    }
                }, e.prototype.linkAllDirectedEdges = function() {
                    this.getEdges();
                    for (var t = null, e = null, n = this._edgeList.size() - 1; n >= 0; n--) {
                        var r = this._edgeList.get(n),
                            i = r.getSym();
                        null === e && (e = i),
                        null !== t && i.setNext(t),
                        t = r
                    }
                    e.setNext(t)
                }, e.prototype.computeDepths = function() {
                    var t = this;
                    if (1 === arguments.length) {
                        var e = arguments[0],
                            n = this.findIndex(e),
                            r = e.getDepth(Sc.LEFT),
                            i = e.getDepth(Sc.RIGHT),
                            o = this.computeDepths(n + 1, this._edgeList.size(), r);
                        if (this.computeDepths(0, n, o) !== i)
                            throw new Oc("depth mismatch at " + e.getCoordinate())
                    } else if (3 === arguments.length) {
                        for (var s = arguments[1], a = arguments[2], u = arguments[0]; u < s; u++) {
                            var l = t._edgeList.get(u);
                            l.setEdgeDepths(Sc.RIGHT, a),
                            a = l.getDepth(Sc.LEFT)
                        }
                        return a
                    }
                }, e.prototype.mergeSymLabels = function() {
                    for (var t = this.iterator(); t.hasNext();) {
                        var e = t.next();
                        e.getLabel().merge(e.getSym().getLabel())
                    }
                }, e.prototype.linkMinimalDirectedEdges = function(t) {
                    for (var e = this, n = null, r = null, i = this._SCANNING_FOR_INCOMING, o = this._resultAreaEdgeList.size() - 1; o >= 0; o--) {
                        var s = e._resultAreaEdgeList.get(o),
                            a = s.getSym();
                        switch (null === n && s.getEdgeRing() === t && (n = s), i) {
                        case e._SCANNING_FOR_INCOMING:
                            if (a.getEdgeRing() !== t)
                                continue;
                            r = a,
                            i = e._LINKING_TO_OUTGOING;
                            break;
                        case e._LINKING_TO_OUTGOING:
                            if (s.getEdgeRing() !== t)
                                continue;
                            r.setNextMin(s),
                            i = e._SCANNING_FOR_INCOMING
                        }
                    }
                    i === this._LINKING_TO_OUTGOING && (Gl.isTrue(null !== n, "found null for first outgoing dirEdge"), Gl.isTrue(n.getEdgeRing() === t, "unable to link last incoming dirEdge"), r.setNextMin(n))
                }, e.prototype.getOutgoingDegree = function() {
                    if (0 === arguments.length) {
                        for (var t = 0, e = this.iterator(); e.hasNext();)
                            e.next().isInResult() && t++;
                        return t
                    }
                    if (1 === arguments.length) {
                        for (var n = arguments[0], r = 0, i = this.iterator(); i.hasNext();)
                            i.next().getEdgeRing() === n && r++;
                        return r
                    }
                }, e.prototype.getLabel = function() {
                    return this._label
                }, e.prototype.findCoveredLineEdges = function() {
                    for (var t = pl.NONE, e = this.iterator(); e.hasNext();) {
                        var n = e.next(),
                            r = n.getSym();
                        if (!n.isLineEdge()) {
                            if (n.isInResult()) {
                                t = pl.INTERIOR;
                                break
                            }
                            if (r.isInResult()) {
                                t = pl.EXTERIOR;
                                break
                            }
                        }
                    }
                    if (t === pl.NONE)
                        return null;
                    for (var i = t, o = this.iterator(); o.hasNext();) {
                        var s = o.next(),
                            a = s.getSym();
                        s.isLineEdge() ? s.getEdge().setCovered(i === pl.INTERIOR) : (s.isInResult() && (i = pl.EXTERIOR), a.isInResult() && (i = pl.INTERIOR))
                    }
                }, e.prototype.computeLabelling = function(e) {
                    t.prototype.computeLabelling.call(this, e),
                    this._label = new Dc(pl.NONE);
                    for (var n = this.iterator(); n.hasNext();)
                        for (var r = n.next().getEdge().getLabel(), i = 0; i < 2; i++) {
                            var o = r.getLocation(i);
                            o !== pl.INTERIOR && o !== pl.BOUNDARY || this._label.setLocation(i, pl.INTERIOR)
                        }
                }, e.prototype.interfaces_ = function() {
                    return []
                }, e.prototype.getClass = function() {
                    return e
                }, e
            }(Xp),
            Yp = function(t) {
                function e() {
                    t.apply(this, arguments)
                }
                return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.createNode = function(t) {
                    return new Bc(t, new Hp)
                }, e.prototype.interfaces_ = function() {
                    return []
                }, e.prototype.getClass = function() {
                    return e
                }, e
            }(Hc),
            Wp = function t() {
                this._pts = null,
                this._orientation = null;
                var e = arguments[0];
                this._pts = e,
                this._orientation = t.orientation(e)
            };
        Wp.prototype.compareTo = function(t) {
            var e = t;
            return Wp.compareOriented(this._pts, this._orientation, e._pts, e._orientation)
        },
        Wp.prototype.interfaces_ = function() {
            return [il]
        },
        Wp.prototype.getClass = function() {
            return Wp
        },
        Wp.orientation = function(t) {
            return 1 === ph.increasingDirection(t)
        },
        Wp.compareOriented = function(t, e, n, r) {
            for (var i = e ? 1 : -1, o = r ? 1 : -1, s = e ? t.length : -1, a = r ? n.length : -1, u = e ? 0 : t.length - 1, l = r ? 0 : n.length - 1;;) {
                var h = t[u].compareTo(n[l]);
                if (0 !== h)
                    return h;
                var c = (u += i) === s,
                    p = (l += o) === a;
                if (c && !p)
                    return -1;
                if (!c && p)
                    return 1;
                if (c && p)
                    return 0
            }
        };
        var $p = function() {
            this._edges = new lh,
            this._ocaMap = new Ih
        };
        $p.prototype.print = function(t) {
            t.print("MULTILINESTRING ( ");
            for (var e = 0; e < this._edges.size(); e++) {
                var n = this._edges.get(e);
                e > 0 && t.print(","),
                t.print("(");
                for (var r = n.getCoordinates(), i = 0; i < r.length; i++)
                    i > 0 && t.print(","),
                    t.print(r[i].x + " " + r[i].y);
                t.println(")")
            }
            t.print(")  ")
        },
        $p.prototype.addAll = function(t) {
            for (var e = t.iterator(); e.hasNext();)
                this.add(e.next())
        },
        $p.prototype.findEdgeIndex = function(t) {
            for (var e = 0; e < this._edges.size(); e++)
                if (this._edges.get(e).equals(t))
                    return e;
            return -1
        },
        $p.prototype.iterator = function() {
            return this._edges.iterator()
        },
        $p.prototype.getEdges = function() {
            return this._edges
        },
        $p.prototype.get = function(t) {
            return this._edges.get(t)
        },
        $p.prototype.findEqualEdge = function(t) {
            var e = new Wp(t.getCoordinates());
            return this._ocaMap.get(e)
        },
        $p.prototype.add = function(t) {
            this._edges.add(t);
            var e = new Wp(t.getCoordinates());
            this._ocaMap.put(e, t)
        },
        $p.prototype.interfaces_ = function() {
            return []
        },
        $p.prototype.getClass = function() {
            return $p
        };
        var Kp = function() {};
        Kp.prototype.processIntersections = function(t, e, n, r) {},
        Kp.prototype.isDone = function() {},
        Kp.prototype.interfaces_ = function() {
            return []
        },
        Kp.prototype.getClass = function() {
            return Kp
        };
        var Zp = function() {
            this._hasIntersection = !1,
            this._hasProper = !1,
            this._hasProperInterior = !1,
            this._hasInterior = !1,
            this._properIntersectionPoint = null,
            this._li = null,
            this._isSelfIntersection = null,
            this.numIntersections = 0,
            this.numInteriorIntersections = 0,
            this.numProperIntersections = 0,
            this.numTests = 0;
            var t = arguments[0];
            this._li = t
        };
        Zp.prototype.isTrivialIntersection = function(t, e, n, r) {
            if (t === n && 1 === this._li.getIntersectionNum()) {
                if (Zp.isAdjacentSegments(e, r))
                    return !0;
                if (t.isClosed()) {
                    var i = t.size() - 1;
                    if (0 === e && r === i || 0 === r && e === i)
                        return !0
                }
            }
            return !1
        },
        Zp.prototype.getProperIntersectionPoint = function() {
            return this._properIntersectionPoint
        },
        Zp.prototype.hasProperInteriorIntersection = function() {
            return this._hasProperInterior
        },
        Zp.prototype.getLineIntersector = function() {
            return this._li
        },
        Zp.prototype.hasProperIntersection = function() {
            return this._hasProper
        },
        Zp.prototype.processIntersections = function(t, e, n, r) {
            if (t === n && e === r)
                return null;
            this.numTests++;
            var i = t.getCoordinates()[e],
                o = t.getCoordinates()[e + 1],
                s = n.getCoordinates()[r],
                a = n.getCoordinates()[r + 1];
            this._li.computeIntersection(i, o, s, a),
            this._li.hasIntersection() && (this.numIntersections++, this._li.isInteriorIntersection() && (this.numInteriorIntersections++, this._hasInterior = !0), this.isTrivialIntersection(t, e, n, r) || (this._hasIntersection = !0, t.addIntersections(this._li, e, 0), n.addIntersections(this._li, r, 1), this._li.isProper() && (this.numProperIntersections++, this._hasProper = !0, this._hasProperInterior = !0)))
        },
        Zp.prototype.hasIntersection = function() {
            return this._hasIntersection
        },
        Zp.prototype.isDone = function() {
            return !1
        },
        Zp.prototype.hasInteriorIntersection = function() {
            return this._hasInterior
        },
        Zp.prototype.interfaces_ = function() {
            return [Kp]
        },
        Zp.prototype.getClass = function() {
            return Zp
        },
        Zp.isAdjacentSegments = function(t, e) {
            return 1 === Math.abs(t - e)
        };
        var Jp = function() {
            this.coord = null,
            this.segmentIndex = null,
            this.dist = null;
            var t = arguments[0],
                e = arguments[1],
                n = arguments[2];
            this.coord = new ul(t),
            this.segmentIndex = e,
            this.dist = n
        };
        Jp.prototype.getSegmentIndex = function() {
            return this.segmentIndex
        },
        Jp.prototype.getCoordinate = function() {
            return this.coord
        },
        Jp.prototype.print = function(t) {
            t.print(this.coord),
            t.print(" seg # = " + this.segmentIndex),
            t.println(" dist = " + this.dist)
        },
        Jp.prototype.compareTo = function(t) {
            var e = t;
            return this.compare(e.segmentIndex, e.dist)
        },
        Jp.prototype.isEndPoint = function(t) {
            return 0 === this.segmentIndex && 0 === this.dist || this.segmentIndex === t
        },
        Jp.prototype.toString = function() {
            return this.coord + " seg # = " + this.segmentIndex + " dist = " + this.dist
        },
        Jp.prototype.getDistance = function() {
            return this.dist
        },
        Jp.prototype.compare = function(t, e) {
            return this.segmentIndex < t ? -1 : this.segmentIndex > t ? 1 : this.dist < e ? -1 : this.dist > e ? 1 : 0
        },
        Jp.prototype.interfaces_ = function() {
            return [il]
        },
        Jp.prototype.getClass = function() {
            return Jp
        };
        var Qp = function() {
            this._nodeMap = new Ih,
            this.edge = null;
            var t = arguments[0];
            this.edge = t
        };
        Qp.prototype.print = function(t) {
            t.println("Intersections:");
            for (var e = this.iterator(); e.hasNext();)
                e.next().print(t)
        },
        Qp.prototype.iterator = function() {
            return this._nodeMap.values().iterator()
        },
        Qp.prototype.addSplitEdges = function(t) {
            this.addEndpoints();
            for (var e = this.iterator(), n = e.next(); e.hasNext();) {
                var r = e.next(),
                    i = this.createSplitEdge(n, r);
                t.add(i),
                n = r
            }
        },
        Qp.prototype.addEndpoints = function() {
            var t = this.edge.pts.length - 1;
            this.add(this.edge.pts[0], 0, 0),
            this.add(this.edge.pts[t], t, 0)
        },
        Qp.prototype.createSplitEdge = function(t, e) {
            var n = e.segmentIndex - t.segmentIndex + 2,
                r = this.edge.pts[e.segmentIndex],
                i = e.dist > 0 || !e.coord.equals2D(r);
            i || n--;
            var o = new Array(n).fill(null),
                s = 0;
            o[s++] = new ul(t.coord);
            for (var a = t.segmentIndex + 1; a <= e.segmentIndex; a++)
                o[s++] = this.edge.pts[a];
            return i && (o[s] = e.coord), new of(o, new Dc(this.edge._label))
        },
        Qp.prototype.add = function(t, e, n) {
            var r = new Jp(t, e, n),
                i = this._nodeMap.get(r);
            return null !== i ? i : (this._nodeMap.put(r, r), r)
        },
        Qp.prototype.isIntersection = function(t) {
            for (var e = this.iterator(); e.hasNext();)
                if (e.next().coord.equals(t))
                    return !0;
            return !1
        },
        Qp.prototype.interfaces_ = function() {
            return []
        },
        Qp.prototype.getClass = function() {
            return Qp
        };
        var tf = function() {};
        tf.prototype.getChainStartIndices = function(t) {
            var e = 0,
                n = new lh;
            n.add(new ml(e));
            do {
                var r = this.findChainEnd(t, e);
                n.add(new ml(r)),
                e = r
            } while (e < t.length - 1);
            return tf.toIntArray(n)
        },
        tf.prototype.findChainEnd = function(t, e) {
            for (var n = zc.quadrant(t[e], t[e + 1]), r = e + 1; r < t.length && zc.quadrant(t[r - 1], t[r]) === n;)
                r++;
            return r - 1
        },
        tf.prototype.interfaces_ = function() {
            return []
        },
        tf.prototype.getClass = function() {
            return tf
        },
        tf.toIntArray = function(t) {
            for (var e = new Array(t.size()).fill(null), n = 0; n < e.length; n++)
                e[n] = t.get(n).intValue();
            return e
        };
        var ef = function() {
            this.e = null,
            this.pts = null,
            this.startIndex = null,
            this.env1 = new Ll,
            this.env2 = new Ll;
            var t = arguments[0];
            this.e = t,
            this.pts = t.getCoordinates();
            var e = new tf;
            this.startIndex = e.getChainStartIndices(this.pts)
        };
        ef.prototype.getCoordinates = function() {
            return this.pts
        },
        ef.prototype.getMaxX = function(t) {
            var e = this.pts[this.startIndex[t]].x,
                n = this.pts[this.startIndex[t + 1]].x;
            return e > n ? e : n
        },
        ef.prototype.getMinX = function(t) {
            var e = this.pts[this.startIndex[t]].x,
                n = this.pts[this.startIndex[t + 1]].x;
            return e < n ? e : n
        },
        ef.prototype.computeIntersectsForChain = function() {
            if (4 === arguments.length) {
                var t = arguments[0],
                    e = arguments[1],
                    n = arguments[2],
                    r = arguments[3];
                this.computeIntersectsForChain(this.startIndex[t], this.startIndex[t + 1], e, e.startIndex[n], e.startIndex[n + 1], r)
            } else if (6 === arguments.length) {
                var i = arguments[0],
                    o = arguments[1],
                    s = arguments[2],
                    a = arguments[3],
                    u = arguments[4],
                    l = arguments[5],
                    h = this.pts[i],
                    c = this.pts[o],
                    p = s.pts[a],
                    f = s.pts[u];
                if (o - i == 1 && u - a == 1)
                    return l.addIntersections(this.e, i, s.e, a), null;
                if (this.env1.init(h, c), this.env2.init(p, f), !this.env1.intersects(this.env2))
                    return null;
                var d = Math.trunc((i + o) / 2),
                    g = Math.trunc((a + u) / 2);
                i < d && (a < g && this.computeIntersectsForChain(i, d, s, a, g, l), g < u && this.computeIntersectsForChain(i, d, s, g, u, l)),
                d < o && (a < g && this.computeIntersectsForChain(d, o, s, a, g, l), g < u && this.computeIntersectsForChain(d, o, s, g, u, l))
            }
        },
        ef.prototype.getStartIndexes = function() {
            return this.startIndex
        },
        ef.prototype.computeIntersects = function(t, e) {
            for (var n = 0; n < this.startIndex.length - 1; n++)
                for (var r = 0; r < t.startIndex.length - 1; r++)
                    this.computeIntersectsForChain(n, t, r, e)
        },
        ef.prototype.interfaces_ = function() {
            return []
        },
        ef.prototype.getClass = function() {
            return ef
        };
        var nf = function t() {
                this._depth = Array(2).fill().map((function() {
                    return Array(3)
                }));
                for (var e = 0; e < 2; e++)
                    for (var n = 0; n < 3; n++)
                        this._depth[e][n] = t.NULL_VALUE
            },
            rf = {
                NULL_VALUE: {
                    configurable: !0
                }
            };
        nf.prototype.getDepth = function(t, e) {
            return this._depth[t][e]
        },
        nf.prototype.setDepth = function(t, e, n) {
            this._depth[t][e] = n
        },
        nf.prototype.isNull = function() {
            var t = this;
            if (0 === arguments.length) {
                for (var e = 0; e < 2; e++)
                    for (var n = 0; n < 3; n++)
                        if (t._depth[e][n] !== nf.NULL_VALUE)
                            return !1;
                return !0
            }
            if (1 === arguments.length) {
                var r = arguments[0];
                return this._depth[r][1] === nf.NULL_VALUE
            }
            if (2 === arguments.length) {
                var i = arguments[0],
                    o = arguments[1];
                return this._depth[i][o] === nf.NULL_VALUE
            }
        },
        nf.prototype.normalize = function() {
            for (var t = this, e = 0; e < 2; e++)
                if (!t.isNull(e)) {
                    var n = t._depth[e][1];
                    t._depth[e][2] < n && (n = t._depth[e][2]),
                    n < 0 && (n = 0);
                    for (var r = 1; r < 3; r++) {
                        var i = 0;
                        t._depth[e][r] > n && (i = 1),
                        t._depth[e][r] = i
                    }
                }
        },
        nf.prototype.getDelta = function(t) {
            return this._depth[t][Sc.RIGHT] - this._depth[t][Sc.LEFT]
        },
        nf.prototype.getLocation = function(t, e) {
            return this._depth[t][e] <= 0 ? pl.EXTERIOR : pl.INTERIOR
        },
        nf.prototype.toString = function() {
            return "A: " + this._depth[0][1] + "," + this._depth[0][2] + " B: " + this._depth[1][1] + "," + this._depth[1][2]
        },
        nf.prototype.add = function() {
            var t = this;
            if (1 === arguments.length)
                for (var e = arguments[0], n = 0; n < 2; n++)
                    for (var r = 1; r < 3; r++) {
                        var i = e.getLocation(n, r);
                        i !== pl.EXTERIOR && i !== pl.INTERIOR || (t.isNull(n, r) ? t._depth[n][r] = nf.depthAtLocation(i) : t._depth[n][r] += nf.depthAtLocation(i))
                    }
            else if (3 === arguments.length) {
                var o = arguments[0],
                    s = arguments[1];
                arguments[2] === pl.INTERIOR && this._depth[o][s]++
            }
        },
        nf.prototype.interfaces_ = function() {
            return []
        },
        nf.prototype.getClass = function() {
            return nf
        },
        nf.depthAtLocation = function(t) {
            return t === pl.EXTERIOR ? 0 : t === pl.INTERIOR ? 1 : nf.NULL_VALUE
        },
        rf.NULL_VALUE.get = function() {
            return -1
        },
        Object.defineProperties(nf, rf);
        var of = function(t) {
                function e() {
                    if (t.call(this), this.pts = null, this._env = null, this.eiList = new Qp(this), this._name = null, this._mce = null, this._isIsolated = !0, this._depth = new nf, this._depthDelta = 0, 1 === arguments.length) {
                        var n = arguments[0];
                        e.call(this, n, null)
                    } else if (2 === arguments.length) {
                        var r = arguments[0],
                            i = arguments[1];
                        this.pts = r,
                        this._label = i
                    }
                }
                return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.getDepth = function() {
                    return this._depth
                }, e.prototype.getCollapsedEdge = function() {
                    var t = new Array(2).fill(null);
                    return t[0] = this.pts[0], t[1] = this.pts[1], new e(t, Dc.toLineLabel(this._label))
                }, e.prototype.isIsolated = function() {
                    return this._isIsolated
                }, e.prototype.getCoordinates = function() {
                    return this.pts
                }, e.prototype.setIsolated = function(t) {
                    this._isIsolated = t
                }, e.prototype.setName = function(t) {
                    this._name = t
                }, e.prototype.equals = function(t) {
                    if (!(t instanceof e))
                        return !1;
                    var n = t;
                    if (this.pts.length !== n.pts.length)
                        return !1;
                    for (var r = !0, i = !0, o = this.pts.length, s = 0; s < this.pts.length; s++)
                        if (this.pts[s].equals2D(n.pts[s]) || (r = !1), this.pts[s].equals2D(n.pts[--o]) || (i = !1), !r && !i)
                            return !1;
                    return !0
                }, e.prototype.getCoordinate = function() {
                    if (0 === arguments.length)
                        return this.pts.length > 0 ? this.pts[0] : null;
                    if (1 === arguments.length) {
                        var t = arguments[0];
                        return this.pts[t]
                    }
                }, e.prototype.print = function(t) {
                    t.print("edge " + this._name + ": "),
                    t.print("LINESTRING (");
                    for (var e = 0; e < this.pts.length; e++)
                        e > 0 && t.print(","),
                        t.print(this.pts[e].x + " " + this.pts[e].y);
                    t.print(")  " + this._label + " " + this._depthDelta)
                }, e.prototype.computeIM = function(t) {
                    e.updateIM(this._label, t)
                }, e.prototype.isCollapsed = function() {
                    return !!this._label.isArea() && 3 === this.pts.length && !!this.pts[0].equals(this.pts[2])
                }, e.prototype.isClosed = function() {
                    return this.pts[0].equals(this.pts[this.pts.length - 1])
                }, e.prototype.getMaximumSegmentIndex = function() {
                    return this.pts.length - 1
                }, e.prototype.getDepthDelta = function() {
                    return this._depthDelta
                }, e.prototype.getNumPoints = function() {
                    return this.pts.length
                }, e.prototype.printReverse = function(t) {
                    t.print("edge " + this._name + ": ");
                    for (var e = this.pts.length - 1; e >= 0; e--)
                        t.print(this.pts[e] + " ");
                    t.println("")
                }, e.prototype.getMonotoneChainEdge = function() {
                    return null === this._mce && (this._mce = new ef(this)), this._mce
                }, e.prototype.getEnvelope = function() {
                    if (null === this._env) {
                        this._env = new Ll;
                        for (var t = 0; t < this.pts.length; t++)
                            this._env.expandToInclude(this.pts[t])
                    }
                    return this._env
                }, e.prototype.addIntersection = function(t, e, n, r) {
                    var i = new ul(t.getIntersection(r)),
                        o = e,
                        s = t.getEdgeDistance(n, r),
                        a = o + 1;
                    if (a < this.pts.length) {
                        var u = this.pts[a];
                        i.equals2D(u) && (o = a, s = 0)
                    }
                    this.eiList.add(i, o, s)
                }, e.prototype.toString = function() {
                    var t = new vl;
                    t.append("edge " + this._name + ": "),
                    t.append("LINESTRING (");
                    for (var e = 0; e < this.pts.length; e++)
                        e > 0 && t.append(","),
                        t.append(this.pts[e].x + " " + this.pts[e].y);
                    return t.append(")  " + this._label + " " + this._depthDelta), t.toString()
                }, e.prototype.isPointwiseEqual = function(t) {
                    if (this.pts.length !== t.pts.length)
                        return !1;
                    for (var e = 0; e < this.pts.length; e++)
                        if (!this.pts[e].equals2D(t.pts[e]))
                            return !1;
                    return !0
                }, e.prototype.setDepthDelta = function(t) {
                    this._depthDelta = t
                }, e.prototype.getEdgeIntersectionList = function() {
                    return this.eiList
                }, e.prototype.addIntersections = function(t, e, n) {
                    for (var r = 0; r < t.getIntersectionNum(); r++)
                        this.addIntersection(t, e, n, r)
                }, e.prototype.interfaces_ = function() {
                    return []
                }, e.prototype.getClass = function() {
                    return e
                }, e.updateIM = function() {
                    if (2 !== arguments.length)
                        return t.prototype.updateIM.apply(this, arguments);
                    var e = arguments[0],
                        n = arguments[1];
                    n.setAtLeastIfValid(e.getLocation(0, Sc.ON), e.getLocation(1, Sc.ON), 1),
                    e.isArea() && (n.setAtLeastIfValid(e.getLocation(0, Sc.LEFT), e.getLocation(1, Sc.LEFT), 2), n.setAtLeastIfValid(e.getLocation(0, Sc.RIGHT), e.getLocation(1, Sc.RIGHT), 2))
                }, e
            }(Gc),
            sf = function(t) {
                this._workingPrecisionModel = null,
                this._workingNoder = null,
                this._geomFact = null,
                this._graph = null,
                this._edgeList = new $p,
                this._bufParams = t || null
            };
        sf.prototype.setWorkingPrecisionModel = function(t) {
            this._workingPrecisionModel = t
        },
        sf.prototype.insertUniqueEdge = function(t) {
            var e = this._edgeList.findEqualEdge(t);
            if (null !== e) {
                var n = e.getLabel(),
                    r = t.getLabel();
                e.isPointwiseEqual(t) || (r = new Dc(t.getLabel())).flip(),
                n.merge(r);
                var i = sf.depthDelta(r),
                    o = e.getDepthDelta() + i;
                e.setDepthDelta(o)
            } else
                this._edgeList.add(t),
                t.setDepthDelta(sf.depthDelta(t.getLabel()))
        },
        sf.prototype.buildSubgraphs = function(t, e) {
            for (var n = new lh, r = t.iterator(); r.hasNext();) {
                var i = r.next(),
                    o = i.getRightmostCoordinate(),
                    s = new kp(n).getDepth(o);
                i.computeDepth(s),
                i.findResultEdges(),
                n.add(i),
                e.add(i.getDirectedEdges(), i.getNodes())
            }
        },
        sf.prototype.createSubgraphs = function(t) {
            for (var e = new lh, n = t.getNodes().iterator(); n.hasNext();) {
                var r = n.next();
                if (!r.isVisited()) {
                    var i = new Rc;
                    i.create(r),
                    e.add(i)
                }
            }
            return np.sort(e, np.reverseOrder()), e
        },
        sf.prototype.createEmptyResultGeometry = function() {
            return this._geomFact.createPolygon()
        },
        sf.prototype.getNoder = function(t) {
            if (null !== this._workingNoder)
                return this._workingNoder;
            var e = new Cp,
                n = new zl;
            return n.setPrecisionModel(t), e.setSegmentIntersector(new Zp(n)), e
        },
        sf.prototype.buffer = function(t, e) {
            var n = this._workingPrecisionModel;
            null === n && (n = t.getPrecisionModel()),
            this._geomFact = t.getFactory();
            var r = new Fp(n, this._bufParams),
                i = new qp(t, e, r).getCurves();
            if (i.size() <= 0)
                return this.createEmptyResultGeometry();
            this.computeNodedEdges(i, n),
            this._graph = new Yc(new Yp),
            this._graph.addEdges(this._edgeList.getEdges());
            var o = this.createSubgraphs(this._graph),
                s = new Wc(this._geomFact);
            this.buildSubgraphs(o, s);
            var a = s.getPolygons();
            return a.size() <= 0 ? this.createEmptyResultGeometry() : this._geomFact.buildGeometry(a)
        },
        sf.prototype.computeNodedEdges = function(t, e) {
            var n = this.getNoder(e);
            n.computeNodes(t);
            for (var r = n.getNodedSubstrings().iterator(); r.hasNext();) {
                var i = r.next(),
                    o = i.getCoordinates();
                if (2 !== o.length || !o[0].equals2D(o[1])) {
                    var s = i.getData(),
                        a = new of(i.getCoordinates(), new Dc(s));
                    this.insertUniqueEdge(a)
                }
            }
        },
        sf.prototype.setNoder = function(t) {
            this._workingNoder = t
        },
        sf.prototype.interfaces_ = function() {
            return []
        },
        sf.prototype.getClass = function() {
            return sf
        },
        sf.depthDelta = function(t) {
            var e = t.getLocation(0, Sc.LEFT),
                n = t.getLocation(0, Sc.RIGHT);
            return e === pl.INTERIOR && n === pl.EXTERIOR ? 1 : e === pl.EXTERIOR && n === pl.INTERIOR ? -1 : 0
        },
        sf.convertSegStrings = function(t) {
            for (var e = new mc, n = new lh; t.hasNext();) {
                var r = t.next(),
                    i = e.createLineString(r.getCoordinates());
                n.add(i)
            }
            return e.buildGeometry(n)
        };
        var af = function() {
            if (this._noder = null, this._scaleFactor = null, this._offsetX = null, this._offsetY = null, this._isScaled = !1, 2 === arguments.length) {
                var t = arguments[0],
                    e = arguments[1];
                this._noder = t,
                this._scaleFactor = e,
                this._offsetX = 0,
                this._offsetY = 0,
                this._isScaled = !this.isIntegerPrecision()
            } else if (4 === arguments.length) {
                var n = arguments[0],
                    r = arguments[1],
                    i = arguments[2],
                    o = arguments[3];
                this._noder = n,
                this._scaleFactor = r,
                this._offsetX = i,
                this._offsetY = o,
                this._isScaled = !this.isIntegerPrecision()
            }
        };
        af.prototype.rescale = function() {
            var t = this;
            if (dl(arguments[0], ih))
                for (var e = arguments[0].iterator(); e.hasNext();) {
                    var n = e.next();
                    t.rescale(n.getCoordinates())
                }
            else if (arguments[0] instanceof Array) {
                for (var r = arguments[0], i = 0; i < r.length; i++)
                    r[i].x = r[i].x / t._scaleFactor + t._offsetX,
                    r[i].y = r[i].y / t._scaleFactor + t._offsetY;
                2 === r.length && r[0].equals2D(r[1]) && Tl.out.println(r)
            }
        },
        af.prototype.scale = function() {
            var t = this;
            if (dl(arguments[0], ih)) {
                for (var e = arguments[0], n = new lh, r = e.iterator(); r.hasNext();) {
                    var i = r.next();
                    n.add(new yp(t.scale(i.getCoordinates()), i.getData()))
                }
                return n
            }
            if (arguments[0] instanceof Array) {
                for (var o = arguments[0], s = new Array(o.length).fill(null), a = 0; a < o.length; a++)
                    s[a] = new ul(Math.round((o[a].x - t._offsetX) * t._scaleFactor), Math.round((o[a].y - t._offsetY) * t._scaleFactor), o[a].z);
                return ph.removeRepeatedPoints(s)
            }
        },
        af.prototype.isIntegerPrecision = function() {
            return 1 === this._scaleFactor
        },
        af.prototype.getNodedSubstrings = function() {
            var t = this._noder.getNodedSubstrings();
            return this._isScaled && this.rescale(t), t
        },
        af.prototype.computeNodes = function(t) {
            var e = t;
            this._isScaled && (e = this.scale(t)),
            this._noder.computeNodes(e)
        },
        af.prototype.interfaces_ = function() {
            return [wp]
        },
        af.prototype.getClass = function() {
            return af
        };
        var uf = function() {
                this._li = new zl,
                this._segStrings = null;
                var t = arguments[0];
                this._segStrings = t
            },
            lf = {
                fact: {
                    configurable: !0
                }
            };
        uf.prototype.checkEndPtVertexIntersections = function() {
            var t = this;
            if (0 === arguments.length)
                for (var e = this._segStrings.iterator(); e.hasNext();) {
                    var n = e.next().getCoordinates();
                    t.checkEndPtVertexIntersections(n[0], t._segStrings),
                    t.checkEndPtVertexIntersections(n[n.length - 1], t._segStrings)
                }
            else if (2 === arguments.length)
                for (var r = arguments[0], i = arguments[1].iterator(); i.hasNext();)
                    for (var o = i.next().getCoordinates(), s = 1; s < o.length - 1; s++)
                        if (o[s].equals(r))
                            throw new kl("found endpt/interior pt intersection at index " + s + " :pt " + r)
        },
        uf.prototype.checkInteriorIntersections = function() {
            var t = this;
            if (0 === arguments.length)
                for (var e = this._segStrings.iterator(); e.hasNext();)
                    for (var n = e.next(), r = this._segStrings.iterator(); r.hasNext();) {
                        var i = r.next();
                        t.checkInteriorIntersections(n, i)
                    }
            else if (2 === arguments.length)
                for (var o = arguments[0], s = arguments[1], a = o.getCoordinates(), u = s.getCoordinates(), l = 0; l < a.length - 1; l++)
                    for (var h = 0; h < u.length - 1; h++)
                        t.checkInteriorIntersections(o, l, s, h);
            else if (4 === arguments.length) {
                var c = arguments[0],
                    p = arguments[1],
                    f = arguments[2],
                    d = arguments[3];
                if (c === f && p === d)
                    return null;
                var g = c.getCoordinates()[p],
                    y = c.getCoordinates()[p + 1],
                    v = f.getCoordinates()[d],
                    m = f.getCoordinates()[d + 1];
                if (this._li.computeIntersection(g, y, v, m), this._li.hasIntersection() && (this._li.isProper() || this.hasInteriorIntersection(this._li, g, y) || this.hasInteriorIntersection(this._li, v, m)))
                    throw new kl("found non-noded intersection at " + g + "-" + y + " and " + v + "-" + m)
            }
        },
        uf.prototype.checkValid = function() {
            this.checkEndPtVertexIntersections(),
            this.checkInteriorIntersections(),
            this.checkCollapses()
        },
        uf.prototype.checkCollapses = function() {
            var t = this;
            if (0 === arguments.length)
                for (var e = this._segStrings.iterator(); e.hasNext();) {
                    var n = e.next();
                    t.checkCollapses(n)
                }
            else if (1 === arguments.length)
                for (var r = arguments[0].getCoordinates(), i = 0; i < r.length - 2; i++)
                    t.checkCollapse(r[i], r[i + 1], r[i + 2])
        },
        uf.prototype.hasInteriorIntersection = function(t, e, n) {
            for (var r = 0; r < t.getIntersectionNum(); r++) {
                var i = t.getIntersection(r);
                if (!i.equals(e) && !i.equals(n))
                    return !0
            }
            return !1
        },
        uf.prototype.checkCollapse = function(t, e, n) {
            if (t.equals(n))
                throw new kl("found non-noded collapse at " + uf.fact.createLineString([t, e, n]))
        },
        uf.prototype.interfaces_ = function() {
            return []
        },
        uf.prototype.getClass = function() {
            return uf
        },
        lf.fact.get = function() {
            return new mc
        },
        Object.defineProperties(uf, lf);
        var hf = function() {
                this._li = null,
                this._pt = null,
                this._originalPt = null,
                this._ptScaled = null,
                this._p0Scaled = null,
                this._p1Scaled = null,
                this._scaleFactor = null,
                this._minx = null,
                this._maxx = null,
                this._miny = null,
                this._maxy = null,
                this._corner = new Array(4).fill(null),
                this._safeEnv = null;
                var t = arguments[0],
                    e = arguments[1],
                    n = arguments[2];
                if (this._originalPt = t, this._pt = t, this._scaleFactor = e, this._li = n, e <= 0)
                    throw new el("Scale factor must be non-zero");
                1 !== e && (this._pt = new ul(this.scale(t.x), this.scale(t.y)), this._p0Scaled = new ul, this._p1Scaled = new ul),
                this.initCorners(this._pt)
            },
            cf = {
                SAFE_ENV_EXPANSION_FACTOR: {
                    configurable: !0
                }
            };
        hf.prototype.intersectsScaled = function(t, e) {
            var n = Math.min(t.x, e.x),
                r = Math.max(t.x, e.x),
                i = Math.min(t.y, e.y),
                o = Math.max(t.y, e.y),
                s = this._maxx < n || this._minx > r || this._maxy < i || this._miny > o;
            if (s)
                return !1;
            var a = this.intersectsToleranceSquare(t, e);
            return Gl.isTrue(!(s && a), "Found bad envelope test"), a
        },
        hf.prototype.initCorners = function(t) {
            var e = .5;
            this._minx = t.x - e,
            this._maxx = t.x + e,
            this._miny = t.y - e,
            this._maxy = t.y + e,
            this._corner[0] = new ul(this._maxx, this._maxy),
            this._corner[1] = new ul(this._minx, this._maxy),
            this._corner[2] = new ul(this._minx, this._miny),
            this._corner[3] = new ul(this._maxx, this._miny)
        },
        hf.prototype.intersects = function(t, e) {
            return 1 === this._scaleFactor ? this.intersectsScaled(t, e) : (this.copyScaled(t, this._p0Scaled), this.copyScaled(e, this._p1Scaled), this.intersectsScaled(this._p0Scaled, this._p1Scaled))
        },
        hf.prototype.scale = function(t) {
            return Math.round(t * this._scaleFactor)
        },
        hf.prototype.getCoordinate = function() {
            return this._originalPt
        },
        hf.prototype.copyScaled = function(t, e) {
            e.x = this.scale(t.x),
            e.y = this.scale(t.y)
        },
        hf.prototype.getSafeEnvelope = function() {
            if (null === this._safeEnv) {
                var t = hf.SAFE_ENV_EXPANSION_FACTOR / this._scaleFactor;
                this._safeEnv = new Ll(this._originalPt.x - t, this._originalPt.x + t, this._originalPt.y - t, this._originalPt.y + t)
            }
            return this._safeEnv
        },
        hf.prototype.intersectsPixelClosure = function(t, e) {
            return this._li.computeIntersection(t, e, this._corner[0], this._corner[1]), !!(this._li.hasIntersection() || (this._li.computeIntersection(t, e, this._corner[1], this._corner[2]), this._li.hasIntersection() || (this._li.computeIntersection(t, e, this._corner[2], this._corner[3]), this._li.hasIntersection() || (this._li.computeIntersection(t, e, this._corner[3], this._corner[0]), this._li.hasIntersection()))))
        },
        hf.prototype.intersectsToleranceSquare = function(t, e) {
            var n = !1,
                r = !1;
            return this._li.computeIntersection(t, e, this._corner[0], this._corner[1]), !!(this._li.isProper() || (this._li.computeIntersection(t, e, this._corner[1], this._corner[2]), this._li.isProper() || (this._li.hasIntersection() && (n = !0), this._li.computeIntersection(t, e, this._corner[2], this._corner[3]), this._li.isProper() || (this._li.hasIntersection() && (r = !0), this._li.computeIntersection(t, e, this._corner[3], this._corner[0]), this._li.isProper() || n && r || t.equals(this._pt) || e.equals(this._pt)))))
        },
        hf.prototype.addSnappedNode = function(t, e) {
            var n = t.getCoordinate(e),
                r = t.getCoordinate(e + 1);
            return !!this.intersects(n, r) && (t.addIntersection(this.getCoordinate(), e), !0)
        },
        hf.prototype.interfaces_ = function() {
            return []
        },
        hf.prototype.getClass = function() {
            return hf
        },
        cf.SAFE_ENV_EXPANSION_FACTOR.get = function() {
            return .75
        },
        Object.defineProperties(hf, cf);
        var pf = function() {
            this.tempEnv1 = new Ll,
            this.selectedSegment = new vp
        };
        pf.prototype.select = function() {
            if (1 === arguments.length)
                ;
            else if (2 === arguments.length) {
                var t = arguments[1];
                arguments[0].getLineSegment(t, this.selectedSegment),
                this.select(this.selectedSegment)
            }
        },
        pf.prototype.interfaces_ = function() {
            return []
        },
        pf.prototype.getClass = function() {
            return pf
        };
        var ff = function() {
                this._index = null;
                var t = arguments[0];
                this._index = t
            },
            df = {
                HotPixelSnapAction: {
                    configurable: !0
                }
            };
        ff.prototype.snap = function() {
            if (1 === arguments.length) {
                var t = arguments[0];
                return this.snap(t, null, -1)
            }
            if (3 === arguments.length) {
                var e = arguments[0],
                    n = arguments[1],
                    r = arguments[2],
                    i = e.getSafeEnvelope(),
                    o = new gf(e, n, r);
                return this._index.query(i, {
                    interfaces_: function() {
                        return [Jc]
                    },
                    visitItem: function(t) {
                        t.select(i, o)
                    }
                }), o.isNodeAdded()
            }
        },
        ff.prototype.interfaces_ = function() {
            return []
        },
        ff.prototype.getClass = function() {
            return ff
        },
        df.HotPixelSnapAction.get = function() {
            return gf
        },
        Object.defineProperties(ff, df);
        var gf = function(t) {
                function e() {
                    t.call(this),
                    this._hotPixel = null,
                    this._parentEdge = null,
                    this._hotPixelVertexIndex = null,
                    this._isNodeAdded = !1;
                    var e = arguments[0],
                        n = arguments[1],
                        r = arguments[2];
                    this._hotPixel = e,
                    this._parentEdge = n,
                    this._hotPixelVertexIndex = r
                }
                return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.isNodeAdded = function() {
                    return this._isNodeAdded
                }, e.prototype.select = function() {
                    if (2 !== arguments.length)
                        return t.prototype.select.apply(this, arguments);
                    var e = arguments[1],
                        n = arguments[0].getContext();
                    if (null !== this._parentEdge && n === this._parentEdge && e === this._hotPixelVertexIndex)
                        return null;
                    this._isNodeAdded = this._hotPixel.addSnappedNode(n, e)
                }, e.prototype.interfaces_ = function() {
                    return []
                }, e.prototype.getClass = function() {
                    return e
                }, e
            }(pf),
            yf = function() {
                this._li = null,
                this._interiorIntersections = null;
                var t = arguments[0];
                this._li = t,
                this._interiorIntersections = new lh
            };
        yf.prototype.processIntersections = function(t, e, n, r) {
            if (t === n && e === r)
                return null;
            var i = t.getCoordinates()[e],
                o = t.getCoordinates()[e + 1],
                s = n.getCoordinates()[r],
                a = n.getCoordinates()[r + 1];
            if (this._li.computeIntersection(i, o, s, a), this._li.hasIntersection() && this._li.isInteriorIntersection()) {
                for (var u = 0; u < this._li.getIntersectionNum(); u++)
                    this._interiorIntersections.add(this._li.getIntersection(u));
                t.addIntersections(this._li, e, 0),
                n.addIntersections(this._li, r, 1)
            }
        },
        yf.prototype.isDone = function() {
            return !1
        },
        yf.prototype.getInteriorIntersections = function() {
            return this._interiorIntersections
        },
        yf.prototype.interfaces_ = function() {
            return [Kp]
        },
        yf.prototype.getClass = function() {
            return yf
        };
        var vf = function() {
            this._pm = null,
            this._li = null,
            this._scaleFactor = null,
            this._noder = null,
            this._pointSnapper = null,
            this._nodedSegStrings = null;
            var t = arguments[0];
            this._pm = t,
            this._li = new zl,
            this._li.setPrecisionModel(t),
            this._scaleFactor = t.getScale()
        };
        vf.prototype.checkCorrectness = function(t) {
            var e = yp.getNodedSubstrings(t),
                n = new uf(e);
            try {
                n.checkValid()
            } catch (t) {
                if (!(t instanceof Sl))
                    throw t;
                t.printStackTrace()
            }
        },
        vf.prototype.getNodedSubstrings = function() {
            return yp.getNodedSubstrings(this._nodedSegStrings)
        },
        vf.prototype.snapRound = function(t, e) {
            var n = this.findInteriorIntersections(t, e);
            this.computeIntersectionSnaps(n),
            this.computeVertexSnaps(t)
        },
        vf.prototype.findInteriorIntersections = function(t, e) {
            var n = new yf(e);
            return this._noder.setSegmentIntersector(n), this._noder.computeNodes(t), n.getInteriorIntersections()
        },
        vf.prototype.computeVertexSnaps = function() {
            var t = this;
            if (dl(arguments[0], ih))
                for (var e = arguments[0].iterator(); e.hasNext();) {
                    var n = e.next();
                    t.computeVertexSnaps(n)
                }
            else if (arguments[0] instanceof yp)
                for (var r = arguments[0], i = r.getCoordinates(), o = 0; o < i.length; o++) {
                    var s = new hf(i[o], t._scaleFactor, t._li);
                    t._pointSnapper.snap(s, r, o) && r.addIntersection(i[o], o)
                }
        },
        vf.prototype.computeNodes = function(t) {
            this._nodedSegStrings = t,
            this._noder = new Cp,
            this._pointSnapper = new ff(this._noder.getIndex()),
            this.snapRound(t, this._li)
        },
        vf.prototype.computeIntersectionSnaps = function(t) {
            for (var e = this, n = t.iterator(); n.hasNext();) {
                var r = n.next(),
                    i = new hf(r, e._scaleFactor, e._li);
                e._pointSnapper.snap(i)
            }
        },
        vf.prototype.interfaces_ = function() {
            return [wp]
        },
        vf.prototype.getClass = function() {
            return vf
        };
        var mf = function() {
                if (this._argGeom = null, this._distance = null, this._bufParams = new Sp, this._resultGeometry = null, this._saveException = null, 1 === arguments.length) {
                    var t = arguments[0];
                    this._argGeom = t
                } else if (2 === arguments.length) {
                    var e = arguments[0],
                        n = arguments[1];
                    this._argGeom = e,
                    this._bufParams = n
                }
            },
            _f = {
                CAP_ROUND: {
                    configurable: !0
                },
                CAP_BUTT: {
                    configurable: !0
                },
                CAP_FLAT: {
                    configurable: !0
                },
                CAP_SQUARE: {
                    configurable: !0
                },
                MAX_PRECISION_DIGITS: {
                    configurable: !0
                }
            };
        mf.prototype.bufferFixedPrecision = function(t) {
            var e = new af(new vf(new dc(1)), t.getScale()),
                n = new sf(this._bufParams);
            n.setWorkingPrecisionModel(t),
            n.setNoder(e),
            this._resultGeometry = n.buffer(this._argGeom, this._distance)
        },
        mf.prototype.bufferReducedPrecision = function() {
            var t = this;
            if (0 === arguments.length) {
                for (var e = mf.MAX_PRECISION_DIGITS; e >= 0; e--) {
                    try {
                        t.bufferReducedPrecision(e)
                    } catch (e) {
                        if (!(e instanceof Oc))
                            throw e;
                        t._saveException = e
                    }
                    if (null !== t._resultGeometry)
                        return null
                }
                throw this._saveException
            }
            if (1 === arguments.length) {
                var n = arguments[0],
                    r = mf.precisionScaleFactor(this._argGeom, this._distance, n),
                    i = new dc(r);
                this.bufferFixedPrecision(i)
            }
        },
        mf.prototype.computeGeometry = function() {
            if (this.bufferOriginalPrecision(), null !== this._resultGeometry)
                return null;
            var t = this._argGeom.getFactory().getPrecisionModel();
            t.getType() === dc.FIXED ? this.bufferFixedPrecision(t) : this.bufferReducedPrecision()
        },
        mf.prototype.setQuadrantSegments = function(t) {
            this._bufParams.setQuadrantSegments(t)
        },
        mf.prototype.bufferOriginalPrecision = function() {
            try {
                var t = new sf(this._bufParams);
                this._resultGeometry = t.buffer(this._argGeom, this._distance)
            } catch (t) {
                if (!(t instanceof kl))
                    throw t;
                this._saveException = t
            }
        },
        mf.prototype.getResultGeometry = function(t) {
            return this._distance = t, this.computeGeometry(), this._resultGeometry
        },
        mf.prototype.setEndCapStyle = function(t) {
            this._bufParams.setEndCapStyle(t)
        },
        mf.prototype.interfaces_ = function() {
            return []
        },
        mf.prototype.getClass = function() {
            return mf
        },
        mf.bufferOp = function() {
            if (2 === arguments.length) {
                var t = arguments[1];
                return new mf(arguments[0]).getResultGeometry(t)
            }
            if (3 === arguments.length) {
                if (Number.isInteger(arguments[2]) && arguments[0] instanceof Wl && "number" == typeof arguments[1]) {
                    var e = arguments[1],
                        n = arguments[2],
                        r = new mf(arguments[0]);
                    return r.setQuadrantSegments(n), r.getResultGeometry(e)
                }
                if (arguments[2] instanceof Sp && arguments[0] instanceof Wl && "number" == typeof arguments[1]) {
                    var i = arguments[1];
                    return new mf(arguments[0], arguments[2]).getResultGeometry(i)
                }
            } else if (4 === arguments.length) {
                var o = arguments[1],
                    s = arguments[2],
                    a = arguments[3],
                    u = new mf(arguments[0]);
                return u.setQuadrantSegments(s), u.setEndCapStyle(a), u.getResultGeometry(o)
            }
        },
        mf.precisionScaleFactor = function(t, e, n) {
            var r = t.getEnvelopeInternal(),
                i = gl.max(Math.abs(r.getMaxX()), Math.abs(r.getMaxY()), Math.abs(r.getMinX()), Math.abs(r.getMinY())) + 2 * (e > 0 ? e : 0),
                o = n - Math.trunc(Math.log(i) / Math.log(10) + 1);
            return Math.pow(10, o)
        },
        _f.CAP_ROUND.get = function() {
            return Sp.CAP_ROUND
        },
        _f.CAP_BUTT.get = function() {
            return Sp.CAP_FLAT
        },
        _f.CAP_FLAT.get = function() {
            return Sp.CAP_FLAT
        },
        _f.CAP_SQUARE.get = function() {
            return Sp.CAP_SQUARE
        },
        _f.MAX_PRECISION_DIGITS.get = function() {
            return 12
        },
        Object.defineProperties(mf, _f);
        var xf = function() {
            this._pt = [new ul, new ul],
            this._distance = nl.NaN,
            this._isNull = !0
        };
        xf.prototype.getCoordinates = function() {
            return this._pt
        },
        xf.prototype.getCoordinate = function(t) {
            return this._pt[t]
        },
        xf.prototype.setMinimum = function() {
            if (1 === arguments.length) {
                var t = arguments[0];
                this.setMinimum(t._pt[0], t._pt[1])
            } else if (2 === arguments.length) {
                var e = arguments[0],
                    n = arguments[1];
                if (this._isNull)
                    return this.initialize(e, n), null;
                var r = e.distance(n);
                r < this._distance && this.initialize(e, n, r)
            }
        },
        xf.prototype.initialize = function() {
            if (0 === arguments.length)
                this._isNull = !0;
            else if (2 === arguments.length) {
                var t = arguments[0],
                    e = arguments[1];
                this._pt[0].setCoordinate(t),
                this._pt[1].setCoordinate(e),
                this._distance = t.distance(e),
                this._isNull = !1
            } else if (3 === arguments.length) {
                var n = arguments[0],
                    r = arguments[1],
                    i = arguments[2];
                this._pt[0].setCoordinate(n),
                this._pt[1].setCoordinate(r),
                this._distance = i,
                this._isNull = !1
            }
        },
        xf.prototype.getDistance = function() {
            return this._distance
        },
        xf.prototype.setMaximum = function() {
            if (1 === arguments.length) {
                var t = arguments[0];
                this.setMaximum(t._pt[0], t._pt[1])
            } else if (2 === arguments.length) {
                var e = arguments[0],
                    n = arguments[1];
                if (this._isNull)
                    return this.initialize(e, n), null;
                var r = e.distance(n);
                r > this._distance && this.initialize(e, n, r)
            }
        },
        xf.prototype.interfaces_ = function() {
            return []
        },
        xf.prototype.getClass = function() {
            return xf
        };
        var Ef = function() {};
        Ef.prototype.interfaces_ = function() {
            return []
        },
        Ef.prototype.getClass = function() {
            return Ef
        },
        Ef.computeDistance = function() {
            if (arguments[2] instanceof xf && arguments[0] instanceof Kh && arguments[1] instanceof ul)
                for (var t = arguments[1], e = arguments[2], n = arguments[0].getCoordinates(), r = new vp, i = 0; i < n.length - 1; i++) {
                    r.setCoordinates(n[i], n[i + 1]);
                    var o = r.closestPoint(t);
                    e.setMinimum(o, t)
                }
            else if (arguments[2] instanceof xf && arguments[0] instanceof tc && arguments[1] instanceof ul) {
                var s = arguments[0],
                    a = arguments[1],
                    u = arguments[2];
                Ef.computeDistance(s.getExteriorRing(), a, u);
                for (var l = 0; l < s.getNumInteriorRing(); l++)
                    Ef.computeDistance(s.getInteriorRingN(l), a, u)
            } else if (arguments[2] instanceof xf && arguments[0] instanceof Wl && arguments[1] instanceof ul) {
                var h = arguments[0],
                    c = arguments[1],
                    p = arguments[2];
                if (h instanceof Kh)
                    Ef.computeDistance(h, c, p);
                else if (h instanceof tc)
                    Ef.computeDistance(h, c, p);
                else if (h instanceof kh)
                    for (var f = h, d = 0; d < f.getNumGeometries(); d++) {
                        var g = f.getGeometryN(d);
                        Ef.computeDistance(g, c, p)
                    }
                else
                    p.setMinimum(h.getCoordinate(), c)
            } else if (arguments[2] instanceof xf && arguments[0] instanceof vp && arguments[1] instanceof ul) {
                var y = arguments[1],
                    v = arguments[2],
                    m = arguments[0].closestPoint(y);
                v.setMinimum(m, y)
            }
        };
        var wf = function(t) {
                this._maxPtDist = new xf,
                this._inputGeom = t || null
            },
            bf = {
                MaxPointDistanceFilter: {
                    configurable: !0
                },
                MaxMidpointDistanceFilter: {
                    configurable: !0
                }
            };
        wf.prototype.computeMaxMidpointDistance = function(t) {
            var e = new Mf(this._inputGeom);
            t.apply(e),
            this._maxPtDist.setMaximum(e.getMaxPointDistance())
        },
        wf.prototype.computeMaxVertexDistance = function(t) {
            var e = new Cf(this._inputGeom);
            t.apply(e),
            this._maxPtDist.setMaximum(e.getMaxPointDistance())
        },
        wf.prototype.findDistance = function(t) {
            return this.computeMaxVertexDistance(t), this.computeMaxMidpointDistance(t), this._maxPtDist.getDistance()
        },
        wf.prototype.getDistancePoints = function() {
            return this._maxPtDist
        },
        wf.prototype.interfaces_ = function() {
            return []
        },
        wf.prototype.getClass = function() {
            return wf
        },
        bf.MaxPointDistanceFilter.get = function() {
            return Cf
        },
        bf.MaxMidpointDistanceFilter.get = function() {
            return Mf
        },
        Object.defineProperties(wf, bf);
        var Cf = function(t) {
            this._maxPtDist = new xf,
            this._minPtDist = new xf,
            this._geom = t || null
        };
        Cf.prototype.filter = function(t) {
            this._minPtDist.initialize(),
            Ef.computeDistance(this._geom, t, this._minPtDist),
            this._maxPtDist.setMaximum(this._minPtDist)
        },
        Cf.prototype.getMaxPointDistance = function() {
            return this._maxPtDist
        },
        Cf.prototype.interfaces_ = function() {
            return [Zl]
        },
        Cf.prototype.getClass = function() {
            return Cf
        };
        var Mf = function(t) {
            this._maxPtDist = new xf,
            this._minPtDist = new xf,
            this._geom = t || null
        };
        Mf.prototype.filter = function(t, e) {
            if (0 === e)
                return null;
            var n = t.getCoordinate(e - 1),
                r = t.getCoordinate(e),
                i = new ul((n.x + r.x) / 2, (n.y + r.y) / 2);
            this._minPtDist.initialize(),
            Ef.computeDistance(this._geom, i, this._minPtDist),
            this._maxPtDist.setMaximum(this._minPtDist)
        },
        Mf.prototype.isDone = function() {
            return !1
        },
        Mf.prototype.isGeometryChanged = function() {
            return !1
        },
        Mf.prototype.getMaxPointDistance = function() {
            return this._maxPtDist
        },
        Mf.prototype.interfaces_ = function() {
            return [Fh]
        },
        Mf.prototype.getClass = function() {
            return Mf
        };
        var Sf = function(t) {
            this._comps = t || null
        };
        Sf.prototype.filter = function(t) {
            t instanceof tc && this._comps.add(t)
        },
        Sf.prototype.interfaces_ = function() {
            return [Dh]
        },
        Sf.prototype.getClass = function() {
            return Sf
        },
        Sf.getPolygons = function() {
            if (1 === arguments.length) {
                var t = arguments[0];
                return Sf.getPolygons(t, new lh)
            }
            if (2 === arguments.length) {
                var e = arguments[0],
                    n = arguments[1];
                return e instanceof tc ? n.add(e) : e instanceof kh && e.apply(new Sf(n)), n
            }
        };
        var If = function() {
            if (this._lines = null, this._isForcedToLineString = !1, 1 === arguments.length) {
                var t = arguments[0];
                this._lines = t
            } else if (2 === arguments.length) {
                var e = arguments[0],
                    n = arguments[1];
                this._lines = e,
                this._isForcedToLineString = n
            }
        };
        If.prototype.filter = function(t) {
            if (this._isForcedToLineString && t instanceof nc) {
                var e = t.getFactory().createLineString(t.getCoordinateSequence());
                return this._lines.add(e), null
            }
            t instanceof Kh && this._lines.add(t)
        },
        If.prototype.setForceToLineString = function(t) {
            this._isForcedToLineString = t
        },
        If.prototype.interfaces_ = function() {
            return [Yl]
        },
        If.prototype.getClass = function() {
            return If
        },
        If.getGeometry = function() {
            if (1 === arguments.length) {
                var t = arguments[0];
                return t.getFactory().buildGeometry(If.getLines(t))
            }
            if (2 === arguments.length) {
                var e = arguments[0],
                    n = arguments[1];
                return e.getFactory().buildGeometry(If.getLines(e, n))
            }
        },
        If.getLines = function() {
            if (1 === arguments.length) {
                var t = arguments[0];
                return If.getLines(t, !1)
            }
            if (2 === arguments.length) {
                if (dl(arguments[0], ih) && dl(arguments[1], ih)) {
                    for (var e = arguments[1], n = arguments[0].iterator(); n.hasNext();) {
                        var r = n.next();
                        If.getLines(r, e)
                    }
                    return e
                }
                if (arguments[0] instanceof Wl && "boolean" == typeof arguments[1]) {
                    var i = arguments[0],
                        o = arguments[1],
                        s = new lh;
                    return i.apply(new If(s, o)), s
                }
                if (arguments[0] instanceof Wl && dl(arguments[1], ih)) {
                    var a = arguments[0],
                        u = arguments[1];
                    return a instanceof Kh ? u.add(a) : a.apply(new If(u)), u
                }
            } else if (3 === arguments.length) {
                if ("boolean" == typeof arguments[2] && dl(arguments[0], ih) && dl(arguments[1], ih)) {
                    for (var l = arguments[1], h = arguments[2], c = arguments[0].iterator(); c.hasNext();) {
                        var p = c.next();
                        If.getLines(p, l, h)
                    }
                    return l
                }
                if ("boolean" == typeof arguments[2] && arguments[0] instanceof Wl && dl(arguments[1], ih)) {
                    var f = arguments[1],
                        d = arguments[2];
                    return arguments[0].apply(new If(f, d)), f
                }
            }
        };
        var Tf = function() {
            if (this._boundaryRule = Jl.OGC_SFS_BOUNDARY_RULE, this._isIn = null, this._numBoundaries = null, 0 === arguments.length)
                ;
            else if (1 === arguments.length) {
                var t = arguments[0];
                if (null === t)
                    throw new el("Rule must be non-null");
                this._boundaryRule = t
            }
        };
        Tf.prototype.locateInternal = function() {
            var t = this;
            if (arguments[0] instanceof ul && arguments[1] instanceof tc) {
                var e = arguments[0],
                    n = arguments[1];
                if (n.isEmpty())
                    return pl.EXTERIOR;
                var r = n.getExteriorRing(),
                    i = this.locateInPolygonRing(e, r);
                if (i === pl.EXTERIOR)
                    return pl.EXTERIOR;
                if (i === pl.BOUNDARY)
                    return pl.BOUNDARY;
                for (var o = 0; o < n.getNumInteriorRing(); o++) {
                    var s = n.getInteriorRingN(o),
                        a = t.locateInPolygonRing(e, s);
                    if (a === pl.INTERIOR)
                        return pl.EXTERIOR;
                    if (a === pl.BOUNDARY)
                        return pl.BOUNDARY
                }
                return pl.INTERIOR
            }
            if (arguments[0] instanceof ul && arguments[1] instanceof Kh) {
                var u = arguments[0],
                    l = arguments[1];
                if (!l.getEnvelopeInternal().intersects(u))
                    return pl.EXTERIOR;
                var h = l.getCoordinates();
                return l.isClosed() || !u.equals(h[0]) && !u.equals(h[h.length - 1]) ? Xl.isOnLine(u, h) ? pl.INTERIOR : pl.EXTERIOR : pl.BOUNDARY
            }
            if (arguments[0] instanceof ul && arguments[1] instanceof Jh) {
                var c = arguments[0];
                return arguments[1].getCoordinate().equals2D(c) ? pl.INTERIOR : pl.EXTERIOR
            }
        },
        Tf.prototype.locateInPolygonRing = function(t, e) {
            return e.getEnvelopeInternal().intersects(t) ? Xl.locatePointInRing(t, e.getCoordinates()) : pl.EXTERIOR
        },
        Tf.prototype.intersects = function(t, e) {
            return this.locate(t, e) !== pl.EXTERIOR
        },
        Tf.prototype.updateLocationInfo = function(t) {
            t === pl.INTERIOR && (this._isIn = !0),
            t === pl.BOUNDARY && this._numBoundaries++
        },
        Tf.prototype.computeLocation = function(t, e) {
            var n = this;
            if (e instanceof Jh && this.updateLocationInfo(this.locateInternal(t, e)), e instanceof Kh)
                this.updateLocationInfo(this.locateInternal(t, e));
            else if (e instanceof tc)
                this.updateLocationInfo(this.locateInternal(t, e));
            else if (e instanceof jh)
                for (var r = e, i = 0; i < r.getNumGeometries(); i++) {
                    var o = r.getGeometryN(i);
                    n.updateLocationInfo(n.locateInternal(t, o))
                }
            else if (e instanceof rc)
                for (var s = e, a = 0; a < s.getNumGeometries(); a++) {
                    var u = s.getGeometryN(a);
                    n.updateLocationInfo(n.locateInternal(t, u))
                }
            else if (e instanceof kh)
                for (var l = new Up(e); l.hasNext();) {
                    var h = l.next();
                    h !== e && n.computeLocation(t, h)
                }
        },
        Tf.prototype.locate = function(t, e) {
            return e.isEmpty() ? pl.EXTERIOR : e instanceof Kh || e instanceof tc ? this.locateInternal(t, e) : (this._isIn = !1, this._numBoundaries = 0, this.computeLocation(t, e), this._boundaryRule.isInBoundary(this._numBoundaries) ? pl.BOUNDARY : this._numBoundaries > 0 || this._isIn ? pl.INTERIOR : pl.EXTERIOR)
        },
        Tf.prototype.interfaces_ = function() {
            return []
        },
        Tf.prototype.getClass = function() {
            return Tf
        };
        var Pf = function t() {
                if (this._component = null, this._segIndex = null, this._pt = null, 2 === arguments.length)
                    t.call(this, arguments[0], t.INSIDE_AREA, arguments[1]);
                else if (3 === arguments.length) {
                    var e = arguments[0],
                        n = arguments[1],
                        r = arguments[2];
                    this._component = e,
                    this._segIndex = n,
                    this._pt = r
                }
            },
            Lf = {
                INSIDE_AREA: {
                    configurable: !0
                }
            };
        Pf.prototype.isInsideArea = function() {
            return this._segIndex === Pf.INSIDE_AREA
        },
        Pf.prototype.getCoordinate = function() {
            return this._pt
        },
        Pf.prototype.getGeometryComponent = function() {
            return this._component
        },
        Pf.prototype.getSegmentIndex = function() {
            return this._segIndex
        },
        Pf.prototype.interfaces_ = function() {
            return []
        },
        Pf.prototype.getClass = function() {
            return Pf
        },
        Lf.INSIDE_AREA.get = function() {
            return -1
        },
        Object.defineProperties(Pf, Lf);
        var Of = function(t) {
            this._pts = t || null
        };
        Of.prototype.filter = function(t) {
            t instanceof Jh && this._pts.add(t)
        },
        Of.prototype.interfaces_ = function() {
            return [Dh]
        },
        Of.prototype.getClass = function() {
            return Of
        },
        Of.getPoints = function() {
            if (1 === arguments.length) {
                var t = arguments[0];
                return t instanceof Jh ? np.singletonList(t) : Of.getPoints(t, new lh)
            }
            if (2 === arguments.length) {
                var e = arguments[0],
                    n = arguments[1];
                return e instanceof Jh ? n.add(e) : e instanceof kh && e.apply(new Of(n)), n
            }
        };
        var Nf = function() {
            this._locations = null;
            var t = arguments[0];
            this._locations = t
        };
        Nf.prototype.filter = function(t) {
            (t instanceof Jh || t instanceof Kh || t instanceof tc) && this._locations.add(new Pf(t, 0, t.getCoordinate()))
        },
        Nf.prototype.interfaces_ = function() {
            return [Dh]
        },
        Nf.prototype.getClass = function() {
            return Nf
        },
        Nf.getLocations = function(t) {
            var e = new lh;
            return t.apply(new Nf(e)), e
        };
        var Rf = function() {
            if (this._geom = null, this._terminateDistance = 0, this._ptLocator = new Tf, this._minDistanceLocation = null, this._minDistance = nl.MAX_VALUE, 2 === arguments.length) {
                var t = arguments[0],
                    e = arguments[1];
                this._geom = [t, e],
                this._terminateDistance = 0
            } else if (3 === arguments.length) {
                var n = arguments[0],
                    r = arguments[1],
                    i = arguments[2];
                this._geom = new Array(2).fill(null),
                this._geom[0] = n,
                this._geom[1] = r,
                this._terminateDistance = i
            }
        };
        Rf.prototype.computeContainmentDistance = function() {
            var t = this;
            if (0 === arguments.length) {
                var e = new Array(2).fill(null);
                if (this.computeContainmentDistance(0, e), this._minDistance <= this._terminateDistance)
                    return null;
                this.computeContainmentDistance(1, e)
            } else if (2 === arguments.length) {
                var n = arguments[0],
                    r = arguments[1],
                    i = 1 - n,
                    o = Sf.getPolygons(this._geom[n]);
                if (o.size() > 0) {
                    var s = Nf.getLocations(this._geom[i]);
                    if (this.computeContainmentDistance(s, o, r), this._minDistance <= this._terminateDistance)
                        return this._minDistanceLocation[i] = r[0], this._minDistanceLocation[n] = r[1], null
                }
            } else if (3 === arguments.length)
                if (arguments[2] instanceof Array && dl(arguments[0], ah) && dl(arguments[1], ah)) {
                    for (var a = arguments[0], u = arguments[1], l = arguments[2], h = 0; h < a.size(); h++)
                        for (var c = a.get(h), p = 0; p < u.size(); p++)
                            if (t.computeContainmentDistance(c, u.get(p), l), t._minDistance <= t._terminateDistance)
                                return null
                } else if (arguments[2] instanceof Array && arguments[0] instanceof Pf && arguments[1] instanceof tc) {
                    var f = arguments[0],
                        d = arguments[1],
                        g = arguments[2],
                        y = f.getCoordinate();
                    if (pl.EXTERIOR !== this._ptLocator.locate(y, d))
                        return this._minDistance = 0, g[0] = f, g[1] = new Pf(d, y), null
                }
        },
        Rf.prototype.computeMinDistanceLinesPoints = function(t, e, n) {
            for (var r = this, i = 0; i < t.size(); i++)
                for (var o = t.get(i), s = 0; s < e.size(); s++) {
                    var a = e.get(s);
                    if (r.computeMinDistance(o, a, n), r._minDistance <= r._terminateDistance)
                        return null
                }
        },
        Rf.prototype.computeFacetDistance = function() {
            var t = new Array(2).fill(null),
                e = If.getLines(this._geom[0]),
                n = If.getLines(this._geom[1]),
                r = Of.getPoints(this._geom[0]),
                i = Of.getPoints(this._geom[1]);
            return this.computeMinDistanceLines(e, n, t), this.updateMinDistance(t, !1), this._minDistance <= this._terminateDistance ? null : (t[0] = null, t[1] = null, this.computeMinDistanceLinesPoints(e, i, t), this.updateMinDistance(t, !1), this._minDistance <= this._terminateDistance ? null : (t[0] = null, t[1] = null, this.computeMinDistanceLinesPoints(n, r, t), this.updateMinDistance(t, !0), this._minDistance <= this._terminateDistance ? null : (t[0] = null, t[1] = null, this.computeMinDistancePoints(r, i, t), void this.updateMinDistance(t, !1))))
        },
        Rf.prototype.nearestLocations = function() {
            return this.computeMinDistance(), this._minDistanceLocation
        },
        Rf.prototype.updateMinDistance = function(t, e) {
            if (null === t[0])
                return null;
            e ? (this._minDistanceLocation[0] = t[1], this._minDistanceLocation[1] = t[0]) : (this._minDistanceLocation[0] = t[0], this._minDistanceLocation[1] = t[1])
        },
        Rf.prototype.nearestPoints = function() {
            return this.computeMinDistance(), [this._minDistanceLocation[0].getCoordinate(), this._minDistanceLocation[1].getCoordinate()]
        },
        Rf.prototype.computeMinDistance = function() {
            var t = this;
            if (0 === arguments.length) {
                if (null !== this._minDistanceLocation)
                    return null;
                if (this._minDistanceLocation = new Array(2).fill(null), this.computeContainmentDistance(), this._minDistance <= this._terminateDistance)
                    return null;
                this.computeFacetDistance()
            } else if (3 === arguments.length)
                if (arguments[2] instanceof Array && arguments[0] instanceof Kh && arguments[1] instanceof Jh) {
                    var e = arguments[0],
                        n = arguments[1],
                        r = arguments[2];
                    if (e.getEnvelopeInternal().distance(n.getEnvelopeInternal()) > this._minDistance)
                        return null;
                    for (var i = e.getCoordinates(), o = n.getCoordinate(), s = 0; s < i.length - 1; s++) {
                        var a = Xl.distancePointLine(o, i[s], i[s + 1]);
                        if (a < t._minDistance) {
                            t._minDistance = a;
                            var u = new vp(i[s], i[s + 1]).closestPoint(o);
                            r[0] = new Pf(e, s, u),
                            r[1] = new Pf(n, 0, o)
                        }
                        if (t._minDistance <= t._terminateDistance)
                            return null
                    }
                } else if (arguments[2] instanceof Array && arguments[0] instanceof Kh && arguments[1] instanceof Kh) {
                    var l = arguments[0],
                        h = arguments[1],
                        c = arguments[2];
                    if (l.getEnvelopeInternal().distance(h.getEnvelopeInternal()) > this._minDistance)
                        return null;
                    for (var p = l.getCoordinates(), f = h.getCoordinates(), d = 0; d < p.length - 1; d++)
                        for (var g = 0; g < f.length - 1; g++) {
                            var y = Xl.distanceLineLine(p[d], p[d + 1], f[g], f[g + 1]);
                            if (y < t._minDistance) {
                                t._minDistance = y;
                                var v = new vp(p[d], p[d + 1]),
                                    m = new vp(f[g], f[g + 1]),
                                    _ = v.closestPoints(m);
                                c[0] = new Pf(l, d, _[0]),
                                c[1] = new Pf(h, g, _[1])
                            }
                            if (t._minDistance <= t._terminateDistance)
                                return null
                        }
                }
        },
        Rf.prototype.computeMinDistancePoints = function(t, e, n) {
            for (var r = this, i = 0; i < t.size(); i++)
                for (var o = t.get(i), s = 0; s < e.size(); s++) {
                    var a = e.get(s),
                        u = o.getCoordinate().distance(a.getCoordinate());
                    if (u < r._minDistance && (r._minDistance = u, n[0] = new Pf(o, 0, o.getCoordinate()), n[1] = new Pf(a, 0, a.getCoordinate())), r._minDistance <= r._terminateDistance)
                        return null
                }
        },
        Rf.prototype.distance = function() {
            if (null === this._geom[0] || null === this._geom[1])
                throw new el("null geometries are not supported");
            return this._geom[0].isEmpty() || this._geom[1].isEmpty() ? 0 : (this.computeMinDistance(), this._minDistance)
        },
        Rf.prototype.computeMinDistanceLines = function(t, e, n) {
            for (var r = this, i = 0; i < t.size(); i++)
                for (var o = t.get(i), s = 0; s < e.size(); s++) {
                    var a = e.get(s);
                    if (r.computeMinDistance(o, a, n), r._minDistance <= r._terminateDistance)
                        return null
                }
        },
        Rf.prototype.interfaces_ = function() {
            return []
        },
        Rf.prototype.getClass = function() {
            return Rf
        },
        Rf.distance = function(t, e) {
            return new Rf(t, e).distance()
        },
        Rf.isWithinDistance = function(t, e, n) {
            return new Rf(t, e, n).distance() <= n
        },
        Rf.nearestPoints = function(t, e) {
            return new Rf(t, e).nearestPoints()
        };
        var Af = function() {
            this._pt = [new ul, new ul],
            this._distance = nl.NaN,
            this._isNull = !0
        };
        Af.prototype.getCoordinates = function() {
            return this._pt
        },
        Af.prototype.getCoordinate = function(t) {
            return this._pt[t]
        },
        Af.prototype.setMinimum = function() {
            if (1 === arguments.length) {
                var t = arguments[0];
                this.setMinimum(t._pt[0], t._pt[1])
            } else if (2 === arguments.length) {
                var e = arguments[0],
                    n = arguments[1];
                if (this._isNull)
                    return this.initialize(e, n), null;
                var r = e.distance(n);
                r < this._distance && this.initialize(e, n, r)
            }
        },
        Af.prototype.initialize = function() {
            if (0 === arguments.length)
                this._isNull = !0;
            else if (2 === arguments.length) {
                var t = arguments[0],
                    e = arguments[1];
                this._pt[0].setCoordinate(t),
                this._pt[1].setCoordinate(e),
                this._distance = t.distance(e),
                this._isNull = !1
            } else if (3 === arguments.length) {
                var n = arguments[0],
                    r = arguments[1],
                    i = arguments[2];
                this._pt[0].setCoordinate(n),
                this._pt[1].setCoordinate(r),
                this._distance = i,
                this._isNull = !1
            }
        },
        Af.prototype.toString = function() {
            return Fl.toLineString(this._pt[0], this._pt[1])
        },
        Af.prototype.getDistance = function() {
            return this._distance
        },
        Af.prototype.setMaximum = function() {
            if (1 === arguments.length) {
                var t = arguments[0];
                this.setMaximum(t._pt[0], t._pt[1])
            } else if (2 === arguments.length) {
                var e = arguments[0],
                    n = arguments[1];
                if (this._isNull)
                    return this.initialize(e, n), null;
                var r = e.distance(n);
                r > this._distance && this.initialize(e, n, r)
            }
        },
        Af.prototype.interfaces_ = function() {
            return []
        },
        Af.prototype.getClass = function() {
            return Af
        };
        var Df = function() {};
        Df.prototype.interfaces_ = function() {
            return []
        },
        Df.prototype.getClass = function() {
            return Df
        },
        Df.computeDistance = function() {
            if (arguments[2] instanceof Af && arguments[0] instanceof Kh && arguments[1] instanceof ul)
                for (var t = arguments[0], e = arguments[1], n = arguments[2], r = new vp, i = t.getCoordinates(), o = 0; o < i.length - 1; o++) {
                    r.setCoordinates(i[o], i[o + 1]);
                    var s = r.closestPoint(e);
                    n.setMinimum(s, e)
                }
            else if (arguments[2] instanceof Af && arguments[0] instanceof tc && arguments[1] instanceof ul) {
                var a = arguments[0],
                    u = arguments[1],
                    l = arguments[2];
                Df.computeDistance(a.getExteriorRing(), u, l);
                for (var h = 0; h < a.getNumInteriorRing(); h++)
                    Df.computeDistance(a.getInteriorRingN(h), u, l)
            } else if (arguments[2] instanceof Af && arguments[0] instanceof Wl && arguments[1] instanceof ul) {
                var c = arguments[0],
                    p = arguments[1],
                    f = arguments[2];
                if (c instanceof Kh)
                    Df.computeDistance(c, p, f);
                else if (c instanceof tc)
                    Df.computeDistance(c, p, f);
                else if (c instanceof kh)
                    for (var d = c, g = 0; g < d.getNumGeometries(); g++) {
                        var y = d.getGeometryN(g);
                        Df.computeDistance(y, p, f)
                    }
                else
                    f.setMinimum(c.getCoordinate(), p)
            } else if (arguments[2] instanceof Af && arguments[0] instanceof vp && arguments[1] instanceof ul) {
                var v = arguments[1],
                    m = arguments[2],
                    _ = arguments[0].closestPoint(v);
                m.setMinimum(_, v)
            }
        };
        var Ff = function() {
                this._g0 = null,
                this._g1 = null,
                this._ptDist = new Af,
                this._densifyFrac = 0;
                var t = arguments[0],
                    e = arguments[1];
                this._g0 = t,
                this._g1 = e
            },
            kf = {
                MaxPointDistanceFilter: {
                    configurable: !0
                },
                MaxDensifiedByFractionDistanceFilter: {
                    configurable: !0
                }
            };
        Ff.prototype.getCoordinates = function() {
            return this._ptDist.getCoordinates()
        },
        Ff.prototype.setDensifyFraction = function(t) {
            if (t > 1 || t <= 0)
                throw new el("Fraction is not in range (0.0 - 1.0]");
            this._densifyFrac = t
        },
        Ff.prototype.compute = function(t, e) {
            this.computeOrientedDistance(t, e, this._ptDist),
            this.computeOrientedDistance(e, t, this._ptDist)
        },
        Ff.prototype.distance = function() {
            return this.compute(this._g0, this._g1), this._ptDist.getDistance()
        },
        Ff.prototype.computeOrientedDistance = function(t, e, n) {
            var r = new jf(e);
            if (t.apply(r), n.setMaximum(r.getMaxPointDistance()), this._densifyFrac > 0) {
                var i = new Gf(e, this._densifyFrac);
                t.apply(i),
                n.setMaximum(i.getMaxPointDistance())
            }
        },
        Ff.prototype.orientedDistance = function() {
            return this.computeOrientedDistance(this._g0, this._g1, this._ptDist), this._ptDist.getDistance()
        },
        Ff.prototype.interfaces_ = function() {
            return []
        },
        Ff.prototype.getClass = function() {
            return Ff
        },
        Ff.distance = function() {
            if (2 === arguments.length)
                return new Ff(arguments[0], arguments[1]).distance();
            if (3 === arguments.length) {
                var t = arguments[2],
                    e = new Ff(arguments[0], arguments[1]);
                return e.setDensifyFraction(t), e.distance()
            }
        },
        kf.MaxPointDistanceFilter.get = function() {
            return jf
        },
        kf.MaxDensifiedByFractionDistanceFilter.get = function() {
            return Gf
        },
        Object.defineProperties(Ff, kf);
        var jf = function() {
            this._maxPtDist = new Af,
            this._minPtDist = new Af,
            this._euclideanDist = new Df,
            this._geom = null;
            var t = arguments[0];
            this._geom = t
        };
        jf.prototype.filter = function(t) {
            this._minPtDist.initialize(),
            Df.computeDistance(this._geom, t, this._minPtDist),
            this._maxPtDist.setMaximum(this._minPtDist)
        },
        jf.prototype.getMaxPointDistance = function() {
            return this._maxPtDist
        },
        jf.prototype.interfaces_ = function() {
            return [Zl]
        },
        jf.prototype.getClass = function() {
            return jf
        };
        var Gf = function() {
            this._maxPtDist = new Af,
            this._minPtDist = new Af,
            this._geom = null,
            this._numSubSegs = 0;
            var t = arguments[0],
                e = arguments[1];
            this._geom = t,
            this._numSubSegs = Math.trunc(Math.round(1 / e))
        };
        Gf.prototype.filter = function(t, e) {
            var n = this;
            if (0 === e)
                return null;
            for (var r = t.getCoordinate(e - 1), i = t.getCoordinate(e), o = (i.x - r.x) / this._numSubSegs, s = (i.y - r.y) / this._numSubSegs, a = 0; a < this._numSubSegs; a++) {
                var u = r.x + a * o,
                    l = r.y + a * s,
                    h = new ul(u, l);
                n._minPtDist.initialize(),
                Df.computeDistance(n._geom, h, n._minPtDist),
                n._maxPtDist.setMaximum(n._minPtDist)
            }
        },
        Gf.prototype.isDone = function() {
            return !1
        },
        Gf.prototype.isGeometryChanged = function() {
            return !1
        },
        Gf.prototype.getMaxPointDistance = function() {
            return this._maxPtDist
        },
        Gf.prototype.interfaces_ = function() {
            return [Fh]
        },
        Gf.prototype.getClass = function() {
            return Gf
        };
        var Bf = function(t, e, n) {
                this._minValidDistance = null,
                this._maxValidDistance = null,
                this._minDistanceFound = null,
                this._maxDistanceFound = null,
                this._isValid = !0,
                this._errMsg = null,
                this._errorLocation = null,
                this._errorIndicator = null,
                this._input = t || null,
                this._bufDistance = e || null,
                this._result = n || null
            },
            qf = {
                VERBOSE: {
                    configurable: !0
                },
                MAX_DISTANCE_DIFF_FRAC: {
                    configurable: !0
                }
            };
        Bf.prototype.checkMaximumDistance = function(t, e, n) {
            var r = new Ff(e, t);
            if (r.setDensifyFraction(.25), this._maxDistanceFound = r.orientedDistance(), this._maxDistanceFound > n) {
                this._isValid = !1;
                var i = r.getCoordinates();
                this._errorLocation = i[1],
                this._errorIndicator = t.getFactory().createLineString(i),
                this._errMsg = "Distance between buffer curve and input is too large (" + this._maxDistanceFound + " at " + Fl.toLineString(i[0], i[1]) + ")"
            }
        },
        Bf.prototype.isValid = function() {
            var t = Math.abs(this._bufDistance),
                e = Bf.MAX_DISTANCE_DIFF_FRAC * t;
            return this._minValidDistance = t - e, this._maxValidDistance = t + e, !(!this._input.isEmpty() && !this._result.isEmpty()) || (this._bufDistance > 0 ? this.checkPositiveValid() : this.checkNegativeValid(), Bf.VERBOSE && Tl.out.println("Min Dist= " + this._minDistanceFound + "  err= " + (1 - this._minDistanceFound / this._bufDistance) + "  Max Dist= " + this._maxDistanceFound + "  err= " + (this._maxDistanceFound / this._bufDistance - 1)), this._isValid)
        },
        Bf.prototype.checkNegativeValid = function() {
            if (!(this._input instanceof tc || this._input instanceof rc || this._input instanceof kh))
                return null;
            var t = this.getPolygonLines(this._input);
            if (this.checkMinimumDistance(t, this._result, this._minValidDistance), !this._isValid)
                return null;
            this.checkMaximumDistance(t, this._result, this._maxValidDistance)
        },
        Bf.prototype.getErrorIndicator = function() {
            return this._errorIndicator
        },
        Bf.prototype.checkMinimumDistance = function(t, e, n) {
            var r = new Rf(t, e, n);
            if (this._minDistanceFound = r.distance(), this._minDistanceFound < n) {
                this._isValid = !1;
                var i = r.nearestPoints();
                this._errorLocation = r.nearestPoints()[1],
                this._errorIndicator = t.getFactory().createLineString(i),
                this._errMsg = "Distance between buffer curve and input is too small (" + this._minDistanceFound + " at " + Fl.toLineString(i[0], i[1]) + " )"
            }
        },
        Bf.prototype.checkPositiveValid = function() {
            var t = this._result.getBoundary();
            if (this.checkMinimumDistance(this._input, t, this._minValidDistance), !this._isValid)
                return null;
            this.checkMaximumDistance(this._input, t, this._maxValidDistance)
        },
        Bf.prototype.getErrorLocation = function() {
            return this._errorLocation
        },
        Bf.prototype.getPolygonLines = function(t) {
            for (var e = new lh, n = new If(e), r = Sf.getPolygons(t).iterator(); r.hasNext();)
                r.next().apply(n);
            return t.getFactory().buildGeometry(e)
        },
        Bf.prototype.getErrorMessage = function() {
            return this._errMsg
        },
        Bf.prototype.interfaces_ = function() {
            return []
        },
        Bf.prototype.getClass = function() {
            return Bf
        },
        qf.VERBOSE.get = function() {
            return !1
        },
        qf.MAX_DISTANCE_DIFF_FRAC.get = function() {
            return .012
        },
        Object.defineProperties(Bf, qf);
        var zf = function(t, e, n) {
                this._isValid = !0,
                this._errorMsg = null,
                this._errorLocation = null,
                this._errorIndicator = null,
                this._input = t || null,
                this._distance = e || null,
                this._result = n || null
            },
            Uf = {
                VERBOSE: {
                    configurable: !0
                },
                MAX_ENV_DIFF_FRAC: {
                    configurable: !0
                }
            };
        zf.prototype.isValid = function() {
            return this.checkPolygonal(), this._isValid ? (this.checkExpectedEmpty(), this._isValid ? (this.checkEnvelope(), this._isValid ? (this.checkArea(), this._isValid ? (this.checkDistance(), this._isValid) : this._isValid) : this._isValid) : this._isValid) : this._isValid
        },
        zf.prototype.checkEnvelope = function() {
            if (this._distance < 0)
                return null;
            var t = this._distance * zf.MAX_ENV_DIFF_FRAC;
            0 === t && (t = .001);
            var e = new Ll(this._input.getEnvelopeInternal());
            e.expandBy(this._distance);
            var n = new Ll(this._result.getEnvelopeInternal());
            n.expandBy(t),
            n.contains(e) || (this._isValid = !1, this._errorMsg = "Buffer envelope is incorrect", this._errorIndicator = this._input.getFactory().toGeometry(n)),
            this.report("Envelope")
        },
        zf.prototype.checkDistance = function() {
            var t = new Bf(this._input, this._distance, this._result);
            t.isValid() || (this._isValid = !1, this._errorMsg = t.getErrorMessage(), this._errorLocation = t.getErrorLocation(), this._errorIndicator = t.getErrorIndicator()),
            this.report("Distance")
        },
        zf.prototype.checkArea = function() {
            var t = this._input.getArea(),
                e = this._result.getArea();
            this._distance > 0 && t > e && (this._isValid = !1, this._errorMsg = "Area of positive buffer is smaller than input", this._errorIndicator = this._result),
            this._distance < 0 && t < e && (this._isValid = !1, this._errorMsg = "Area of negative buffer is larger than input", this._errorIndicator = this._result),
            this.report("Area")
        },
        zf.prototype.checkPolygonal = function() {
            this._result instanceof tc || this._result instanceof rc || (this._isValid = !1),
            this._errorMsg = "Result is not polygonal",
            this._errorIndicator = this._result,
            this.report("Polygonal")
        },
        zf.prototype.getErrorIndicator = function() {
            return this._errorIndicator
        },
        zf.prototype.getErrorLocation = function() {
            return this._errorLocation
        },
        zf.prototype.checkExpectedEmpty = function() {
            return this._input.getDimension() >= 2 || this._distance > 0 ? null : (this._result.isEmpty() || (this._isValid = !1, this._errorMsg = "Result is non-empty", this._errorIndicator = this._result), void this.report("ExpectedEmpty"))
        },
        zf.prototype.report = function(t) {
            if (!zf.VERBOSE)
                return null;
            Tl.out.println("Check " + t + ": " + (this._isValid ? "passed" : "FAILED"))
        },
        zf.prototype.getErrorMessage = function() {
            return this._errorMsg
        },
        zf.prototype.interfaces_ = function() {
            return []
        },
        zf.prototype.getClass = function() {
            return zf
        },
        zf.isValidMsg = function(t, e, n) {
            var r = new zf(t, e, n);
            return r.isValid() ? null : r.getErrorMessage()
        },
        zf.isValid = function(t, e, n) {
            return !!new zf(t, e, n).isValid()
        },
        Uf.VERBOSE.get = function() {
            return !1
        },
        Uf.MAX_ENV_DIFF_FRAC.get = function() {
            return .012
        },
        Object.defineProperties(zf, Uf);
        var Vf = function() {
            this._pts = null,
            this._data = null;
            var t = arguments[0],
                e = arguments[1];
            this._pts = t,
            this._data = e
        };
        Vf.prototype.getCoordinates = function() {
            return this._pts
        },
        Vf.prototype.size = function() {
            return this._pts.length
        },
        Vf.prototype.getCoordinate = function(t) {
            return this._pts[t]
        },
        Vf.prototype.isClosed = function() {
            return this._pts[0].equals(this._pts[this._pts.length - 1])
        },
        Vf.prototype.getSegmentOctant = function(t) {
            return t === this._pts.length - 1 ? -1 : fp.octant(this.getCoordinate(t), this.getCoordinate(t + 1))
        },
        Vf.prototype.setData = function(t) {
            this._data = t
        },
        Vf.prototype.getData = function() {
            return this._data
        },
        Vf.prototype.toString = function() {
            return Fl.toLineString(new lc(this._pts))
        },
        Vf.prototype.interfaces_ = function() {
            return [dp]
        },
        Vf.prototype.getClass = function() {
            return Vf
        };
        var Xf = function() {
            this._findAllIntersections = !1,
            this._isCheckEndSegmentsOnly = !1,
            this._li = null,
            this._interiorIntersection = null,
            this._intSegments = null,
            this._intersections = new lh,
            this._intersectionCount = 0,
            this._keepIntersections = !0;
            var t = arguments[0];
            this._li = t,
            this._interiorIntersection = null
        };
        Xf.prototype.getInteriorIntersection = function() {
            return this._interiorIntersection
        },
        Xf.prototype.setCheckEndSegmentsOnly = function(t) {
            this._isCheckEndSegmentsOnly = t
        },
        Xf.prototype.getIntersectionSegments = function() {
            return this._intSegments
        },
        Xf.prototype.count = function() {
            return this._intersectionCount
        },
        Xf.prototype.getIntersections = function() {
            return this._intersections
        },
        Xf.prototype.setFindAllIntersections = function(t) {
            this._findAllIntersections = t
        },
        Xf.prototype.setKeepIntersections = function(t) {
            this._keepIntersections = t
        },
        Xf.prototype.processIntersections = function(t, e, n, r) {
            if (!this._findAllIntersections && this.hasIntersection())
                return null;
            if (t === n && e === r)
                return null;
            if (this._isCheckEndSegmentsOnly && !this.isEndSegment(t, e) && !this.isEndSegment(n, r))
                return null;
            var i = t.getCoordinates()[e],
                o = t.getCoordinates()[e + 1],
                s = n.getCoordinates()[r],
                a = n.getCoordinates()[r + 1];
            this._li.computeIntersection(i, o, s, a),
            this._li.hasIntersection() && this._li.isInteriorIntersection() && (this._intSegments = new Array(4).fill(null), this._intSegments[0] = i, this._intSegments[1] = o, this._intSegments[2] = s, this._intSegments[3] = a, this._interiorIntersection = this._li.getIntersection(0), this._keepIntersections && this._intersections.add(this._interiorIntersection), this._intersectionCount++)
        },
        Xf.prototype.isEndSegment = function(t, e) {
            return 0 === e || e >= t.size() - 2
        },
        Xf.prototype.hasIntersection = function() {
            return null !== this._interiorIntersection
        },
        Xf.prototype.isDone = function() {
            return !this._findAllIntersections && null !== this._interiorIntersection
        },
        Xf.prototype.interfaces_ = function() {
            return [Kp]
        },
        Xf.prototype.getClass = function() {
            return Xf
        },
        Xf.createAllIntersectionsFinder = function(t) {
            var e = new Xf(t);
            return e.setFindAllIntersections(!0), e
        },
        Xf.createAnyIntersectionFinder = function(t) {
            return new Xf(t)
        },
        Xf.createIntersectionCounter = function(t) {
            var e = new Xf(t);
            return e.setFindAllIntersections(!0), e.setKeepIntersections(!1), e
        };
        var Hf = function() {
            this._li = new zl,
            this._segStrings = null,
            this._findAllIntersections = !1,
            this._segInt = null,
            this._isValid = !0;
            var t = arguments[0];
            this._segStrings = t
        };
        Hf.prototype.execute = function() {
            if (null !== this._segInt)
                return null;
            this.checkInteriorIntersections()
        },
        Hf.prototype.getIntersections = function() {
            return this._segInt.getIntersections()
        },
        Hf.prototype.isValid = function() {
            return this.execute(), this._isValid
        },
        Hf.prototype.setFindAllIntersections = function(t) {
            this._findAllIntersections = t
        },
        Hf.prototype.checkInteriorIntersections = function() {
            this._isValid = !0,
            this._segInt = new Xf(this._li),
            this._segInt.setFindAllIntersections(this._findAllIntersections);
            var t = new Cp;
            if (t.setSegmentIntersector(this._segInt), t.computeNodes(this._segStrings), this._segInt.hasIntersection())
                return this._isValid = !1, null
        },
        Hf.prototype.checkValid = function() {
            if (this.execute(), !this._isValid)
                throw new Oc(this.getErrorMessage(), this._segInt.getInteriorIntersection())
        },
        Hf.prototype.getErrorMessage = function() {
            if (this._isValid)
                return "no intersections found";
            var t = this._segInt.getIntersectionSegments();
            return "found non-noded intersection between " + Fl.toLineString(t[0], t[1]) + " and " + Fl.toLineString(t[2], t[3])
        },
        Hf.prototype.interfaces_ = function() {
            return []
        },
        Hf.prototype.getClass = function() {
            return Hf
        },
        Hf.computeIntersections = function(t) {
            var e = new Hf(t);
            return e.setFindAllIntersections(!0), e.isValid(), e.getIntersections()
        };
        var Yf = function t() {
            this._nv = null;
            var e = arguments[0];
            this._nv = new Hf(t.toSegmentStrings(e))
        };
        Yf.prototype.checkValid = function() {
            this._nv.checkValid()
        },
        Yf.prototype.interfaces_ = function() {
            return []
        },
        Yf.prototype.getClass = function() {
            return Yf
        },
        Yf.toSegmentStrings = function(t) {
            for (var e = new lh, n = t.iterator(); n.hasNext();) {
                var r = n.next();
                e.add(new Vf(r.getCoordinates(), r))
            }
            return e
        },
        Yf.checkValid = function(t) {
            new Yf(t).checkValid()
        };
        var Wf = function(t) {
            this._mapOp = t
        };
        Wf.prototype.map = function(t) {
            for (var e = new lh, n = 0; n < t.getNumGeometries(); n++) {
                var r = this._mapOp.map(t.getGeometryN(n));
                r.isEmpty() || e.add(r)
            }
            return t.getFactory().createGeometryCollection(mc.toGeometryArray(e))
        },
        Wf.prototype.interfaces_ = function() {
            return []
        },
        Wf.prototype.getClass = function() {
            return Wf
        },
        Wf.map = function(t, e) {
            return new Wf(e).map(t)
        };
        var $f = function() {
            this._op = null,
            this._geometryFactory = null,
            this._ptLocator = null,
            this._lineEdgesList = new lh,
            this._resultLineList = new lh;
            var t = arguments[0],
                e = arguments[1],
                n = arguments[2];
            this._op = t,
            this._geometryFactory = e,
            this._ptLocator = n
        };
        $f.prototype.collectLines = function(t) {
            for (var e = this, n = this._op.getGraph().getEdgeEnds().iterator(); n.hasNext();) {
                var r = n.next();
                e.collectLineEdge(r, t, e._lineEdgesList),
                e.collectBoundaryTouchEdge(r, t, e._lineEdgesList)
            }
        },
        $f.prototype.labelIsolatedLine = function(t, e) {
            var n = this._ptLocator.locate(t.getCoordinate(), this._op.getArgGeometry(e));
            t.getLabel().setLocation(e, n)
        },
        $f.prototype.build = function(t) {
            return this.findCoveredLineEdges(), this.collectLines(t), this.buildLines(t), this._resultLineList
        },
        $f.prototype.collectLineEdge = function(t, e, n) {
            var r = t.getLabel(),
                i = t.getEdge();
            t.isLineEdge() && (t.isVisited() || !Pd.isResultOfOp(r, e) || i.isCovered() || (n.add(i), t.setVisitedEdge(!0)))
        },
        $f.prototype.findCoveredLineEdges = function() {
            for (var t = this._op.getGraph().getNodes().iterator(); t.hasNext();)
                t.next().getEdges().findCoveredLineEdges();
            for (var e = this._op.getGraph().getEdgeEnds().iterator(); e.hasNext();) {
                var n = e.next(),
                    r = n.getEdge();
                if (n.isLineEdge() && !r.isCoveredSet()) {
                    var i = this._op.isCoveredByA(n.getCoordinate());
                    r.setCovered(i)
                }
            }
        },
        $f.prototype.labelIsolatedLines = function(t) {
            for (var e = t.iterator(); e.hasNext();) {
                var n = e.next(),
                    r = n.getLabel();
                n.isIsolated() && (r.isNull(0) ? this.labelIsolatedLine(n, 0) : this.labelIsolatedLine(n, 1))
            }
        },
        $f.prototype.buildLines = function(t) {
            for (var e = this._lineEdgesList.iterator(); e.hasNext();) {
                var n = e.next(),
                    r = this._geometryFactory.createLineString(n.getCoordinates());
                this._resultLineList.add(r),
                n.setInResult(!0)
            }
        },
        $f.prototype.collectBoundaryTouchEdge = function(t, e, n) {
            var r = t.getLabel();
            return t.isLineEdge() || t.isVisited() || t.isInteriorAreaEdge() || t.getEdge().isInResult() ? null : (Gl.isTrue(!(t.isInResult() || t.getSym().isInResult()) || !t.getEdge().isInResult()), void (Pd.isResultOfOp(r, e) && e === Pd.INTERSECTION && (n.add(t.getEdge()), t.setVisitedEdge(!0))))
        },
        $f.prototype.interfaces_ = function() {
            return []
        },
        $f.prototype.getClass = function() {
            return $f
        };
        var Kf = function() {
            this._op = null,
            this._geometryFactory = null,
            this._resultPointList = new lh;
            var t = arguments[0],
                e = arguments[1];
            this._op = t,
            this._geometryFactory = e
        };
        Kf.prototype.filterCoveredNodeToPoint = function(t) {
            var e = t.getCoordinate();
            if (!this._op.isCoveredByLA(e)) {
                var n = this._geometryFactory.createPoint(e);
                this._resultPointList.add(n)
            }
        },
        Kf.prototype.extractNonCoveredResultNodes = function(t) {
            for (var e = this._op.getGraph().getNodes().iterator(); e.hasNext();) {
                var n = e.next();
                if (!(n.isInResult() || n.isIncidentEdgeInResult() || 0 !== n.getEdges().getDegree() && t !== Pd.INTERSECTION)) {
                    var r = n.getLabel();
                    Pd.isResultOfOp(r, t) && this.filterCoveredNodeToPoint(n)
                }
            }
        },
        Kf.prototype.build = function(t) {
            return this.extractNonCoveredResultNodes(t), this._resultPointList
        },
        Kf.prototype.interfaces_ = function() {
            return []
        },
        Kf.prototype.getClass = function() {
            return Kf
        };
        var Zf = function() {
            this._inputGeom = null,
            this._factory = null,
            this._pruneEmptyGeometry = !0,
            this._preserveGeometryCollectionType = !0,
            this._preserveCollections = !1,
            this._preserveType = !1
        };
        Zf.prototype.transformPoint = function(t, e) {
            return this._factory.createPoint(this.transformCoordinates(t.getCoordinateSequence(), t))
        },
        Zf.prototype.transformPolygon = function(t, e) {
            var n = !0,
                r = this.transformLinearRing(t.getExteriorRing(), t);
            null !== r && r instanceof nc && !r.isEmpty() || (n = !1);
            for (var i = new lh, o = 0; o < t.getNumInteriorRing(); o++) {
                var s = this.transformLinearRing(t.getInteriorRingN(o), t);
                null === s || s.isEmpty() || (s instanceof nc || (n = !1), i.add(s))
            }
            if (n)
                return this._factory.createPolygon(r, i.toArray([]));
            var a = new lh;
            return null !== r && a.add(r), a.addAll(i), this._factory.buildGeometry(a)
        },
        Zf.prototype.createCoordinateSequence = function(t) {
            return this._factory.getCoordinateSequenceFactory().create(t)
        },
        Zf.prototype.getInputGeometry = function() {
            return this._inputGeom
        },
        Zf.prototype.transformMultiLineString = function(t, e) {
            for (var n = new lh, r = 0; r < t.getNumGeometries(); r++) {
                var i = this.transformLineString(t.getGeometryN(r), t);
                null !== i && (i.isEmpty() || n.add(i))
            }
            return this._factory.buildGeometry(n)
        },
        Zf.prototype.transformCoordinates = function(t, e) {
            return this.copy(t)
        },
        Zf.prototype.transformLineString = function(t, e) {
            return this._factory.createLineString(this.transformCoordinates(t.getCoordinateSequence(), t))
        },
        Zf.prototype.transformMultiPoint = function(t, e) {
            for (var n = new lh, r = 0; r < t.getNumGeometries(); r++) {
                var i = this.transformPoint(t.getGeometryN(r), t);
                null !== i && (i.isEmpty() || n.add(i))
            }
            return this._factory.buildGeometry(n)
        },
        Zf.prototype.transformMultiPolygon = function(t, e) {
            for (var n = new lh, r = 0; r < t.getNumGeometries(); r++) {
                var i = this.transformPolygon(t.getGeometryN(r), t);
                null !== i && (i.isEmpty() || n.add(i))
            }
            return this._factory.buildGeometry(n)
        },
        Zf.prototype.copy = function(t) {
            return t.copy()
        },
        Zf.prototype.transformGeometryCollection = function(t, e) {
            for (var n = new lh, r = 0; r < t.getNumGeometries(); r++) {
                var i = this.transform(t.getGeometryN(r));
                null !== i && (this._pruneEmptyGeometry && i.isEmpty() || n.add(i))
            }
            return this._preserveGeometryCollectionType ? this._factory.createGeometryCollection(mc.toGeometryArray(n)) : this._factory.buildGeometry(n)
        },
        Zf.prototype.transform = function(t) {
            if (this._inputGeom = t, this._factory = t.getFactory(), t instanceof Jh)
                return this.transformPoint(t, null);
            if (t instanceof ec)
                return this.transformMultiPoint(t, null);
            if (t instanceof nc)
                return this.transformLinearRing(t, null);
            if (t instanceof Kh)
                return this.transformLineString(t, null);
            if (t instanceof jh)
                return this.transformMultiLineString(t, null);
            if (t instanceof tc)
                return this.transformPolygon(t, null);
            if (t instanceof rc)
                return this.transformMultiPolygon(t, null);
            if (t instanceof kh)
                return this.transformGeometryCollection(t, null);
            throw new el("Unknown Geometry subtype: " + t.getClass().getName())
        },
        Zf.prototype.transformLinearRing = function(t, e) {
            var n = this.transformCoordinates(t.getCoordinateSequence(), t);
            if (null === n)
                return this._factory.createLinearRing(null);
            var r = n.size();
            return r > 0 && r < 4 && !this._preserveType ? this._factory.createLineString(n) : this._factory.createLinearRing(n)
        },
        Zf.prototype.interfaces_ = function() {
            return []
        },
        Zf.prototype.getClass = function() {
            return Zf
        };
        var Jf = function t() {
            if (this._snapTolerance = 0, this._srcPts = null, this._seg = new vp, this._allowSnappingToSourceVertices = !1, this._isClosed = !1, arguments[0] instanceof Kh && "number" == typeof arguments[1]) {
                var e = arguments[1];
                t.call(this, arguments[0].getCoordinates(), e)
            } else if (arguments[0] instanceof Array && "number" == typeof arguments[1]) {
                var n = arguments[0],
                    r = arguments[1];
                this._srcPts = n,
                this._isClosed = t.isClosed(n),
                this._snapTolerance = r
            }
        };
        Jf.prototype.snapVertices = function(t, e) {
            for (var n = this._isClosed ? t.size() - 1 : t.size(), r = 0; r < n; r++) {
                var i = t.get(r),
                    o = this.findSnapForVertex(i, e);
                null !== o && (t.set(r, new ul(o)), 0 === r && this._isClosed && t.set(t.size() - 1, new ul(o)))
            }
        },
        Jf.prototype.findSnapForVertex = function(t, e) {
            for (var n = 0; n < e.length; n++) {
                if (t.equals2D(e[n]))
                    return null;
                if (t.distance(e[n]) < this._snapTolerance)
                    return e[n]
            }
            return null
        },
        Jf.prototype.snapTo = function(t) {
            var e = new ch(this._srcPts);
            return this.snapVertices(e, t), this.snapSegments(e, t), e.toCoordinateArray()
        },
        Jf.prototype.snapSegments = function(t, e) {
            if (0 === e.length)
                return null;
            var n = e.length;
            e[0].equals2D(e[e.length - 1]) && (n = e.length - 1);
            for (var r = 0; r < n; r++) {
                var i = e[r],
                    o = this.findSegmentIndexToSnap(i, t);
                o >= 0 && t.add(o + 1, new ul(i), !1)
            }
        },
        Jf.prototype.findSegmentIndexToSnap = function(t, e) {
            for (var n = this, r = nl.MAX_VALUE, i = -1, o = 0; o < e.size() - 1; o++) {
                if (n._seg.p0 = e.get(o), n._seg.p1 = e.get(o + 1), n._seg.p0.equals2D(t) || n._seg.p1.equals2D(t)) {
                    if (n._allowSnappingToSourceVertices)
                        continue;
                    return -1
                }
                var s = n._seg.distance(t);
                s < n._snapTolerance && s < r && (r = s, i = o)
            }
            return i
        },
        Jf.prototype.setAllowSnappingToSourceVertices = function(t) {
            this._allowSnappingToSourceVertices = t
        },
        Jf.prototype.interfaces_ = function() {
            return []
        },
        Jf.prototype.getClass = function() {
            return Jf
        },
        Jf.isClosed = function(t) {
            return !(t.length <= 1) && t[0].equals2D(t[t.length - 1])
        };
        var Qf = function(t) {
                this._srcGeom = t || null
            },
            td = {
                SNAP_PRECISION_FACTOR: {
                    configurable: !0
                }
            };
        Qf.prototype.snapTo = function(t, e) {
            var n = this.extractTargetCoordinates(t);
            return new ed(e, n).transform(this._srcGeom)
        },
        Qf.prototype.snapToSelf = function(t, e) {
            var n = this.extractTargetCoordinates(this._srcGeom),
                r = new ed(t, n, !0).transform(this._srcGeom),
                i = r;
            return e && dl(i, Qh) && (i = r.buffer(0)), i
        },
        Qf.prototype.computeSnapTolerance = function(t) {
            return this.computeMinimumSegmentLength(t) / 10
        },
        Qf.prototype.extractTargetCoordinates = function(t) {
            for (var e = new Lh, n = t.getCoordinates(), r = 0; r < n.length; r++)
                e.add(n[r]);
            return e.toArray(new Array(0).fill(null))
        },
        Qf.prototype.computeMinimumSegmentLength = function(t) {
            for (var e = nl.MAX_VALUE, n = 0; n < t.length - 1; n++) {
                var r = t[n].distance(t[n + 1]);
                r < e && (e = r)
            }
            return e
        },
        Qf.prototype.interfaces_ = function() {
            return []
        },
        Qf.prototype.getClass = function() {
            return Qf
        },
        Qf.snap = function(t, e, n) {
            var r = new Array(2).fill(null),
                i = new Qf(t);
            r[0] = i.snapTo(e, n);
            var o = new Qf(e);
            return r[1] = o.snapTo(r[0], n), r
        },
        Qf.computeOverlaySnapTolerance = function() {
            if (1 === arguments.length) {
                var t = arguments[0],
                    e = Qf.computeSizeBasedSnapTolerance(t),
                    n = t.getPrecisionModel();
                if (n.getType() === dc.FIXED) {
                    var r = 1 / n.getScale() * 2 / 1.415;
                    r > e && (e = r)
                }
                return e
            }
            if (2 === arguments.length) {
                var i = arguments[0],
                    o = arguments[1];
                return Math.min(Qf.computeOverlaySnapTolerance(i), Qf.computeOverlaySnapTolerance(o))
            }
        },
        Qf.computeSizeBasedSnapTolerance = function(t) {
            var e = t.getEnvelopeInternal();
            return Math.min(e.getHeight(), e.getWidth()) * Qf.SNAP_PRECISION_FACTOR
        },
        Qf.snapToSelf = function(t, e, n) {
            return new Qf(t).snapToSelf(e, n)
        },
        td.SNAP_PRECISION_FACTOR.get = function() {
            return 1e-9
        },
        Object.defineProperties(Qf, td);
        var ed = function(t) {
                function e(e, n, r) {
                    t.call(this),
                    this._snapTolerance = e || null,
                    this._snapPts = n || null,
                    this._isSelfSnap = void 0 !== r && r
                }
                return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.snapLine = function(t, e) {
                    var n = new Jf(t, this._snapTolerance);
                    return n.setAllowSnappingToSourceVertices(this._isSelfSnap), n.snapTo(e)
                }, e.prototype.transformCoordinates = function(t, e) {
                    var n = t.toCoordinateArray(),
                        r = this.snapLine(n, this._snapPts);
                    return this._factory.getCoordinateSequenceFactory().create(r)
                }, e.prototype.interfaces_ = function() {
                    return []
                }, e.prototype.getClass = function() {
                    return e
                }, e
            }(Zf),
            nd = function() {
                this._isFirst = !0,
                this._commonMantissaBitsCount = 53,
                this._commonBits = 0,
                this._commonSignExp = null
            };
        nd.prototype.getCommon = function() {
            return nl.longBitsToDouble(this._commonBits)
        },
        nd.prototype.add = function(t) {
            var e = nl.doubleToLongBits(t);
            return this._isFirst ? (this._commonBits = e, this._commonSignExp = nd.signExpBits(this._commonBits), this._isFirst = !1, null) : nd.signExpBits(e) !== this._commonSignExp ? (this._commonBits = 0, null) : (this._commonMantissaBitsCount = nd.numCommonMostSigMantissaBits(this._commonBits, e), void (this._commonBits = nd.zeroLowerBits(this._commonBits, 64 - (12 + this._commonMantissaBitsCount))))
        },
        nd.prototype.toString = function() {
            if (1 === arguments.length) {
                var t = arguments[0],
                    e = nl.longBitsToDouble(t),
                    n = "0000000000000000000000000000000000000000000000000000000000000000" + nl.toBinaryString(t),
                    r = n.substring(n.length - 64);
                return r.substring(0, 1) + "  " + r.substring(1, 12) + "(exp) " + r.substring(12) + " [ " + e + " ]"
            }
        },
        nd.prototype.interfaces_ = function() {
            return []
        },
        nd.prototype.getClass = function() {
            return nd
        },
        nd.getBit = function(t, e) {
            return 0 != (t & 1 << e) ? 1 : 0
        },
        nd.signExpBits = function(t) {
            return t >> 52
        },
        nd.zeroLowerBits = function(t, e) {
            return t & ~((1 << e) - 1)
        },
        nd.numCommonMostSigMantissaBits = function(t, e) {
            for (var n = 0, r = 52; r >= 0; r--) {
                if (nd.getBit(t, r) !== nd.getBit(e, r))
                    return n;
                n++
            }
            return 52
        };
        var rd = function() {
                this._commonCoord = null,
                this._ccFilter = new od
            },
            id = {
                CommonCoordinateFilter: {
                    configurable: !0
                },
                Translater: {
                    configurable: !0
                }
            };
        rd.prototype.addCommonBits = function(t) {
            var e = new sd(this._commonCoord);
            t.apply(e),
            t.geometryChanged()
        },
        rd.prototype.removeCommonBits = function(t) {
            if (0 === this._commonCoord.x && 0 === this._commonCoord.y)
                return t;
            var e = new ul(this._commonCoord);
            e.x = -e.x,
            e.y = -e.y;
            var n = new sd(e);
            return t.apply(n), t.geometryChanged(), t
        },
        rd.prototype.getCommonCoordinate = function() {
            return this._commonCoord
        },
        rd.prototype.add = function(t) {
            t.apply(this._ccFilter),
            this._commonCoord = this._ccFilter.getCommonCoordinate()
        },
        rd.prototype.interfaces_ = function() {
            return []
        },
        rd.prototype.getClass = function() {
            return rd
        },
        id.CommonCoordinateFilter.get = function() {
            return od
        },
        id.Translater.get = function() {
            return sd
        },
        Object.defineProperties(rd, id);
        var od = function() {
            this._commonBitsX = new nd,
            this._commonBitsY = new nd
        };
        od.prototype.filter = function(t) {
            this._commonBitsX.add(t.x),
            this._commonBitsY.add(t.y)
        },
        od.prototype.getCommonCoordinate = function() {
            return new ul(this._commonBitsX.getCommon(), this._commonBitsY.getCommon())
        },
        od.prototype.interfaces_ = function() {
            return [Zl]
        },
        od.prototype.getClass = function() {
            return od
        };
        var sd = function() {
            this.trans = null;
            var t = arguments[0];
            this.trans = t
        };
        sd.prototype.filter = function(t, e) {
            var n = t.getOrdinate(e, 0) + this.trans.x,
                r = t.getOrdinate(e, 1) + this.trans.y;
            t.setOrdinate(e, 0, n),
            t.setOrdinate(e, 1, r)
        },
        sd.prototype.isDone = function() {
            return !1
        },
        sd.prototype.isGeometryChanged = function() {
            return !0
        },
        sd.prototype.interfaces_ = function() {
            return [Fh]
        },
        sd.prototype.getClass = function() {
            return sd
        };
        var ad = function(t, e) {
            this._geom = new Array(2).fill(null),
            this._snapTolerance = null,
            this._cbr = null,
            this._geom[0] = t,
            this._geom[1] = e,
            this.computeSnapTolerance()
        };
        ad.prototype.selfSnap = function(t) {
            return new Qf(t).snapTo(t, this._snapTolerance)
        },
        ad.prototype.removeCommonBits = function(t) {
            this._cbr = new rd,
            this._cbr.add(t[0]),
            this._cbr.add(t[1]);
            var e = new Array(2).fill(null);
            return e[0] = this._cbr.removeCommonBits(t[0].copy()), e[1] = this._cbr.removeCommonBits(t[1].copy()), e
        },
        ad.prototype.prepareResult = function(t) {
            return this._cbr.addCommonBits(t), t
        },
        ad.prototype.getResultGeometry = function(t) {
            var e = this.snap(this._geom),
                n = Pd.overlayOp(e[0], e[1], t);
            return this.prepareResult(n)
        },
        ad.prototype.checkValid = function(t) {
            t.isValid() || Tl.out.println("Snapped geometry is invalid")
        },
        ad.prototype.computeSnapTolerance = function() {
            this._snapTolerance = Qf.computeOverlaySnapTolerance(this._geom[0], this._geom[1])
        },
        ad.prototype.snap = function(t) {
            var e = this.removeCommonBits(t);
            return Qf.snap(e[0], e[1], this._snapTolerance)
        },
        ad.prototype.interfaces_ = function() {
            return []
        },
        ad.prototype.getClass = function() {
            return ad
        },
        ad.overlayOp = function(t, e, n) {
            return new ad(t, e).getResultGeometry(n)
        },
        ad.union = function(t, e) {
            return ad.overlayOp(t, e, Pd.UNION)
        },
        ad.intersection = function(t, e) {
            return ad.overlayOp(t, e, Pd.INTERSECTION)
        },
        ad.symDifference = function(t, e) {
            return ad.overlayOp(t, e, Pd.SYMDIFFERENCE)
        },
        ad.difference = function(t, e) {
            return ad.overlayOp(t, e, Pd.DIFFERENCE)
        };
        var ud = function(t, e) {
            this._geom = new Array(2).fill(null),
            this._geom[0] = t,
            this._geom[1] = e
        };
        ud.prototype.getResultGeometry = function(t) {
            var e = null,
                n = !1,
                r = null;
            try {
                e = Pd.overlayOp(this._geom[0], this._geom[1], t),
                n = !0
            } catch (t) {
                if (!(t instanceof kl))
                    throw t;
                r = t
            }
            if (!n)
                try {
                    e = ad.overlayOp(this._geom[0], this._geom[1], t)
                } catch (t) {
                    throw t instanceof kl ? r : t
                }
            return e
        },
        ud.prototype.interfaces_ = function() {
            return []
        },
        ud.prototype.getClass = function() {
            return ud
        },
        ud.overlayOp = function(t, e, n) {
            return new ud(t, e).getResultGeometry(n)
        },
        ud.union = function(t, e) {
            return ud.overlayOp(t, e, Pd.UNION)
        },
        ud.intersection = function(t, e) {
            return ud.overlayOp(t, e, Pd.INTERSECTION)
        },
        ud.symDifference = function(t, e) {
            return ud.overlayOp(t, e, Pd.SYMDIFFERENCE)
        },
        ud.difference = function(t, e) {
            return ud.overlayOp(t, e, Pd.DIFFERENCE)
        };
        var ld = function() {
            this.mce = null,
            this.chainIndex = null;
            var t = arguments[0],
                e = arguments[1];
            this.mce = t,
            this.chainIndex = e
        };
        ld.prototype.computeIntersections = function(t, e) {
            this.mce.computeIntersectsForChain(this.chainIndex, t.mce, t.chainIndex, e)
        },
        ld.prototype.interfaces_ = function() {
            return []
        },
        ld.prototype.getClass = function() {
            return ld
        };
        var hd = function t() {
                if (this._label = null, this._xValue = null, this._eventType = null, this._insertEvent = null, this._deleteEventIndex = null, this._obj = null, 2 === arguments.length) {
                    var e = arguments[0],
                        n = arguments[1];
                    this._eventType = t.DELETE,
                    this._xValue = e,
                    this._insertEvent = n
                } else if (3 === arguments.length) {
                    var r = arguments[0],
                        i = arguments[1],
                        o = arguments[2];
                    this._eventType = t.INSERT,
                    this._label = r,
                    this._xValue = i,
                    this._obj = o
                }
            },
            cd = {
                INSERT: {
                    configurable: !0
                },
                DELETE: {
                    configurable: !0
                }
            };
        hd.prototype.isDelete = function() {
            return this._eventType === hd.DELETE
        },
        hd.prototype.setDeleteEventIndex = function(t) {
            this._deleteEventIndex = t
        },
        hd.prototype.getObject = function() {
            return this._obj
        },
        hd.prototype.compareTo = function(t) {
            var e = t;
            return this._xValue < e._xValue ? -1 : this._xValue > e._xValue ? 1 : this._eventType < e._eventType ? -1 : this._eventType > e._eventType ? 1 : 0
        },
        hd.prototype.getInsertEvent = function() {
            return this._insertEvent
        },
        hd.prototype.isInsert = function() {
            return this._eventType === hd.INSERT
        },
        hd.prototype.isSameLabel = function(t) {
            return null !== this._label && this._label === t._label
        },
        hd.prototype.getDeleteEventIndex = function() {
            return this._deleteEventIndex
        },
        hd.prototype.interfaces_ = function() {
            return [il]
        },
        hd.prototype.getClass = function() {
            return hd
        },
        cd.INSERT.get = function() {
            return 1
        },
        cd.DELETE.get = function() {
            return 2
        },
        Object.defineProperties(hd, cd);
        var pd = function() {};
        pd.prototype.interfaces_ = function() {
            return []
        },
        pd.prototype.getClass = function() {
            return pd
        };
        var fd = function() {
            this._hasIntersection = !1,
            this._hasProper = !1,
            this._hasProperInterior = !1,
            this._properIntersectionPoint = null,
            this._li = null,
            this._includeProper = null,
            this._recordIsolated = null,
            this._isSelfIntersection = null,
            this._numIntersections = 0,
            this.numTests = 0,
            this._bdyNodes = null,
            this._isDone = !1,
            this._isDoneWhenProperInt = !1;
            var t = arguments[0],
                e = arguments[1],
                n = arguments[2];
            this._li = t,
            this._includeProper = e,
            this._recordIsolated = n
        };
        fd.prototype.isTrivialIntersection = function(t, e, n, r) {
            if (t === n && 1 === this._li.getIntersectionNum()) {
                if (fd.isAdjacentSegments(e, r))
                    return !0;
                if (t.isClosed()) {
                    var i = t.getNumPoints() - 1;
                    if (0 === e && r === i || 0 === r && e === i)
                        return !0
                }
            }
            return !1
        },
        fd.prototype.getProperIntersectionPoint = function() {
            return this._properIntersectionPoint
        },
        fd.prototype.setIsDoneIfProperInt = function(t) {
            this._isDoneWhenProperInt = t
        },
        fd.prototype.hasProperInteriorIntersection = function() {
            return this._hasProperInterior
        },
        fd.prototype.isBoundaryPointInternal = function(t, e) {
            for (var n = e.iterator(); n.hasNext();) {
                var r = n.next().getCoordinate();
                if (t.isIntersection(r))
                    return !0
            }
            return !1
        },
        fd.prototype.hasProperIntersection = function() {
            return this._hasProper
        },
        fd.prototype.hasIntersection = function() {
            return this._hasIntersection
        },
        fd.prototype.isDone = function() {
            return this._isDone
        },
        fd.prototype.isBoundaryPoint = function(t, e) {
            return !(null === e || !this.isBoundaryPointInternal(t, e[0]) && !this.isBoundaryPointInternal(t, e[1]))
        },
        fd.prototype.setBoundaryNodes = function(t, e) {
            this._bdyNodes = new Array(2).fill(null),
            this._bdyNodes[0] = t,
            this._bdyNodes[1] = e
        },
        fd.prototype.addIntersections = function(t, e, n, r) {
            if (t === n && e === r)
                return null;
            this.numTests++;
            var i = t.getCoordinates()[e],
                o = t.getCoordinates()[e + 1],
                s = n.getCoordinates()[r],
                a = n.getCoordinates()[r + 1];
            this._li.computeIntersection(i, o, s, a),
            this._li.hasIntersection() && (this._recordIsolated && (t.setIsolated(!1), n.setIsolated(!1)), this._numIntersections++, this.isTrivialIntersection(t, e, n, r) || (this._hasIntersection = !0, !this._includeProper && this._li.isProper() || (t.addIntersections(this._li, e, 0), n.addIntersections(this._li, r, 1)), this._li.isProper() && (this._properIntersectionPoint = this._li.getIntersection(0).copy(), this._hasProper = !0, this._isDoneWhenProperInt && (this._isDone = !0), this.isBoundaryPoint(this._li, this._bdyNodes) || (this._hasProperInterior = !0))))
        },
        fd.prototype.interfaces_ = function() {
            return []
        },
        fd.prototype.getClass = function() {
            return fd
        },
        fd.isAdjacentSegments = function(t, e) {
            return 1 === Math.abs(t - e)
        };
        var dd = function(t) {
                function e() {
                    t.call(this),
                    this.events = new lh,
                    this.nOverlaps = null
                }
                return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.prepareEvents = function() {
                    np.sort(this.events);
                    for (var t = 0; t < this.events.size(); t++) {
                        var e = this.events.get(t);
                        e.isDelete() && e.getInsertEvent().setDeleteEventIndex(t)
                    }
                }, e.prototype.computeIntersections = function() {
                    var t = this;
                    if (1 === arguments.length) {
                        var e = arguments[0];
                        this.nOverlaps = 0,
                        this.prepareEvents();
                        for (var n = 0; n < this.events.size(); n++) {
                            var r = t.events.get(n);
                            if (r.isInsert() && t.processOverlaps(n, r.getDeleteEventIndex(), r, e), e.isDone())
                                break
                        }
                    } else if (3 === arguments.length)
                        if (arguments[2] instanceof fd && dl(arguments[0], ah) && dl(arguments[1], ah)) {
                            var i = arguments[0],
                                o = arguments[1],
                                s = arguments[2];
                            this.addEdges(i, i),
                            this.addEdges(o, o),
                            this.computeIntersections(s)
                        } else if ("boolean" == typeof arguments[2] && dl(arguments[0], ah) && arguments[1] instanceof fd) {
                            var a = arguments[0],
                                u = arguments[1];
                            arguments[2] ? this.addEdges(a, null) : this.addEdges(a),
                            this.computeIntersections(u)
                        }
                }, e.prototype.addEdge = function(t, e) {
                    for (var n = t.getMonotoneChainEdge(), r = n.getStartIndexes(), i = 0; i < r.length - 1; i++) {
                        var o = new ld(n, i),
                            s = new hd(e, n.getMinX(i), o);
                        this.events.add(s),
                        this.events.add(new hd(n.getMaxX(i), s))
                    }
                }, e.prototype.processOverlaps = function(t, e, n, r) {
                    for (var i = n.getObject(), o = t; o < e; o++) {
                        var s = this.events.get(o);
                        if (s.isInsert()) {
                            var a = s.getObject();
                            n.isSameLabel(s) || (i.computeIntersections(a, r), this.nOverlaps++)
                        }
                    }
                }, e.prototype.addEdges = function() {
                    var t = this;
                    if (1 === arguments.length)
                        for (var e = arguments[0].iterator(); e.hasNext();) {
                            var n = e.next();
                            t.addEdge(n, n)
                        }
                    else if (2 === arguments.length)
                        for (var r = arguments[1], i = arguments[0].iterator(); i.hasNext();) {
                            var o = i.next();
                            t.addEdge(o, r)
                        }
                }, e.prototype.interfaces_ = function() {
                    return []
                }, e.prototype.getClass = function() {
                    return e
                }, e
            }(pd),
            gd = function() {
                this._min = nl.POSITIVE_INFINITY,
                this._max = nl.NEGATIVE_INFINITY
            },
            yd = {
                NodeComparator: {
                    configurable: !0
                }
            };
        gd.prototype.getMin = function() {
            return this._min
        },
        gd.prototype.intersects = function(t, e) {
            return !(this._min > e || this._max < t)
        },
        gd.prototype.getMax = function() {
            return this._max
        },
        gd.prototype.toString = function() {
            return Fl.toLineString(new ul(this._min, 0), new ul(this._max, 0))
        },
        gd.prototype.interfaces_ = function() {
            return []
        },
        gd.prototype.getClass = function() {
            return gd
        },
        yd.NodeComparator.get = function() {
            return vd
        },
        Object.defineProperties(gd, yd);
        var vd = function() {};
        vd.prototype.compare = function(t, e) {
            var n = t,
                r = e,
                i = (n._min + n._max) / 2,
                o = (r._min + r._max) / 2;
            return i < o ? -1 : i > o ? 1 : 0
        },
        vd.prototype.interfaces_ = function() {
            return [sl]
        },
        vd.prototype.getClass = function() {
            return vd
        };
        var md = function(t) {
                function e() {
                    t.call(this),
                    this._item = null;
                    var e = arguments[0],
                        n = arguments[1],
                        r = arguments[2];
                    this._min = e,
                    this._max = n,
                    this._item = r
                }
                return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.query = function(t, e, n) {
                    if (!this.intersects(t, e))
                        return null;
                    n.visitItem(this._item)
                }, e.prototype.interfaces_ = function() {
                    return []
                }, e.prototype.getClass = function() {
                    return e
                }, e
            }(gd),
            _d = function(t) {
                function e() {
                    t.call(this),
                    this._node1 = null,
                    this._node2 = null;
                    var e = arguments[0],
                        n = arguments[1];
                    this._node1 = e,
                    this._node2 = n,
                    this.buildExtent(this._node1, this._node2)
                }
                return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.buildExtent = function(t, e) {
                    this._min = Math.min(t._min, e._min),
                    this._max = Math.max(t._max, e._max)
                }, e.prototype.query = function(t, e, n) {
                    if (!this.intersects(t, e))
                        return null;
                    null !== this._node1 && this._node1.query(t, e, n),
                    null !== this._node2 && this._node2.query(t, e, n)
                }, e.prototype.interfaces_ = function() {
                    return []
                }, e.prototype.getClass = function() {
                    return e
                }, e
            }(gd),
            xd = function() {
                this._leaves = new lh,
                this._root = null,
                this._level = 0
            };
        xd.prototype.buildTree = function() {
            np.sort(this._leaves, new gd.NodeComparator);
            for (var t = this._leaves, e = null, n = new lh;;) {
                if (this.buildLevel(t, n), 1 === n.size())
                    return n.get(0);
                e = t,
                t = n,
                n = e
            }
        },
        xd.prototype.insert = function(t, e, n) {
            if (null !== this._root)
                throw new Error("Index cannot be added to once it has been queried");
            this._leaves.add(new md(t, e, n))
        },
        xd.prototype.query = function(t, e, n) {
            this.init(),
            this._root.query(t, e, n)
        },
        xd.prototype.buildRoot = function() {
            if (null !== this._root)
                return null;
            this._root = this.buildTree()
        },
        xd.prototype.printNode = function(t) {
            Tl.out.println(Fl.toLineString(new ul(t._min, this._level), new ul(t._max, this._level)))
        },
        xd.prototype.init = function() {
            if (null !== this._root)
                return null;
            this.buildRoot()
        },
        xd.prototype.buildLevel = function(t, e) {
            this._level++,
            e.clear();
            for (var n = 0; n < t.size(); n += 2) {
                var r = t.get(n);
                if (null === (n + 1 < t.size() ? t.get(n) : null))
                    e.add(r);
                else {
                    var i = new _d(t.get(n), t.get(n + 1));
                    e.add(i)
                }
            }
        },
        xd.prototype.interfaces_ = function() {
            return []
        },
        xd.prototype.getClass = function() {
            return xd
        };
        var Ed = function() {
            this._items = new lh
        };
        Ed.prototype.visitItem = function(t) {
            this._items.add(t)
        },
        Ed.prototype.getItems = function() {
            return this._items
        },
        Ed.prototype.interfaces_ = function() {
            return [Jc]
        },
        Ed.prototype.getClass = function() {
            return Ed
        };
        var wd = function() {
                this._index = null;
                var t = arguments[0];
                if (!dl(t, Qh))
                    throw new el("Argument must be Polygonal");
                this._index = new Md(t)
            },
            bd = {
                SegmentVisitor: {
                    configurable: !0
                },
                IntervalIndexedGeometry: {
                    configurable: !0
                }
            };
        wd.prototype.locate = function(t) {
            var e = new Vl(t),
                n = new Cd(e);
            return this._index.query(t.y, t.y, n), e.getLocation()
        },
        wd.prototype.interfaces_ = function() {
            return [zp]
        },
        wd.prototype.getClass = function() {
            return wd
        },
        bd.SegmentVisitor.get = function() {
            return Cd
        },
        bd.IntervalIndexedGeometry.get = function() {
            return Md
        },
        Object.defineProperties(wd, bd);
        var Cd = function() {
            this._counter = null;
            var t = arguments[0];
            this._counter = t
        };
        Cd.prototype.visitItem = function(t) {
            var e = t;
            this._counter.countSegment(e.getCoordinate(0), e.getCoordinate(1))
        },
        Cd.prototype.interfaces_ = function() {
            return [Jc]
        },
        Cd.prototype.getClass = function() {
            return Cd
        };
        var Md = function() {
            this._index = new xd;
            var t = arguments[0];
            this.init(t)
        };
        Md.prototype.init = function(t) {
            for (var e = If.getLines(t).iterator(); e.hasNext();) {
                var n = e.next().getCoordinates();
                this.addLine(n)
            }
        },
        Md.prototype.addLine = function(t) {
            for (var e = 1; e < t.length; e++) {
                var n = new vp(t[e - 1], t[e]),
                    r = Math.min(n.p0.y, n.p1.y),
                    i = Math.max(n.p0.y, n.p1.y);
                this._index.insert(r, i, n)
            }
        },
        Md.prototype.query = function() {
            if (2 === arguments.length) {
                var t = arguments[0],
                    e = arguments[1],
                    n = new Ed;
                return this._index.query(t, e, n), n.getItems()
            }
            if (3 === arguments.length) {
                var r = arguments[0],
                    i = arguments[1],
                    o = arguments[2];
                this._index.query(r, i, o)
            }
        },
        Md.prototype.interfaces_ = function() {
            return []
        },
        Md.prototype.getClass = function() {
            return Md
        };
        var Sd = function(t) {
                function e() {
                    if (t.call(this), this._parentGeom = null, this._lineEdgeMap = new fc, this._boundaryNodeRule = null, this._useBoundaryDeterminationRule = !0, this._argIndex = null, this._boundaryNodes = null, this._hasTooFewPoints = !1, this._invalidPoint = null, this._areaPtLocator = null, this._ptLocator = new Tf, 2 === arguments.length) {
                        var e = arguments[0],
                            n = arguments[1],
                            r = Jl.OGC_SFS_BOUNDARY_RULE;
                        this._argIndex = e,
                        this._parentGeom = n,
                        this._boundaryNodeRule = r,
                        null !== n && this.add(n)
                    } else if (3 === arguments.length) {
                        var i = arguments[0],
                            o = arguments[1],
                            s = arguments[2];
                        this._argIndex = i,
                        this._parentGeom = o,
                        this._boundaryNodeRule = s,
                        null !== o && this.add(o)
                    }
                }
                return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.insertBoundaryPoint = function(t, n) {
                    var r = this._nodes.addNode(n).getLabel(),
                        i = 1;
                    r.getLocation(t, Sc.ON) === pl.BOUNDARY && i++;
                    var o = e.determineBoundary(this._boundaryNodeRule, i);
                    r.setLocation(t, o)
                }, e.prototype.computeSelfNodes = function() {
                    if (2 === arguments.length) {
                        var t = arguments[0],
                            e = arguments[1];
                        return this.computeSelfNodes(t, e, !1)
                    }
                    if (3 === arguments.length) {
                        var n = arguments[1],
                            r = arguments[2],
                            i = new fd(arguments[0], !0, !1);
                        i.setIsDoneIfProperInt(r);
                        var o = this.createEdgeSetIntersector(),
                            s = this._parentGeom instanceof nc || this._parentGeom instanceof tc || this._parentGeom instanceof rc,
                            a = n || !s;
                        return o.computeIntersections(this._edges, i, a), this.addSelfIntersectionNodes(this._argIndex), i
                    }
                }, e.prototype.computeSplitEdges = function(t) {
                    for (var e = this._edges.iterator(); e.hasNext();)
                        e.next().eiList.addSplitEdges(t)
                }, e.prototype.computeEdgeIntersections = function(t, e, n) {
                    var r = new fd(e, n, !0);
                    return r.setBoundaryNodes(this.getBoundaryNodes(), t.getBoundaryNodes()), this.createEdgeSetIntersector().computeIntersections(this._edges, t._edges, r), r
                }, e.prototype.getGeometry = function() {
                    return this._parentGeom
                }, e.prototype.getBoundaryNodeRule = function() {
                    return this._boundaryNodeRule
                }, e.prototype.hasTooFewPoints = function() {
                    return this._hasTooFewPoints
                }, e.prototype.addPoint = function() {
                    if (arguments[0] instanceof Jh) {
                        var t = arguments[0].getCoordinate();
                        this.insertPoint(this._argIndex, t, pl.INTERIOR)
                    } else if (arguments[0] instanceof ul) {
                        var e = arguments[0];
                        this.insertPoint(this._argIndex, e, pl.INTERIOR)
                    }
                }, e.prototype.addPolygon = function(t) {
                    this.addPolygonRing(t.getExteriorRing(), pl.EXTERIOR, pl.INTERIOR);
                    for (var e = 0; e < t.getNumInteriorRing(); e++) {
                        var n = t.getInteriorRingN(e);
                        this.addPolygonRing(n, pl.INTERIOR, pl.EXTERIOR)
                    }
                }, e.prototype.addEdge = function(t) {
                    this.insertEdge(t);
                    var e = t.getCoordinates();
                    this.insertPoint(this._argIndex, e[0], pl.BOUNDARY),
                    this.insertPoint(this._argIndex, e[e.length - 1], pl.BOUNDARY)
                }, e.prototype.addLineString = function(t) {
                    var e = ph.removeRepeatedPoints(t.getCoordinates());
                    if (e.length < 2)
                        return this._hasTooFewPoints = !0, this._invalidPoint = e[0], null;
                    var n = new of(e, new Dc(this._argIndex, pl.INTERIOR));
                    this._lineEdgeMap.put(t, n),
                    this.insertEdge(n),
                    Gl.isTrue(e.length >= 2, "found LineString with single point"),
                    this.insertBoundaryPoint(this._argIndex, e[0]),
                    this.insertBoundaryPoint(this._argIndex, e[e.length - 1])
                }, e.prototype.getInvalidPoint = function() {
                    return this._invalidPoint
                }, e.prototype.getBoundaryPoints = function() {
                    for (var t = this.getBoundaryNodes(), e = new Array(t.size()).fill(null), n = 0, r = t.iterator(); r.hasNext();) {
                        var i = r.next();
                        e[n++] = i.getCoordinate().copy()
                    }
                    return e
                }, e.prototype.getBoundaryNodes = function() {
                    return null === this._boundaryNodes && (this._boundaryNodes = this._nodes.getBoundaryNodes(this._argIndex)), this._boundaryNodes
                }, e.prototype.addSelfIntersectionNode = function(t, e, n) {
                    if (this.isBoundaryNode(t, e))
                        return null;
                    n === pl.BOUNDARY && this._useBoundaryDeterminationRule ? this.insertBoundaryPoint(t, e) : this.insertPoint(t, e, n)
                }, e.prototype.addPolygonRing = function(t, e, n) {
                    if (t.isEmpty())
                        return null;
                    var r = ph.removeRepeatedPoints(t.getCoordinates());
                    if (r.length < 4)
                        return this._hasTooFewPoints = !0, this._invalidPoint = r[0], null;
                    var i = e,
                        o = n;
                    Xl.isCCW(r) && (i = n, o = e);
                    var s = new of(r, new Dc(this._argIndex, pl.BOUNDARY, i, o));
                    this._lineEdgeMap.put(t, s),
                    this.insertEdge(s),
                    this.insertPoint(this._argIndex, r[0], pl.BOUNDARY)
                }, e.prototype.insertPoint = function(t, e, n) {
                    var r = this._nodes.addNode(e),
                        i = r.getLabel();
                    null === i ? r._label = new Dc(t, n) : i.setLocation(t, n)
                }, e.prototype.createEdgeSetIntersector = function() {
                    return new dd
                }, e.prototype.addSelfIntersectionNodes = function(t) {
                    for (var e = this._edges.iterator(); e.hasNext();)
                        for (var n = e.next(), r = n.getLabel().getLocation(t), i = n.eiList.iterator(); i.hasNext();) {
                            var o = i.next();
                            this.addSelfIntersectionNode(t, o.coord, r)
                        }
                }, e.prototype.add = function() {
                    if (1 !== arguments.length)
                        return t.prototype.add.apply(this, arguments);
                    var e = arguments[0];
                    if (e.isEmpty())
                        return null;
                    if (e instanceof rc && (this._useBoundaryDeterminationRule = !1), e instanceof tc)
                        this.addPolygon(e);
                    else if (e instanceof Kh)
                        this.addLineString(e);
                    else if (e instanceof Jh)
                        this.addPoint(e);
                    else if (e instanceof ec)
                        this.addCollection(e);
                    else if (e instanceof jh)
                        this.addCollection(e);
                    else if (e instanceof rc)
                        this.addCollection(e);
                    else {
                        if (!(e instanceof kh))
                            throw new Error(e.getClass().getName());
                        this.addCollection(e)
                    }
                }, e.prototype.addCollection = function(t) {
                    for (var e = 0; e < t.getNumGeometries(); e++) {
                        var n = t.getGeometryN(e);
                        this.add(n)
                    }
                }, e.prototype.locate = function(t) {
                    return dl(this._parentGeom, Qh) && this._parentGeom.getNumGeometries() > 50 ? (null === this._areaPtLocator && (this._areaPtLocator = new wd(this._parentGeom)), this._areaPtLocator.locate(t)) : this._ptLocator.locate(t, this._parentGeom)
                }, e.prototype.findEdge = function() {
                    if (1 === arguments.length) {
                        var e = arguments[0];
                        return this._lineEdgeMap.get(e)
                    }
                    return t.prototype.findEdge.apply(this, arguments)
                }, e.prototype.interfaces_ = function() {
                    return []
                }, e.prototype.getClass = function() {
                    return e
                }, e.determineBoundary = function(t, e) {
                    return t.isInBoundary(e) ? pl.BOUNDARY : pl.INTERIOR
                }, e
            }(Yc),
            Id = function() {
                if (this._li = new zl, this._resultPrecisionModel = null, this._arg = null, 1 === arguments.length) {
                    var t = arguments[0];
                    this.setComputationPrecision(t.getPrecisionModel()),
                    this._arg = new Array(1).fill(null),
                    this._arg[0] = new Sd(0, t)
                } else if (2 === arguments.length) {
                    var e = arguments[0],
                        n = arguments[1],
                        r = Jl.OGC_SFS_BOUNDARY_RULE;
                    e.getPrecisionModel().compareTo(n.getPrecisionModel()) >= 0 ? this.setComputationPrecision(e.getPrecisionModel()) : this.setComputationPrecision(n.getPrecisionModel()),
                    this._arg = new Array(2).fill(null),
                    this._arg[0] = new Sd(0, e, r),
                    this._arg[1] = new Sd(1, n, r)
                } else if (3 === arguments.length) {
                    var i = arguments[0],
                        o = arguments[1],
                        s = arguments[2];
                    i.getPrecisionModel().compareTo(o.getPrecisionModel()) >= 0 ? this.setComputationPrecision(i.getPrecisionModel()) : this.setComputationPrecision(o.getPrecisionModel()),
                    this._arg = new Array(2).fill(null),
                    this._arg[0] = new Sd(0, i, s),
                    this._arg[1] = new Sd(1, o, s)
                }
            };
        Id.prototype.getArgGeometry = function(t) {
            return this._arg[t].getGeometry()
        },
        Id.prototype.setComputationPrecision = function(t) {
            this._resultPrecisionModel = t,
            this._li.setPrecisionModel(this._resultPrecisionModel)
        },
        Id.prototype.interfaces_ = function() {
            return []
        },
        Id.prototype.getClass = function() {
            return Id
        };
        var Td = function() {};
        Td.prototype.interfaces_ = function() {
            return []
        },
        Td.prototype.getClass = function() {
            return Td
        },
        Td.map = function() {
            if (arguments[0] instanceof Wl && dl(arguments[1], Td.MapOp)) {
                for (var t = arguments[0], e = arguments[1], n = new lh, r = 0; r < t.getNumGeometries(); r++) {
                    var i = e.map(t.getGeometryN(r));
                    null !== i && n.add(i)
                }
                return t.getFactory().buildGeometry(n)
            }
            if (dl(arguments[0], ih) && dl(arguments[1], Td.MapOp)) {
                for (var o = arguments[0], s = arguments[1], a = new lh, u = o.iterator(); u.hasNext();) {
                    var l = u.next(),
                        h = s.map(l);
                    null !== h && a.add(h)
                }
                return a
            }
        },
        Td.MapOp = function() {};
        var Pd = function(t) {
            function e() {
                var e = arguments[0],
                    n = arguments[1];
                t.call(this, e, n),
                this._ptLocator = new Tf,
                this._geomFact = null,
                this._resultGeom = null,
                this._graph = null,
                this._edgeList = new $p,
                this._resultPolyList = new lh,
                this._resultLineList = new lh,
                this._resultPointList = new lh,
                this._graph = new Yc(new Yp),
                this._geomFact = e.getFactory()
            }
            return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.insertUniqueEdge = function(t) {
                var e = this._edgeList.findEqualEdge(t);
                if (null !== e) {
                    var n = e.getLabel(),
                        r = t.getLabel();
                    e.isPointwiseEqual(t) || (r = new Dc(t.getLabel())).flip();
                    var i = e.getDepth();
                    i.isNull() && i.add(n),
                    i.add(r),
                    n.merge(r)
                } else
                    this._edgeList.add(t)
            }, e.prototype.getGraph = function() {
                return this._graph
            }, e.prototype.cancelDuplicateResultEdges = function() {
                for (var t = this._graph.getEdgeEnds().iterator(); t.hasNext();) {
                    var e = t.next(),
                        n = e.getSym();
                    e.isInResult() && n.isInResult() && (e.setInResult(!1), n.setInResult(!1))
                }
            }, e.prototype.isCoveredByLA = function(t) {
                return !!this.isCovered(t, this._resultLineList) || !!this.isCovered(t, this._resultPolyList)
            }, e.prototype.computeGeometry = function(t, n, r, i) {
                var o = new lh;
                return o.addAll(t), o.addAll(n), o.addAll(r), o.isEmpty() ? e.createEmptyResult(i, this._arg[0].getGeometry(), this._arg[1].getGeometry(), this._geomFact) : this._geomFact.buildGeometry(o)
            }, e.prototype.mergeSymLabels = function() {
                for (var t = this._graph.getNodes().iterator(); t.hasNext();)
                    t.next().getEdges().mergeSymLabels()
            }, e.prototype.isCovered = function(t, e) {
                for (var n = e.iterator(); n.hasNext();) {
                    var r = n.next();
                    if (this._ptLocator.locate(t, r) !== pl.EXTERIOR)
                        return !0
                }
                return !1
            }, e.prototype.replaceCollapsedEdges = function() {
                for (var t = new lh, e = this._edgeList.iterator(); e.hasNext();) {
                    var n = e.next();
                    n.isCollapsed() && (e.remove(), t.add(n.getCollapsedEdge()))
                }
                this._edgeList.addAll(t)
            }, e.prototype.updateNodeLabelling = function() {
                for (var t = this._graph.getNodes().iterator(); t.hasNext();) {
                    var e = t.next(),
                        n = e.getEdges().getLabel();
                    e.getLabel().merge(n)
                }
            }, e.prototype.getResultGeometry = function(t) {
                return this.computeOverlay(t), this._resultGeom
            }, e.prototype.insertUniqueEdges = function(t) {
                for (var e = t.iterator(); e.hasNext();) {
                    var n = e.next();
                    this.insertUniqueEdge(n)
                }
            }, e.prototype.computeOverlay = function(t) {
                this.copyPoints(0),
                this.copyPoints(1),
                this._arg[0].computeSelfNodes(this._li, !1),
                this._arg[1].computeSelfNodes(this._li, !1),
                this._arg[0].computeEdgeIntersections(this._arg[1], this._li, !0);
                var e = new lh;
                this._arg[0].computeSplitEdges(e),
                this._arg[1].computeSplitEdges(e),
                this.insertUniqueEdges(e),
                this.computeLabelsFromDepths(),
                this.replaceCollapsedEdges(),
                Yf.checkValid(this._edgeList.getEdges()),
                this._graph.addEdges(this._edgeList.getEdges()),
                this.computeLabelling(),
                this.labelIncompleteNodes(),
                this.findResultAreaEdges(t),
                this.cancelDuplicateResultEdges();
                var n = new Wc(this._geomFact);
                n.add(this._graph),
                this._resultPolyList = n.getPolygons();
                var r = new $f(this, this._geomFact, this._ptLocator);
                this._resultLineList = r.build(t);
                var i = new Kf(this, this._geomFact, this._ptLocator);
                this._resultPointList = i.build(t),
                this._resultGeom = this.computeGeometry(this._resultPointList, this._resultLineList, this._resultPolyList, t)
            }, e.prototype.labelIncompleteNode = function(t, e) {
                var n = this._ptLocator.locate(t.getCoordinate(), this._arg[e].getGeometry());
                t.getLabel().setLocation(e, n)
            }, e.prototype.copyPoints = function(t) {
                for (var e = this._arg[t].getNodeIterator(); e.hasNext();) {
                    var n = e.next();
                    this._graph.addNode(n.getCoordinate()).setLabel(t, n.getLabel().getLocation(t))
                }
            }, e.prototype.findResultAreaEdges = function(t) {
                for (var n = this._graph.getEdgeEnds().iterator(); n.hasNext();) {
                    var r = n.next(),
                        i = r.getLabel();
                    i.isArea() && !r.isInteriorAreaEdge() && e.isResultOfOp(i.getLocation(0, Sc.RIGHT), i.getLocation(1, Sc.RIGHT), t) && r.setInResult(!0)
                }
            }, e.prototype.computeLabelsFromDepths = function() {
                for (var t = this._edgeList.iterator(); t.hasNext();) {
                    var e = t.next(),
                        n = e.getLabel(),
                        r = e.getDepth();
                    if (!r.isNull()) {
                        r.normalize();
                        for (var i = 0; i < 2; i++)
                            n.isNull(i) || !n.isArea() || r.isNull(i) || (0 === r.getDelta(i) ? n.toLine(i) : (Gl.isTrue(!r.isNull(i, Sc.LEFT), "depth of LEFT side has not been initialized"), n.setLocation(i, Sc.LEFT, r.getLocation(i, Sc.LEFT)), Gl.isTrue(!r.isNull(i, Sc.RIGHT), "depth of RIGHT side has not been initialized"), n.setLocation(i, Sc.RIGHT, r.getLocation(i, Sc.RIGHT))))
                    }
                }
            }, e.prototype.computeLabelling = function() {
                for (var t = this._graph.getNodes().iterator(); t.hasNext();)
                    t.next().getEdges().computeLabelling(this._arg);
                this.mergeSymLabels(),
                this.updateNodeLabelling()
            }, e.prototype.labelIncompleteNodes = function() {
                for (var t = this._graph.getNodes().iterator(); t.hasNext();) {
                    var e = t.next(),
                        n = e.getLabel();
                    e.isIsolated() && (n.isNull(0) ? this.labelIncompleteNode(e, 0) : this.labelIncompleteNode(e, 1)),
                    e.getEdges().updateLabelling(n)
                }
            }, e.prototype.isCoveredByA = function(t) {
                return !!this.isCovered(t, this._resultPolyList)
            }, e.prototype.interfaces_ = function() {
                return []
            }, e.prototype.getClass = function() {
                return e
            }, e
        }(Id);
        Pd.overlayOp = function(t, e, n) {
            return new Pd(t, e).getResultGeometry(n)
        },
        Pd.intersection = function(t, e) {
            if (t.isEmpty() || e.isEmpty())
                return Pd.createEmptyResult(Pd.INTERSECTION, t, e, t.getFactory());
            if (t.isGeometryCollection()) {
                var n = e;
                return Wf.map(t, {
                    interfaces_: function() {
                        return [Td.MapOp]
                    },
                    map: function(t) {
                        return t.intersection(n)
                    }
                })
            }
            return t.checkNotGeometryCollection(t), t.checkNotGeometryCollection(e), ud.overlayOp(t, e, Pd.INTERSECTION)
        },
        Pd.symDifference = function(t, e) {
            if (t.isEmpty() || e.isEmpty()) {
                if (t.isEmpty() && e.isEmpty())
                    return Pd.createEmptyResult(Pd.SYMDIFFERENCE, t, e, t.getFactory());
                if (t.isEmpty())
                    return e.copy();
                if (e.isEmpty())
                    return t.copy()
            }
            return t.checkNotGeometryCollection(t), t.checkNotGeometryCollection(e), ud.overlayOp(t, e, Pd.SYMDIFFERENCE)
        },
        Pd.resultDimension = function(t, e, n) {
            var r = e.getDimension(),
                i = n.getDimension(),
                o = -1;
            switch (t) {
            case Pd.INTERSECTION:
                o = Math.min(r, i);
                break;
            case Pd.UNION:
                o = Math.max(r, i);
                break;
            case Pd.DIFFERENCE:
                o = r;
                break;
            case Pd.SYMDIFFERENCE:
                o = Math.max(r, i)
            }
            return o
        },
        Pd.createEmptyResult = function(t, e, n, r) {
            var i = null;
            switch (Pd.resultDimension(t, e, n)) {
            case -1:
                i = r.createGeometryCollection(new Array(0).fill(null));
                break;
            case 0:
                i = r.createPoint();
                break;
            case 1:
                i = r.createLineString();
                break;
            case 2:
                i = r.createPolygon()
            }
            return i
        },
        Pd.difference = function(t, e) {
            return t.isEmpty() ? Pd.createEmptyResult(Pd.DIFFERENCE, t, e, t.getFactory()) : e.isEmpty() ? t.copy() : (t.checkNotGeometryCollection(t), t.checkNotGeometryCollection(e), ud.overlayOp(t, e, Pd.DIFFERENCE))
        },
        Pd.isResultOfOp = function() {
            if (2 === arguments.length) {
                var t = arguments[0],
                    e = arguments[1],
                    n = t.getLocation(0),
                    r = t.getLocation(1);
                return Pd.isResultOfOp(n, r, e)
            }
            if (3 === arguments.length) {
                var i = arguments[0],
                    o = arguments[1],
                    s = arguments[2];
                switch (i === pl.BOUNDARY && (i = pl.INTERIOR), o === pl.BOUNDARY && (o = pl.INTERIOR), s) {
                case Pd.INTERSECTION:
                    return i === pl.INTERIOR && o === pl.INTERIOR;
                case Pd.UNION:
                    return i === pl.INTERIOR || o === pl.INTERIOR;
                case Pd.DIFFERENCE:
                    return i === pl.INTERIOR && o !== pl.INTERIOR;
                case Pd.SYMDIFFERENCE:
                    return i === pl.INTERIOR && o !== pl.INTERIOR || i !== pl.INTERIOR && o === pl.INTERIOR
                }
                return !1
            }
        },
        Pd.INTERSECTION = 1,
        Pd.UNION = 2,
        Pd.DIFFERENCE = 3,
        Pd.SYMDIFFERENCE = 4;
        var Ld = function() {
            this._g = null,
            this._boundaryDistanceTolerance = null,
            this._linework = null,
            this._ptLocator = new Tf,
            this._seg = new vp;
            var t = arguments[0],
                e = arguments[1];
            this._g = t,
            this._boundaryDistanceTolerance = e,
            this._linework = this.extractLinework(t)
        };
        Ld.prototype.isWithinToleranceOfBoundary = function(t) {
            for (var e = this, n = 0; n < this._linework.getNumGeometries(); n++)
                for (var r = e._linework.getGeometryN(n).getCoordinateSequence(), i = 0; i < r.size() - 1; i++)
                    if (r.getCoordinate(i, e._seg.p0), r.getCoordinate(i + 1, e._seg.p1), e._seg.distance(t) <= e._boundaryDistanceTolerance)
                        return !0;
            return !1
        },
        Ld.prototype.getLocation = function(t) {
            return this.isWithinToleranceOfBoundary(t) ? pl.BOUNDARY : this._ptLocator.locate(t, this._g)
        },
        Ld.prototype.extractLinework = function(t) {
            var e = new Od;
            t.apply(e);
            var n = e.getLinework(),
                r = mc.toLineStringArray(n);
            return t.getFactory().createMultiLineString(r)
        },
        Ld.prototype.interfaces_ = function() {
            return []
        },
        Ld.prototype.getClass = function() {
            return Ld
        };
        var Od = function() {
            this._linework = null,
            this._linework = new lh
        };
        Od.prototype.getLinework = function() {
            return this._linework
        },
        Od.prototype.filter = function(t) {
            if (t instanceof tc) {
                var e = t;
                this._linework.add(e.getExteriorRing());
                for (var n = 0; n < e.getNumInteriorRing(); n++)
                    this._linework.add(e.getInteriorRingN(n))
            }
        },
        Od.prototype.interfaces_ = function() {
            return [Dh]
        },
        Od.prototype.getClass = function() {
            return Od
        };
        var Nd = function() {
            this._g = null,
            this._doLeft = !0,
            this._doRight = !0;
            var t = arguments[0];
            this._g = t
        };
        Nd.prototype.extractPoints = function(t, e, n) {
            for (var r = t.getCoordinates(), i = 0; i < r.length - 1; i++)
                this.computeOffsetPoints(r[i], r[i + 1], e, n)
        },
        Nd.prototype.setSidesToGenerate = function(t, e) {
            this._doLeft = t,
            this._doRight = e
        },
        Nd.prototype.getPoints = function(t) {
            for (var e = new lh, n = If.getLines(this._g).iterator(); n.hasNext();) {
                var r = n.next();
                this.extractPoints(r, t, e)
            }
            return e
        },
        Nd.prototype.computeOffsetPoints = function(t, e, n, r) {
            var i = e.x - t.x,
                o = e.y - t.y,
                s = Math.sqrt(i * i + o * o),
                a = n * i / s,
                u = n * o / s,
                l = (e.x + t.x) / 2,
                h = (e.y + t.y) / 2;
            if (this._doLeft) {
                var c = new ul(l - u, h + a);
                r.add(c)
            }
            if (this._doRight) {
                var p = new ul(l + u, h - a);
                r.add(p)
            }
        },
        Nd.prototype.interfaces_ = function() {
            return []
        },
        Nd.prototype.getClass = function() {
            return Nd
        };
        var Rd = function t() {
                this._geom = null,
                this._locFinder = null,
                this._location = new Array(3).fill(null),
                this._invalidLocation = null,
                this._boundaryDistanceTolerance = t.TOLERANCE,
                this._testCoords = new lh;
                var e = arguments[0],
                    n = arguments[1],
                    r = arguments[2];
                this._boundaryDistanceTolerance = t.computeBoundaryDistanceTolerance(e, n),
                this._geom = [e, n, r],
                this._locFinder = [new Ld(this._geom[0], this._boundaryDistanceTolerance), new Ld(this._geom[1], this._boundaryDistanceTolerance), new Ld(this._geom[2], this._boundaryDistanceTolerance)]
            },
            Ad = {
                TOLERANCE: {
                    configurable: !0
                }
            };
        Rd.prototype.reportResult = function(t, e, n) {
            Tl.out.println("Overlay result invalid - A:" + pl.toLocationSymbol(e[0]) + " B:" + pl.toLocationSymbol(e[1]) + " expected:" + (n ? "i" : "e") + " actual:" + pl.toLocationSymbol(e[2]))
        },
        Rd.prototype.isValid = function(t) {
            return this.addTestPts(this._geom[0]), this.addTestPts(this._geom[1]), this.checkValid(t)
        },
        Rd.prototype.checkValid = function() {
            var t = this;
            if (1 === arguments.length) {
                for (var e = arguments[0], n = 0; n < this._testCoords.size(); n++) {
                    var r = t._testCoords.get(n);
                    if (!t.checkValid(e, r))
                        return t._invalidLocation = r, !1
                }
                return !0
            }
            if (2 === arguments.length) {
                var i = arguments[0],
                    o = arguments[1];
                return this._location[0] = this._locFinder[0].getLocation(o), this._location[1] = this._locFinder[1].getLocation(o), this._location[2] = this._locFinder[2].getLocation(o), !!Rd.hasLocation(this._location, pl.BOUNDARY) || this.isValidResult(i, this._location)
            }
        },
        Rd.prototype.addTestPts = function(t) {
            var e = new Nd(t);
            this._testCoords.addAll(e.getPoints(5 * this._boundaryDistanceTolerance))
        },
        Rd.prototype.isValidResult = function(t, e) {
            var n = Pd.isResultOfOp(e[0], e[1], t),
                r = !(n ^ e[2] === pl.INTERIOR);
            return r || this.reportResult(t, e, n), r
        },
        Rd.prototype.getInvalidLocation = function() {
            return this._invalidLocation
        },
        Rd.prototype.interfaces_ = function() {
            return []
        },
        Rd.prototype.getClass = function() {
            return Rd
        },
        Rd.hasLocation = function(t, e) {
            for (var n = 0; n < 3; n++)
                if (t[n] === e)
                    return !0;
            return !1
        },
        Rd.computeBoundaryDistanceTolerance = function(t, e) {
            return Math.min(Qf.computeSizeBasedSnapTolerance(t), Qf.computeSizeBasedSnapTolerance(e))
        },
        Rd.isValid = function(t, e, n, r) {
            return new Rd(t, e, r).isValid(n)
        },
        Ad.TOLERANCE.get = function() {
            return 1e-6
        },
        Object.defineProperties(Rd, Ad);
        var Dd = function t(e) {
            this._geomFactory = null,
            this._skipEmpty = !1,
            this._inputGeoms = null,
            this._geomFactory = t.extractFactory(e),
            this._inputGeoms = e
        };
        Dd.prototype.extractElements = function(t, e) {
            if (null === t)
                return null;
            for (var n = 0; n < t.getNumGeometries(); n++) {
                var r = t.getGeometryN(n);
                this._skipEmpty && r.isEmpty() || e.add(r)
            }
        },
        Dd.prototype.combine = function() {
            for (var t = new lh, e = this._inputGeoms.iterator(); e.hasNext();) {
                var n = e.next();
                this.extractElements(n, t)
            }
            return 0 === t.size() ? null !== this._geomFactory ? this._geomFactory.createGeometryCollection(null) : null : this._geomFactory.buildGeometry(t)
        },
        Dd.prototype.interfaces_ = function() {
            return []
        },
        Dd.prototype.getClass = function() {
            return Dd
        },
        Dd.combine = function() {
            if (1 === arguments.length)
                return new Dd(arguments[0]).combine();
            if (2 === arguments.length) {
                var t = arguments[0],
                    e = arguments[1];
                return new Dd(Dd.createList(t, e)).combine()
            }
            if (3 === arguments.length) {
                var n = arguments[0],
                    r = arguments[1],
                    i = arguments[2];
                return new Dd(Dd.createList(n, r, i)).combine()
            }
        },
        Dd.extractFactory = function(t) {
            return t.isEmpty() ? null : t.iterator().next().getFactory()
        },
        Dd.createList = function() {
            if (2 === arguments.length) {
                var t = arguments[0],
                    e = arguments[1],
                    n = new lh;
                return n.add(t), n.add(e), n
            }
            if (3 === arguments.length) {
                var r = arguments[0],
                    i = arguments[1],
                    o = arguments[2],
                    s = new lh;
                return s.add(r), s.add(i), s.add(o), s
            }
        };
        var Fd = function() {
                this._inputPolys = null,
                this._geomFactory = null;
                var t = arguments[0];
                this._inputPolys = t,
                null === this._inputPolys && (this._inputPolys = new lh)
            },
            kd = {
                STRTREE_NODE_CAPACITY: {
                    configurable: !0
                }
            };
        Fd.prototype.reduceToGeometries = function(t) {
            for (var e = new lh, n = t.iterator(); n.hasNext();) {
                var r = n.next(),
                    i = null;
                dl(r, ah) ? i = this.unionTree(r) : r instanceof Wl && (i = r),
                e.add(i)
            }
            return e
        },
        Fd.prototype.extractByEnvelope = function(t, e, n) {
            for (var r = new lh, i = 0; i < e.getNumGeometries(); i++) {
                var o = e.getGeometryN(i);
                o.getEnvelopeInternal().intersects(t) ? r.add(o) : n.add(o)
            }
            return this._geomFactory.buildGeometry(r)
        },
        Fd.prototype.unionOptimized = function(t, e) {
            var n = t.getEnvelopeInternal(),
                r = e.getEnvelopeInternal();
            if (!n.intersects(r))
                return Dd.combine(t, e);
            if (t.getNumGeometries() <= 1 && e.getNumGeometries() <= 1)
                return this.unionActual(t, e);
            var i = n.intersection(r);
            return this.unionUsingEnvelopeIntersection(t, e, i)
        },
        Fd.prototype.union = function() {
            if (null === this._inputPolys)
                throw new Error("union() method cannot be called twice");
            if (this._inputPolys.isEmpty())
                return null;
            this._geomFactory = this._inputPolys.iterator().next().getFactory();
            for (var t = new up(Fd.STRTREE_NODE_CAPACITY), e = this._inputPolys.iterator(); e.hasNext();) {
                var n = e.next();
                t.insert(n.getEnvelopeInternal(), n)
            }
            this._inputPolys = null;
            var r = t.itemsTree();
            return this.unionTree(r)
        },
        Fd.prototype.binaryUnion = function() {
            if (1 === arguments.length) {
                var t = arguments[0];
                return this.binaryUnion(t, 0, t.size())
            }
            if (3 === arguments.length) {
                var e = arguments[0],
                    n = arguments[1],
                    r = arguments[2];
                if (r - n <= 1) {
                    var i = Fd.getGeometry(e, n);
                    return this.unionSafe(i, null)
                }
                if (r - n == 2)
                    return this.unionSafe(Fd.getGeometry(e, n), Fd.getGeometry(e, n + 1));
                var o = Math.trunc((r + n) / 2),
                    s = this.binaryUnion(e, n, o),
                    a = this.binaryUnion(e, o, r);
                return this.unionSafe(s, a)
            }
        },
        Fd.prototype.repeatedUnion = function(t) {
            for (var e = null, n = t.iterator(); n.hasNext();) {
                var r = n.next();
                e = null === e ? r.copy() : e.union(r)
            }
            return e
        },
        Fd.prototype.unionSafe = function(t, e) {
            return null === t && null === e ? null : null === t ? e.copy() : null === e ? t.copy() : this.unionOptimized(t, e)
        },
        Fd.prototype.unionActual = function(t, e) {
            return Fd.restrictToPolygons(t.union(e))
        },
        Fd.prototype.unionTree = function(t) {
            var e = this.reduceToGeometries(t);
            return this.binaryUnion(e)
        },
        Fd.prototype.unionUsingEnvelopeIntersection = function(t, e, n) {
            var r = new lh,
                i = this.extractByEnvelope(n, t, r),
                o = this.extractByEnvelope(n, e, r),
                s = this.unionActual(i, o);
            return r.add(s), Dd.combine(r)
        },
        Fd.prototype.bufferUnion = function() {
            if (1 === arguments.length) {
                var t = arguments[0];
                return t.get(0).getFactory().buildGeometry(t).buffer(0)
            }
            if (2 === arguments.length) {
                var e = arguments[0],
                    n = arguments[1];
                return e.getFactory().createGeometryCollection([e, n]).buffer(0)
            }
        },
        Fd.prototype.interfaces_ = function() {
            return []
        },
        Fd.prototype.getClass = function() {
            return Fd
        },
        Fd.restrictToPolygons = function(t) {
            if (dl(t, Qh))
                return t;
            var e = Sf.getPolygons(t);
            return 1 === e.size() ? e.get(0) : t.getFactory().createMultiPolygon(mc.toPolygonArray(e))
        },
        Fd.getGeometry = function(t, e) {
            return e >= t.size() ? null : t.get(e)
        },
        Fd.union = function(t) {
            return new Fd(t).union()
        },
        kd.STRTREE_NODE_CAPACITY.get = function() {
            return 4
        },
        Object.defineProperties(Fd, kd);
        var jd = function() {};
        function Gd() {
            return new Bd
        }
        function Bd() {
            this.reset()
        }
        jd.prototype.interfaces_ = function() {
            return []
        },
        jd.prototype.getClass = function() {
            return jd
        },
        jd.union = function(t, e) {
            if (t.isEmpty() || e.isEmpty()) {
                if (t.isEmpty() && e.isEmpty())
                    return Pd.createEmptyResult(Pd.UNION, t, e, t.getFactory());
                if (t.isEmpty())
                    return e.copy();
                if (e.isEmpty())
                    return t.copy()
            }
            return t.checkNotGeometryCollection(t), t.checkNotGeometryCollection(e), ud.overlayOp(t, e, Pd.UNION)
        },
        Bd.prototype = {
            constructor: Bd,
            reset: function() {
                this.s = this.t = 0
            },
            add: function(t) {
                zd(qd, t, this.t),
                zd(this, qd.s, this.s),
                this.s ? this.t += qd.t : this.s = qd.t
            },
            valueOf: function() {
                return this.s
            }
        };
        var qd = new Bd;
        function zd(t, e, n) {
            var r = t.s = e + n,
                i = r - e,
                o = r - i;
            t.t = e - o + (n - i)
        }
        var Ud = 1e-6,
            Vd = Math.PI,
            Xd = Vd / 2,
            Hd = Vd / 4,
            Yd = 2 * Vd,
            Wd = 180 / Vd,
            $d = Vd / 180,
            Kd = Math.abs,
            Zd = Math.atan,
            Jd = Math.atan2,
            Qd = Math.cos,
            tg = Math.sin,
            eg = Math.sqrt;
        function ng(t) {
            return t > 1 ? 0 : t < -1 ? Vd : Math.acos(t)
        }
        function rg(t) {
            return t > 1 ? Xd : t < -1 ? -Xd : Math.asin(t)
        }
        function ig() {}
        function og(t, e) {
            t && lg.hasOwnProperty(t.type) && lg[t.type](t, e)
        }
        var sg,
            ag,
            ug = {
                Feature: function(t, e) {
                    og(t.geometry, e)
                },
                FeatureCollection: function(t, e) {
                    for (var n = t.features, r = -1, i = n.length; ++r < i;)
                        og(n[r].geometry, e)
                }
            },
            lg = {
                Sphere: function(t, e) {
                    e.sphere()
                },
                Point: function(t, e) {
                    t = t.coordinates,
                    e.point(t[0], t[1], t[2])
                },
                MultiPoint: function(t, e) {
                    for (var n = t.coordinates, r = -1, i = n.length; ++r < i;)
                        t = n[r],
                        e.point(t[0], t[1], t[2])
                },
                LineString: function(t, e) {
                    hg(t.coordinates, e, 0)
                },
                MultiLineString: function(t, e) {
                    for (var n = t.coordinates, r = -1, i = n.length; ++r < i;)
                        hg(n[r], e, 0)
                },
                Polygon: function(t, e) {
                    cg(t.coordinates, e)
                },
                MultiPolygon: function(t, e) {
                    for (var n = t.coordinates, r = -1, i = n.length; ++r < i;)
                        cg(n[r], e)
                },
                GeometryCollection: function(t, e) {
                    for (var n = t.geometries, r = -1, i = n.length; ++r < i;)
                        og(n[r], e)
                }
            };
        function hg(t, e, n) {
            var r,
                i = -1,
                o = t.length - n;
            for (e.lineStart(); ++i < o;)
                r = t[i],
                e.point(r[0], r[1], r[2]);
            e.lineEnd()
        }
        function cg(t, e) {
            var n = -1,
                r = t.length;
            for (e.polygonStart(); ++n < r;)
                hg(t[n], e, 1);
            e.polygonEnd()
        }
        function pg(t) {
            return [Jd(t[1], t[0]), rg(t[2])]
        }
        function fg(t) {
            var e = t[0],
                n = t[1],
                r = Qd(n);
            return [r * Qd(e), r * tg(e), tg(n)]
        }
        function dg(t, e) {
            return t[0] * e[0] + t[1] * e[1] + t[2] * e[2]
        }
        function gg(t, e) {
            return [t[1] * e[2] - t[2] * e[1], t[2] * e[0] - t[0] * e[2], t[0] * e[1] - t[1] * e[0]]
        }
        function yg(t, e) {
            t[0] += e[0],
            t[1] += e[1],
            t[2] += e[2]
        }
        function vg(t, e) {
            return [t[0] * e, t[1] * e, t[2] * e]
        }
        function mg(t) {
            var e = eg(t[0] * t[0] + t[1] * t[1] + t[2] * t[2]);
            t[0] /= e,
            t[1] /= e,
            t[2] /= e
        }
        function _g(t, e) {
            function n(n, r) {
                return n = t(n, r), e(n[0], n[1])
            }
            return t.invert && e.invert && (n.invert = function(n, r) {
                return (n = e.invert(n, r)) && t.invert(n[0], n[1])
            }), n
        }
        function xg(t, e) {
            return [t > Vd ? t - Yd : t < -Vd ? t + Yd : t, e]
        }
        function Eg(t) {
            return function(e, n) {
                return [(e += t) > Vd ? e - Yd : e < -Vd ? e + Yd : e, n]
            }
        }
        function wg(t) {
            var e = Eg(t);
            return e.invert = Eg(-t), e
        }
        function bg(t, e) {
            var n = Qd(t),
                r = tg(t),
                i = Qd(e),
                o = tg(e);
            function s(t, e) {
                var s = Qd(e),
                    a = Qd(t) * s,
                    u = tg(t) * s,
                    l = tg(e),
                    h = l * n + a * r;
                return [Jd(u * i - h * o, a * n - l * r), rg(h * i + u * o)]
            }
            return s.invert = function(t, e) {
                var s = Qd(e),
                    a = Qd(t) * s,
                    u = tg(t) * s,
                    l = tg(e),
                    h = l * i - u * o;
                return [Jd(u * i + l * o, a * n + h * r), rg(h * n - a * r)]
            }, s
        }
        function Cg(t, e) {
            (e = fg(e))[0] -= t,
            mg(e);
            var n = ng(-e[1]);
            return ((-e[2] < 0 ? -n : n) + Yd - Ud) % Yd
        }
        function Mg() {
            var t,
                e = [];
            return {
                point: function(e, n) {
                    t.push([e, n])
                },
                lineStart: function() {
                    e.push(t = [])
                },
                lineEnd: ig,
                rejoin: function() {
                    e.length > 1 && e.push(e.pop().concat(e.shift()))
                },
                result: function() {
                    var n = e;
                    return e = [], t = null, n
                }
            }
        }
        function Sg(t, e) {
            return Kd(t[0] - e[0]) < Ud && Kd(t[1] - e[1]) < Ud
        }
        function Ig(t, e, n, r) {
            this.x = t,
            this.z = e,
            this.o = n,
            this.e = r,
            this.v = !1,
            this.n = this.p = null
        }
        function Tg(t, e, n, r, i) {
            var o,
                s,
                a = [],
                u = [];
            if (t.forEach((function(t) {
                if (!((e = t.length - 1) <= 0)) {
                    var e,
                        n,
                        r = t[0],
                        s = t[e];
                    if (Sg(r, s)) {
                        for (i.lineStart(), o = 0; o < e; ++o)
                            i.point((r = t[o])[0], r[1]);
                        i.lineEnd()
                    } else
                        a.push(n = new Ig(r, t, null, !0)),
                        u.push(n.o = new Ig(r, null, n, !1)),
                        a.push(n = new Ig(s, t, null, !1)),
                        u.push(n.o = new Ig(s, null, n, !0))
                }
            })), a.length) {
                for (u.sort(e), Pg(a), Pg(u), o = 0, s = u.length; o < s; ++o)
                    u[o].e = n = !n;
                for (var l, h, c = a[0];;) {
                    for (var p = c, f = !0; p.v;)
                        if ((p = p.n) === c)
                            return;
                    l = p.z,
                    i.lineStart();
                    do {
                        if (p.v = p.o.v = !0, p.e) {
                            if (f)
                                for (o = 0, s = l.length; o < s; ++o)
                                    i.point((h = l[o])[0], h[1]);
                            else
                                r(p.x, p.n.x, 1, i);
                            p = p.n
                        } else {
                            if (f)
                                for (l = p.p.z, o = l.length - 1; o >= 0; --o)
                                    i.point((h = l[o])[0], h[1]);
                            else
                                r(p.x, p.p.x, -1, i);
                            p = p.p
                        }
                        l = (p = p.o).z,
                        f = !f
                    } while (!p.v);
                    i.lineEnd()
                }
            }
        }
        function Pg(t) {
            if (e = t.length) {
                for (var e, n, r = 0, i = t[0]; ++r < e;)
                    i.n = n = t[r],
                    n.p = i,
                    i = n;
                i.n = n = t[0],
                n.p = i
            }
        }
        function Lg(t, e) {
            return t < e ? -1 : t > e ? 1 : t >= e ? 0 : NaN
        }
        function Og(t) {
            for (var e, n, r, i = t.length, o = -1, s = 0; ++o < i;)
                s += t[o].length;
            for (n = new Array(s); --i >= 0;)
                for (e = (r = t[i]).length; --e >= 0;)
                    n[--s] = r[e];
            return n
        }
        Gd(),
        Gd(),
        Gd(),
        xg.invert = xg,
        1 === (sg = Lg).length && (ag = sg, sg = function(t, e) {
            return Lg(ag(t), e)
        });
        var Ng = 1e9,
            Rg = -Ng;
        function Ag(t, e, n, r) {
            function i(i, o) {
                return t <= i && i <= n && e <= o && o <= r
            }
            function o(i, o, a, l) {
                var h = 0,
                    c = 0;
                if (null == i || (h = s(i, a)) !== (c = s(o, a)) || u(i, o) < 0 ^ a > 0)
                    do {
                        l.point(0 === h || 3 === h ? t : n, h > 1 ? r : e)
                    } while ((h = (h + a + 4) % 4) !== c);
                else
                    l.point(o[0], o[1])
            }
            function s(r, i) {
                return Kd(r[0] - t) < Ud ? i > 0 ? 0 : 3 : Kd(r[0] - n) < Ud ? i > 0 ? 2 : 1 : Kd(r[1] - e) < Ud ? i > 0 ? 1 : 0 : i > 0 ? 3 : 2
            }
            function a(t, e) {
                return u(t.x, e.x)
            }
            function u(t, e) {
                var n = s(t, 1),
                    r = s(e, 1);
                return n !== r ? n - r : 0 === n ? e[1] - t[1] : 1 === n ? t[0] - e[0] : 2 === n ? t[1] - e[1] : e[0] - t[0]
            }
            return function(s) {
                var u,
                    l,
                    h,
                    c,
                    p,
                    f,
                    d,
                    g,
                    y,
                    v,
                    m,
                    _ = s,
                    x = Mg(),
                    E = {
                        point: w,
                        lineStart: function() {
                            E.point = b,
                            l && l.push(h = []),
                            v = !0,
                            y = !1,
                            d = g = NaN
                        },
                        lineEnd: function() {
                            u && (b(c, p), f && y && x.rejoin(), u.push(x.result())),
                            E.point = w,
                            y && _.lineEnd()
                        },
                        polygonStart: function() {
                            _ = x,
                            u = [],
                            l = [],
                            m = !0
                        },
                        polygonEnd: function() {
                            var e = function() {
                                    for (var e = 0, n = 0, i = l.length; n < i; ++n)
                                        for (var o, s, a = l[n], u = 1, h = a.length, c = a[0], p = c[0], f = c[1]; u < h; ++u)
                                            o = p,
                                            s = f,
                                            p = (c = a[u])[0],
                                            f = c[1],
                                            s <= r ? f > r && (p - o) * (r - s) > (f - s) * (t - o) && ++e : f <= r && (p - o) * (r - s) < (f - s) * (t - o) && --e;
                                    return e
                                }(),
                                n = m && e,
                                i = (u = Og(u)).length;
                            (n || i) && (s.polygonStart(), n && (s.lineStart(), o(null, null, 1, s), s.lineEnd()), i && Tg(u, a, e, o, s), s.polygonEnd()),
                            _ = s,
                            u = l = h = null
                        }
                    };
                function w(t, e) {
                    i(t, e) && _.point(t, e)
                }
                function b(o, s) {
                    var a = i(o, s);
                    if (l && h.push([o, s]), v)
                        c = o,
                        p = s,
                        f = a,
                        v = !1,
                        a && (_.lineStart(), _.point(o, s));
                    else if (a && y)
                        _.point(o, s);
                    else {
                        var u = [d = Math.max(Rg, Math.min(Ng, d)), g = Math.max(Rg, Math.min(Ng, g))],
                            x = [o = Math.max(Rg, Math.min(Ng, o)), s = Math.max(Rg, Math.min(Ng, s))];
                        !function(t, e, n, r, i, o) {
                            var s,
                                a = t[0],
                                u = t[1],
                                l = 0,
                                h = 1,
                                c = e[0] - a,
                                p = e[1] - u;
                            if (s = n - a, c || !(s > 0)) {
                                if (s /= c, c < 0) {
                                    if (s < l)
                                        return;
                                    s < h && (h = s)
                                } else if (c > 0) {
                                    if (s > h)
                                        return;
                                    s > l && (l = s)
                                }
                                if (s = i - a, c || !(s < 0)) {
                                    if (s /= c, c < 0) {
                                        if (s > h)
                                            return;
                                        s > l && (l = s)
                                    } else if (c > 0) {
                                        if (s < l)
                                            return;
                                        s < h && (h = s)
                                    }
                                    if (s = r - u, p || !(s > 0)) {
                                        if (s /= p, p < 0) {
                                            if (s < l)
                                                return;
                                            s < h && (h = s)
                                        } else if (p > 0) {
                                            if (s > h)
                                                return;
                                            s > l && (l = s)
                                        }
                                        if (s = o - u, p || !(s < 0)) {
                                            if (s /= p, p < 0) {
                                                if (s > h)
                                                    return;
                                                s > l && (l = s)
                                            } else if (p > 0) {
                                                if (s < l)
                                                    return;
                                                s < h && (h = s)
                                            }
                                            return l > 0 && (t[0] = a + l * c, t[1] = u + l * p), h < 1 && (e[0] = a + h * c, e[1] = u + h * p), !0
                                        }
                                    }
                                }
                            }
                        }(u, x, t, e, n, r) ? a && (_.lineStart(), _.point(o, s), m = !1) : (y || (_.lineStart(), _.point(u[0], u[1])), _.point(x[0], x[1]), a || _.lineEnd(), m = !1)
                    }
                    d = o,
                    g = s,
                    y = a
                }
                return E
            }
        }
        var Dg = Gd();
        function Fg(t) {
            return t
        }
        Gd(),
        Gd(),
        Gd();
        var kg = 1 / 0,
            jg = kg,
            Gg = -kg,
            Bg = Gg,
            qg = {
                point: function(t, e) {
                    t < kg && (kg = t),
                    t > Gg && (Gg = t),
                    e < jg && (jg = e),
                    e > Bg && (Bg = e)
                },
                lineStart: ig,
                lineEnd: ig,
                polygonStart: ig,
                polygonEnd: ig,
                result: function() {
                    var t = [[kg, jg], [Gg, Bg]];
                    return Gg = Bg = -(jg = kg = 1 / 0), t
                }
            };
        function zg(t, e, n, r) {
            return function(i, o) {
                var s,
                    a,
                    u,
                    l = e(o),
                    h = i.invert(r[0], r[1]),
                    c = Mg(),
                    p = e(c),
                    f = !1,
                    d = {
                        point: g,
                        lineStart: v,
                        lineEnd: m,
                        polygonStart: function() {
                            d.point = _,
                            d.lineStart = x,
                            d.lineEnd = E,
                            a = [],
                            s = []
                        },
                        polygonEnd: function() {
                            d.point = g,
                            d.lineStart = v,
                            d.lineEnd = m,
                            a = Og(a);
                            var t = function(t, e) {
                                var n = e[0],
                                    r = e[1],
                                    i = [tg(n), -Qd(n), 0],
                                    o = 0,
                                    s = 0;
                                Dg.reset();
                                for (var a = 0, u = t.length; a < u; ++a)
                                    if (h = (l = t[a]).length)
                                        for (var l, h, c = l[h - 1], p = c[0], f = c[1] / 2 + Hd, d = tg(f), g = Qd(f), y = 0; y < h; ++y, p = m, d = x, g = E, c = v) {
                                            var v = l[y],
                                                m = v[0],
                                                _ = v[1] / 2 + Hd,
                                                x = tg(_),
                                                E = Qd(_),
                                                w = m - p,
                                                b = w >= 0 ? 1 : -1,
                                                C = b * w,
                                                M = C > Vd,
                                                S = d * x;
                                            if (Dg.add(Jd(S * b * tg(C), g * E + S * Qd(C))), o += M ? w + b * Yd : w, M ^ p >= n ^ m >= n) {
                                                var I = gg(fg(c), fg(v));
                                                mg(I);
                                                var T = gg(i, I);
                                                mg(T);
                                                var P = (M ^ w >= 0 ? -1 : 1) * rg(T[2]);
                                                (r > P || r === P && (I[0] || I[1])) && (s += M ^ w >= 0 ? 1 : -1)
                                            }
                                        }
                                return (o < -1e-6 || o < Ud && Dg < -1e-6) ^ 1 & s
                            }(s, h);
                            a.length ? (f || (o.polygonStart(), f = !0), Tg(a, Vg, t, n, o)) : t && (f || (o.polygonStart(), f = !0), o.lineStart(), n(null, null, 1, o), o.lineEnd()),
                            f && (o.polygonEnd(), f = !1),
                            a = s = null
                        },
                        sphere: function() {
                            o.polygonStart(),
                            o.lineStart(),
                            n(null, null, 1, o),
                            o.lineEnd(),
                            o.polygonEnd()
                        }
                    };
                function g(e, n) {
                    var r = i(e, n);
                    t(e = r[0], n = r[1]) && o.point(e, n)
                }
                function y(t, e) {
                    var n = i(t, e);
                    l.point(n[0], n[1])
                }
                function v() {
                    d.point = y,
                    l.lineStart()
                }
                function m() {
                    d.point = g,
                    l.lineEnd()
                }
                function _(t, e) {
                    u.push([t, e]);
                    var n = i(t, e);
                    p.point(n[0], n[1])
                }
                function x() {
                    p.lineStart(),
                    u = []
                }
                function E() {
                    _(u[0][0], u[0][1]),
                    p.lineEnd();
                    var t,
                        e,
                        n,
                        r,
                        i = p.clean(),
                        l = c.result(),
                        h = l.length;
                    if (u.pop(), s.push(u), u = null, h)
                        if (1 & i) {
                            if ((e = (n = l[0]).length - 1) > 0) {
                                for (f || (o.polygonStart(), f = !0), o.lineStart(), t = 0; t < e; ++t)
                                    o.point((r = n[t])[0], r[1]);
                                o.lineEnd()
                            }
                        } else
                            h > 1 && 2 & i && l.push(l.pop().concat(l.shift())),
                            a.push(l.filter(Ug))
                }
                return d
            }
        }
        function Ug(t) {
            return t.length > 1
        }
        function Vg(t, e) {
            return ((t = t.x)[0] < 0 ? t[1] - Xd - Ud : Xd - t[1]) - ((e = e.x)[0] < 0 ? e[1] - Xd - Ud : Xd - e[1])
        }
        Gd();
        var Xg = zg((function() {
            return !0
        }), (function(t) {
            var e,
                n = NaN,
                r = NaN,
                i = NaN;
            return {
                lineStart: function() {
                    t.lineStart(),
                    e = 1
                },
                point: function(o, s) {
                    var a = o > 0 ? Vd : -Vd,
                        u = Kd(o - n);
                    Kd(u - Vd) < Ud ? (t.point(n, r = (r + s) / 2 > 0 ? Xd : -Xd), t.point(i, r), t.lineEnd(), t.lineStart(), t.point(a, r), t.point(o, r), e = 0) : i !== a && u >= Vd && (Kd(n - i) < Ud && (n -= i * Ud), Kd(o - a) < Ud && (o -= a * Ud), r = function(t, e, n, r) {
                        var i,
                            o,
                            s = tg(t - n);
                        return Kd(s) > Ud ? Zd((tg(e) * (o = Qd(r)) * tg(n) - tg(r) * (i = Qd(e)) * tg(t)) / (i * o * s)) : (e + r) / 2
                    }(n, r, o, s), t.point(i, r), t.lineEnd(), t.lineStart(), t.point(a, r), e = 0),
                    t.point(n = o, r = s),
                    i = a
                },
                lineEnd: function() {
                    t.lineEnd(),
                    n = r = NaN
                },
                clean: function() {
                    return 2 - e
                }
            }
        }), (function(t, e, n, r) {
            var i;
            if (null == t)
                i = n * Xd,
                r.point(-Vd, i),
                r.point(0, i),
                r.point(Vd, i),
                r.point(Vd, 0),
                r.point(Vd, -i),
                r.point(0, -i),
                r.point(-Vd, -i),
                r.point(-Vd, 0),
                r.point(-Vd, i);
            else if (Kd(t[0] - e[0]) > Ud) {
                var o = t[0] < e[0] ? Vd : -Vd;
                i = n * o / 2,
                r.point(-o, i),
                r.point(0, i),
                r.point(o, i)
            } else
                r.point(e[0], e[1])
        }), [-Vd, -Xd]);
        function Hg(t, e) {
            var n = Qd(t),
                r = n > 0,
                i = Kd(n) > Ud;
            function o(t, e) {
                return Qd(t) * Qd(e) > n
            }
            function s(t, e, r) {
                var i = [1, 0, 0],
                    o = gg(fg(t), fg(e)),
                    s = dg(o, o),
                    a = o[0],
                    u = s - a * a;
                if (!u)
                    return !r && t;
                var l = n * s / u,
                    h = -n * a / u,
                    c = gg(i, o),
                    p = vg(i, l);
                yg(p, vg(o, h));
                var f = c,
                    d = dg(p, f),
                    g = dg(f, f),
                    y = d * d - g * (dg(p, p) - 1);
                if (!(y < 0)) {
                    var v = eg(y),
                        m = vg(f, (-d - v) / g);
                    if (yg(m, p), m = pg(m), !r)
                        return m;
                    var _,
                        x = t[0],
                        E = e[0],
                        w = t[1],
                        b = e[1];
                    E < x && (_ = x, x = E, E = _);
                    var C = E - x,
                        M = Kd(C - Vd) < Ud;
                    if (!M && b < w && (_ = w, w = b, b = _), M || C < Ud ? M ? w + b > 0 ^ m[1] < (Kd(m[0] - x) < Ud ? w : b) : w <= m[1] && m[1] <= b : C > Vd ^ (x <= m[0] && m[0] <= E)) {
                        var S = vg(f, (-d + v) / g);
                        return yg(S, p), [m, pg(S)]
                    }
                }
            }
            function a(e, n) {
                var i = r ? t : Vd - t,
                    o = 0;
                return e < -i ? o |= 1 : e > i && (o |= 2), n < -i ? o |= 4 : n > i && (o |= 8), o
            }
            return zg(o, (function(t) {
                var e,
                    n,
                    u,
                    l,
                    h;
                return {
                    lineStart: function() {
                        l = u = !1,
                        h = 1
                    },
                    point: function(c, p) {
                        var f,
                            d = [c, p],
                            g = o(c, p),
                            y = r ? g ? 0 : a(c, p) : g ? a(c + (c < 0 ? Vd : -Vd), p) : 0;
                        if (!e && (l = u = g) && t.lineStart(), g !== u && (!(f = s(e, d)) || Sg(e, f) || Sg(d, f)) && (d[0] += Ud, d[1] += Ud, g = o(d[0], d[1])), g !== u)
                            h = 0,
                            g ? (t.lineStart(), f = s(d, e), t.point(f[0], f[1])) : (f = s(e, d), t.point(f[0], f[1]), t.lineEnd()),
                            e = f;
                        else if (i && e && r ^ g) {
                            var v;
                            y & n || !(v = s(d, e, !0)) || (h = 0, r ? (t.lineStart(), t.point(v[0][0], v[0][1]), t.point(v[1][0], v[1][1]), t.lineEnd()) : (t.point(v[1][0], v[1][1]), t.lineEnd(), t.lineStart(), t.point(v[0][0], v[0][1])))
                        }
                        !g || e && Sg(e, d) || t.point(d[0], d[1]),
                        e = d,
                        u = g,
                        n = y
                    },
                    lineEnd: function() {
                        u && t.lineEnd(),
                        e = null
                    },
                    clean: function() {
                        return h | (l && u) << 1
                    }
                }
            }), (function(n, r, i, o) {
                !function(t, e, n, r, i, o) {
                    if (n) {
                        var s = Qd(e),
                            a = tg(e),
                            u = r * n;
                        null == i ? (i = e + r * Yd, o = e - u / 2) : (i = Cg(s, i), o = Cg(s, o), (r > 0 ? i < o : i > o) && (i += r * Yd));
                        for (var l, h = i; r > 0 ? h > o : h < o; h -= u)
                            l = pg([s, -a * Qd(h), -a * tg(h)]),
                            t.point(l[0], l[1])
                    }
                }(o, t, e, i, n, r)
            }), r ? [0, -t] : [-Vd, t - Vd])
        }
        function Yg(t) {
            return function(e) {
                var n = new Wg;
                for (var r in t)
                    n[r] = t[r];
                return n.stream = e, n
            }
        }
        function Wg() {}
        function $g(t, e, n) {
            var r = e[1][0] - e[0][0],
                i = e[1][1] - e[0][1],
                o = t.clipExtent && t.clipExtent();
            t.scale(150).translate([0, 0]),
            null != o && t.clipExtent(null),
            function(t, e) {
                t && ug.hasOwnProperty(t.type) ? ug[t.type](t, e) : og(t, e)
            }(n, t.stream(qg));
            var s = qg.result(),
                a = Math.min(r / (s[1][0] - s[0][0]), i / (s[1][1] - s[0][1])),
                u = +e[0][0] + (r - a * (s[1][0] + s[0][0])) / 2,
                l = +e[0][1] + (i - a * (s[1][1] + s[0][1])) / 2;
            return null != o && t.clipExtent(o), t.scale(150 * a).translate([u, l])
        }
        Wg.prototype = {
            constructor: Wg,
            point: function(t, e) {
                this.stream.point(t, e)
            },
            sphere: function() {
                this.stream.sphere()
            },
            lineStart: function() {
                this.stream.lineStart()
            },
            lineEnd: function() {
                this.stream.lineEnd()
            },
            polygonStart: function() {
                this.stream.polygonStart()
            },
            polygonEnd: function() {
                this.stream.polygonEnd()
            }
        };
        var Kg = Qd(30 * $d);
        function Zg(t, e) {
            return +e ? function(t, e) {
                function n(r, i, o, s, a, u, l, h, c, p, f, d, g, y) {
                    var v = l - r,
                        m = h - i,
                        _ = v * v + m * m;
                    if (_ > 4 * e && g--) {
                        var x = s + p,
                            E = a + f,
                            w = u + d,
                            b = eg(x * x + E * E + w * w),
                            C = rg(w /= b),
                            M = Kd(Kd(w) - 1) < Ud || Kd(o - c) < Ud ? (o + c) / 2 : Jd(E, x),
                            S = t(M, C),
                            I = S[0],
                            T = S[1],
                            P = I - r,
                            L = T - i,
                            O = m * P - v * L;
                        (O * O / _ > e || Kd((v * P + m * L) / _ - .5) > .3 || s * p + a * f + u * d < Kg) && (n(r, i, o, s, a, u, I, T, M, x /= b, E /= b, w, g, y), y.point(I, T), n(I, T, M, x, E, w, l, h, c, p, f, d, g, y))
                    }
                }
                return function(e) {
                    var r,
                        i,
                        o,
                        s,
                        a,
                        u,
                        l,
                        h,
                        c,
                        p,
                        f,
                        d,
                        g = {
                            point: y,
                            lineStart: v,
                            lineEnd: _,
                            polygonStart: function() {
                                e.polygonStart(),
                                g.lineStart = x
                            },
                            polygonEnd: function() {
                                e.polygonEnd(),
                                g.lineStart = v
                            }
                        };
                    function y(n, r) {
                        n = t(n, r),
                        e.point(n[0], n[1])
                    }
                    function v() {
                        h = NaN,
                        g.point = m,
                        e.lineStart()
                    }
                    function m(r, i) {
                        var o = fg([r, i]),
                            s = t(r, i);
                        n(h, c, l, p, f, d, h = s[0], c = s[1], l = r, p = o[0], f = o[1], d = o[2], 16, e),
                        e.point(h, c)
                    }
                    function _() {
                        g.point = y,
                        e.lineEnd()
                    }
                    function x() {
                        v(),
                        g.point = E,
                        g.lineEnd = w
                    }
                    function E(t, e) {
                        m(r = t, e),
                        i = h,
                        o = c,
                        s = p,
                        a = f,
                        u = d,
                        g.point = m
                    }
                    function w() {
                        n(h, c, l, p, f, d, i, o, r, s, a, u, 16, e),
                        g.lineEnd = _,
                        _()
                    }
                    return g
                }
            }(t, e) : function(t) {
                return Yg({
                    point: function(e, n) {
                        e = t(e, n),
                        this.stream.point(e[0], e[1])
                    }
                })
            }(t)
        }
        var Jg = Yg({
            point: function(t, e) {
                this.stream.point(t * $d, e * $d)
            }
        });
        function Qg(t) {
            return function(t) {
                var e,
                    n,
                    r,
                    i,
                    o,
                    s,
                    a,
                    u,
                    l,
                    h,
                    c = 150,
                    p = 480,
                    f = 250,
                    d = 0,
                    g = 0,
                    y = 0,
                    v = 0,
                    m = 0,
                    _ = null,
                    x = Xg,
                    E = null,
                    w = Fg,
                    b = .5,
                    C = Zg(I, b);
                function M(t) {
                    return [(t = o(t[0] * $d, t[1] * $d))[0] * c + n, r - t[1] * c]
                }
                function S(t) {
                    return (t = o.invert((t[0] - n) / c, (r - t[1]) / c)) && [t[0] * Wd, t[1] * Wd]
                }
                function I(t, i) {
                    return [(t = e(t, i))[0] * c + n, r - t[1] * c]
                }
                function T() {
                    o = _g(i = function(t, e, n) {
                        return (t %= Yd) ? e || n ? _g(wg(t), bg(e, n)) : wg(t) : e || n ? bg(e, n) : xg
                    }(y, v, m), e);
                    var t = e(d, g);
                    return n = p - t[0] * c, r = f + t[1] * c, P()
                }
                function P() {
                    return l = h = null, M
                }
                return M.stream = function(t) {
                    return l && h === t ? l : l = Jg(x(i, C(w(h = t))))
                }, M.clipAngle = function(t) {
                    return arguments.length ? (x = +t ? Hg(_ = t * $d, 6 * $d) : (_ = null, Xg), P()) : _ * Wd
                }, M.clipExtent = function(t) {
                    return arguments.length ? (w = null == t ? (E = s = a = u = null, Fg) : Ag(E = +t[0][0], s = +t[0][1], a = +t[1][0], u = +t[1][1]), P()) : null == E ? null : [[E, s], [a, u]]
                }, M.scale = function(t) {
                    return arguments.length ? (c = +t, T()) : c
                }, M.translate = function(t) {
                    return arguments.length ? (p = +t[0], f = +t[1], T()) : [p, f]
                }, M.center = function(t) {
                    return arguments.length ? (d = t[0] % 360 * $d, g = t[1] % 360 * $d, T()) : [d * Wd, g * Wd]
                }, M.rotate = function(t) {
                    return arguments.length ? (y = t[0] % 360 * $d, v = t[1] % 360 * $d, m = t.length > 2 ? t[2] % 360 * $d : 0, T()) : [y * Wd, v * Wd, m * Wd]
                }, M.precision = function(t) {
                    return arguments.length ? (C = Zg(I, b = t * t), P()) : eg(b)
                }, M.fitExtent = function(t, e) {
                    return $g(M, t, e)
                }, M.fitSize = function(t, e) {
                    return function(t, e, n) {
                        return $g(t, [[0, 0], e], n)
                    }(M, t, e)
                }, function() {
                    return e = t.apply(this, arguments), M.invert = e.invert && S, T()
                }
            }((function() {
                return t
            }))()
        }
        var ty = function(t) {
            return function(e, n) {
                var r = Qd(e),
                    i = Qd(n),
                    o = t(r * i);
                return [o * i * tg(e), o * tg(n)]
            }
        }((function(t) {
            return (t = ng(t)) && t / tg(t)
        }));
        function ey() {
            return Qg(ty).scale(79.4188).clipAngle(179.999)
        }
        function ny(t, n, r, i) {
            var s = t.properties || {},
                a = "Feature" === t.type ? t.geometry : t;
            if ("GeometryCollection" === a.type) {
                var u = [];
                return G(t, (function(t) {
                    var e = ny(t, n, r, i);
                    e && u.push(e)
                })), f(u)
            }
            var l = function(t) {
                    var n = xn(t).geometry.coordinates,
                        r = [-n[0], -n[1]];
                    return ey().rotate(r).scale(e)
                }(a),
                h = {
                    type: a.type,
                    coordinates: iy(a.coordinates, l)
                },
                c = (new Cc).read(h),
                p = _(x(n, r), "meters"),
                d = mf.bufferOp(c, p, i);
            if (!ry((d = (new Mc).write(d)).coordinates))
                return o({
                    type: d.type,
                    coordinates: oy(d.coordinates, l)
                }, s)
        }
        function ry(t) {
            return Array.isArray(t[0]) ? ry(t[0]) : isNaN(t[0])
        }
        function iy(t, e) {
            return "object" != typeof t[0] ? e(t) : t.map((function(t) {
                return iy(t, e)
            }))
        }
        function oy(t, e) {
            return "object" != typeof t[0] ? e.invert(t) : t.map((function(t) {
                return oy(t, e)
            }))
        }
        function sy(t, e, n) {
            void 0 === n && (n = {});
            var r = rt(t),
                i = rt(e),
                o = Qu.intersection(r.coordinates, i.coordinates);
            return 0 === o.length ? null : 1 === o.length ? l(o[0], n.properties) : y(o, n.properties)
        }
        function ay(t, e, n) {
            void 0 === n && (n = {});
            var r = JSON.stringify(n.properties || {}),
                i = t[0],
                o = t[1],
                s = t[2],
                a = t[3],
                u = (o + a) / 2,
                l = (i + s) / 2,
                h = 2 * e / _e([i, u], [s, u], n) * (s - i),
                c = 2 * e / _e([l, o], [l, a], n) * (a - o),
                p = h / 2,
                d = 2 * p,
                g = Math.sqrt(3) / 2 * c,
                y = s - i,
                v = a - o,
                m = 3 / 4 * d,
                _ = g,
                x = (y - d) / (d - p / 2),
                E = Math.floor(x),
                w = (E * m - p / 2 - y) / 2 - p / 2 + m / 2,
                b = Math.floor((v - g) / g),
                C = (v - b * g) / 2,
                M = b * g - v > g / 2;
            M && (C -= g / 4);
            for (var S = [], I = [], T = 0; T < 6; T++) {
                var P = 2 * Math.PI / 6 * T;
                S.push(Math.cos(P)),
                I.push(Math.sin(P))
            }
            for (var L = [], O = 0; O <= E; O++)
                for (var N = 0; N <= b; N++) {
                    var R = O % 2 == 1;
                    if (!(0 === N && R || 0 === N && M)) {
                        var A = O * m + i - w,
                            D = N * _ + o + C;
                        if (R && (D -= g / 2), !0 === n.triangles)
                            ly([A, D], h / 2, c / 2, JSON.parse(r), S, I).forEach((function(t) {
                                n.mask ? sy(n.mask, t) && L.push(t) : L.push(t)
                            }));
                        else {
                            var F = uy([A, D], h / 2, c / 2, JSON.parse(r), S, I);
                            n.mask ? sy(n.mask, F) && L.push(F) : L.push(F)
                        }
                    }
                }
            return f(L)
        }
        function uy(t, e, n, r, i, o) {
            for (var s = [], a = 0; a < 6; a++) {
                var u = t[0] + e * i[a],
                    h = t[1] + n * o[a];
                s.push([u, h])
            }
            return s.push(s[0].slice()), l([s], r)
        }
        function ly(t, e, n, r, i, o) {
            for (var s = [], a = 0; a < 6; a++) {
                var u = [];
                u.push(t),
                u.push([t[0] + e * i[a], t[1] + n * o[a]]),
                u.push([t[0] + e * i[(a + 1) % 6], t[1] + n * o[(a + 1) % 6]]),
                u.push(t),
                s.push(l([u], r))
            }
            return s
        }
        function hy(t) {
            return y(t)
        }
        function cy(t) {
            return l(t && t.geometry.coordinates || [[[180, 90], [-180, 90], [-180, -90], [180, -90], [180, 90]]])
        }
        function py(t, e, n) {
            return void 0 === n && (n = {}), function(t, e, n, r) {
                void 0 === r && (r = {});
                for (var i = [], o = t[0], s = t[1], a = t[2], u = t[3], h = e / _e([o, s], [a, s], r) * (a - o), c = n / _e([o, s], [o, u], r) * (u - s), p = a - o, d = u - s, g = Math.floor(p / h), y = Math.floor(d / c), v = (d - y * c) / 2, m = o + (p - g * h) / 2, _ = 0; _ < g; _++) {
                    for (var x = s + v, E = 0; E < y; E++) {
                        var w = l([[[m, x], [m, x + c], [m + h, x + c], [m + h, x], [m, x]]], r.properties);
                        r.mask ? Ts(r.mask, w) && i.push(w) : i.push(w),
                        x += c
                    }
                    m += h
                }
                return f(i)
            }(t, e, e, n)
        }
        function fy(t, e, n) {
            void 0 === n && (n = {});
            for (var r = [], i = e / _e([t[0], t[1]], [t[2], t[1]], n) * (t[2] - t[0]), o = e / _e([t[0], t[1]], [t[0], t[3]], n) * (t[3] - t[1]), s = 0, a = t[0]; a <= t[2];) {
                for (var u = 0, h = t[1]; h <= t[3];) {
                    var c = null,
                        p = null;
                    s % 2 == 0 && u % 2 == 0 ? (c = l([[[a, h], [a, h + o], [a + i, h], [a, h]]], n.properties), p = l([[[a, h + o], [a + i, h + o], [a + i, h], [a, h + o]]], n.properties)) : s % 2 == 0 && u % 2 == 1 ? (c = l([[[a, h], [a + i, h + o], [a + i, h], [a, h]]], n.properties), p = l([[[a, h], [a, h + o], [a + i, h + o], [a, h]]], n.properties)) : u % 2 == 0 && s % 2 == 1 ? (c = l([[[a, h], [a, h + o], [a + i, h + o], [a, h]]], n.properties), p = l([[[a, h], [a + i, h + o], [a + i, h], [a, h]]], n.properties)) : u % 2 == 1 && s % 2 == 1 && (c = l([[[a, h], [a, h + o], [a + i, h], [a, h]]], n.properties), p = l([[[a, h + o], [a + i, h + o], [a + i, h], [a, h + o]]], n.properties)),
                    n.mask ? (sy(n.mask, c) && r.push(c), sy(n.mask, p) && r.push(p)) : (r.push(c), r.push(p)),
                    h += o,
                    u++
                }
                s++,
                a += i
            }
            return f(r)
        }
        ty.invert = function(t) {
            return function(e, n) {
                var r = eg(e * e + n * n),
                    i = t(r),
                    o = tg(i),
                    s = Qd(i);
                return [Jd(e * o, r * s), rg(r && n * o / r)]
            }
        }((function(t) {
            return t
        })),
        t.along = function(t, e, n) {
            void 0 === n && (n = {});
            for (var r = rt(t).coordinates, i = 0, o = 0; o < r.length && !(e >= i && o === r.length - 1); o++) {
                if (i >= e) {
                    var s = e - i;
                    if (s) {
                        var u = _n(r[o], r[o - 1]) - 180;
                        return vn(r[o], s, u, n)
                    }
                    return a(r[o])
                }
                i += _e(r[o], r[o + 1], n)
            }
            return a(r[r.length - 1])
        },
        t.angle = function(t, e, n, r) {
            if (void 0 === r && (r = {}), !T(r))
                throw new Error("options is invalid");
            if (!t)
                throw new Error("startPoint is required");
            if (!e)
                throw new Error("midPoint is required");
            if (!n)
                throw new Error("endPoint is required");
            var i = t,
                o = e,
                s = n,
                a = w(!0 !== r.mercator ? _n(i, o) : Bi(i, o)),
                u = w(!0 !== r.mercator ? _n(s, o) : Bi(s, o)),
                l = Math.abs(a - u);
            return !0 === r.explementary ? 360 - l : l
        },
        t.applyFilter = uu,
        t.area = zr,
        t.areaFactors = i,
        t.bbox = K,
        t.bboxClip = function(t, e) {
            var n = rt(t),
                r = n.type,
                i = "Feature" === t.type ? t.properties : {},
                o = n.coordinates;
            switch (r) {
            case "LineString":
            case "MultiLineString":
                var s = [];
                return "LineString" === r && (o = [o]), o.forEach((function(t) {
                    !function(t, e, n) {
                        var r,
                            i,
                            o,
                            s,
                            a,
                            u = t.length,
                            l = Ni(t[0], e),
                            h = [];
                        for (n || (n = []), r = 1; r < u; r++) {
                            for (s = t[r - 1], i = o = Ni(a = t[r], e);;) {
                                if (!(l | i)) {
                                    h.push(s),
                                    i !== o ? (h.push(a), r < u - 1 && (n.push(h), h = [])) : r === u - 1 && h.push(a);
                                    break
                                }
                                if (l & i)
                                    break;
                                l ? l = Ni(s = Oi(s, a, l, e), e) : i = Ni(a = Oi(s, a, i, e), e)
                            }
                            l = o
                        }
                        h.length && n.push(h)
                    }(t, e, s)
                })), 1 === s.length ? c(s[0], i) : d(s, i);
            case "Polygon":
                return l(Ri(o, e), i);
            case "MultiPolygon":
                return y(o.map((function(t) {
                    return Ri(t, e)
                })), i);
            default:
                throw new Error("geometry " + r + " not supported")
            }
        },
        t.bboxPolygon = dn,
        t.bearing = _n,
        t.bearingToAngle = w,
        t.bearingToAzimuth = w,
        t.bezier = fn,
        t.bezierSpline = fn,
        t.booleanClockwise = Hi,
        t.booleanContains = function(t, e) {
            var n = rt(t),
                r = rt(e),
                i = n.type,
                o = r.type,
                s = n.coordinates,
                a = r.coordinates;
            switch (i) {
            case "Point":
                if ("Point" === o)
                    return vs(s, a);
                throw new Error("feature2 " + o + " geometry not supported");
            case "MultiPoint":
                switch (o) {
                case "Point":
                    return function(t, e) {
                        var n,
                            r = !1;
                        for (n = 0; n < t.coordinates.length; n++)
                            if (vs(t.coordinates[n], e.coordinates)) {
                                r = !0;
                                break
                            }
                        return r
                    }(n, r);
                case "MultiPoint":
                    return function(t, e) {
                        for (var n = 0, r = e.coordinates; n < r.length; n++) {
                            for (var i = r[n], o = !1, s = 0, a = t.coordinates; s < a.length; s++)
                                if (vs(i, a[s])) {
                                    o = !0;
                                    break
                                }
                            if (!o)
                                return !1
                        }
                        return !0
                    }(n, r);
                default:
                    throw new Error("feature2 " + o + " geometry not supported")
                }
            case "LineString":
                switch (o) {
                case "Point":
                    return Wr(r, n, {
                        ignoreEndVertices: !0
                    });
                case "LineString":
                    return function(t, e) {
                        for (var n = !1, r = 0, i = e.coordinates; r < i.length; r++) {
                            var o = i[r];
                            if (Wr({
                                type: "Point",
                                coordinates: o
                            }, t, {
                                ignoreEndVertices: !0
                            }) && (n = !0), !Wr({
                                type: "Point",
                                coordinates: o
                            }, t, {
                                ignoreEndVertices: !1
                            }))
                                return !1
                        }
                        return n
                    }(n, r);
                case "MultiPoint":
                    return function(t, e) {
                        for (var n = !1, r = 0, i = e.coordinates; r < i.length; r++) {
                            var o = i[r];
                            if (Wr(o, t, {
                                ignoreEndVertices: !0
                            }) && (n = !0), !Wr(o, t))
                                return !1
                        }
                        return !!n
                    }(n, r);
                default:
                    throw new Error("feature2 " + o + " geometry not supported")
                }
            case "Polygon":
                switch (o) {
                case "Point":
                    return ye(r, n, {
                        ignoreBoundary: !0
                    });
                case "LineString":
                    return function(t, e) {
                        var n = !1,
                            r = 0;
                        if (!ys(K(t), K(e)))
                            return !1;
                        for (; r < e.coordinates.length - 1; r++)
                            if (ye({
                                type: "Point",
                                coordinates: ms(e.coordinates[r], e.coordinates[r + 1])
                            }, t, {
                                ignoreBoundary: !0
                            })) {
                                n = !0;
                                break
                            }
                        return n
                    }(n, r);
                case "Polygon":
                    return function(t, e) {
                        if ("Feature" === t.type && null === t.geometry)
                            return !1;
                        if ("Feature" === e.type && null === e.geometry)
                            return !1;
                        if (!ys(K(t), K(e)))
                            return !1;
                        for (var n = 0, r = rt(e).coordinates; n < r.length; n++)
                            for (var i = 0, o = r[n]; i < o.length; i++)
                                if (!ye(o[i], t))
                                    return !1;
                        return !0
                    }(n, r);
                case "MultiPoint":
                    return function(t, e) {
                        for (var n = 0, r = e.coordinates; n < r.length; n++)
                            if (!ye(r[n], t, {
                                ignoreBoundary: !0
                            }))
                                return !1;
                        return !0
                    }(n, r);
                default:
                    throw new Error("feature2 " + o + " geometry not supported")
                }
            default:
                throw new Error("feature1 " + i + " geometry not supported")
            }
        },
        t.booleanCrosses = function(t, e) {
            var n = rt(t),
                r = rt(e),
                i = n.type,
                o = r.type;
            switch (i) {
            case "MultiPoint":
                switch (o) {
                case "LineString":
                    return _s(n, r);
                case "Polygon":
                    return Es(n, r);
                default:
                    throw new Error("feature2 " + o + " geometry not supported")
                }
            case "LineString":
                switch (o) {
                case "MultiPoint":
                    return _s(r, n);
                case "LineString":
                    return function(t, e) {
                        if (Or(t, e).features.length > 0)
                            for (var n = 0; n < t.coordinates.length - 1; n++)
                                for (var r = 0; r < e.coordinates.length - 1; r++) {
                                    var i = !0;
                                    if (0 !== r && r !== e.coordinates.length - 2 || (i = !1), ws(t.coordinates[n], t.coordinates[n + 1], e.coordinates[r], i))
                                        return !0
                                }
                        return !1
                    }(n, r);
                case "Polygon":
                    return xs(n, r);
                default:
                    throw new Error("feature2 " + o + " geometry not supported")
                }
            case "Polygon":
                switch (o) {
                case "MultiPoint":
                    return Es(r, n);
                case "LineString":
                    return xs(r, n);
                default:
                    throw new Error("feature2 " + o + " geometry not supported")
                }
            default:
                throw new Error("feature1 " + i + " geometry not supported")
            }
        },
        t.booleanDisjoint = ps,
        t.booleanEqual = function(t, e) {
            return rt(t).type === rt(e).type && new Is({
                    precision: 6
                }).compare(tn(t), tn(e))
        },
        t.booleanIntersects = Ts,
        t.booleanOverlap = function(t, e) {
            var n = rt(t),
                r = rt(e),
                i = n.type,
                o = r.type;
            if ("MultiPoint" === i && "MultiPoint" !== o || ("LineString" === i || "MultiLineString" === i) && "LineString" !== o && "MultiLineString" !== o || ("Polygon" === i || "MultiPolygon" === i) && "Polygon" !== o && "MultiPolygon" !== o)
                throw new Error("features must be of the same type");
            if ("Point" === i)
                throw new Error("Point geometry not supported");
            if (new Is({
                precision: 6
            }).compare(t, e))
                return !1;
            var s = 0;
            switch (i) {
            case "MultiPoint":
                for (var a = 0; a < n.coordinates.length; a++)
                    for (var u = 0; u < r.coordinates.length; u++) {
                        var l = n.coordinates[a],
                            h = r.coordinates[u];
                        if (l[0] === h[0] && l[1] === h[1])
                            return !0
                    }
                return !1;
            case "LineString":
            case "MultiLineString":
                U(t, (function(t) {
                    U(e, (function(e) {
                        ki(t, e).features.length && s++
                    }))
                }));
                break;
            case "Polygon":
            case "MultiPolygon":
                U(t, (function(t) {
                    U(e, (function(e) {
                        Or(t, e).features.length && s++
                    }))
                }))
            }
            return s > 0
        },
        t.booleanParallel = function(t, e) {
            if (!t)
                throw new Error("line1 is required");
            if (!e)
                throw new Error("line2 is required");
            if ("LineString" !== Us(t, "line1"))
                throw new Error("line1 must be a LineString");
            if ("LineString" !== Us(e, "line2"))
                throw new Error("line2 must be a LineString");
            for (var n = Kn(tn(t)).features, r = Kn(tn(e)).features, i = 0; i < n.length; i++) {
                var o = n[i].geometry.coordinates;
                if (!r[i])
                    break;
                if (!zs(o, r[i].geometry.coordinates))
                    return !1
            }
            return !0
        },
        t.booleanPointInPolygon = ye,
        t.booleanPointOnLine = Wr,
        t.booleanWithin = Kr,
        t.buffer = function(t, e, n) {
            var r = (n = n || {}).units || "kilometers",
                i = n.steps || 8;
            if (!t)
                throw new Error("geojson is required");
            if ("object" != typeof n)
                throw new Error("options must be an object");
            if ("number" != typeof i)
                throw new Error("steps must be an number");
            if (void 0 === e)
                throw new Error("radius is required");
            if (i <= 0)
                throw new Error("steps must be greater than 0");
            var o = [];
            switch (t.type) {
            case "GeometryCollection":
                return G(t, (function(t) {
                    var n = ny(t, e, r, i);
                    n && o.push(n)
                })), f(o);
            case "FeatureCollection":
                return F(t, (function(t) {
                    var n = ny(t, e, r, i);
                    n && F(n, (function(t) {
                        t && o.push(t)
                    }))
                })), f(o)
            }
            return ny(t, e, r, i)
        },
        t.center = xn,
        t.centerMean = Fa,
        t.centerMedian = function(t, e) {
            if (void 0 === e && (e = {}), !T(e = e || {}))
                throw new Error("options is invalid");
            var n = e.counter || 10;
            if (!I(n))
                throw new Error("counter must be a number");
            var r = e.weight,
                i = Fa(t, {
                    weight: e.weight
                }),
                o = f([]);
            F(t, (function(t) {
                var e;
                o.features.push(En(t, {
                    properties: {
                        weight: null === (e = t.properties) || void 0 === e ? void 0 : e[r]
                    }
                }))
            }));
            var s = {
                tolerance: e.tolerance,
                medianCandidates: []
            };
            return ka(i.geometry.coordinates, [0, 0], o, s, n)
        },
        t.centerOfMass = function t(e, n) {
            switch (void 0 === n && (n = {}), it(e)) {
            case "Point":
                return a(Z(e), n.properties);
            case "Polygon":
                var r = [];
                N(e, (function(t) {
                    r.push(t)
                }));
                var i,
                    o,
                    s,
                    u,
                    l,
                    h,
                    c,
                    p,
                    f = En(e, {
                        properties: n.properties
                    }),
                    d = f.geometry.coordinates,
                    g = 0,
                    y = 0,
                    v = 0,
                    m = r.map((function(t) {
                        return [t[0] - d[0], t[1] - d[1]]
                    }));
                for (i = 0; i < r.length - 1; i++)
                    u = (o = m[i])[0],
                    h = o[1],
                    l = (s = m[i + 1])[0],
                    v += p = u * (c = s[1]) - l * h,
                    g += (u + l) * p,
                    y += (h + c) * p;
                if (0 === v)
                    return f;
                var _ = 1 / (.5 * v * 6);
                return a([d[0] + _ * g, d[1] + _ * y], n.properties);
            default:
                var x = ge(e);
                return x ? t(x, {
                    properties: n.properties
                }) : En(e, {
                    properties: n.properties
                })
            }
        },
        t.centroid = En,
        t.circle = mn,
        t.cleanCoords = tn,
        t.clone = Ce,
        t.clusterEach = ou,
        t.clusterReduce = su,
        t.clusters = cu,
        t.clustersDbscan = function(t, e, n) {
            void 0 === n && (n = {}),
            !0 !== n.mutate && (t = Ce(t)),
            n.minPoints = n.minPoints || 3;
            var r = new Rs.DBSCAN,
                i = r.run(j(t), M(e, n.units), n.minPoints, _e),
                o = -1;
            return i.forEach((function(e) {
                o++,
                e.forEach((function(e) {
                    var n = t.features[e];
                    n.properties || (n.properties = {}),
                    n.properties.cluster = o,
                    n.properties.dbscan = "core"
                }))
            })), r.noise.forEach((function(e) {
                var n = t.features[e];
                n.properties || (n.properties = {}),
                n.properties.cluster ? n.properties.dbscan = "edge" : n.properties.dbscan = "noise"
            })), t
        },
        t.clustersKmeans = function(t, e) {
            void 0 === e && (e = {});
            var n = t.features.length;
            e.numberOfClusters = e.numberOfClusters || Math.round(Math.sqrt(n / 2)),
            e.numberOfClusters > n && (e.numberOfClusters = n),
            !0 !== e.mutate && (t = Ce(t));
            var r = j(t),
                i = r.slice(0, e.numberOfClusters),
                o = qs(r, e.numberOfClusters, i),
                s = {};
            return o.centroids.forEach((function(t, e) {
                s[e] = t
            })), F(t, (function(t, e) {
                var n = o.idxs[e];
                t.properties.cluster = n,
                t.properties.centroid = s[n]
            })), t
        },
        t.collect = function(t, e, n, r) {
            var i = Mt(6),
                o = e.features.map((function(t) {
                    var e;
                    return {
                        minX: t.geometry.coordinates[0],
                        minY: t.geometry.coordinates[1],
                        maxX: t.geometry.coordinates[0],
                        maxY: t.geometry.coordinates[1],
                        property: null === (e = t.properties) || void 0 === e ? void 0 : e[n]
                    }
                }));
            return i.load(o), t.features.forEach((function(t) {
                t.properties || (t.properties = {});
                var e = K(t),
                    n = i.search({
                        minX: e[0],
                        minY: e[1],
                        maxX: e[2],
                        maxY: e[3]
                    }),
                    o = [];
                n.forEach((function(e) {
                    ye([e.minX, e.minY], t) && o.push(e.property)
                })),
                t.properties[r] = o
            })), t
        },
        t.collectionOf = nt,
        t.combine = function(t) {
            var e = {
                MultiPoint: {
                    coordinates: [],
                    properties: []
                },
                MultiLineString: {
                    coordinates: [],
                    properties: []
                },
                MultiPolygon: {
                    coordinates: [],
                    properties: []
                }
            };
            return F(t, (function(t) {
                var n,
                    r,
                    i,
                    o;
                switch (null === (o = t.geometry) || void 0 === o ? void 0 : o.type) {
                case "Point":
                    e.MultiPoint.coordinates.push(t.geometry.coordinates),
                    e.MultiPoint.properties.push(t.properties);
                    break;
                case "MultiPoint":
                    (n = e.MultiPoint.coordinates).push.apply(n, t.geometry.coordinates),
                    e.MultiPoint.properties.push(t.properties);
                    break;
                case "LineString":
                    e.MultiLineString.coordinates.push(t.geometry.coordinates),
                    e.MultiLineString.properties.push(t.properties);
                    break;
                case "MultiLineString":
                    (r = e.MultiLineString.coordinates).push.apply(r, t.geometry.coordinates),
                    e.MultiLineString.properties.push(t.properties);
                    break;
                case "Polygon":
                    e.MultiPolygon.coordinates.push(t.geometry.coordinates),
                    e.MultiPolygon.properties.push(t.properties);
                    break;
                case "MultiPolygon":
                    (i = e.MultiPolygon.coordinates).push.apply(i, t.geometry.coordinates),
                    e.MultiPolygon.properties.push(t.properties)
                }
            })), f(Object.keys(e).filter((function(t) {
                return e[t].coordinates.length
            })).sort().map((function(t) {
                return o({
                    type: t,
                    coordinates: e[t].coordinates
                }, {
                    collectedProperties: e[t].properties
                })
            })))
        },
        t.concave = function(t, e) {
            void 0 === e && (e = {});
            var n = e.maxEdge || 1 / 0,
                r = xe(function(t) {
                    var e = [],
                        n = {};
                    return F(t, (function(t) {
                        if (t.geometry) {
                            var r = t.geometry.coordinates.join("-");
                            Object.prototype.hasOwnProperty.call(n, r) || (e.push(t), n[r] = !0)
                        }
                    })), f(e)
                }(t));
            if (r.features = r.features.filter((function(t) {
                var r = t.geometry.coordinates[0][0],
                    i = t.geometry.coordinates[0][1],
                    o = t.geometry.coordinates[0][2],
                    s = _e(r, i, e),
                    a = _e(i, o, e),
                    u = _e(r, o, e);
                return s <= n && a <= n && u <= n
            })), r.features.length < 1)
                return null;
            var i = Qe(r);
            return 1 === i.coordinates.length && (i.coordinates = i.coordinates[0], i.type = "Polygon"), o(i)
        },
        t.containsNumber = Q,
        t.convertArea = S,
        t.convertDistance = M,
        t.convertLength = M,
        t.convex = ge,
        t.coordAll = j,
        t.coordEach = N,
        t.coordReduce = R,
        t.createBins = au,
        t.degrees2radians = C,
        t.degreesToRadians = C,
        t.destination = vn,
        t.difference = function(t, e) {
            var n = rt(t),
                r = rt(e),
                i = t.properties || {},
                o = Qu.difference(n.coordinates, r.coordinates);
            return 0 === o.length ? null : 1 === o.length ? l(o[0], i) : y(o, i)
        },
        t.dissolve = function(t, e) {
            if (!T(e = e || {}))
                throw new Error("options is invalid");
            var n = e.propertyName;
            nt(t, "Polygon", "dissolve");
            var r = [];
            if (!e.propertyName)
                return ni(y(Qu.union.apply(null, t.features.map((function(t) {
                    return t.geometry.coordinates
                })))));
            var i = {};
            F(t, (function(t) {
                Object.prototype.hasOwnProperty.call(i, t.properties[n]) || (i[t.properties[n]] = []),
                i[t.properties[n]].push(t)
            }));
            for (var o = Object.keys(i), s = 0; s < o.length; s++) {
                var a = y(Qu.union.apply(null, i[o[s]].map((function(t) {
                    return t.geometry.coordinates
                }))));
                a.properties[n] = o[s],
                r.push(a)
            }
            return ni(f(r))
        },
        t.distance = _e,
        t.distanceToDegrees = E,
        t.distanceToRadians = x,
        t.distanceWeight = za,
        t.earthRadius = e,
        t.ellipse = Aa,
        t.envelope = gn,
        t.explode = wn,
        t.factors = n,
        t.feature = o,
        t.featureCollection = f,
        t.featureEach = F,
        t.featureOf = et,
        t.featureReduce = k,
        t.filterProperties = hu,
        t.findPoint = W,
        t.findSegment = Y,
        t.flatten = ni,
        t.flattenEach = q,
        t.flattenReduce = z,
        t.flip = function(t, e) {
            if (!T(e = e || {}))
                throw new Error("options is invalid");
            var n = e.mutate;
            if (!t)
                throw new Error("geojson is required");
            return !1 !== n && void 0 !== n || (t = Ce(t)), N(t, (function(t) {
                var e = t[0],
                    n = t[1];
                t[0] = n,
                t[1] = e
            })), t
        },
        t.geojsonType = tt,
        t.geomEach = G,
        t.geomReduce = B,
        t.geometry = s,
        t.geometryCollection = v,
        t.getCluster = iu,
        t.getCoord = Z,
        t.getCoords = J,
        t.getGeom = rt,
        t.getType = it,
        t.greatCircle = function(t, e, n) {
            if ("object" != typeof (n = n || {}))
                throw new Error("options is invalid");
            var r = n.properties,
                i = n.npoints,
                o = n.offset;
            return t = Z(t), e = Z(e), r = r || {}, i = i || 100, o = o || 10, new vi({
                x: t[0],
                y: t[1]
            }, {
                x: e[0],
                y: e[1]
            }, r).Arc(i, {
                offset: o
            }).json()
        },
        t.helpers = O,
        t.hexGrid = ay,
        t.inside = ye,
        t.interpolate = function(t, e, n) {
            if ("object" != typeof (n = n || {}))
                throw new Error("options is invalid");
            var r = n.gridType,
                i = n.property,
                o = n.weight;
            if (!t)
                throw new Error("points is required");
            if (nt(t, "Point", "input must contain Points"), !e)
                throw new Error("cellSize is required");
            if (void 0 !== o && "number" != typeof o)
                throw new Error("weight must be a number");
            i = i || "elevation",
            r = r || "square",
            o = o || 1;
            var s,
                a = K(t);
            switch (r) {
            case "point":
            case "points":
                s = ti(a, e, n);
                break;
            case "square":
            case "squares":
                s = py(a, e, n);
                break;
            case "hex":
            case "hexes":
                s = ay(a, e, n);
                break;
            case "triangle":
            case "triangles":
                s = fy(a, e, n);
                break;
            default:
                throw new Error("invalid gridType")
            }
            var u = [];
            return F(s, (function(e) {
                var s = 0,
                    a = 0;
                F(t, (function(t) {
                    var u,
                        l = _e("point" === r ? e : En(e), t, n);
                    if (void 0 !== i && (u = t.properties[i]), void 0 === u && (u = t.geometry.coordinates[2]), void 0 === u)
                        throw new Error("zValue is missing");
                    0 === l && (s = u);
                    var h = 1 / Math.pow(l, o);
                    a += h,
                    s += h * u
                }));
                var l = Ce(e);
                l.properties[i] = s / a,
                u.push(l)
            })), f(u)
        },
        t.intersect = sy,
        t.invariant = ot,
        t.isNumber = I,
        t.isObject = T,
        t.isobands = function(t, e, n) {
            if (!T(n = n || {}))
                throw new Error("options is invalid");
            var r = n.zProperty || "elevation",
                i = n.commonProperties || {},
                o = n.breaksProperties || [];
            if (nt(t, "Point", "Input must contain Points"), !e)
                throw new Error("breaks is required");
            if (!Array.isArray(e))
                throw new Error("breaks is not an Array");
            if (!T(i))
                throw new Error("commonProperties is not an Object");
            if (!Array.isArray(o))
                throw new Error("breaksProperties is not an Array");
            var s = Ki(t, {
                    zProperty: r,
                    flip: !0
                }),
                a = function(t, e, n) {
                    for (var r = [], i = 1; i < e.length; i++) {
                        var o = +e[i - 1],
                            s = +e[i],
                            a = Ko($o(Qi(t, o, s - o))),
                            u = {};
                        u.groupedRings = a,
                        u[n] = o + "-" + s,
                        r.push(u)
                    }
                    return r
                }(s, e, r);
            return f((a = function(t, e, n) {
                var r = K(n),
                    i = r[2] - r[0],
                    o = r[3] - r[1],
                    s = r[0],
                    a = r[1],
                    u = e[0].length - 1,
                    l = e.length - 1,
                    h = i / u,
                    c = o / l,
                    p = function(t) {
                        t[0] = t[0] * h + s,
                        t[1] = t[1] * c + a
                    };
                return t.forEach((function(t) {
                    t.groupedRings.forEach((function(t) {
                        t.forEach((function(t) {
                            t.forEach(p)
                        }))
                    }))
                })), t
            }(a, s, t)).map((function(t, e) {
                if (o[e] && !T(o[e]))
                    throw new Error("Each mappedProperty is required to be an Object");
                var n = ht({}, i, o[e]);
                return n[r] = t[r], y(t.groupedRings, n)
            })))
        },
        t.isolines = function(t, e, n) {
            if (!T(n = n || {}))
                throw new Error("options is invalid");
            var r = n.zProperty || "elevation",
                i = n.commonProperties || {},
                o = n.breaksProperties || [];
            if (nt(t, "Point", "Input must contain Points"), !e)
                throw new Error("breaks is required");
            if (!Array.isArray(e))
                throw new Error("breaks must be an Array");
            if (!T(i))
                throw new Error("commonProperties must be an Object");
            if (!Array.isArray(o))
                throw new Error("breaksProperties must be an Array");
            var s = mt(t, {
                zProperty: r,
                flip: !0
            });
            return f(function(t, e, n) {
                var r = K(n),
                    i = r[2] - r[0],
                    o = r[3] - r[1],
                    s = r[0],
                    a = r[1],
                    u = e[0].length - 1,
                    l = e.length - 1,
                    h = i / u,
                    c = o / l,
                    p = function(t) {
                        t[0] = t[0] * h + s,
                        t[1] = t[1] * c + a
                    };
                return t.forEach((function(t) {
                    N(t, p)
                })), t
            }(function(t, e, n, r, i) {
                for (var o = [], s = 1; s < e.length; s++) {
                    var a = +e[s],
                        u = ht({}, r, i[s]);
                    u[n] = a;
                    var l = d(ft(t, a), u);
                    o.push(l)
                }
                return o
            }(s, e, r, i, o), s, t))
        },
        t.kinks = function(t) {
            var e,
                n,
                r = {
                    type: "FeatureCollection",
                    features: []
                };
            if ("LineString" === (n = "Feature" === t.type ? t.geometry : t).type)
                e = [n.coordinates];
            else if ("MultiLineString" === n.type)
                e = n.coordinates;
            else if ("MultiPolygon" === n.type)
                e = [].concat.apply([], n.coordinates);
            else {
                if ("Polygon" !== n.type)
                    throw new Error("Input must be a LineString, MultiLineString, Polygon, or MultiPolygon Feature or Geometry");
                e = n.coordinates
            }
            return e.forEach((function(t) {
                e.forEach((function(e) {
                    for (var n = 0; n < t.length - 1; n++)
                        for (var i = n; i < e.length - 1; i++) {
                            if (t === e) {
                                if (1 === Math.abs(n - i))
                                    continue;
                                if (0 === n && i === t.length - 2 && t[n][0] === t[t.length - 1][0] && t[n][1] === t[t.length - 1][1])
                                    continue
                            }
                            var o = jr(t[n][0], t[n][1], t[n + 1][0], t[n + 1][1], e[i][0], e[i][1], e[i + 1][0], e[i + 1][1]);
                            o && r.features.push(a([o[0], o[1]]))
                        }
                }))
            })), r
        },
        t.length = Hr,
        t.lengthToDegrees = E,
        t.lengthToRadians = x,
        t.lineArc = wi,
        t.lineChunk = function(t, e, n) {
            if (!T(n = n || {}))
                throw new Error("options is invalid");
            var r = n.units,
                i = n.reverse;
            if (!t)
                throw new Error("geojson is required");
            if (e <= 0)
                throw new Error("segmentLength must be greater than 0");
            var o = [];
            return q(t, (function(t) {
                i && (t.geometry.coordinates = t.geometry.coordinates.reverse()),
                function(t, e, n, r) {
                    var i = Hr(t, {
                        units: n
                    });
                    if (i <= e)
                        return r(t);
                    var o = i / e;
                    Number.isInteger(o) || (o = Math.floor(o) + 1);
                    for (var s = 0; s < o; s++)
                        r(Yr(t, e * s, e * (s + 1), {
                            units: n
                        }), s)
                }(t, e, r, (function(t) {
                    o.push(t)
                }))
            })), f(o)
        },
        t.lineDistance = Hr,
        t.lineEach = X,
        t.lineIntersect = Or,
        t.lineOffset = function(t, e, n) {
            if (!T(n = n || {}))
                throw new Error("options is invalid");
            var r = n.units;
            if (!t)
                throw new Error("geojson is required");
            if (null == e || isNaN(e))
                throw new Error("distance is required");
            var i = it(t),
                o = t.properties;
            switch (i) {
            case "LineString":
                return os(t, e, r);
            case "MultiLineString":
                var s = [];
                return q(t, (function(t) {
                    s.push(os(t, e, r).geometry.coordinates)
                })), d(s, o);
            default:
                throw new Error("geometry " + i + " is not supported")
            }
        },
        t.lineOverlap = ki,
        t.lineReduce = H,
        t.lineSegment = Kn,
        t.lineSlice = function(t, e, n) {
            var r = J(n);
            if ("LineString" !== it(n))
                throw new Error("line must be a LineString");
            for (var i, o = Rr(n, t), s = Rr(n, e), a = [(i = o.properties.index <= s.properties.index ? [o, s] : [s, o])[0].geometry.coordinates], u = i[0].properties.index + 1; u < i[1].properties.index + 1; u++)
                a.push(r[u]);
            return a.push(i[1].geometry.coordinates), c(a, n.properties)
        },
        t.lineSliceAlong = Yr,
        t.lineSplit = function(t, e) {
            if (!t)
                throw new Error("line is required");
            if (!e)
                throw new Error("splitter is required");
            var n = it(t),
                r = it(e);
            if ("LineString" !== n)
                throw new Error("line must be LineString");
            if ("FeatureCollection" === r)
                throw new Error("splitter cannot be a FeatureCollection");
            if ("GeometryCollection" === r)
                throw new Error("splitter cannot be a GeometryCollection");
            var i = ei(e, {
                precision: 7
            });
            switch (r) {
            case "Point":
                return _i(t, i);
            case "MultiPoint":
                return mi(t, i);
            case "LineString":
            case "MultiLineString":
            case "Polygon":
            case "MultiPolygon":
                return mi(t, Or(t, i))
            }
        },
        t.lineString = c,
        t.lineStringToPolygon = Ii,
        t.lineStrings = p,
        t.lineToPolygon = Ii,
        t.mask = function(t, e) {
            var n,
                r = cy(e);
            return ("FeatureCollection" === t.type ? hy(2 === (n = t).features.length ? Qu.union(n.features[0].geometry.coordinates, n.features[1].geometry.coordinates) : Qu.union.apply(Qu, n.features.map((function(t) {
                return t.geometry.coordinates
            })))) : hy(Qu.union(t.geometry.coordinates))).geometry.coordinates.forEach((function(t) {
                r.geometry.coordinates.push(t[0])
            })), r
        },
        t.meta = $,
        t.midpoint = function(t, e) {
            return vn(t, _e(t, e) / 2, _n(t, e))
        },
        t.moranIndex = function(t, e) {
            var n = e.inputField,
                r = e.threshold || 1e5,
                i = e.p || 2,
                o = e.binary || !1,
                s = za(t, {
                    alpha: e.alpha || -1,
                    binary: o,
                    p: i,
                    standardization: e.standardization || !0,
                    threshold: r
                }),
                a = [];
            F(t, (function(t) {
                var e = t.properties || {};
                a.push(e[n])
            }));
            for (var u = Ua(a), l = function(t) {
                    for (var e = Ua(t), n = 0, r = 0, i = t; r < i.length; r++) {
                        var o = i[r];
                        n += Math.pow(o - e, 2)
                    }
                    return n / t.length
                }(a), h = 0, c = 0, p = 0, f = 0, d = s.length, g = 0; g < d; g++) {
                for (var y = 0, v = 0; v < d; v++)
                    h += s[g][v] * (a[g] - u) * (a[v] - u),
                    c += s[g][v],
                    p += Math.pow(s[g][v] + s[v][g], 2),
                    y += s[g][v] + s[v][g];
                f += Math.pow(y, 2)
            }
            var m = h / c / l,
                _ = -1 / (d - 1),
                x = (d * d * (p *= .5) - d * f + c * c * 3) / ((d - 1) * (d + 1) * (c * c)) - _ * _,
                E = Math.sqrt(x);
            return {
                expectedMoranIndex: _,
                moranIndex: m,
                stdNorm: E,
                zNorm: (m - _) / E
            }
        },
        t.multiLineString = d,
        t.multiPoint = g,
        t.multiPolygon = y,
        t.nearest = $n,
        t.nearestPoint = $n,
        t.nearestPointOnLine = Rr,
        t.nearestPointToLine = function(t, e, n) {
            void 0 === n && (n = {});
            var r = n.units,
                i = n.properties || {},
                o = function(t) {
                    var e = [];
                    switch (t.geometry ? t.geometry.type : t.type) {
                    case "GeometryCollection":
                        return G(t, (function(t) {
                            "Point" === t.type && e.push({
                                type: "Feature",
                                properties: {},
                                geometry: t
                            })
                        })), {
                            type: "FeatureCollection",
                            features: e
                        };
                    case "FeatureCollection":
                        return t.features = t.features.filter((function(t) {
                            return "Point" === t.geometry.type
                        })), t;
                    default:
                        throw new Error("points must be a Point Collection")
                    }
                }(t);
            if (!o.features.length)
                throw new Error("points must contain features");
            if (!e)
                throw new Error("line is required");
            if ("LineString" !== it(e))
                throw new Error("line must be a LineString");
            var s = 1 / 0,
                a = null;
            return F(o, (function(t) {
                var n = Dr(t, e, {
                    units: r
                });
                n < s && (s = n, a = t)
            })), a && (a.properties = ht({
                dist: s
            }, a.properties, i)), a
        },
        t.planepoint = function(t, e) {
            var n = Z(t),
                r = rt(e).coordinates[0];
            if (r.length < 4)
                throw new Error("OuterRing of a Polygon must have 4 or more Positions.");
            var i = e.properties || {},
                o = i.a,
                s = i.b,
                a = i.c,
                u = n[0],
                l = n[1],
                h = r[0][0],
                c = r[0][1],
                p = void 0 !== o ? o : r[0][2],
                f = r[1][0],
                d = r[1][1],
                g = void 0 !== s ? s : r[1][2],
                y = r[2][0],
                v = r[2][1],
                m = void 0 !== a ? a : r[2][2];
            return (m * (u - h) * (l - d) + p * (u - f) * (l - v) + g * (u - y) * (l - c) - g * (u - h) * (l - v) - m * (u - f) * (l - c) - p * (u - y) * (l - d)) / ((u - h) * (l - d) + (u - f) * (l - v) + (u - y) * (l - c) - (u - h) * (l - v) - (u - f) * (l - c) - (u - y) * (l - d))
        },
        t.point = a,
        t.pointGrid = ti,
        t.pointOnFeature = Gr,
        t.pointOnLine = Rr,
        t.pointOnSurface = Gr,
        t.pointToLineDistance = Dr,
        t.points = u,
        t.pointsWithinPolygon = me,
        t.polygon = l,
        t.polygonSmooth = function(t, e) {
            var n = [],
                r = e.iterations || 1;
            if (!t)
                throw new Error("inputPolys is required");
            return G(t, (function(t, e, i) {
                var o,
                    s,
                    a;
                switch (t.type) {
                case "Polygon":
                    o = [[]];
                    for (var u = 0; u < r; u++)
                        a = [[]],
                        s = t,
                        u > 0 && (s = l(o).geometry),
                        Ga(s, a),
                        o = a.slice(0);
                    n.push(l(o, i));
                    break;
                case "MultiPolygon":
                    o = [[[]]];
                    for (var h = 0; h < r; h++)
                        a = [[[]]],
                        s = t,
                        h > 0 && (s = y(o).geometry),
                        Ba(s, a),
                        o = a.slice(0);
                    n.push(y(o, i));
                    break;
                default:
                    throw new Error("geometry is invalid, must be Polygon or MultiPolygon")
                }
            })), f(n)
        },
        t.polygonTangents = function(t, e) {
            var n,
                r,
                i,
                o,
                s = J(t),
                u = J(e),
                l = K(e),
                h = 0,
                c = null;
            switch (s[0] > l[0] && s[0] < l[2] && s[1] > l[1] && s[1] < l[3] && (h = (c = $n(t, wn(e))).properties.featureIndex), it(e)) {
            case "Polygon":
                n = u[0][h],
                r = u[0][0],
                null !== c && c.geometry.coordinates[1] < s[1] && (r = u[0][h]),
                o = Xi(u[0][0], u[0][u[0].length - 1], s);
                var p = Ui(u[0], s, o, i, n, r);
                n = p[0],
                r = p[1];
                break;
            case "MultiPolygon":
                for (var d = 0, g = 0, y = 0, v = 0; v < u[0].length; v++) {
                    d = v;
                    for (var m = !1, _ = 0; _ < u[0][v].length; _++) {
                        if (g = _, y === h) {
                            m = !0;
                            break
                        }
                        y++
                    }
                    if (m)
                        break
                }
                n = u[0][d][g],
                r = u[0][d][g],
                o = Xi(u[0][0][0], u[0][0][u[0][0].length - 1], s),
                u.forEach((function(t) {
                    var e = Ui(t[0], s, o, i, n, r);
                    n = e[0],
                    r = e[1]
                }))
            }
            return f([a(n), a(r)])
        },
        t.polygonToLine = Ci,
        t.polygonToLineString = Ci,
        t.polygonize = function(t) {
            var e = cs.fromGeoJson(t);
            e.deleteDangles(),
            e.deleteCutEdges();
            var n = [],
                r = [];
            return e.getEdgeRings().filter((function(t) {
                return t.isValid()
            })).forEach((function(t) {
                t.isHole() ? n.push(t) : r.push(t)
            })), n.forEach((function(t) {
                hs.findEdgeRingContaining(t, r) && r.push(t)
            })), f(r.map((function(t) {
                return t.toPolygon()
            })))
        },
        t.polygons = h,
        t.projection = $a,
        t.propEach = A,
        t.propReduce = D,
        t.propertiesContainsFilter = lu,
        t.radians2degrees = b,
        t.radiansToDegrees = b,
        t.radiansToDistance = _,
        t.radiansToLength = _,
        t.random = ru,
        t.randomLineString = tu,
        t.randomPoint = Ja,
        t.randomPolygon = Qa,
        t.randomPosition = Za,
        t.rewind = function(t, e) {
            if (!T(e = e || {}))
                throw new Error("options is invalid");
            var n = e.reverse || !1,
                r = e.mutate || !1;
            if (!t)
                throw new Error("<geojson> is required");
            if ("boolean" != typeof n)
                throw new Error("<reverse> must be a boolean");
            if ("boolean" != typeof r)
                throw new Error("<mutate> must be a boolean");
            !1 === r && (t = Ce(t));
            var i = [];
            switch (t.type) {
            case "GeometryCollection":
                return G(t, (function(t) {
                    Yi(t, n)
                })), t;
            case "FeatureCollection":
                return F(t, (function(t) {
                    F(Yi(t, n), (function(t) {
                        i.push(t)
                    }))
                })), f(i)
            }
            return Yi(t, n)
        },
        t.rhumbBearing = Bi,
        t.rhumbDestination = zi,
        t.rhumbDistance = Ar,
        t.round = m,
        t.sample = function(t, e) {
            if (!t)
                throw new Error("featurecollection is required");
            if (null == e)
                throw new Error("num is required");
            if ("number" != typeof e)
                throw new Error("num must be a number");
            return f(function(t, e) {
                for (var n, r, i = t.slice(0), o = t.length, s = o - e; o-- > s;)
                    n = i[r = Math.floor((o + 1) * Math.random())],
                    i[r] = i[o],
                    i[o] = n;
                return i.slice(s)
            }(t.features, e))
        },
        t.sector = function(t, e, n, r, i) {
            if (!T(i = i || {}))
                throw new Error("options is invalid");
            var o = i.properties;
            if (!t)
                throw new Error("center is required");
            if (null == n)
                throw new Error("bearing1 is required");
            if (null == r)
                throw new Error("bearing2 is required");
            if (!e)
                throw new Error("radius is required");
            if ("object" != typeof i)
                throw new Error("options must be an object");
            if (Gi(n) === Gi(r))
                return mn(t, e, i);
            var s = J(t),
                a = wi(t, e, n, r, i),
                u = [[s]];
            return N(a, (function(t) {
                u[0].push(t)
            })), u[0].push(s), l(u, o)
        },
        t.segmentEach = U,
        t.segmentReduce = V,
        t.shortestPath = function(t, e, n) {
            if (!T(n = n || {}))
                throw new Error("options is invalid");
            var r = n.resolution,
                i = n.minDistance,
                s = n.obstacles || f([]);
            if (!t)
                throw new Error("start is required");
            if (!e)
                throw new Error("end is required");
            if (r && !I(r) || r <= 0)
                throw new Error("options.resolution must be a number, greater than 0");
            if (i)
                throw new Error("options.minDistance is not yet implemented");
            var u = Z(t),
                l = Z(e);
            switch (t = a(u), e = a(l), it(s)) {
            case "FeatureCollection":
                if (0 === s.features.length)
                    return c([u, l]);
                break;
            case "Polygon":
                s = f([o(rt(s))]);
                break;
            default:
                throw new Error("invalid obstacles")
            }
            var h = s;
            h.features.push(t),
            h.features.push(e);
            var p = K(ts(dn(K(h)), 1.15));
            r || (r = _e([p[0], p[1]], [p[2], p[1]], n) / 100),
            h.features.pop(),
            h.features.pop();
            for (var d = p[0], g = p[1], y = p[2], v = p[3], m = r / _e([d, g], [y, g], n) * (y - d), _ = r / _e([d, g], [d, v], n) * (v - g), x = y - d, E = v - g, w = Math.floor(x / m), b = Math.floor(E / _), C = (x - w * m) / 2, M = [], S = [], P = [], L = [], O = 1 / 0, N = 1 / 0, R = v - (E - b * _) / 2, A = 0; R >= g;) {
                for (var D = [], F = [], k = d + C, j = 0; k <= y;) {
                    var G = a([k, R]),
                        B = $s(G, s);
                    D.push(B ? 0 : 1),
                    F.push(k + "|" + R);
                    var q = _e(G, t);
                    !B && q < O && (O = q, P = {
                        x: j,
                        y: A
                    });
                    var z = _e(G, e);
                    !B && z < N && (N = z, L = {
                        x: j,
                        y: A
                    }),
                    k += m,
                    j++
                }
                S.push(D),
                M.push(F),
                R -= _,
                A++
            }
            var U = new Hs(S, {
                    diagonal: !0
                }),
                V = U.grid[P.y][P.x],
                X = U.grid[L.y][L.x],
                H = Xs.search(U, V, X),
                Y = [u];
            return H.forEach((function(t) {
                var e = M[t.x][t.y].split("|");
                Y.push([+e[0], +e[1]])
            })), Y.push(l), tn(c(Y))
        },
        t.simplify = function(t, e) {
            if (!T(e = e || {}))
                throw new Error("options is invalid");
            var n = void 0 !== e.tolerance ? e.tolerance : 1,
                r = e.highQuality || !1,
                i = e.mutate || !1;
            if (!t)
                throw new Error("geojson is required");
            if (n && n < 0)
                throw new Error("invalid tolerance");
            return !0 !== i && (t = Ce(t)), G(t, (function(t) {
                !function(t, e, n) {
                    var r = t.type;
                    if ("Point" === r || "MultiPoint" === r)
                        return t;
                    tn(t, !0);
                    var i = t.coordinates;
                    switch (r) {
                    case "LineString":
                        t.coordinates = ln(i, e, n);
                        break;
                    case "MultiLineString":
                        t.coordinates = i.map((function(t) {
                            return ln(t, e, n)
                        }));
                        break;
                    case "Polygon":
                        t.coordinates = hn(i, e, n);
                        break;
                    case "MultiPolygon":
                        t.coordinates = i.map((function(t) {
                            return hn(t, e, n)
                        }))
                    }
                }(t, n, r)
            })), t
        },
        t.square = yn,
        t.squareGrid = py,
        t.standardDeviationalEllipse = function(t, e) {
            if (!T(e = e || {}))
                throw new Error("options is invalid");
            var n = e.steps || 64,
                r = e.weight,
                i = e.properties || {};
            if (!I(n))
                throw new Error("steps must be a number");
            if (!T(i))
                throw new Error("properties must be a number");
            var o = j(t).length,
                s = Fa(t, {
                    weight: r
                }),
                a = 0,
                u = 0,
                l = 0;
            F(t, (function(t) {
                var e = t.properties[r] || 1,
                    n = ja(J(t), J(s));
                a += Math.pow(n.x, 2) * e,
                u += Math.pow(n.y, 2) * e,
                l += n.x * n.y * e
            }));
            var h = a - u,
                c = Math.sqrt(Math.pow(h, 2) + 4 * Math.pow(l, 2)),
                p = 2 * l,
                d = Math.atan((h + c) / p),
                g = 180 * d / Math.PI,
                y = 0,
                v = 0,
                m = 0;
            F(t, (function(t) {
                var e = t.properties[r] || 1,
                    n = ja(J(t), J(s));
                y += Math.pow(n.x * Math.cos(d) - n.y * Math.sin(d), 2) * e,
                v += Math.pow(n.x * Math.sin(d) + n.y * Math.cos(d), 2) * e,
                m += e
            }));
            var _ = Math.sqrt(2 * y / m),
                x = Math.sqrt(2 * v / m),
                E = Aa(s, _, x, {
                    units: "degrees",
                    angle: g,
                    steps: n,
                    properties: i
                }),
                w = me(t, f([E])),
                b = {
                    meanCenterCoordinates: J(s),
                    semiMajorAxis: _,
                    semiMinorAxis: x,
                    numberOfFeatures: o,
                    angle: g,
                    percentageWithinEllipse: 100 * j(w).length / o
                };
            return E.properties.standardDeviationalEllipse = b, E
        },
        t.tag = function(t, e, n, r) {
            return t = Ce(t), e = Ce(e), F(t, (function(t) {
                t.properties || (t.properties = {}),
                F(e, (function(e) {
                    void 0 === t.properties[r] && ye(t, e) && (t.properties[r] = e.properties[n])
                }))
            })), t
        },
        t.tesselate = function(t) {
            if (!t.geometry || "Polygon" !== t.geometry.type && "MultiPolygon" !== t.geometry.type)
                throw new Error("input must be a Polygon or MultiPolygon");
            var e = {
                type: "FeatureCollection",
                features: []
            };
            return "Polygon" === t.geometry.type ? e.features = Wn(t.geometry.coordinates) : t.geometry.coordinates.forEach((function(t) {
                e.features = e.features.concat(Wn(t))
            })), e
        },
        t.tin = xe,
        t.toMercator = Va,
        t.toWgs84 = Xa,
        t.transformRotate = Qo,
        t.transformScale = ts,
        t.transformTranslate = function(t, e, n, r) {
            if (!T(r = r || {}))
                throw new Error("options is invalid");
            var i = r.units,
                o = r.zTranslation,
                s = r.mutate;
            if (!t)
                throw new Error("geojson is required");
            if (null == e || isNaN(e))
                throw new Error("distance is required");
            if (o && "number" != typeof o && isNaN(o))
                throw new Error("zTranslation is not a number");
            if (o = void 0 !== o ? o : 0, 0 === e && 0 === o)
                return t;
            if (null == n || isNaN(n))
                throw new Error("direction is required");
            return e < 0 && (e = -e, n += 180), !1 !== s && void 0 !== s || (t = Ce(t)), N(t, (function(t) {
                var r = J(zi(t, e, n, {
                    units: i
                }));
                t[0] = r[0],
                t[1] = r[1],
                o && 3 === t.length && (t[2] += o)
            })), t
        },
        t.triangleGrid = fy,
        t.truncate = ei,
        t.union = function(t, e, n) {
            void 0 === n && (n = {});
            var r = rt(t),
                i = rt(e),
                o = Qu.union(r.coordinates, i.coordinates);
            return 0 === o.length ? null : 1 === o.length ? l(o[0], n.properties) : y(o, n.properties)
        },
        t.unitsFactors = r,
        t.unkinkPolygon = function(t) {
            var e = [];
            return q(t, (function(t) {
                "Polygon" === t.geometry.type && F(oi(t), (function(n) {
                    e.push(l(n.geometry.coordinates, t.properties))
                }))
            })), f(e)
        },
        t.validateBBox = P,
        t.validateId = L,
        t.voronoi = function(t, e) {
            if (!T(e = e || {}))
                throw new Error("options is invalid");
            var n = e.bbox || [-180, -85, 180, 85];
            if (!t)
                throw new Error("points is required");
            if (!Array.isArray(n))
                throw new Error("bbox is invalid");
            return nt(t, "Point", "points"), f(function() {
                var t = Zs,
                    e = Js,
                    n = null;
                function r(r) {
                    return new Na(r.map((function(n, i) {
                        var o = [Math.round(t(n, i, r) / Pa) * Pa, Math.round(e(n, i, r) / Pa) * Pa];
                        return o.index = i, o.data = n, o
                    })), n)
                }
                return r.polygons = function(t) {
                    return r(t).polygons()
                }, r.links = function(t) {
                    return r(t).links()
                }, r.triangles = function(t) {
                    return r(t).triangles()
                }, r.x = function(e) {
                    return arguments.length ? (t = "function" == typeof e ? e : Ks(+e), r) : t
                }, r.y = function(t) {
                    return arguments.length ? (e = "function" == typeof t ? t : Ks(+t), r) : e
                }, r.extent = function(t) {
                    return arguments.length ? (n = null == t ? null : [[+t[0][0], +t[0][1]], [+t[1][0], +t[1][1]]], r) : n && [[n[0][0], n[0][1]], [n[1][0], n[1][1]]]
                }, r.size = function(t) {
                    return arguments.length ? (n = null == t ? null : [[0, 0], [+t[0], +t[1]]], r) : n && [n[1][0] - n[0][0], n[1][1] - n[0][1]]
                }, r
            }().x((function(t) {
                return t.geometry.coordinates[0]
            })).y((function(t) {
                return t.geometry.coordinates[1]
            })).extent([[n[0], n[1]], [n[2], n[3]]]).polygons(t.features).map(Ra))
        },
        t.within = me,
        Object.defineProperty(t, "__esModule", {
            value: !0
        })
    }(t.exports)
})),
o.register("hPtJY", (function(t, e) {
    var n,
        r,
        i = t.exports = {};
    function o() {
        throw new Error("setTimeout has not been defined")
    }
    function s() {
        throw new Error("clearTimeout has not been defined")
    }
    function a(t) {
        if (n === setTimeout)
            return setTimeout(t, 0);
        if ((n === o || !n) && setTimeout)
            return n = setTimeout, setTimeout(t, 0);
        try {
            return n(t, 0)
        } catch (e) {
            try {
                return n.call(null, t, 0)
            } catch (e) {
                return n.call(this, t, 0)
            }
        }
    }
    !function() {
        try {
            n = "function" == typeof setTimeout ? setTimeout : o
        } catch (t) {
            n = o
        }
        try {
            r = "function" == typeof clearTimeout ? clearTimeout : s
        } catch (t) {
            r = s
        }
    }();
    var u,
        l = [],
        h = !1,
        c = -1;
    function p() {
        h && u && (h = !1, u.length ? l = u.concat(l) : c = -1, l.length && f())
    }
    function f() {
        if (!h) {
            var t = a(p);
            h = !0;
            for (var e = l.length; e;) {
                for (u = l, l = []; ++c < e;)
                    u && u[c].run();
                c = -1,
                e = l.length
            }
            u = null,
            h = !1,
            function(t) {
                if (r === clearTimeout)
                    return clearTimeout(t);
                if ((r === s || !r) && clearTimeout)
                    return r = clearTimeout, clearTimeout(t);
                try {
                    r(t)
                } catch (e) {
                    try {
                        return r.call(null, t)
                    } catch (e) {
                        return r.call(this, t)
                    }
                }
            }(t)
        }
    }
    function d(t, e) {
        this.fun = t,
        this.array = e
    }
    function g() {}
    i.nextTick = function(t) {
        var e = new Array(arguments.length - 1);
        if (arguments.length > 1)
            for (var n = 1; n < arguments.length; n++)
                e[n - 1] = arguments[n];
        l.push(new d(t, e)),
        1 !== l.length || h || a(f)
    },
    d.prototype.run = function() {
        this.fun.apply(null, this.array)
    },
    i.title = "browser",
    i.browser = !0,
    i.env = {},
    i.argv = [],
    i.version = "",
    i.versions = {},
    i.on = g,
    i.addListener = g,
    i.once = g,
    i.off = g,
    i.removeListener = g,
    i.removeAllListeners = g,
    i.emit = g,
    i.prependListener = g,
    i.prependOnceListener = g,
    i.listeners = function(t) {
        return []
    },
    i.binding = function(t) {
        throw new Error("process.binding is not supported")
    },
    i.cwd = function() {
        return "/"
    },
    i.chdir = function(t) {
        throw new Error("process.chdir is not supported")
    },
    i.umask = function() {
        return 0
    }
})),
o.register("9eDez", (function(e, n) {
    t(e.exports, "default", (() => a));
    var r = o("hzflP"),
        i = o("7XioC"),
        s = o("fGJNI");
    var a = function(t, e, n, o) {
        void 0 === o && (o = {});
        for (var a = [], u = t[0], l = t[1], h = t[2], c = t[3], p = e / (0, i.default)([u, l], [h, l], o) * (h - u), f = n / (0, i.default)([u, l], [u, c], o) * (c - l), d = h - u, g = c - l, y = Math.floor(d / p), v = Math.floor(g / f), m = (g - v * f) / 2, _ = u + (d - y * p) / 2, x = 0; x < y; x++) {
            for (var E = l + m, w = 0; w < v; w++) {
                var b = (0, s.polygon)([[[_, E], [_, E + f], [_ + p, E + f], [_ + p, E], [_, E]]], o.properties);
                o.mask ? (0, r.default)(o.mask, b) && a.push(b) : a.push(b),
                E += f
            }
            _ += p
        }
        return (0, s.featureCollection)(a)
    }
})),
o.register("hzflP", (function(e, n) {
    t(e.exports, "default", (() => s));
    var r = o("bmsoN"),
        i = o("9SUUV");
    function s(t, e) {
        var n = !1;
        return (0, i.flattenEach)(t, (function(t) {
            (0, i.flattenEach)(e, (function(e) {
                if (!0 === n)
                    return !0;
                n = !(0, r.default)(t.geometry, e.geometry)
            }))
        })), n
    }
})),
o.register("bmsoN", (function(e, n) {
    t(e.exports, "default", (() => c));
    var r = o("lC5qP"),
        i = o("65Z2D"),
        s = o("9SUUV"),
        a = o("exGnI");
    function u(t, e) {
        for (var n = 0; n < t.coordinates.length - 1; n++)
            if (h(t.coordinates[n], t.coordinates[n + 1], e.coordinates))
                return !0;
        return !1
    }
    function l(t, e) {
        for (var n = 0, o = e.coordinates; n < o.length; n++) {
            var s = o[n];
            if ((0, r.default)(s, t))
                return !0
        }
        return (0, i.default)(e, (0, a.default)(t)).features.length > 0
    }
    function h(t, e, n) {
        var r = n[0] - t[0],
            i = n[1] - t[1],
            o = e[0] - t[0],
            s = e[1] - t[1];
        return 0 == r * s - i * o && (Math.abs(o) >= Math.abs(s) ? o > 0 ? t[0] <= n[0] && n[0] <= e[0] : e[0] <= n[0] && n[0] <= t[0] : s > 0 ? t[1] <= n[1] && n[1] <= e[1] : e[1] <= n[1] && n[1] <= t[1])
    }
    var c = function(t, e) {
        var n = !0;
        return (0, s.flattenEach)(t, (function(t) {
            (0, s.flattenEach)(e, (function(e) {
                if (!1 === n)
                    return !1;
                n = function(t, e) {
                    switch (t.type) {
                    case "Point":
                        switch (e.type) {
                        case "Point":
                            return s = t.coordinates, h = e.coordinates, !(s[0] === h[0] && s[1] === h[1]);
                        case "LineString":
                            return !u(e, t);
                        case "Polygon":
                            return !(0, r.default)(t, e)
                        }
                        break;
                    case "LineString":
                        switch (e.type) {
                        case "Point":
                            return !u(t, e);
                        case "LineString":
                            return n = t, o = e, !((0, i.default)(n, o).features.length > 0);
                        case "Polygon":
                            return !l(e, t)
                        }
                        break;
                    case "Polygon":
                        switch (e.type) {
                        case "Point":
                            return !(0, r.default)(e, t);
                        case "LineString":
                            return !l(t, e);
                        case "Polygon":
                            return !function(t, e) {
                                for (var n = 0, o = t.coordinates[0]; n < o.length; n++) {
                                    var s = o[n];
                                    if ((0, r.default)(s, e))
                                        return !0
                                }
                                for (var u = 0, l = e.coordinates[0]; u < l.length; u++) {
                                    var h = l[u];
                                    if ((0, r.default)(h, t))
                                        return !0
                                }
                                return (0, i.default)((0, a.default)(t), (0, a.default)(e)).features.length > 0
                            }(e, t)
                        }
                    }
                    var n,
                        o;
                    var s,
                        h;
                    return !1
                }(t.geometry, e.geometry)
            }))
        })), n
    }
})),
o.register("lC5qP", (function(e, n) {
    t(e.exports, "default", (() => i));
    var r = o("kIJpF");
    function i(t, e, n) {
        if (void 0 === n && (n = {}), !t)
            throw new Error("point is required");
        if (!e)
            throw new Error("polygon is required");
        var i = (0, r.getCoord)(t),
            o = (0, r.getGeom)(e),
            a = o.type,
            u = e.bbox,
            l = o.coordinates;
        if (u && !1 === function(t, e) {
            return e[0] <= t[0] && e[1] <= t[1] && e[2] >= t[0] && e[3] >= t[1]
        }(i, u))
            return !1;
        "Polygon" === a && (l = [l]);
        for (var h = !1, c = 0; c < l.length && !h; c++)
            if (s(i, l[c][0], n.ignoreBoundary)) {
                for (var p = !1, f = 1; f < l[c].length && !p;)
                    s(i, l[c][f], !n.ignoreBoundary) && (p = !0),
                    f++;
                p || (h = !0)
            }
        return h
    }
    function s(t, e, n) {
        var r = !1;
        e[0][0] === e[e.length - 1][0] && e[0][1] === e[e.length - 1][1] && (e = e.slice(0, e.length - 1));
        for (var i = 0, o = e.length - 1; i < e.length; o = i++) {
            var s = e[i][0],
                a = e[i][1],
                u = e[o][0],
                l = e[o][1];
            if (t[1] * (s - u) + a * (u - t[0]) + l * (t[0] - s) == 0 && (s - t[0]) * (u - t[0]) <= 0 && (a - t[1]) * (l - t[1]) <= 0)
                return !n;
            a > t[1] != l > t[1] && t[0] < (u - s) * (t[1] - a) / (l - a) + s && (r = !r)
        }
        return r
    }
})),
o.register("kIJpF", (function(e, n) {
    t(e.exports, "getCoord", (() => r)),
    t(e.exports, "getCoords", (() => i)),
    t(e.exports, "getGeom", (() => s));
    o("fGJNI");
    function r(t) {
        if (!t)
            throw new Error("coord is required");
        if (!Array.isArray(t)) {
            if ("Feature" === t.type && null !== t.geometry && "Point" === t.geometry.type)
                return t.geometry.coordinates;
            if ("Point" === t.type)
                return t.coordinates
        }
        if (Array.isArray(t) && t.length >= 2 && !Array.isArray(t[0]) && !Array.isArray(t[1]))
            return t;
        throw new Error("coord must be GeoJSON Point or an Array of numbers")
    }
    function i(t) {
        if (Array.isArray(t))
            return t;
        if ("Feature" === t.type) {
            if (null !== t.geometry)
                return t.geometry.coordinates
        } else if (t.coordinates)
            return t.coordinates;
        throw new Error("coords must be GeoJSON Feature, Geometry Object or an Array")
    }
    function s(t) {
        return "Feature" === t.type ? t.geometry : t
    }
})),
o.register("fGJNI", (function(e, n) {
    t(e.exports, "feature", (() => o)),
    t(e.exports, "point", (() => s)),
    t(e.exports, "lineString", (() => u)),
    t(e.exports, "polygon", (() => a)),
    t(e.exports, "multiLineString", (() => h)),
    t(e.exports, "isNumber", (() => f)),
    t(e.exports, "featureCollection", (() => l)),
    t(e.exports, "radiansToLength", (() => c)),
    t(e.exports, "degreesToRadians", (() => p)),
    t(e.exports, "isObject", (() => d));
    var r = 6371008.8,
        i = {
            centimeters: 637100880,
            centimetres: 637100880,
            degrees: 57.22891354143274,
            feet: 20902260.511392,
            inches: 250826616.45599997,
            kilometers: 6371.0088,
            kilometres: 6371.0088,
            meters: r,
            metres: r,
            miles: 3958.761333810546,
            millimeters: 6371008800,
            millimetres: 6371008800,
            nauticalmiles: 3440.069546436285,
            radians: 1,
            yards: 6967335.223679999
        };
    function o(t, e, n) {
        void 0 === n && (n = {});
        var r = {
            type: "Feature"
        };
        return (0 === n.id || n.id) && (r.id = n.id), n.bbox && (r.bbox = n.bbox), r.properties = e || {}, r.geometry = t, r
    }
    function s(t, e, n) {
        if (void 0 === n && (n = {}), !t)
            throw new Error("coordinates is required");
        if (!Array.isArray(t))
            throw new Error("coordinates must be an Array");
        if (t.length < 2)
            throw new Error("coordinates must be at least 2 numbers long");
        if (!f(t[0]) || !f(t[1]))
            throw new Error("coordinates must contain numbers");
        return o({
            type: "Point",
            coordinates: t
        }, e, n)
    }
    function a(t, e, n) {
        void 0 === n && (n = {});
        for (var r = 0, i = t; r < i.length; r++) {
            var s = i[r];
            if (s.length < 4)
                throw new Error("Each LinearRing of a Polygon must have 4 or more Positions.");
            for (var a = 0; a < s[s.length - 1].length; a++)
                if (s[s.length - 1][a] !== s[0][a])
                    throw new Error("First and last Position are not equivalent.")
        }
        return o({
            type: "Polygon",
            coordinates: t
        }, e, n)
    }
    function u(t, e, n) {
        if (void 0 === n && (n = {}), t.length < 2)
            throw new Error("coordinates must be an array of two or more positions");
        return o({
            type: "LineString",
            coordinates: t
        }, e, n)
    }
    function l(t, e) {
        void 0 === e && (e = {});
        var n = {
            type: "FeatureCollection"
        };
        return e.id && (n.id = e.id), e.bbox && (n.bbox = e.bbox), n.features = t, n
    }
    function h(t, e, n) {
        return void 0 === n && (n = {}), o({
            type: "MultiLineString",
            coordinates: t
        }, e, n)
    }
    function c(t, e) {
        void 0 === e && (e = "kilometers");
        var n = i[e];
        if (!n)
            throw new Error(e + " units is invalid");
        return t * n
    }
    function p(t) {
        return t % 360 * Math.PI / 180
    }
    function f(t) {
        return !isNaN(t) && null !== t && !Array.isArray(t)
    }
    function d(t) {
        return !!t && t.constructor === Object
    }
})),
o.register("65Z2D", (function(n, r) {
    t(n.exports, "default", (() => c));
    var i = o("fGJNI"),
        s = o("kIJpF"),
        a = o("g8xUG"),
        u = o("9SUUV"),
        l = o("qYooA");
    function h(t, e) {
        var n = (0, s.getCoords)(t),
            r = (0, s.getCoords)(e);
        if (2 !== n.length)
            throw new Error("<intersects> line1 must only contain 2 coordinates");
        if (2 !== r.length)
            throw new Error("<intersects> line2 must only contain 2 coordinates");
        var o = n[0][0],
            a = n[0][1],
            u = n[1][0],
            l = n[1][1],
            h = r[0][0],
            c = r[0][1],
            p = r[1][0],
            f = r[1][1],
            d = (f - c) * (u - o) - (p - h) * (l - a),
            g = (p - h) * (a - c) - (f - c) * (o - h),
            y = (u - o) * (a - c) - (l - a) * (o - h);
        if (0 === d)
            return null;
        var v = g / d,
            m = y / d;
        if (v >= 0 && v <= 1 && m >= 0 && m <= 1) {
            var _ = o + v * (u - o),
                x = a + v * (l - a);
            return (0, i.point)([_, x])
        }
        return null
    }
    var c = function(t, n) {
        var r = {},
            o = [];
        if ("LineString" === t.type && (t = (0, i.feature)(t)), "LineString" === n.type && (n = (0, i.feature)(n)), "Feature" === t.type && "Feature" === n.type && null !== t.geometry && null !== n.geometry && "LineString" === t.geometry.type && "LineString" === n.geometry.type && 2 === t.geometry.coordinates.length && 2 === n.geometry.coordinates.length) {
            var c = h(t, n);
            return c && o.push(c), (0, i.featureCollection)(o)
        }
        var p = e(l)();
        return p.load((0, a.default)(n)), (0, u.featureEach)((0, a.default)(t), (function(t) {
            (0, u.featureEach)(p.search(t), (function(e) {
                var n = h(t, e);
                if (n) {
                    var i = (0, s.getCoords)(n).join(",");
                    r[i] || (r[i] = !0, o.push(n))
                }
            }))
        })), (0, i.featureCollection)(o)
    }
})),
o.register("g8xUG", (function(e, n) {
    t(e.exports, "default", (() => a));
    var r = o("fGJNI"),
        i = o("kIJpF"),
        s = o("9SUUV");
    var a = function(t) {
        if (!t)
            throw new Error("geojson is required");
        var e = [];
        return (0, s.flattenEach)(t, (function(t) {
            !function(t, e) {
                var n = [],
                    o = t.geometry;
                if (null !== o) {
                    switch (o.type) {
                    case "Polygon":
                        n = (0, i.getCoords)(o);
                        break;
                    case "LineString":
                        n = [(0, i.getCoords)(o)]
                    }
                    n.forEach((function(n) {
                        var i = function(t, e) {
                            var n = [];
                            return t.reduce((function(t, i) {
                                var o,
                                    s,
                                    a,
                                    u,
                                    l,
                                    h,
                                    c = (0, r.lineString)([t, i], e);
                                return c.bbox = (s = i, a = (o = t)[0], u = o[1], l = s[0], h = s[1], [a < l ? a : l, u < h ? u : h, a > l ? a : l, u > h ? u : h]), n.push(c), i
                            })), n
                        }(n, t.properties);
                        i.forEach((function(t) {
                            t.id = e.length,
                            e.push(t)
                        }))
                    }))
                }
            }(t, e)
        })), (0, r.featureCollection)(e)
    }
})),
o.register("9SUUV", (function(e, n) {
    t(e.exports, "coordEach", (() => i)),
    t(e.exports, "featureEach", (() => s)),
    t(e.exports, "flattenEach", (() => u));
    var r = o("fGJNI");
    function i(t, e, n) {
        if (null !== t)
            for (var r, o, s, a, u, l, h, c, p = 0, f = 0, d = t.type, g = "FeatureCollection" === d, y = "Feature" === d, v = g ? t.features.length : 1, m = 0; m < v; m++) {
                u = (c = !!(h = g ? t.features[m].geometry : y ? t.geometry : t) && "GeometryCollection" === h.type) ? h.geometries.length : 1;
                for (var _ = 0; _ < u; _++) {
                    var x = 0,
                        E = 0;
                    if (null !== (a = c ? h.geometries[_] : h)) {
                        l = a.coordinates;
                        var w = a.type;
                        switch (p = !n || "Polygon" !== w && "MultiPolygon" !== w ? 0 : 1, w) {
                        case null:
                            break;
                        case "Point":
                            if (!1 === e(l, f, m, x, E))
                                return !1;
                            f++,
                            x++;
                            break;
                        case "LineString":
                        case "MultiPoint":
                            for (r = 0; r < l.length; r++) {
                                if (!1 === e(l[r], f, m, x, E))
                                    return !1;
                                f++,
                                "MultiPoint" === w && x++
                            }
                            "LineString" === w && x++;
                            break;
                        case "Polygon":
                        case "MultiLineString":
                            for (r = 0; r < l.length; r++) {
                                for (o = 0; o < l[r].length - p; o++) {
                                    if (!1 === e(l[r][o], f, m, x, E))
                                        return !1;
                                    f++
                                }
                                "MultiLineString" === w && x++,
                                "Polygon" === w && E++
                            }
                            "Polygon" === w && x++;
                            break;
                        case "MultiPolygon":
                            for (r = 0; r < l.length; r++) {
                                for (E = 0, o = 0; o < l[r].length; o++) {
                                    for (s = 0; s < l[r][o].length - p; s++) {
                                        if (!1 === e(l[r][o][s], f, m, x, E))
                                            return !1;
                                        f++
                                    }
                                    E++
                                }
                                x++
                            }
                            break;
                        case "GeometryCollection":
                            for (r = 0; r < a.geometries.length; r++)
                                if (!1 === i(a.geometries[r], e, n))
                                    return !1;
                            break;
                        default:
                            throw new Error("Unknown Geometry Type")
                        }
                    }
                }
            }
    }
    function s(t, e) {
        if ("Feature" === t.type)
            e(t, 0);
        else if ("FeatureCollection" === t.type)
            for (var n = 0; n < t.features.length && !1 !== e(t.features[n], n); n++)
                ;
    }
    function a(t, e) {
        var n,
            r,
            i,
            o,
            s,
            a,
            u,
            l,
            h,
            c,
            p = 0,
            f = "FeatureCollection" === t.type,
            d = "Feature" === t.type,
            g = f ? t.features.length : 1;
        for (n = 0; n < g; n++) {
            for (a = f ? t.features[n].geometry : d ? t.geometry : t, l = f ? t.features[n].properties : d ? t.properties : {}, h = f ? t.features[n].bbox : d ? t.bbox : void 0, c = f ? t.features[n].id : d ? t.id : void 0, s = (u = !!a && "GeometryCollection" === a.type) ? a.geometries.length : 1, i = 0; i < s; i++)
                if (null !== (o = u ? a.geometries[i] : a))
                    switch (o.type) {
                    case "Point":
                    case "LineString":
                    case "MultiPoint":
                    case "Polygon":
                    case "MultiLineString":
                    case "MultiPolygon":
                        if (!1 === e(o, p, l, h, c))
                            return !1;
                        break;
                    case "GeometryCollection":
                        for (r = 0; r < o.geometries.length; r++)
                            if (!1 === e(o.geometries[r], p, l, h, c))
                                return !1;
                        break;
                    default:
                        throw new Error("Unknown Geometry Type")
                    }
                else if (!1 === e(null, p, l, h, c))
                    return !1;
            p++
        }
    }
    function u(t, e) {
        a(t, (function(t, n, i, o, s) {
            var a,
                u = null === t ? null : t.type;
            switch (u) {
            case null:
            case "Point":
            case "LineString":
            case "Polygon":
                return !1 !== e((0, r.feature)(t, i, {
                        bbox: o,
                        id: s
                    }), n, 0) && void 0
            }
            switch (u) {
            case "MultiPoint":
                a = "Point";
                break;
            case "MultiLineString":
                a = "LineString";
                break;
            case "MultiPolygon":
                a = "Polygon"
            }
            for (var l = 0; l < t.coordinates.length; l++) {
                var h = {
                    type: a,
                    coordinates: t.coordinates[l]
                };
                if (!1 === e((0, r.feature)(h, i), n, l))
                    return !1
            }
        }))
    }
})),
o.register("qYooA", (function(t, e) {
    var n = o("20GDs"),
        r = o("fGJNI"),
        i = o("9SUUV"),
        s = o("11Tzk").default,
        a = i.featureEach,
        u = (i.coordEach, r.polygon, r.featureCollection);
    function l(t) {
        var e = new n(t);
        return e.insert = function(t) {
            if ("Feature" !== t.type)
                throw new Error("invalid feature");
            return t.bbox = t.bbox ? t.bbox : s(t), n.prototype.insert.call(this, t)
        }, e.load = function(t) {
            var e = [];
            return Array.isArray(t) ? t.forEach((function(t) {
                if ("Feature" !== t.type)
                    throw new Error("invalid features");
                t.bbox = t.bbox ? t.bbox : s(t),
                e.push(t)
            })) : a(t, (function(t) {
                if ("Feature" !== t.type)
                    throw new Error("invalid features");
                t.bbox = t.bbox ? t.bbox : s(t),
                e.push(t)
            })), n.prototype.load.call(this, e)
        }, e.remove = function(t, e) {
            if ("Feature" !== t.type)
                throw new Error("invalid feature");
            return t.bbox = t.bbox ? t.bbox : s(t), n.prototype.remove.call(this, t, e)
        }, e.clear = function() {
            return n.prototype.clear.call(this)
        }, e.search = function(t) {
            var e = n.prototype.search.call(this, this.toBBox(t));
            return u(e)
        }, e.collides = function(t) {
            return n.prototype.collides.call(this, this.toBBox(t))
        }, e.all = function() {
            var t = n.prototype.all.call(this);
            return u(t)
        }, e.toJSON = function() {
            return n.prototype.toJSON.call(this)
        }, e.fromJSON = function(t) {
            return n.prototype.fromJSON.call(this, t)
        }, e.toBBox = function(t) {
            var e;
            if (t.bbox)
                e = t.bbox;
            else if (Array.isArray(t) && 4 === t.length)
                e = t;
            else if (Array.isArray(t) && 6 === t.length)
                e = [t[0], t[1], t[3], t[4]];
            else if ("Feature" === t.type)
                e = s(t);
            else {
                if ("FeatureCollection" !== t.type)
                    throw new Error("invalid geojson");
                e = s(t)
            }
            return {
                minX: e[0],
                minY: e[1],
                maxX: e[2],
                maxY: e[3]
            }
        }, e
    }
    t.exports = l,
    t.exports.default = l
})),
o.register("20GDs", (function(t, e) {
    t.exports,
    t.exports = function() {
        function t(t, r, i, o, s) {
            !function t(n, r, i, o, s) {
                for (; o > i;) {
                    if (o - i > 600) {
                        var a = o - i + 1,
                            u = r - i + 1,
                            l = Math.log(a),
                            h = .5 * Math.exp(2 * l / 3),
                            c = .5 * Math.sqrt(l * h * (a - h) / a) * (u - a / 2 < 0 ? -1 : 1);
                        t(n, r, Math.max(i, Math.floor(r - u * h / a + c)), Math.min(o, Math.floor(r + (a - u) * h / a + c)), s)
                    }
                    var p = n[r],
                        f = i,
                        d = o;
                    for (e(n, i, r), s(n[o], p) > 0 && e(n, i, o); f < d;) {
                        for (e(n, f, d), f++, d--; s(n[f], p) < 0;)
                            f++;
                        for (; s(n[d], p) > 0;)
                            d--
                    }
                    0 === s(n[i], p) ? e(n, i, d) : e(n, ++d, o),
                    d <= r && (i = d + 1),
                    r <= d && (o = d - 1)
                }
            }(t, r, i || 0, o || t.length - 1, s || n)
        }
        function e(t, e, n) {
            var r = t[e];
            t[e] = t[n],
            t[n] = r
        }
        function n(t, e) {
            return t < e ? -1 : t > e ? 1 : 0
        }
        var r = function(t) {
            void 0 === t && (t = 9),
            this._maxEntries = Math.max(4, t),
            this._minEntries = Math.max(2, Math.ceil(.4 * this._maxEntries)),
            this.clear()
        };
        function i(t, e, n) {
            if (!n)
                return e.indexOf(t);
            for (var r = 0; r < e.length; r++)
                if (n(t, e[r]))
                    return r;
            return -1
        }
        function o(t, e) {
            s(t, 0, t.children.length, e, t)
        }
        function s(t, e, n, r, i) {
            i || (i = d(null)),
            i.minX = 1 / 0,
            i.minY = 1 / 0,
            i.maxX = -1 / 0,
            i.maxY = -1 / 0;
            for (var o = e; o < n; o++) {
                var s = t.children[o];
                a(i, t.leaf ? r(s) : s)
            }
            return i
        }
        function a(t, e) {
            return t.minX = Math.min(t.minX, e.minX), t.minY = Math.min(t.minY, e.minY), t.maxX = Math.max(t.maxX, e.maxX), t.maxY = Math.max(t.maxY, e.maxY), t
        }
        function u(t, e) {
            return t.minX - e.minX
        }
        function l(t, e) {
            return t.minY - e.minY
        }
        function h(t) {
            return (t.maxX - t.minX) * (t.maxY - t.minY)
        }
        function c(t) {
            return t.maxX - t.minX + (t.maxY - t.minY)
        }
        function p(t, e) {
            return t.minX <= e.minX && t.minY <= e.minY && e.maxX <= t.maxX && e.maxY <= t.maxY
        }
        function f(t, e) {
            return e.minX <= t.maxX && e.minY <= t.maxY && e.maxX >= t.minX && e.maxY >= t.minY
        }
        function d(t) {
            return {
                children: t,
                height: 1,
                leaf: !0,
                minX: 1 / 0,
                minY: 1 / 0,
                maxX: -1 / 0,
                maxY: -1 / 0
            }
        }
        function g(e, n, r, i, o) {
            for (var s = [n, r]; s.length;)
                if (!((r = s.pop()) - (n = s.pop()) <= i)) {
                    var a = n + Math.ceil((r - n) / i / 2) * i;
                    t(e, a, n, r, o),
                    s.push(n, a, a, r)
                }
        }
        return r.prototype.all = function() {
            return this._all(this.data, [])
        }, r.prototype.search = function(t) {
            var e = this.data,
                n = [];
            if (!f(t, e))
                return n;
            for (var r = this.toBBox, i = []; e;) {
                for (var o = 0; o < e.children.length; o++) {
                    var s = e.children[o],
                        a = e.leaf ? r(s) : s;
                    f(t, a) && (e.leaf ? n.push(s) : p(t, a) ? this._all(s, n) : i.push(s))
                }
                e = i.pop()
            }
            return n
        }, r.prototype.collides = function(t) {
            var e = this.data;
            if (!f(t, e))
                return !1;
            for (var n = []; e;) {
                for (var r = 0; r < e.children.length; r++) {
                    var i = e.children[r],
                        o = e.leaf ? this.toBBox(i) : i;
                    if (f(t, o)) {
                        if (e.leaf || p(t, o))
                            return !0;
                        n.push(i)
                    }
                }
                e = n.pop()
            }
            return !1
        }, r.prototype.load = function(t) {
            if (!t || !t.length)
                return this;
            if (t.length < this._minEntries) {
                for (var e = 0; e < t.length; e++)
                    this.insert(t[e]);
                return this
            }
            var n = this._build(t.slice(), 0, t.length - 1, 0);
            if (this.data.children.length)
                if (this.data.height === n.height)
                    this._splitRoot(this.data, n);
                else {
                    if (this.data.height < n.height) {
                        var r = this.data;
                        this.data = n,
                        n = r
                    }
                    this._insert(n, this.data.height - n.height - 1, !0)
                }
            else
                this.data = n;
            return this
        }, r.prototype.insert = function(t) {
            return t && this._insert(t, this.data.height - 1), this
        }, r.prototype.clear = function() {
            return this.data = d([]), this
        }, r.prototype.remove = function(t, e) {
            if (!t)
                return this;
            for (var n, r, o, s = this.data, a = this.toBBox(t), u = [], l = []; s || u.length;) {
                if (s || (s = u.pop(), r = u[u.length - 1], n = l.pop(), o = !0), s.leaf) {
                    var h = i(t, s.children, e);
                    if (-1 !== h)
                        return s.children.splice(h, 1), u.push(s), this._condense(u), this
                }
                o || s.leaf || !p(s, a) ? r ? (n++, s = r.children[n], o = !1) : s = null : (u.push(s), l.push(n), n = 0, r = s, s = s.children[0])
            }
            return this
        }, r.prototype.toBBox = function(t) {
            return t
        }, r.prototype.compareMinX = function(t, e) {
            return t.minX - e.minX
        }, r.prototype.compareMinY = function(t, e) {
            return t.minY - e.minY
        }, r.prototype.toJSON = function() {
            return this.data
        }, r.prototype.fromJSON = function(t) {
            return this.data = t, this
        }, r.prototype._all = function(t, e) {
            for (var n = []; t;)
                t.leaf ? e.push.apply(e, t.children) : n.push.apply(n, t.children),
                t = n.pop();
            return e
        }, r.prototype._build = function(t, e, n, r) {
            var i,
                s = n - e + 1,
                a = this._maxEntries;
            if (s <= a)
                return o(i = d(t.slice(e, n + 1)), this.toBBox), i;
            r || (r = Math.ceil(Math.log(s) / Math.log(a)), a = Math.ceil(s / Math.pow(a, r - 1))),
            (i = d([])).leaf = !1,
            i.height = r;
            var u = Math.ceil(s / a),
                l = u * Math.ceil(Math.sqrt(a));
            g(t, e, n, l, this.compareMinX);
            for (var h = e; h <= n; h += l) {
                var c = Math.min(h + l - 1, n);
                g(t, h, c, u, this.compareMinY);
                for (var p = h; p <= c; p += u) {
                    var f = Math.min(p + u - 1, c);
                    i.children.push(this._build(t, p, f, r - 1))
                }
            }
            return o(i, this.toBBox), i
        }, r.prototype._chooseSubtree = function(t, e, n, r) {
            for (; r.push(e), !e.leaf && r.length - 1 !== n;) {
                for (var i = 1 / 0, o = 1 / 0, s = void 0, a = 0; a < e.children.length; a++) {
                    var u = e.children[a],
                        l = h(u),
                        c = (p = t, f = u, (Math.max(f.maxX, p.maxX) - Math.min(f.minX, p.minX)) * (Math.max(f.maxY, p.maxY) - Math.min(f.minY, p.minY)) - l);
                    c < o ? (o = c, i = l < i ? l : i, s = u) : c === o && l < i && (i = l, s = u)
                }
                e = s || e.children[0]
            }
            var p,
                f;
            return e
        }, r.prototype._insert = function(t, e, n) {
            var r = n ? t : this.toBBox(t),
                i = [],
                o = this._chooseSubtree(r, this.data, e, i);
            for (o.children.push(t), a(o, r); e >= 0 && i[e].children.length > this._maxEntries;)
                this._split(i, e),
                e--;
            this._adjustParentBBoxes(r, i, e)
        }, r.prototype._split = function(t, e) {
            var n = t[e],
                r = n.children.length,
                i = this._minEntries;
            this._chooseSplitAxis(n, i, r);
            var s = this._chooseSplitIndex(n, i, r),
                a = d(n.children.splice(s, n.children.length - s));
            a.height = n.height,
            a.leaf = n.leaf,
            o(n, this.toBBox),
            o(a, this.toBBox),
            e ? t[e - 1].children.push(a) : this._splitRoot(n, a)
        }, r.prototype._splitRoot = function(t, e) {
            this.data = d([t, e]),
            this.data.height = t.height + 1,
            this.data.leaf = !1,
            o(this.data, this.toBBox)
        }, r.prototype._chooseSplitIndex = function(t, e, n) {
            for (var r, i, o, a, u, l, c, p = 1 / 0, f = 1 / 0, d = e; d <= n - e; d++) {
                var g = s(t, 0, d, this.toBBox),
                    y = s(t, d, n, this.toBBox),
                    v = (i = g, o = y, a = void 0, u = void 0, l = void 0, c = void 0, a = Math.max(i.minX, o.minX), u = Math.max(i.minY, o.minY), l = Math.min(i.maxX, o.maxX), c = Math.min(i.maxY, o.maxY), Math.max(0, l - a) * Math.max(0, c - u)),
                    m = h(g) + h(y);
                v < p ? (p = v, r = d, f = m < f ? m : f) : v === p && m < f && (f = m, r = d)
            }
            return r || n - e
        }, r.prototype._chooseSplitAxis = function(t, e, n) {
            var r = t.leaf ? this.compareMinX : u,
                i = t.leaf ? this.compareMinY : l;
            this._allDistMargin(t, e, n, r) < this._allDistMargin(t, e, n, i) && t.children.sort(r)
        }, r.prototype._allDistMargin = function(t, e, n, r) {
            t.children.sort(r);
            for (var i = this.toBBox, o = s(t, 0, e, i), u = s(t, n - e, n, i), l = c(o) + c(u), h = e; h < n - e; h++) {
                var p = t.children[h];
                a(o, t.leaf ? i(p) : p),
                l += c(o)
            }
            for (var f = n - e - 1; f >= e; f--) {
                var d = t.children[f];
                a(u, t.leaf ? i(d) : d),
                l += c(u)
            }
            return l
        }, r.prototype._adjustParentBBoxes = function(t, e, n) {
            for (var r = n; r >= 0; r--)
                a(e[r], t)
        }, r.prototype._condense = function(t) {
            for (var e = t.length - 1, n = void 0; e >= 0; e--)
                0 === t[e].children.length ? e > 0 ? (n = t[e - 1].children).splice(n.indexOf(t[e]), 1) : this.clear() : o(t[e], this.toBBox)
        }, r
    }()
})),
o.register("11Tzk", (function(e, n) {
    t(e.exports, "default", (() => s));
    var r = o("9SUUV");
    function i(t) {
        var e = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
        return (0, r.coordEach)(t, (function(t) {
            e[0] > t[0] && (e[0] = t[0]),
            e[1] > t[1] && (e[1] = t[1]),
            e[2] < t[0] && (e[2] = t[0]),
            e[3] < t[1] && (e[3] = t[1])
        })), e
    }
    i.default = i;
    var s = i
})),
o.register("exGnI", (function(e, n) {
    t(e.exports, "default", (() => s));
    var r = o("fGJNI"),
        i = o("kIJpF");
    function s(t, e) {
        void 0 === e && (e = {});
        var n = (0, i.getGeom)(t);
        switch (e.properties || "Feature" !== t.type || (e.properties = t.properties), n.type) {
        case "Polygon":
            return function(t, e) {
                void 0 === e && (e = {});
                var n = (0, i.getGeom)(t).coordinates,
                    r = e.properties ? e.properties : "Feature" === t.type ? t.properties : {};
                return a(n, r)
            }(n, e);
        case "MultiPolygon":
            return function(t, e) {
                void 0 === e && (e = {});
                var n = (0, i.getGeom)(t).coordinates,
                    o = e.properties ? e.properties : "Feature" === t.type ? t.properties : {},
                    s = [];
                return n.forEach((function(t) {
                    s.push(a(t, o))
                })), (0, r.featureCollection)(s)
            }(n, e);
        default:
            throw new Error("invalid poly")
        }
    }
    function a(t, e) {
        return t.length > 1 ? (0, r.multiLineString)(t, e) : (0, r.lineString)(t[0], e)
    }
})),
o.register("7XioC", (function(e, n) {
    t(e.exports, "default", (() => s));
    var r = o("kIJpF"),
        i = o("fGJNI");
    var s = function(t, e, n) {
        void 0 === n && (n = {});
        var o = (0, r.getCoord)(t),
            s = (0, r.getCoord)(e),
            a = (0, i.degreesToRadians)(s[1] - o[1]),
            u = (0, i.degreesToRadians)(s[0] - o[0]),
            l = (0, i.degreesToRadians)(o[1]),
            h = (0, i.degreesToRadians)(s[1]),
            c = Math.pow(Math.sin(a / 2), 2) + Math.pow(Math.sin(u / 2), 2) * Math.cos(l) * Math.cos(h);
        return (0, i.radiansToLength)(2 * Math.atan2(Math.sqrt(c), Math.sqrt(1 - c)), n.units)
    }
}));
var s = {};
t(s, "CollectionEvent", (() => $), (t => $ = t)),
t(s, "default", (() => K), (t => K = t));
var a = {};
function u() {
    return function() {
        throw new Error("Unimplemented abstract method.")
    }()
}
t(a, "default", (() => f), (t => f = t));
var l = 0;
function h(t) {
    return t.ol_uid || (t.ol_uid = String(++l))
}
var c,
    p = (c = function(t, e) {
        return c = Object.setPrototypeOf || {
            __proto__: []
        } instanceof Array && function(t, e) {
            t.__proto__ = e
        } || function(t, e) {
            for (var n in e)
                Object.prototype.hasOwnProperty.call(e, n) && (t[n] = e[n])
        }, c(t, e)
    }, function(t, e) {
        if ("function" != typeof e && null !== e)
            throw new TypeError("Class extends value " + String(e) + " is not a constructor or null");
        function n() {
            this.constructor = t
        }
        c(t, e),
        t.prototype = null === e ? Object.create(e) : (n.prototype = e.prototype, new n)
    }),
    f = function(t) {
        function e(e) {
            var n = this,
                r = "Assertion failed. See https://openlayers.org/en/" + ("v" + "6.15.1".split("-")[0]) + "/doc/errors/#" + e + " for details.";
            return (n = t.call(this, r) || this).code = e, n.name = "AssertionError", n.message = r, n
        }
        return p(e, t), e
    }(Error),
    d = {};
t(d, "ObjectEvent", (() => V), (t => V = t)),
t(d, "default", (() => X), (t => X = t));
var g = function() {
        function t(t) {
            this.propagationStopped,
            this.defaultPrevented,
            this.type = t,
            this.target = null
        }
        return t.prototype.preventDefault = function() {
            this.defaultPrevented = !0
        }, t.prototype.stopPropagation = function() {
            this.propagationStopped = !0
        }, t
    }(),
    y = {
        PROPERTYCHANGE: "propertychange"
    },
    v = {};
t(v, "unByKey", (() => q), (t => q = t)),
t(v, "default", (() => z), (t => z = t));
var m = {};
t(m, "default", (() => A), (t => A = t));
var _ = function() {
    function t() {
        this.disposed = !1
    }
    return t.prototype.dispose = function() {
        this.disposed || (this.disposed = !0, this.disposeInternal())
    }, t.prototype.disposeInternal = function() {}, t
}();
function x(t, e, n) {
    for (var r, i, o = n || E, s = 0, a = t.length, u = !1; s < a;)
        (i = +o(t[r = s + (a - s >> 1)], e)) < 0 ? s = r + 1 : (a = r, u = !i);
    return u ? s : ~s
}
function E(t, e) {
    return t > e ? 1 : t < e ? -1 : 0
}
function w(t, e, n) {
    var r = t.length;
    if (t[0] <= e)
        return 0;
    if (e <= t[r - 1])
        return r - 1;
    var i = void 0;
    if (n > 0) {
        for (i = 1; i < r; ++i)
            if (t[i] < e)
                return i - 1
    } else if (n < 0) {
        for (i = 1; i < r; ++i)
            if (t[i] <= e)
                return i
    } else
        for (i = 1; i < r; ++i) {
            if (t[i] == e)
                return i;
            if (t[i] < e)
                return "function" == typeof n ? n(e, t[i - 1], t[i]) > 0 ? i - 1 : i : t[i - 1] - e < e - t[i] ? i - 1 : i
        }
    return r - 1
}
function b(t, e, n) {
    for (; e < n;) {
        var r = t[e];
        t[e] = t[n],
        t[n] = r,
        ++e,
        --n
    }
}
function C(t, e) {
    for (var n = Array.isArray(e) ? e : [e], r = n.length, i = 0; i < r; i++)
        t[t.length] = n[i]
}
function M(t, e) {
    var n = t.length;
    if (n !== e.length)
        return !1;
    for (var r = 0; r < n; r++)
        if (t[r] !== e[r])
            return !1;
    return !0
}
function S() {
    return !0
}
function I() {
    return !1
}
function T() {}
var P = "function" == typeof Object.assign ? Object.assign : function(t, e) {
    if (null == t)
        throw new TypeError("Cannot convert undefined or null to object");
    for (var n = Object(t), r = 1, i = arguments.length; r < i; ++r) {
        var o = arguments[r];
        if (null != o)
            for (var s in o)
                o.hasOwnProperty(s) && (n[s] = o[s])
    }
    return n
};
function L(t) {
    for (var e in t)
        delete t[e]
}
var O = "function" == typeof Object.values ? Object.values : function(t) {
    var e = [];
    for (var n in t)
        e.push(t[n]);
    return e
};
function N(t) {
    var e;
    for (e in t)
        return !1;
    return !e
}
var R = function() {
        var t = function(e, n) {
            return t = Object.setPrototypeOf || {
                __proto__: []
            } instanceof Array && function(t, e) {
                t.__proto__ = e
            } || function(t, e) {
                for (var n in e)
                    Object.prototype.hasOwnProperty.call(e, n) && (t[n] = e[n])
            }, t(e, n)
        };
        return function(e, n) {
            if ("function" != typeof n && null !== n)
                throw new TypeError("Class extends value " + String(n) + " is not a constructor or null");
            function r() {
                this.constructor = e
            }
            t(e, n),
            e.prototype = null === n ? Object.create(n) : (r.prototype = n.prototype, new r)
        }
    }(),
    A = function(t) {
        function e(e) {
            var n = t.call(this) || this;
            return n.eventTarget_ = e, n.pendingRemovals_ = null, n.dispatching_ = null, n.listeners_ = null, n
        }
        return R(e, t), e.prototype.addEventListener = function(t, e) {
            if (t && e) {
                var n = this.listeners_ || (this.listeners_ = {}),
                    r = n[t] || (n[t] = []);
                -1 === r.indexOf(e) && r.push(e)
            }
        }, e.prototype.dispatchEvent = function(t) {
            var e = "string" == typeof t,
                n = e ? t : t.type,
                r = this.listeners_ && this.listeners_[n];
            if (r) {
                var i = e ? new g(t) : t;
                i.target || (i.target = this.eventTarget_ || this);
                var o,
                    s = this.dispatching_ || (this.dispatching_ = {}),
                    a = this.pendingRemovals_ || (this.pendingRemovals_ = {});
                n in s || (s[n] = 0, a[n] = 0),
                ++s[n];
                for (var u = 0, l = r.length; u < l; ++u)
                    if (!1 === (o = "handleEvent" in r[u] ? r[u].handleEvent(i) : r[u].call(this, i)) || i.propagationStopped) {
                        o = !1;
                        break
                    }
                if (0 == --s[n]) {
                    var h = a[n];
                    for (delete a[n]; h--;)
                        this.removeEventListener(n, T);
                    delete s[n]
                }
                return o
            }
        }, e.prototype.disposeInternal = function() {
            this.listeners_ && L(this.listeners_)
        }, e.prototype.getListeners = function(t) {
            return this.listeners_ && this.listeners_[t] || void 0
        }, e.prototype.hasListener = function(t) {
            return !!this.listeners_ && (t ? t in this.listeners_ : Object.keys(this.listeners_).length > 0)
        }, e.prototype.removeEventListener = function(t, e) {
            var n = this.listeners_ && this.listeners_[t];
            if (n) {
                var r = n.indexOf(e);
                -1 !== r && (this.pendingRemovals_ && t in this.pendingRemovals_ ? (n[r] = T, ++this.pendingRemovals_[t]) : (n.splice(r, 1), 0 === n.length && delete this.listeners_[t]))
            }
        }, e
    }(_),
    D = {
        CHANGE: "change",
        ERROR: "error",
        BLUR: "blur",
        CLEAR: "clear",
        CONTEXTMENU: "contextmenu",
        CLICK: "click",
        DBLCLICK: "dblclick",
        DRAGENTER: "dragenter",
        DRAGOVER: "dragover",
        DROP: "drop",
        FOCUS: "focus",
        KEYDOWN: "keydown",
        KEYPRESS: "keypress",
        LOAD: "load",
        RESIZE: "resize",
        TOUCHMOVE: "touchmove",
        WHEEL: "wheel"
    };
function F(t, e, n, r, i) {
    if (r && r !== t && (n = n.bind(r)), i) {
        var o = n;
        n = function() {
            t.removeEventListener(e, n),
            o.apply(this, arguments)
        }
    }
    var s = {
        target: t,
        type: e,
        listener: n
    };
    return t.addEventListener(e, n), s
}
function k(t, e, n, r) {
    return F(t, e, n, r, !0)
}
function j(t) {
    t && t.target && (t.target.removeEventListener(t.type, t.listener), L(t))
}
var G = function() {
        var t = function(e, n) {
            return t = Object.setPrototypeOf || {
                __proto__: []
            } instanceof Array && function(t, e) {
                t.__proto__ = e
            } || function(t, e) {
                for (var n in e)
                    Object.prototype.hasOwnProperty.call(e, n) && (t[n] = e[n])
            }, t(e, n)
        };
        return function(e, n) {
            if ("function" != typeof n && null !== n)
                throw new TypeError("Class extends value " + String(n) + " is not a constructor or null");
            function r() {
                this.constructor = e
            }
            t(e, n),
            e.prototype = null === n ? Object.create(n) : (r.prototype = n.prototype, new r)
        }
    }(),
    B = function(t) {
        function e() {
            var e = t.call(this) || this;
            return e.on = e.onInternal, e.once = e.onceInternal, e.un = e.unInternal, e.revision_ = 0, e
        }
        return G(e, t), e.prototype.changed = function() {
            ++this.revision_,
            this.dispatchEvent(D.CHANGE)
        }, e.prototype.getRevision = function() {
            return this.revision_
        }, e.prototype.onInternal = function(t, e) {
            if (Array.isArray(t)) {
                for (var n = t.length, r = new Array(n), i = 0; i < n; ++i)
                    r[i] = F(this, t[i], e);
                return r
            }
            return F(this, t, e)
        }, e.prototype.onceInternal = function(t, e) {
            var n;
            if (Array.isArray(t)) {
                var r = t.length;
                n = new Array(r);
                for (var i = 0; i < r; ++i)
                    n[i] = k(this, t[i], e)
            } else
                n = k(this, t, e);
            return e.ol_key = n, n
        }, e.prototype.unInternal = function(t, e) {
            var n = e.ol_key;
            if (n)
                q(n);
            else if (Array.isArray(t))
                for (var r = 0, i = t.length; r < i; ++r)
                    this.removeEventListener(t[r], e);
            else
                this.removeEventListener(t, e)
        }, e
    }(m.default);
function q(t) {
    if (Array.isArray(t))
        for (var e = 0, n = t.length; e < n; ++e)
            j(t[e]);
    else
        j(t)
}
B.prototype.on,
B.prototype.once,
B.prototype.un;
var z = B,
    U = function() {
        var t = function(e, n) {
            return t = Object.setPrototypeOf || {
                __proto__: []
            } instanceof Array && function(t, e) {
                t.__proto__ = e
            } || function(t, e) {
                for (var n in e)
                    Object.prototype.hasOwnProperty.call(e, n) && (t[n] = e[n])
            }, t(e, n)
        };
        return function(e, n) {
            if ("function" != typeof n && null !== n)
                throw new TypeError("Class extends value " + String(n) + " is not a constructor or null");
            function r() {
                this.constructor = e
            }
            t(e, n),
            e.prototype = null === n ? Object.create(n) : (r.prototype = n.prototype, new r)
        }
    }(),
    V = function(t) {
        function e(e, n, r) {
            var i = t.call(this, e) || this;
            return i.key = n, i.oldValue = r, i
        }
        return U(e, t), e
    }(g),
    X = function(t) {
        function e(e) {
            var n = t.call(this) || this;
            return n.on, n.once, n.un, h(n), n.values_ = null, void 0 !== e && n.setProperties(e), n
        }
        return U(e, t), e.prototype.get = function(t) {
            var e;
            return this.values_ && this.values_.hasOwnProperty(t) && (e = this.values_[t]), e
        }, e.prototype.getKeys = function() {
            return this.values_ && Object.keys(this.values_) || []
        }, e.prototype.getProperties = function() {
            return this.values_ && P({}, this.values_) || {}
        }, e.prototype.hasProperties = function() {
            return !!this.values_
        }, e.prototype.notify = function(t, e) {
            var n;
            n = "change:".concat(t),
            this.hasListener(n) && this.dispatchEvent(new V(n, t, e)),
            n = y.PROPERTYCHANGE,
            this.hasListener(n) && this.dispatchEvent(new V(n, t, e))
        }, e.prototype.addChangeListener = function(t, e) {
            this.addEventListener("change:".concat(t), e)
        }, e.prototype.removeChangeListener = function(t, e) {
            this.removeEventListener("change:".concat(t), e)
        }, e.prototype.set = function(t, e, n) {
            var r = this.values_ || (this.values_ = {});
            if (n)
                r[t] = e;
            else {
                var i = r[t];
                r[t] = e,
                i !== e && this.notify(t, i)
            }
        }, e.prototype.setProperties = function(t, e) {
            for (var n in t)
                this.set(n, t[n], e)
        }, e.prototype.applyProperties = function(t) {
            t.values_ && P(this.values_ || (this.values_ = {}), t.values_)
        }, e.prototype.unset = function(t, e) {
            if (this.values_ && t in this.values_) {
                var n = this.values_[t];
                delete this.values_[t],
                N(this.values_) && (this.values_ = null),
                e || this.notify(t, n)
            }
        }, e
    }(v.default),
    H = {
        ADD: "add",
        REMOVE: "remove"
    },
    Y = function() {
        var t = function(e, n) {
            return t = Object.setPrototypeOf || {
                __proto__: []
            } instanceof Array && function(t, e) {
                t.__proto__ = e
            } || function(t, e) {
                for (var n in e)
                    Object.prototype.hasOwnProperty.call(e, n) && (t[n] = e[n])
            }, t(e, n)
        };
        return function(e, n) {
            if ("function" != typeof n && null !== n)
                throw new TypeError("Class extends value " + String(n) + " is not a constructor or null");
            function r() {
                this.constructor = e
            }
            t(e, n),
            e.prototype = null === n ? Object.create(n) : (r.prototype = n.prototype, new r)
        }
    }(),
    W = "length",
    $ = function(t) {
        function e(e, n, r) {
            var i = t.call(this, e) || this;
            return i.element = n, i.index = r, i
        }
        return Y(e, t), e
    }(g),
    K = function(t) {
        function e(e, n) {
            var r = t.call(this) || this;
            r.on,
            r.once,
            r.un;
            var i = n || {};
            if (r.unique_ = !!i.unique, r.array_ = e || [], r.unique_)
                for (var o = 0, s = r.array_.length; o < s; ++o)
                    r.assertUnique_(r.array_[o], o);
            return r.updateLength_(), r
        }
        return Y(e, t), e.prototype.clear = function() {
            for (; this.getLength() > 0;)
                this.pop()
        }, e.prototype.extend = function(t) {
            for (var e = 0, n = t.length; e < n; ++e)
                this.push(t[e]);
            return this
        }, e.prototype.forEach = function(t) {
            for (var e = this.array_, n = 0, r = e.length; n < r; ++n)
                t(e[n], n, e)
        }, e.prototype.getArray = function() {
            return this.array_
        }, e.prototype.item = function(t) {
            return this.array_[t]
        }, e.prototype.getLength = function() {
            return this.get(W)
        }, e.prototype.insertAt = function(t, e) {
            this.unique_ && this.assertUnique_(e),
            this.array_.splice(t, 0, e),
            this.updateLength_(),
            this.dispatchEvent(new $(H.ADD, e, t))
        }, e.prototype.pop = function() {
            return this.removeAt(this.getLength() - 1)
        }, e.prototype.push = function(t) {
            this.unique_ && this.assertUnique_(t);
            var e = this.getLength();
            return this.insertAt(e, t), this.getLength()
        }, e.prototype.remove = function(t) {
            for (var e = this.array_, n = 0, r = e.length; n < r; ++n)
                if (e[n] === t)
                    return this.removeAt(n)
        }, e.prototype.removeAt = function(t) {
            var e = this.array_[t];
            return this.array_.splice(t, 1), this.updateLength_(), this.dispatchEvent(new $(H.REMOVE, e, t)), e
        }, e.prototype.setAt = function(t, e) {
            var n = this.getLength();
            if (t < n) {
                this.unique_ && this.assertUnique_(e, t);
                var r = this.array_[t];
                this.array_[t] = e,
                this.dispatchEvent(new $(H.REMOVE, r, t)),
                this.dispatchEvent(new $(H.ADD, e, t))
            } else {
                for (var i = n; i < t; ++i)
                    this.insertAt(i, void 0);
                this.insertAt(t, e)
            }
        }, e.prototype.updateLength_ = function() {
            this.set(W, this.array_.length)
        }, e.prototype.assertUnique_ = function(t, e) {
            for (var n = 0, r = this.array_.length; n < r; ++n)
                if (this.array_[n] === t && n !== e)
                    throw new (0, a.default)(58)
        }, e
    }(d.default),
    Z = {};
function J(t, e) {
    if (!t)
        throw new (0, a.default)(e)
}
t(Z, "createStyleFunction", (() => tt), (t => tt = t)),
t(Z, "default", (() => et), (t => et = t));
var Q = function() {
    var t = function(e, n) {
        return t = Object.setPrototypeOf || {
            __proto__: []
        } instanceof Array && function(t, e) {
            t.__proto__ = e
        } || function(t, e) {
            for (var n in e)
                Object.prototype.hasOwnProperty.call(e, n) && (t[n] = e[n])
        }, t(e, n)
    };
    return function(e, n) {
        if ("function" != typeof n && null !== n)
            throw new TypeError("Class extends value " + String(n) + " is not a constructor or null");
        function r() {
            this.constructor = e
        }
        t(e, n),
        e.prototype = null === n ? Object.create(n) : (r.prototype = n.prototype, new r)
    }
}();
function tt(t) {
    return "function" == typeof t ? t : (Array.isArray(t) ? e = t : (J("function" == typeof t.getZIndex, 41), e = [t]), function() {
        return e
    });
    var e
}
var et = function(t) {
        function e(e) {
            var n = t.call(this) || this;
            if (n.on, n.once, n.un, n.id_ = void 0, n.geometryName_ = "geometry", n.style_ = null, n.styleFunction_ = void 0, n.geometryChangeKey_ = null, n.addChangeListener(n.geometryName_, n.handleGeometryChanged_), e)
                if ("function" == typeof e.getSimplifiedGeometry) {
                    var r = e;
                    n.setGeometry(r)
                } else {
                    var i = e;
                    n.setProperties(i)
                }
            return n
        }
        return Q(e, t), e.prototype.clone = function() {
            var t = new e(this.hasProperties() ? this.getProperties() : null);
            t.setGeometryName(this.getGeometryName());
            var n = this.getGeometry();
            n && t.setGeometry(n.clone());
            var r = this.getStyle();
            return r && t.setStyle(r), t
        }, e.prototype.getGeometry = function() {
            return this.get(this.geometryName_)
        }, e.prototype.getId = function() {
            return this.id_
        }, e.prototype.getGeometryName = function() {
            return this.geometryName_
        }, e.prototype.getStyle = function() {
            return this.style_
        }, e.prototype.getStyleFunction = function() {
            return this.styleFunction_
        }, e.prototype.handleGeometryChange_ = function() {
            this.changed()
        }, e.prototype.handleGeometryChanged_ = function() {
            this.geometryChangeKey_ && (j(this.geometryChangeKey_), this.geometryChangeKey_ = null);
            var t = this.getGeometry();
            t && (this.geometryChangeKey_ = F(t, D.CHANGE, this.handleGeometryChange_, this)),
            this.changed()
        }, e.prototype.setGeometry = function(t) {
            this.set(this.geometryName_, t)
        }, e.prototype.setStyle = function(t) {
            this.style_ = t,
            this.styleFunction_ = t ? tt(t) : void 0,
            this.changed()
        }, e.prototype.setId = function(t) {
            this.id_ = t,
            this.changed()
        }, e.prototype.setGeometryName = function(t) {
            this.removeChangeListener(this.geometryName_, this.handleGeometryChanged_),
            this.geometryName_ = t,
            this.addChangeListener(this.geometryName_, this.handleGeometryChanged_),
            this.handleGeometryChanged_()
        }, e
    }(d.default),
    nt = {};
t(nt, "default", (() => Kr), (t => Kr = t));
var rt = {};
t(rt, "default", (() => Rr), (t => Rr = t)),
t(rt, "circular", (() => Ar), (t => Ar = t)),
t(rt, "fromExtent", (() => Dr), (t => Dr = t)),
t(rt, "fromCircle", (() => Fr), (t => Fr = t)),
t(rt, "makeRegular", (() => kr), (t => kr = t));
var it = {
        XY: "XY",
        XYZ: "XYZ",
        XYM: "XYM",
        XYZM: "XYZM"
    },
    ot = {};
t(ot, "default", (() => lr), (t => lr = t));
var st = {};
t(st, "getStrideForLayout", (() => Fn), (t => Fn = t)),
t(st, "transformGeom2D", (() => kn), (t => kn = t)),
t(st, "default", (() => jn), (t => jn = t));
var at = {};
t(at, "default", (() => An), (t => An = t));
var ut = {
    RADIANS: "radians",
    DEGREES: "degrees",
    FEET: "ft",
    METERS: "m",
    PIXELS: "pixels",
    TILE_PIXELS: "tile-pixels",
    USFEET: "us-ft"
};
var lt = {};
lt[ut.RADIANS] = 6370997 / (2 * Math.PI),
lt[ut.DEGREES] = 2 * Math.PI * 6370997 / 360,
lt[ut.FEET] = .3048,
lt[ut.METERS] = 1,
lt[ut.USFEET] = 1200 / 3937;
var ht,
    ct = ut,
    pt = "undefined" != typeof navigator && void 0 !== navigator.userAgent ? navigator.userAgent.toLowerCase() : "",
    ft = -1 !== pt.indexOf("firefox"),
    dt = (-1 !== pt.indexOf("safari") && -1 == pt.indexOf("chrom") && (pt.indexOf("version/15.4") >= 0 || pt.match(/cpu (os|iphone os) 15_4 like mac os x/)), -1 !== pt.indexOf("webkit") && -1 == pt.indexOf("edge")),
    gt = -1 !== pt.indexOf("macintosh"),
    yt = "undefined" != typeof devicePixelRatio ? devicePixelRatio : 1,
    vt = "undefined" != typeof WorkerGlobalScope && "undefined" != typeof OffscreenCanvas && self instanceof WorkerGlobalScope,
    mt = "undefined" != typeof Image && Image.prototype.decode,
    _t = function() {
        var t = !1;
        try {
            var e = Object.defineProperty({}, "passive", {
                get: function() {
                    t = !0
                }
            });
            window.addEventListener("_", null, e),
            window.removeEventListener("_", null, e)
        } catch (t) {}
        return t
    }();
new Array(6);
function xt(t, e, n, r, i, o, s) {
    return t[0] = e, t[1] = n, t[2] = r, t[3] = i, t[4] = o, t[5] = s, t
}
function Et(t, e) {
    var n = e[0],
        r = e[1];
    return e[0] = t[0] * n + t[2] * r + t[4], e[1] = t[1] * n + t[3] * r + t[5], e
}
function wt(t, e, n) {
    return xt(t, e, 0, 0, n, 0, 0)
}
function bt(t, e, n, r, i, o, s, a) {
    var u = Math.sin(o),
        l = Math.cos(o);
    return t[0] = r * l, t[1] = i * u, t[2] = -r * u, t[3] = i * l, t[4] = s * r * l - a * r * u + e, t[5] = s * i * u + a * i * l + n, t
}
function Ct(t, e) {
    var n,
        r = (n = e)[0] * n[3] - n[1] * n[2];
    J(0 !== r, 32);
    var i = e[0],
        o = e[1],
        s = e[2],
        a = e[3],
        u = e[4],
        l = e[5];
    return t[0] = a / r, t[1] = -o / r, t[2] = -s / r, t[3] = i / r, t[4] = (s * l - a * u) / r, t[5] = -(i * l - o * u) / r, t
}
function Mt(t) {
    var e = "matrix(" + t.join(", ") + ")";
    if (vt)
        return e;
    var n = ht || (ht = document.createElement("div"));
    return n.style.transform = e, n.style.transform
}
var St = {
    UNKNOWN: 0,
    INTERSECTING: 1,
    ABOVE: 2,
    RIGHT: 4,
    BELOW: 8,
    LEFT: 16
};
function It(t) {
    for (var e = Dt(), n = 0, r = t.length; n < r; ++n)
        zt(e, t[n]);
    return e
}
function Tt(t, e, n) {
    return n ? (n[0] = t[0] - e, n[1] = t[1] - e, n[2] = t[2] + e, n[3] = t[3] + e, n) : [t[0] - e, t[1] - e, t[2] + e, t[3] + e]
}
function Pt(t, e) {
    return e ? (e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3], e) : t.slice()
}
function Lt(t, e, n) {
    var r,
        i;
    return (r = e < t[0] ? t[0] - e : t[2] < e ? e - t[2] : 0) * r + (i = n < t[1] ? t[1] - n : t[3] < n ? n - t[3] : 0) * i
}
function Ot(t, e) {
    return Rt(t, e[0], e[1])
}
function Nt(t, e) {
    return t[0] <= e[0] && e[2] <= t[2] && t[1] <= e[1] && e[3] <= t[3]
}
function Rt(t, e, n) {
    return t[0] <= e && e <= t[2] && t[1] <= n && n <= t[3]
}
function At(t, e) {
    var n = t[0],
        r = t[1],
        i = t[2],
        o = t[3],
        s = e[0],
        a = e[1],
        u = St.UNKNOWN;
    return s < n ? u |= St.LEFT : s > i && (u |= St.RIGHT), a < r ? u |= St.BELOW : a > o && (u |= St.ABOVE), u === St.UNKNOWN && (u = St.INTERSECTING), u
}
function Dt() {
    return [1 / 0, 1 / 0, -1 / 0, -1 / 0]
}
function Ft(t, e, n, r, i) {
    return i ? (i[0] = t, i[1] = e, i[2] = n, i[3] = r, i) : [t, e, n, r]
}
function kt(t) {
    return Ft(1 / 0, 1 / 0, -1 / 0, -1 / 0, t)
}
function jt(t, e) {
    var n = t[0],
        r = t[1];
    return Ft(n, r, n, r, e)
}
function Gt(t, e, n, r, i) {
    return Ut(kt(i), t, e, n, r)
}
function Bt(t, e) {
    return t[0] == e[0] && t[2] == e[2] && t[1] == e[1] && t[3] == e[3]
}
function qt(t, e) {
    return e[0] < t[0] && (t[0] = e[0]), e[2] > t[2] && (t[2] = e[2]), e[1] < t[1] && (t[1] = e[1]), e[3] > t[3] && (t[3] = e[3]), t
}
function zt(t, e) {
    e[0] < t[0] && (t[0] = e[0]),
    e[0] > t[2] && (t[2] = e[0]),
    e[1] < t[1] && (t[1] = e[1]),
    e[1] > t[3] && (t[3] = e[1])
}
function Ut(t, e, n, r, i) {
    for (; n < r; n += i)
        Vt(t, e[n], e[n + 1]);
    return t
}
function Vt(t, e, n) {
    t[0] = Math.min(t[0], e),
    t[1] = Math.min(t[1], n),
    t[2] = Math.max(t[2], e),
    t[3] = Math.max(t[3], n)
}
function Xt(t, e) {
    var n;
    return (n = e(Yt(t))) || (n = e(Wt(t))) || (n = e(ne(t))) ? n : (n = e(ee(t))) || !1
}
function Ht(t) {
    var e = 0;
    return oe(t) || (e = re(t) * Qt(t)), e
}
function Yt(t) {
    return [t[0], t[1]]
}
function Wt(t) {
    return [t[2], t[1]]
}
function $t(t) {
    return [(t[0] + t[2]) / 2, (t[1] + t[3]) / 2]
}
function Kt(t, e) {
    var n;
    return "bottom-left" === e ? n = Yt(t) : "bottom-right" === e ? n = Wt(t) : "top-left" === e ? n = ee(t) : "top-right" === e ? n = ne(t) : J(!1, 13), n
}
function Zt(t, e, n, r, i) {
    var o = Jt(t, e, n, r),
        s = o[0],
        a = o[1],
        u = o[2],
        l = o[3],
        h = o[4],
        c = o[5],
        p = o[6],
        f = o[7];
    return Ft(Math.min(s, u, h, p), Math.min(a, l, c, f), Math.max(s, u, h, p), Math.max(a, l, c, f), i)
}
function Jt(t, e, n, r) {
    var i = e * r[0] / 2,
        o = e * r[1] / 2,
        s = Math.cos(n),
        a = Math.sin(n),
        u = i * s,
        l = i * a,
        h = o * s,
        c = o * a,
        p = t[0],
        f = t[1];
    return [p - u + c, f - l - h, p - u - c, f - l + h, p + u - c, f + l + h, p + u + c, f + l - h, p - u + c, f - l - h]
}
function Qt(t) {
    return t[3] - t[1]
}
function te(t, e, n) {
    var r = n || [1 / 0, 1 / 0, -1 / 0, -1 / 0];
    return ie(t, e) ? (t[0] > e[0] ? r[0] = t[0] : r[0] = e[0], t[1] > e[1] ? r[1] = t[1] : r[1] = e[1], t[2] < e[2] ? r[2] = t[2] : r[2] = e[2], t[3] < e[3] ? r[3] = t[3] : r[3] = e[3]) : kt(r), r
}
function ee(t) {
    return [t[0], t[3]]
}
function ne(t) {
    return [t[2], t[3]]
}
function re(t) {
    return t[2] - t[0]
}
function ie(t, e) {
    return t[0] <= e[2] && t[2] >= e[0] && t[1] <= e[3] && t[3] >= e[1]
}
function oe(t) {
    return t[2] < t[0] || t[3] < t[1]
}
function se(t, e) {
    return e ? (e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3], e) : t
}
function ae(t, e, n) {
    var r = !1,
        i = At(t, e),
        o = At(t, n);
    if (i === St.INTERSECTING || o === St.INTERSECTING)
        r = !0;
    else {
        var s = t[0],
            a = t[1],
            u = t[2],
            l = t[3],
            h = e[0],
            c = e[1],
            p = n[0],
            f = n[1],
            d = (f - c) / (p - h),
            g = void 0,
            y = void 0;
        o & St.ABOVE && !(i & St.ABOVE) && (r = (g = p - (f - l) / d) >= s && g <= u),
        r || !(o & St.RIGHT) || i & St.RIGHT || (r = (y = f - (p - u) * d) >= a && y <= l),
        r || !(o & St.BELOW) || i & St.BELOW || (r = (g = p - (f - a) / d) >= s && g <= u),
        r || !(o & St.LEFT) || i & St.LEFT || (r = (y = f - (p - s) * d) >= a && y <= l)
    }
    return r
}
function ue(t, e, n, r) {
    var i = [];
    if (r > 1)
        for (var o = t[2] - t[0], s = t[3] - t[1], a = 0; a < r; ++a)
            i.push(t[0] + o * a / r, t[1], t[2], t[1] + s * a / r, t[2] - o * a / r, t[3], t[0], t[3] - s * a / r);
    else
        i = [t[0], t[1], t[2], t[1], t[2], t[3], t[0], t[3]];
    e(i, i, 2);
    for (var u = [], l = [], h = (a = 0, i.length); a < h; a += 2)
        u.push(i[a]),
        l.push(i[a + 1]);
    return function(t, e, n) {
        return Ft(Math.min.apply(null, t), Math.min.apply(null, e), Math.max.apply(null, t), Math.max.apply(null, e), n)
    }(u, l, n)
}
function le(t, e) {
    var n = e.getExtent(),
        r = $t(t);
    if (e.canWrapX() && (r[0] < n[0] || r[0] >= n[2])) {
        var i = re(n),
            o = Math.floor((r[0] - n[0]) / i) * i;
        t[0] -= o,
        t[2] -= o
    }
    return t
}
function he(t, e) {
    if (e.canWrapX()) {
        var n = e.getExtent();
        if (!isFinite(t[0]) || !isFinite(t[2]))
            return [[n[0], t[1], n[2], t[3]]];
        le(t, e);
        var r = re(n);
        if (re(t) > r)
            return [[n[0], t[1], n[2], t[3]]];
        if (t[0] < n[0])
            return [[t[0] + r, t[1], n[2], t[3]], [n[0], t[1], t[2], t[3]]];
        if (t[2] > n[2])
            return [[t[0], t[1], n[2], t[3]], [n[0], t[1], t[2] - r, t[3]]]
    }
    return [t]
}
var ce = {};
t(ce, "PROJECTIONS", (() => Ne), (t => Ne = t)),
t(ce, "fromEPSG4326", (() => Re), (t => Re = t)),
t(ce, "toEPSG4326", (() => Ae), (t => Ae = t));
var pe = function() {
    function t(t) {
        this.code_ = t.code,
        this.units_ = t.units,
        this.extent_ = void 0 !== t.extent ? t.extent : null,
        this.worldExtent_ = void 0 !== t.worldExtent ? t.worldExtent : null,
        this.axisOrientation_ = void 0 !== t.axisOrientation ? t.axisOrientation : "enu",
        this.global_ = void 0 !== t.global && t.global,
        this.canWrapX_ = !(!this.global_ || !this.extent_),
        this.getPointResolutionFunc_ = t.getPointResolution,
        this.defaultTileGrid_ = null,
        this.metersPerUnit_ = t.metersPerUnit
    }
    return t.prototype.canWrapX = function() {
        return this.canWrapX_
    }, t.prototype.getCode = function() {
        return this.code_
    }, t.prototype.getExtent = function() {
        return this.extent_
    }, t.prototype.getUnits = function() {
        return this.units_
    }, t.prototype.getMetersPerUnit = function() {
        return this.metersPerUnit_ || lt[this.units_]
    }, t.prototype.getWorldExtent = function() {
        return this.worldExtent_
    }, t.prototype.getAxisOrientation = function() {
        return this.axisOrientation_
    }, t.prototype.isGlobal = function() {
        return this.global_
    }, t.prototype.setGlobal = function(t) {
        this.global_ = t,
        this.canWrapX_ = !(!t || !this.extent_)
    }, t.prototype.getDefaultTileGrid = function() {
        return this.defaultTileGrid_
    }, t.prototype.setDefaultTileGrid = function(t) {
        this.defaultTileGrid_ = t
    }, t.prototype.setExtent = function(t) {
        this.extent_ = t,
        this.canWrapX_ = !(!this.global_ || !t)
    }, t.prototype.setWorldExtent = function(t) {
        this.worldExtent_ = t
    }, t.prototype.setGetPointResolution = function(t) {
        this.getPointResolutionFunc_ = t
    }, t.prototype.getPointResolutionFunc = function() {
        return this.getPointResolutionFunc_
    }, t
}();
function fe(t, e, n) {
    return Math.min(Math.max(t, e), n)
}
var de = "cosh" in Math ? Math.cosh : function(t) {
        var e = Math.exp(t);
        return (e + 1 / e) / 2
    },
    ge = "log2" in Math ? Math.log2 : function(t) {
        return Math.log(t) * Math.LOG2E
    };
function ye(t, e, n, r, i, o) {
    var s = i - n,
        a = o - r;
    if (0 !== s || 0 !== a) {
        var u = ((t - n) * s + (e - r) * a) / (s * s + a * a);
        u > 1 ? (n = i, r = o) : u > 0 && (n += s * u, r += a * u)
    }
    return ve(t, e, n, r)
}
function ve(t, e, n, r) {
    var i = n - t,
        o = r - e;
    return i * i + o * o
}
function me(t) {
    for (var e = t.length, n = 0; n < e; n++) {
        for (var r = n, i = Math.abs(t[n][n]), o = n + 1; o < e; o++) {
            var s = Math.abs(t[o][n]);
            s > i && (i = s, r = o)
        }
        if (0 === i)
            return null;
        var a = t[r];
        t[r] = t[n],
        t[n] = a;
        for (var u = n + 1; u < e; u++)
            for (var l = -t[u][n] / t[n][n], h = n; h < e + 1; h++)
                n == h ? t[u][h] = 0 : t[u][h] += l * t[n][h]
    }
    for (var c = new Array(e), p = e - 1; p >= 0; p--) {
        c[p] = t[p][e] / t[p][p];
        for (var f = p - 1; f >= 0; f--)
            t[f][e] -= t[f][p] * c[p]
    }
    return c
}
function _e(t) {
    return 180 * t / Math.PI
}
function xe(t) {
    return t * Math.PI / 180
}
function Ee(t, e) {
    var n = t % e;
    return n * e < 0 ? n + e : n
}
function we(t, e, n) {
    return t + n * (e - t)
}
function be(t, e) {
    var n = Math.pow(10, e);
    return Math.round(t * n) / n
}
function Ce(t, e) {
    return Math.floor(be(t, e))
}
function Me(t, e) {
    return Math.ceil(be(t, e))
}
var Se = function() {
        var t = function(e, n) {
            return t = Object.setPrototypeOf || {
                __proto__: []
            } instanceof Array && function(t, e) {
                t.__proto__ = e
            } || function(t, e) {
                for (var n in e)
                    Object.prototype.hasOwnProperty.call(e, n) && (t[n] = e[n])
            }, t(e, n)
        };
        return function(e, n) {
            if ("function" != typeof n && null !== n)
                throw new TypeError("Class extends value " + String(n) + " is not a constructor or null");
            function r() {
                this.constructor = e
            }
            t(e, n),
            e.prototype = null === n ? Object.create(n) : (r.prototype = n.prototype, new r)
        }
    }(),
    Ie = 6378137 * Math.PI,
    Te = [-Ie, -Ie, Ie, Ie],
    Pe = [-180, -85, 180, 85],
    Le = 6378137 * Math.log(Math.tan(Math.PI / 2)),
    Oe = function(t) {
        function e(e) {
            return t.call(this, {
                    code: e,
                    units: ct.METERS,
                    extent: Te,
                    global: !0,
                    worldExtent: Pe,
                    getPointResolution: function(t, e) {
                        return t / de(e[1] / 6378137)
                    }
                }) || this
        }
        return Se(e, t), e
    }(pe),
    Ne = [new Oe("EPSG:3857"), new Oe("EPSG:102100"), new Oe("EPSG:102113"), new Oe("EPSG:900913"), new Oe("http://www.opengis.net/def/crs/EPSG/0/3857"), new Oe("http://www.opengis.net/gml/srs/epsg.xml#3857")];
function Re(t, e, n) {
    var r = t.length,
        i = n > 1 ? n : 2,
        o = e;
    void 0 === o && (o = i > 2 ? t.slice() : new Array(r));
    for (var s = 0; s < r; s += i) {
        o[s] = Ie * t[s] / 180;
        var a = 6378137 * Math.log(Math.tan(Math.PI * (+t[s + 1] + 90) / 360));
        a > Le ? a = Le : a < -Le && (a = -Le),
        o[s + 1] = a
    }
    return o
}
function Ae(t, e, n) {
    var r = t.length,
        i = n > 1 ? n : 2,
        o = e;
    void 0 === o && (o = i > 2 ? t.slice() : new Array(r));
    for (var s = 0; s < r; s += i)
        o[s] = 180 * t[s] / Ie,
        o[s + 1] = 360 * Math.atan(Math.exp(t[s + 1] / 6378137)) / Math.PI - 90;
    return o
}
var De = {};
t(De, "PROJECTIONS", (() => Be), (t => Be = t));
var Fe = function() {
        var t = function(e, n) {
            return t = Object.setPrototypeOf || {
                __proto__: []
            } instanceof Array && function(t, e) {
                t.__proto__ = e
            } || function(t, e) {
                for (var n in e)
                    Object.prototype.hasOwnProperty.call(e, n) && (t[n] = e[n])
            }, t(e, n)
        };
        return function(e, n) {
            if ("function" != typeof n && null !== n)
                throw new TypeError("Class extends value " + String(n) + " is not a constructor or null");
            function r() {
                this.constructor = e
            }
            t(e, n),
            e.prototype = null === n ? Object.create(n) : (r.prototype = n.prototype, new r)
        }
    }(),
    ke = [-180, -90, 180, 90],
    je = 6378137 * Math.PI / 180,
    Ge = function(t) {
        function e(e, n) {
            return t.call(this, {
                    code: e,
                    units: ct.DEGREES,
                    extent: ke,
                    axisOrientation: n,
                    global: !0,
                    metersPerUnit: je,
                    worldExtent: ke
                }) || this
        }
        return Fe(e, t), e
    }(pe),
    Be = [new Ge("CRS:84"), new Ge("EPSG:4326", "neu"), new Ge("urn:ogc:def:crs:OGC:1.3:CRS84"), new Ge("urn:ogc:def:crs:OGC:2:84"), new Ge("http://www.opengis.net/def/crs/OGC/1.3/CRS84"), new Ge("http://www.opengis.net/gml/srs/epsg.xml#4326", "neu"), new Ge("http://www.opengis.net/def/crs/EPSG/0/4326", "neu")],
    qe = {};
function ze(t, e) {
    qe[t] = e
}
var Ue = {};
function Ve(t, e, n) {
    var r = t.getCode(),
        i = e.getCode();
    r in Ue || (Ue[r] = {}),
    Ue[r][i] = n
}
function Xe(t, e) {
    var n;
    return t in Ue && e in Ue[t] && (n = Ue[t][e]), n
}
function He(t, e) {
    var n = e.getRadius(),
        r = e.getCenter(),
        i = r[0],
        o = r[1],
        s = t[0] - i,
        a = t[1] - o;
    0 === s && 0 === a && (s = 1);
    var u = Math.sqrt(s * s + a * a);
    return [i + n * s / u, o + n * a / u]
}
function Ye(t, e) {
    var n,
        r,
        i = t[0],
        o = t[1],
        s = e[0],
        a = e[1],
        u = s[0],
        l = s[1],
        h = a[0],
        c = a[1],
        p = h - u,
        f = c - l,
        d = 0 === p && 0 === f ? 0 : (p * (i - u) + f * (o - l)) / (p * p + f * f || 0);
    return d <= 0 ? (n = u, r = l) : d >= 1 ? (n = h, r = c) : (n = u + d * p, r = l + d * f), [n, r]
}
function We(t, e) {
    for (var n = !0, r = t.length - 1; r >= 0; --r)
        if (t[r] != e[r]) {
            n = !1;
            break
        }
    return n
}
function $e(t, e) {
    var n = Math.cos(e),
        r = Math.sin(e),
        i = t[0] * n - t[1] * r,
        o = t[1] * n + t[0] * r;
    return t[0] = i, t[1] = o, t
}
function Ke(t, e) {
    var n = t[0] - e[0],
        r = t[1] - e[1];
    return n * n + r * r
}
function Ze(t, e) {
    return Math.sqrt(Ke(t, e))
}
function Je(t, e) {
    return Ke(t, Ye(t, e))
}
function Qe(t, e) {
    if (e.canWrapX()) {
        var n = re(e.getExtent()),
            r = tn(t, e, n);
        r && (t[0] -= r * n)
    }
    return t
}
function tn(t, e, n) {
    var r = e.getExtent(),
        i = 0;
    if (e.canWrapX() && (t[0] < r[0] || t[0] > r[2])) {
        var o = n || re(r);
        i = Math.floor((t[0] - r[0]) / o)
    }
    return i
}
function en(t, e, n) {
    var r = n || 6371008.8,
        i = xe(t[1]),
        o = xe(e[1]),
        s = (o - i) / 2,
        a = xe(e[0] - t[0]) / 2,
        u = Math.sin(s) * Math.sin(s) + Math.sin(a) * Math.sin(a) * Math.cos(i) * Math.cos(o);
    return 2 * r * Math.atan2(Math.sqrt(u), Math.sqrt(1 - u))
}
function nn(t, e, n, r) {
    var i = r || 6371008.8,
        o = xe(t[1]),
        s = xe(t[0]),
        a = e / i,
        u = Math.asin(Math.sin(o) * Math.cos(a) + Math.cos(o) * Math.sin(a) * Math.cos(n));
    return [_e(s + Math.atan2(Math.sin(n) * Math.sin(a) * Math.cos(o), Math.cos(a) - Math.sin(o) * Math.sin(u))), _e(u)]
}
var rn = !0;
function on(t) {
    rn = !(void 0 === t || t)
}
function sn(t, e, n) {
    var r;
    if (void 0 !== e) {
        for (var i = 0, o = t.length; i < o; ++i)
            e[i] = t[i];
        r = e
    } else
        r = t.slice();
    return r
}
function an(t, e, n) {
    if (void 0 !== e && t !== e) {
        for (var r = 0, i = t.length; r < i; ++r)
            e[r] = t[r];
        t = e
    }
    return t
}
function un(t) {
    ze(t.getCode(), t),
    Ve(t, t, sn)
}
function ln(t) {
    return "string" == typeof t ? qe[e = t] || qe[e.replace(/urn:(x-)?ogc:def:crs:EPSG:(.*:)?(\w+)$/, "EPSG:$3")] || null : t || null;
    var e
}
function hn(t, e, n, r) {
    var i,
        o = (t = ln(t)).getPointResolutionFunc();
    if (o) {
        if (i = o(e, n), r && r !== t.getUnits())
            (a = t.getMetersPerUnit()) && (i = i * a / lt[r])
    } else {
        var s = t.getUnits();
        if (s == ct.DEGREES && !r || r == ct.DEGREES)
            i = e;
        else {
            var a,
                u = dn(t, ln("EPSG:4326"));
            if (u === an && s !== ct.DEGREES)
                i = e * t.getMetersPerUnit();
            else {
                var l = [n[0] - e / 2, n[1], n[0] + e / 2, n[1], n[0], n[1] - e / 2, n[0], n[1] + e / 2];
                i = (en((l = u(l, l, 2)).slice(0, 2), l.slice(2, 4)) + en(l.slice(4, 6), l.slice(6, 8))) / 2
            }
            void 0 !== (a = r ? lt[r] : t.getMetersPerUnit()) && (i /= a)
        }
    }
    return i
}
function cn(t) {
    !function(t) {
        t.forEach(un)
    }(t),
    t.forEach((function(e) {
        t.forEach((function(t) {
            e !== t && Ve(e, t, sn)
        }))
    }))
}
function pn(t, e) {
    return t ? "string" == typeof t ? ln(t) : t : ln(e)
}
function fn(t, e) {
    if (t === e)
        return !0;
    var n = t.getUnits() === e.getUnits();
    return (t.getCode() === e.getCode() || dn(t, e) === sn) && n
}
function dn(t, e) {
    var n = Xe(t.getCode(), e.getCode());
    return n || (n = an), n
}
function gn(t, e) {
    return dn(ln(t), ln(e))
}
function yn(t, e, n) {
    return gn(e, n)(t, void 0, t.length)
}
function vn(t, e, n, r) {
    return ue(t, gn(e, n), void 0, r)
}
var mn,
    _n,
    xn,
    En = null;
function wn() {
    return En
}
function bn(t, e) {
    return En ? yn(t, e, En) : t
}
function Cn(t, e) {
    return En ? yn(t, En, e) : (rn && !We(t, [0, 0]) && t[0] >= -180 && t[0] <= 180 && t[1] >= -90 && t[1] <= 90 && (rn = !1, console.warn("Call useGeographic() from ol/proj once to work with [longitude, latitude] coordinates.")), t)
}
function Mn(t, e) {
    return En ? vn(t, e, En) : t
}
function Sn(t, e) {
    return En ? vn(t, En, e) : t
}
function In(t, e) {
    if (!En)
        return t;
    var n = ln(e).getUnits(),
        r = En.getUnits();
    return n && r ? t * lt[n] / lt[r] : t
}
function Tn(t, e, n, r, i, o) {
    for (var s = o || [], a = 0, u = e; u < n; u += r) {
        var l = t[u],
            h = t[u + 1];
        s[a++] = i[0] * l + i[2] * h + i[4],
        s[a++] = i[1] * l + i[3] * h + i[5]
    }
    return o && s.length != a && (s.length = a), s
}
function Pn(t, e, n, r, i, o, s) {
    for (var a = s || [], u = Math.cos(i), l = Math.sin(i), h = o[0], c = o[1], p = 0, f = e; f < n; f += r) {
        var d = t[f] - h,
            g = t[f + 1] - c;
        a[p++] = h + d * u - g * l,
        a[p++] = c + d * l + g * u;
        for (var y = f + 2; y < f + r; ++y)
            a[p++] = t[y]
    }
    return s && a.length != p && (a.length = p), a
}
function Ln(t, e, n, r, i, o, s, a) {
    for (var u = a || [], l = s[0], h = s[1], c = 0, p = e; p < n; p += r) {
        var f = t[p] - l,
            d = t[p + 1] - h;
        u[c++] = l + i * f,
        u[c++] = h + o * d;
        for (var g = p + 2; g < p + r; ++g)
            u[c++] = t[g]
    }
    return a && u.length != c && (u.length = c), u
}
function On(t, e, n, r, i, o, s) {
    for (var a = s || [], u = 0, l = e; l < n; l += r) {
        a[u++] = t[l] + i,
        a[u++] = t[l + 1] + o;
        for (var h = l + 2; h < l + r; ++h)
            a[u++] = t[h]
    }
    return s && a.length != u && (a.length = u), a
}
cn(ce.PROJECTIONS),
cn(De.PROJECTIONS),
mn = ce.PROJECTIONS,
_n = ce.fromEPSG4326,
xn = ce.toEPSG4326,
De.PROJECTIONS.forEach((function(t) {
    mn.forEach((function(e) {
        Ve(t, e, _n),
        Ve(e, t, xn)
    }))
}));
var Nn = function() {
        var t = function(e, n) {
            return t = Object.setPrototypeOf || {
                __proto__: []
            } instanceof Array && function(t, e) {
                t.__proto__ = e
            } || function(t, e) {
                for (var n in e)
                    Object.prototype.hasOwnProperty.call(e, n) && (t[n] = e[n])
            }, t(e, n)
        };
        return function(e, n) {
            if ("function" != typeof n && null !== n)
                throw new TypeError("Class extends value " + String(n) + " is not a constructor or null");
            function r() {
                this.constructor = e
            }
            t(e, n),
            e.prototype = null === n ? Object.create(n) : (r.prototype = n.prototype, new r)
        }
    }(),
    Rn = [1, 0, 0, 1, 0, 0],
    An = function(t) {
        function e() {
            var e,
                n,
                r,
                i,
                o,
                s = t.call(this) || this;
            return s.extent_ = [1 / 0, 1 / 0, -1 / 0, -1 / 0], s.extentRevision_ = -1, s.simplifiedGeometryMaxMinSquaredTolerance = 0, s.simplifiedGeometryRevision = 0, s.simplifyTransformedInternal = (e = function(t, e, n) {
                if (!n)
                    return this.getSimplifiedGeometry(e);
                var r = this.clone();
                return r.applyTransform(n), r.getSimplifiedGeometry(e)
            }, o = !1, function() {
                var t = Array.prototype.slice.call(arguments);
                return o && this === i && M(t, r) || (o = !0, i = this, r = t, n = e.apply(this, arguments)), n
            }), s
        }
        return Nn(e, t), e.prototype.simplifyTransformed = function(t, e) {
            return this.simplifyTransformedInternal(this.getRevision(), t, e)
        }, e.prototype.clone = function() {
            return u()
        }, e.prototype.closestPointXY = function(t, e, n, r) {
            return u()
        }, e.prototype.containsXY = function(t, e) {
            var n = this.getClosestPoint([t, e]);
            return n[0] === t && n[1] === e
        }, e.prototype.getClosestPoint = function(t, e) {
            var n = e || [NaN, NaN];
            return this.closestPointXY(t[0], t[1], n, 1 / 0), n
        }, e.prototype.intersectsCoordinate = function(t) {
            return this.containsXY(t[0], t[1])
        }, e.prototype.computeExtent = function(t) {
            return u()
        }, e.prototype.getExtent = function(t) {
            if (this.extentRevision_ != this.getRevision()) {
                var e = this.computeExtent(this.extent_);
                (isNaN(e[0]) || isNaN(e[1])) && kt(e),
                this.extentRevision_ = this.getRevision()
            }
            return se(this.extent_, t)
        }, e.prototype.rotate = function(t, e) {
            u()
        }, e.prototype.scale = function(t, e, n) {
            u()
        }, e.prototype.simplify = function(t) {
            return this.getSimplifiedGeometry(t * t)
        }, e.prototype.getSimplifiedGeometry = function(t) {
            return u()
        }, e.prototype.getType = function() {
            return u()
        }, e.prototype.applyTransform = function(t) {
            u()
        }, e.prototype.intersectsExtent = function(t) {
            return u()
        }, e.prototype.translate = function(t, e) {
            u()
        }, e.prototype.transform = function(t, e) {
            var n = ln(t),
                r = n.getUnits() == ct.TILE_PIXELS ? function(t, r, i) {
                    var o = n.getExtent(),
                        s = n.getWorldExtent(),
                        a = Qt(s) / Qt(o);
                    return bt(Rn, s[0], s[3], a, -a, 0, 0, 0), Tn(t, 0, t.length, i, Rn, r), gn(n, e)(t, r, i)
                } : gn(n, e);
            return this.applyTransform(r), this
        }, e
    }(d.default),
    Dn = function() {
        var t = function(e, n) {
            return t = Object.setPrototypeOf || {
                __proto__: []
            } instanceof Array && function(t, e) {
                t.__proto__ = e
            } || function(t, e) {
                for (var n in e)
                    Object.prototype.hasOwnProperty.call(e, n) && (t[n] = e[n])
            }, t(e, n)
        };
        return function(e, n) {
            if ("function" != typeof n && null !== n)
                throw new TypeError("Class extends value " + String(n) + " is not a constructor or null");
            function r() {
                this.constructor = e
            }
            t(e, n),
            e.prototype = null === n ? Object.create(n) : (r.prototype = n.prototype, new r)
        }
    }();
function Fn(t) {
    var e;
    return t == it.XY ? e = 2 : t == it.XYZ || t == it.XYM ? e = 3 : t == it.XYZM && (e = 4), e
}
function kn(t, e, n) {
    var r = t.getFlatCoordinates();
    if (r) {
        var i = t.getStride();
        return Tn(r, 0, r.length, i, e, n)
    }
    return null
}
var jn = function(t) {
    function e() {
        var e = t.call(this) || this;
        return e.layout = it.XY, e.stride = 2, e.flatCoordinates = null, e
    }
    return Dn(e, t), e.prototype.computeExtent = function(t) {
        return Gt(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, t)
    }, e.prototype.getCoordinates = function() {
        return u()
    }, e.prototype.getFirstCoordinate = function() {
        return this.flatCoordinates.slice(0, this.stride)
    }, e.prototype.getFlatCoordinates = function() {
        return this.flatCoordinates
    }, e.prototype.getLastCoordinate = function() {
        return this.flatCoordinates.slice(this.flatCoordinates.length - this.stride)
    }, e.prototype.getLayout = function() {
        return this.layout
    }, e.prototype.getSimplifiedGeometry = function(t) {
        if (this.simplifiedGeometryRevision !== this.getRevision() && (this.simplifiedGeometryMaxMinSquaredTolerance = 0, this.simplifiedGeometryRevision = this.getRevision()), t < 0 || 0 !== this.simplifiedGeometryMaxMinSquaredTolerance && t <= this.simplifiedGeometryMaxMinSquaredTolerance)
            return this;
        var e = this.getSimplifiedGeometryInternal(t);
        return e.getFlatCoordinates().length < this.flatCoordinates.length ? e : (this.simplifiedGeometryMaxMinSquaredTolerance = t, this)
    }, e.prototype.getSimplifiedGeometryInternal = function(t) {
        return this
    }, e.prototype.getStride = function() {
        return this.stride
    }, e.prototype.setFlatCoordinates = function(t, e) {
        this.stride = Fn(t),
        this.layout = t,
        this.flatCoordinates = e
    }, e.prototype.setCoordinates = function(t, e) {
        u()
    }, e.prototype.setLayout = function(t, e, n) {
        var r;
        if (t)
            r = Fn(t);
        else {
            for (var i = 0; i < n; ++i) {
                if (0 === e.length)
                    return this.layout = it.XY, void (this.stride = 2);
                e = e[0]
            }
            t = function(t) {
                var e;
                2 == t ? e = it.XY : 3 == t ? e = it.XYZ : 4 == t && (e = it.XYZM);
                return e
            }(r = e.length)
        }
        this.layout = t,
        this.stride = r
    }, e.prototype.applyTransform = function(t) {
        this.flatCoordinates && (t(this.flatCoordinates, this.flatCoordinates, this.stride), this.changed())
    }, e.prototype.rotate = function(t, e) {
        var n = this.getFlatCoordinates();
        if (n) {
            var r = this.getStride();
            Pn(n, 0, n.length, r, t, e, n),
            this.changed()
        }
    }, e.prototype.scale = function(t, e, n) {
        var r = e;
        void 0 === r && (r = t);
        var i = n;
        i || (i = $t(this.getExtent()));
        var o = this.getFlatCoordinates();
        if (o) {
            var s = this.getStride();
            Ln(o, 0, o.length, s, t, r, i, o),
            this.changed()
        }
    }, e.prototype.translate = function(t, e) {
        var n = this.getFlatCoordinates();
        if (n) {
            var r = this.getStride();
            On(n, 0, n.length, r, t, e, n),
            this.changed()
        }
    }, e
}(at.default);
function Gn(t, e, n, r, i, o, s) {
    var a,
        u = t[e],
        l = t[e + 1],
        h = t[n] - u,
        c = t[n + 1] - l;
    if (0 === h && 0 === c)
        a = e;
    else {
        var p = ((i - u) * h + (o - l) * c) / (h * h + c * c);
        if (p > 1)
            a = n;
        else {
            if (p > 0) {
                for (var f = 0; f < r; ++f)
                    s[f] = we(t[e + f], t[n + f], p);
                return void (s.length = r)
            }
            a = e
        }
    }
    for (f = 0; f < r; ++f)
        s[f] = t[a + f];
    s.length = r
}
function Bn(t, e, n, r, i) {
    var o = t[e],
        s = t[e + 1];
    for (e += r; e < n; e += r) {
        var a = t[e],
            u = t[e + 1],
            l = ve(o, s, a, u);
        l > i && (i = l),
        o = a,
        s = u
    }
    return i
}
function qn(t, e, n, r, i) {
    for (var o = 0, s = n.length; o < s; ++o) {
        var a = n[o];
        i = Bn(t, e, a, r, i),
        e = a
    }
    return i
}
function zn(t, e, n, r, i) {
    for (var o = 0, s = n.length; o < s; ++o) {
        var a = n[o];
        i = qn(t, e, a, r, i),
        e = a[a.length - 1]
    }
    return i
}
function Un(t, e, n, r, i, o, s, a, u, l, h) {
    if (e == n)
        return l;
    var c,
        p;
    if (0 === i) {
        if ((p = ve(s, a, t[e], t[e + 1])) < l) {
            for (c = 0; c < r; ++c)
                u[c] = t[e + c];
            return u.length = r, p
        }
        return l
    }
    for (var f = h || [NaN, NaN], d = e + r; d < n;)
        if (Gn(t, d - r, d, r, s, a, f), (p = ve(s, a, f[0], f[1])) < l) {
            for (l = p, c = 0; c < r; ++c)
                u[c] = f[c];
            u.length = r,
            d += r
        } else
            d += r * Math.max((Math.sqrt(p) - Math.sqrt(l)) / i | 0, 1);
    if (o && (Gn(t, n - r, e, r, s, a, f), (p = ve(s, a, f[0], f[1])) < l)) {
        for (l = p, c = 0; c < r; ++c)
            u[c] = f[c];
        u.length = r
    }
    return l
}
function Vn(t, e, n, r, i, o, s, a, u, l, h) {
    for (var c = h || [NaN, NaN], p = 0, f = n.length; p < f; ++p) {
        var d = n[p];
        l = Un(t, e, d, r, i, o, s, a, u, l, c),
        e = d
    }
    return l
}
function Xn(t, e, n, r, i, o, s, a, u, l, h) {
    for (var c = h || [NaN, NaN], p = 0, f = n.length; p < f; ++p) {
        var d = n[p];
        l = Vn(t, e, d, r, i, o, s, a, u, l, c),
        e = d[d.length - 1]
    }
    return l
}
function Hn(t, e, n, r) {
    for (var i = 0, o = n.length; i < o; ++i)
        t[e++] = n[i];
    return e
}
function Yn(t, e, n, r) {
    for (var i = 0, o = n.length; i < o; ++i)
        for (var s = n[i], a = 0; a < r; ++a)
            t[e++] = s[a];
    return e
}
function Wn(t, e, n, r, i) {
    for (var o = i || [], s = 0, a = 0, u = n.length; a < u; ++a) {
        var l = Yn(t, e, n[a], r);
        o[s++] = l,
        e = l
    }
    return o.length = s, o
}
function $n(t, e, n, r, i) {
    for (var o = i || [], s = 0, a = 0, u = n.length; a < u; ++a) {
        var l = Wn(t, e, n[a], r, o[s]);
        o[s++] = l,
        e = l[l.length - 1]
    }
    return o.length = s, o
}
function Kn(t, e, n, r, i, o, s) {
    var a = (n - e) / r;
    if (a < 3) {
        for (; e < n; e += r)
            o[s++] = t[e],
            o[s++] = t[e + 1];
        return s
    }
    var u = new Array(a);
    u[0] = 1,
    u[a - 1] = 1;
    for (var l = [e, n - r], h = 0; l.length > 0;) {
        for (var c = l.pop(), p = l.pop(), f = 0, d = t[p], g = t[p + 1], y = t[c], v = t[c + 1], m = p + r; m < c; m += r) {
            var _ = ye(t[m], t[m + 1], d, g, y, v);
            _ > f && (h = m, f = _)
        }
        f > i && (u[(h - e) / r] = 1, p + r < h && l.push(p, h), h + r < c && l.push(h, c))
    }
    for (m = 0; m < a; ++m)
        u[m] && (o[s++] = t[e + m * r], o[s++] = t[e + m * r + 1]);
    return s
}
function Zn(t, e, n, r, i, o, s, a) {
    for (var u = 0, l = n.length; u < l; ++u) {
        var h = n[u];
        s = Kn(t, e, h, r, i, o, s),
        a.push(s),
        e = h
    }
    return s
}
function Jn(t, e) {
    return e * Math.round(t / e)
}
function Qn(t, e, n, r, i, o, s) {
    if (e == n)
        return s;
    var a,
        u,
        l = Jn(t[e], i),
        h = Jn(t[e + 1], i);
    e += r,
    o[s++] = l,
    o[s++] = h;
    do {
        if (a = Jn(t[e], i), u = Jn(t[e + 1], i), (e += r) == n)
            return o[s++] = a, o[s++] = u, s
    } while (a == l && u == h);
    for (; e < n;) {
        var c = Jn(t[e], i),
            p = Jn(t[e + 1], i);
        if (e += r, c != a || p != u) {
            var f = a - l,
                d = u - h,
                g = c - l,
                y = p - h;
            f * y == d * g && (f < 0 && g < f || f == g || f > 0 && g > f) && (d < 0 && y < d || d == y || d > 0 && y > d) ? (a = c, u = p) : (o[s++] = a, o[s++] = u, l = a, h = u, a = c, u = p)
        }
    }
    return o[s++] = a, o[s++] = u, s
}
function tr(t, e, n, r, i, o, s, a) {
    for (var u = 0, l = n.length; u < l; ++u) {
        var h = n[u];
        s = Qn(t, e, h, r, i, o, s),
        a.push(s),
        e = h
    }
    return s
}
function er(t, e, n, r, i, o, s, a) {
    for (var u = 0, l = n.length; u < l; ++u) {
        var h = n[u],
            c = [];
        s = tr(t, e, h, r, i, o, s, c),
        a.push(c),
        e = h[h.length - 1]
    }
    return s
}
function nr(t, e, n, r, i) {
    for (var o = void 0 !== i ? i : [], s = 0, a = e; a < n; a += r)
        o[s++] = t.slice(a, a + r);
    return o.length = s, o
}
function rr(t, e, n, r, i) {
    for (var o = void 0 !== i ? i : [], s = 0, a = 0, u = n.length; a < u; ++a) {
        var l = n[a];
        o[s++] = nr(t, e, l, r, o[s]),
        e = l
    }
    return o.length = s, o
}
function ir(t, e, n, r, i) {
    for (var o = void 0 !== i ? i : [], s = 0, a = 0, u = n.length; a < u; ++a) {
        var l = n[a];
        o[s++] = rr(t, e, l, r, o[s]),
        e = l[l.length - 1]
    }
    return o.length = s, o
}
function or(t, e, n, r) {
    for (var i = 0, o = t[n - r], s = t[n - r + 1]; e < n; e += r) {
        var a = t[e],
            u = t[e + 1];
        i += s * a - o * u,
        o = a,
        s = u
    }
    return i / 2
}
function sr(t, e, n, r) {
    for (var i = 0, o = 0, s = n.length; o < s; ++o) {
        var a = n[o];
        i += or(t, e, a, r),
        e = a
    }
    return i
}
function ar(t, e, n, r) {
    for (var i = 0, o = 0, s = n.length; o < s; ++o) {
        var a = n[o];
        i += sr(t, e, a, r),
        e = a[a.length - 1]
    }
    return i
}
var ur = function() {
        var t = function(e, n) {
            return t = Object.setPrototypeOf || {
                __proto__: []
            } instanceof Array && function(t, e) {
                t.__proto__ = e
            } || function(t, e) {
                for (var n in e)
                    Object.prototype.hasOwnProperty.call(e, n) && (t[n] = e[n])
            }, t(e, n)
        };
        return function(e, n) {
            if ("function" != typeof n && null !== n)
                throw new TypeError("Class extends value " + String(n) + " is not a constructor or null");
            function r() {
                this.constructor = e
            }
            t(e, n),
            e.prototype = null === n ? Object.create(n) : (r.prototype = n.prototype, new r)
        }
    }(),
    lr = function(t) {
        function e(e, n) {
            var r = t.call(this) || this;
            return r.maxDelta_ = -1, r.maxDeltaRevision_ = -1, void 0 === n || Array.isArray(e[0]) ? r.setCoordinates(e, n) : r.setFlatCoordinates(n, e), r
        }
        return ur(e, t), e.prototype.clone = function() {
            return new e(this.flatCoordinates.slice(), this.layout)
        }, e.prototype.closestPointXY = function(t, e, n, r) {
            return r < Lt(this.getExtent(), t, e) ? r : (this.maxDeltaRevision_ != this.getRevision() && (this.maxDelta_ = Math.sqrt(Bn(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, 0)), this.maxDeltaRevision_ = this.getRevision()), Un(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, this.maxDelta_, !0, t, e, n, r))
        }, e.prototype.getArea = function() {
            return or(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride)
        }, e.prototype.getCoordinates = function() {
            return nr(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride)
        }, e.prototype.getSimplifiedGeometryInternal = function(t) {
            var n = [];
            return n.length = Kn(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, t, n, 0), new e(n, it.XY)
        }, e.prototype.getType = function() {
            return "LinearRing"
        }, e.prototype.intersectsExtent = function(t) {
            return !1
        }, e.prototype.setCoordinates = function(t, e) {
            this.setLayout(e, t, 1),
            this.flatCoordinates || (this.flatCoordinates = []),
            this.flatCoordinates.length = Yn(this.flatCoordinates, 0, t, this.stride),
            this.changed()
        }, e
    }(st.default),
    hr = {};
t(hr, "default", (() => pr), (t => pr = t));
var cr = function() {
        var t = function(e, n) {
            return t = Object.setPrototypeOf || {
                __proto__: []
            } instanceof Array && function(t, e) {
                t.__proto__ = e
            } || function(t, e) {
                for (var n in e)
                    Object.prototype.hasOwnProperty.call(e, n) && (t[n] = e[n])
            }, t(e, n)
        };
        return function(e, n) {
            if ("function" != typeof n && null !== n)
                throw new TypeError("Class extends value " + String(n) + " is not a constructor or null");
            function r() {
                this.constructor = e
            }
            t(e, n),
            e.prototype = null === n ? Object.create(n) : (r.prototype = n.prototype, new r)
        }
    }(),
    pr = function(t) {
        function e(e, n) {
            var r = t.call(this) || this;
            return r.setCoordinates(e, n), r
        }
        return cr(e, t), e.prototype.clone = function() {
            var t = new e(this.flatCoordinates.slice(), this.layout);
            return t.applyProperties(this), t
        }, e.prototype.closestPointXY = function(t, e, n, r) {
            var i = this.flatCoordinates,
                o = ve(t, e, i[0], i[1]);
            if (o < r) {
                for (var s = this.stride, a = 0; a < s; ++a)
                    n[a] = i[a];
                return n.length = s, o
            }
            return r
        }, e.prototype.getCoordinates = function() {
            return this.flatCoordinates ? this.flatCoordinates.slice() : []
        }, e.prototype.computeExtent = function(t) {
            return jt(this.flatCoordinates, t)
        }, e.prototype.getType = function() {
            return "Point"
        }, e.prototype.intersectsExtent = function(t) {
            return Rt(t, this.flatCoordinates[0], this.flatCoordinates[1])
        }, e.prototype.setCoordinates = function(t, e) {
            this.setLayout(e, t, 0),
            this.flatCoordinates || (this.flatCoordinates = []),
            this.flatCoordinates.length = Hn(this.flatCoordinates, 0, t, this.stride),
            this.changed()
        }, e
    }(st.default);
function fr(t, e, n, r, i) {
    return !Xt(i, (function(i) {
        return !dr(t, e, n, r, i[0], i[1])
    }))
}
function dr(t, e, n, r, i, o) {
    for (var s = 0, a = t[n - r], u = t[n - r + 1]; e < n; e += r) {
        var l = t[e],
            h = t[e + 1];
        u <= o ? h > o && (l - a) * (o - u) - (i - a) * (h - u) > 0 && s++ : h <= o && (l - a) * (o - u) - (i - a) * (h - u) < 0 && s--,
        a = l,
        u = h
    }
    return 0 !== s
}
function gr(t, e, n, r, i, o) {
    if (0 === n.length)
        return !1;
    if (!dr(t, e, n[0], r, i, o))
        return !1;
    for (var s = 1, a = n.length; s < a; ++s)
        if (dr(t, n[s - 1], n[s], r, i, o))
            return !1;
    return !0
}
function yr(t, e, n, r, i, o) {
    if (0 === n.length)
        return !1;
    for (var s = 0, a = n.length; s < a; ++s) {
        var u = n[s];
        if (gr(t, e, u, r, i, o))
            return !0;
        e = u[u.length - 1]
    }
    return !1
}
function vr(t, e, n, r, i, o, s) {
    for (var a, u, l, h, c, p, f, d = i[o + 1], g = [], y = 0, v = n.length; y < v; ++y) {
        var m = n[y];
        for (h = t[m - r], p = t[m - r + 1], a = e; a < m; a += r)
            c = t[a],
            f = t[a + 1],
            (d <= p && f <= d || p <= d && d <= f) && (l = (d - p) / (f - p) * (c - h) + h, g.push(l)),
            h = c,
            p = f
    }
    var _ = NaN,
        x = -1 / 0;
    for (g.sort(E), h = g[0], a = 1, u = g.length; a < u; ++a) {
        c = g[a];
        var w = Math.abs(c - h);
        w > x && gr(t, e, n, r, l = (h + c) / 2, d) && (_ = l, x = w),
        h = c
    }
    return isNaN(_) && (_ = i[o]), s ? (s.push(_, d, x), s) : [_, d, x]
}
function mr(t, e, n, r, i) {
    for (var o = [], s = 0, a = n.length; s < a; ++s) {
        var u = n[s];
        o = vr(t, e, u, r, i, 2 * s, o),
        e = u[u.length - 1]
    }
    return o
}
function _r(t, e, n, r, i) {
    var o;
    for (e += r; e < n; e += r)
        if (o = i(t.slice(e - r, e), t.slice(e, e + r)))
            return o;
    return !1
}
function xr(t, e, n, r, i) {
    var o = Ut([1 / 0, 1 / 0, -1 / 0, -1 / 0], t, e, n, r);
    return !!ie(i, o) && (!!Nt(i, o) || (o[0] >= i[0] && o[2] <= i[2] || (o[1] >= i[1] && o[3] <= i[3] || _r(t, e, n, r, (function(t, e) {
            return ae(i, t, e)
        })))))
}
function Er(t, e, n, r, i) {
    for (var o = 0, s = n.length; o < s; ++o) {
        if (xr(t, e, n[o], r, i))
            return !0;
        e = n[o]
    }
    return !1
}
function wr(t, e, n, r, i) {
    return !!xr(t, e, n, r, i) || (!!dr(t, e, n, r, i[0], i[1]) || (!!dr(t, e, n, r, i[0], i[3]) || (!!dr(t, e, n, r, i[2], i[1]) || !!dr(t, e, n, r, i[2], i[3]))))
}
function br(t, e, n, r, i) {
    if (!wr(t, e, n[0], r, i))
        return !1;
    if (1 === n.length)
        return !0;
    for (var o = 1, s = n.length; o < s; ++o)
        if (fr(t, n[o - 1], n[o], r, i) && !xr(t, n[o - 1], n[o], r, i))
            return !1;
    return !0
}
function Cr(t, e, n, r, i) {
    for (var o = 0, s = n.length; o < s; ++o) {
        var a = n[o];
        if (br(t, e, a, r, i))
            return !0;
        e = a[a.length - 1]
    }
    return !1
}
function Mr(t, e, n, r) {
    for (; e < n - r;) {
        for (var i = 0; i < r; ++i) {
            var o = t[e + i];
            t[e + i] = t[n - r + i],
            t[n - r + i] = o
        }
        e += r,
        n -= r
    }
}
function Sr(t, e, n, r) {
    for (var i = 0, o = t[n - r], s = t[n - r + 1]; e < n; e += r) {
        var a = t[e],
            u = t[e + 1];
        i += (a - o) * (u + s),
        o = a,
        s = u
    }
    return 0 === i ? void 0 : i > 0
}
function Ir(t, e, n, r, i) {
    for (var o = void 0 !== i && i, s = 0, a = n.length; s < a; ++s) {
        var u = n[s],
            l = Sr(t, e, u, r);
        if (0 === s) {
            if (o && l || !o && !l)
                return !1
        } else if (o && !l || !o && l)
            return !1;
        e = u
    }
    return !0
}
function Tr(t, e, n, r, i) {
    for (var o = 0, s = n.length; o < s; ++o) {
        var a = n[o];
        if (!Ir(t, e, a, r, i))
            return !1;
        a.length && (e = a[a.length - 1])
    }
    return !0
}
function Pr(t, e, n, r, i) {
    for (var o = void 0 !== i && i, s = 0, a = n.length; s < a; ++s) {
        var u = n[s],
            l = Sr(t, e, u, r);
        (0 === s ? o && l || !o && !l : o && !l || !o && l) && Mr(t, e, u, r),
        e = u
    }
    return e
}
function Lr(t, e, n, r, i) {
    for (var o = 0, s = n.length; o < s; ++o)
        e = Pr(t, e, n[o], r, i);
    return e
}
var Or = function() {
        var t = function(e, n) {
            return t = Object.setPrototypeOf || {
                __proto__: []
            } instanceof Array && function(t, e) {
                t.__proto__ = e
            } || function(t, e) {
                for (var n in e)
                    Object.prototype.hasOwnProperty.call(e, n) && (t[n] = e[n])
            }, t(e, n)
        };
        return function(e, n) {
            if ("function" != typeof n && null !== n)
                throw new TypeError("Class extends value " + String(n) + " is not a constructor or null");
            function r() {
                this.constructor = e
            }
            t(e, n),
            e.prototype = null === n ? Object.create(n) : (r.prototype = n.prototype, new r)
        }
    }(),
    Nr = function(t) {
        function e(e, n, r) {
            var i = t.call(this) || this;
            return i.ends_ = [], i.flatInteriorPointRevision_ = -1, i.flatInteriorPoint_ = null, i.maxDelta_ = -1, i.maxDeltaRevision_ = -1, i.orientedRevision_ = -1, i.orientedFlatCoordinates_ = null, void 0 !== n && r ? (i.setFlatCoordinates(n, e), i.ends_ = r) : i.setCoordinates(e, n), i
        }
        return Or(e, t), e.prototype.appendLinearRing = function(t) {
            this.flatCoordinates ? C(this.flatCoordinates, t.getFlatCoordinates()) : this.flatCoordinates = t.getFlatCoordinates().slice(),
            this.ends_.push(this.flatCoordinates.length),
            this.changed()
        }, e.prototype.clone = function() {
            var t = new e(this.flatCoordinates.slice(), this.layout, this.ends_.slice());
            return t.applyProperties(this), t
        }, e.prototype.closestPointXY = function(t, e, n, r) {
            return r < Lt(this.getExtent(), t, e) ? r : (this.maxDeltaRevision_ != this.getRevision() && (this.maxDelta_ = Math.sqrt(qn(this.flatCoordinates, 0, this.ends_, this.stride, 0)), this.maxDeltaRevision_ = this.getRevision()), Vn(this.flatCoordinates, 0, this.ends_, this.stride, this.maxDelta_, !0, t, e, n, r))
        }, e.prototype.containsXY = function(t, e) {
            return gr(this.getOrientedFlatCoordinates(), 0, this.ends_, this.stride, t, e)
        }, e.prototype.getArea = function() {
            return sr(this.getOrientedFlatCoordinates(), 0, this.ends_, this.stride)
        }, e.prototype.getCoordinates = function(t) {
            var e;
            return void 0 !== t ? Pr(e = this.getOrientedFlatCoordinates().slice(), 0, this.ends_, this.stride, t) : e = this.flatCoordinates, rr(e, 0, this.ends_, this.stride)
        }, e.prototype.getEnds = function() {
            return this.ends_
        }, e.prototype.getFlatInteriorPoint = function() {
            if (this.flatInteriorPointRevision_ != this.getRevision()) {
                var t = $t(this.getExtent());
                this.flatInteriorPoint_ = vr(this.getOrientedFlatCoordinates(), 0, this.ends_, this.stride, t, 0),
                this.flatInteriorPointRevision_ = this.getRevision()
            }
            return this.flatInteriorPoint_
        }, e.prototype.getInteriorPoint = function() {
            return new (0, hr.default)(this.getFlatInteriorPoint(), it.XYM)
        }, e.prototype.getLinearRingCount = function() {
            return this.ends_.length
        }, e.prototype.getLinearRing = function(t) {
            return t < 0 || this.ends_.length <= t ? null : new (0, ot.default)(this.flatCoordinates.slice(0 === t ? 0 : this.ends_[t - 1], this.ends_[t]), this.layout)
        }, e.prototype.getLinearRings = function() {
            for (var t = this.layout, e = this.flatCoordinates, n = this.ends_, r = [], i = 0, o = 0, s = n.length; o < s; ++o) {
                var a = n[o],
                    u = new (0, ot.default)(e.slice(i, a), t);
                r.push(u),
                i = a
            }
            return r
        }, e.prototype.getOrientedFlatCoordinates = function() {
            if (this.orientedRevision_ != this.getRevision()) {
                var t = this.flatCoordinates;
                Ir(t, 0, this.ends_, this.stride) ? this.orientedFlatCoordinates_ = t : (this.orientedFlatCoordinates_ = t.slice(), this.orientedFlatCoordinates_.length = Pr(this.orientedFlatCoordinates_, 0, this.ends_, this.stride)),
                this.orientedRevision_ = this.getRevision()
            }
            return this.orientedFlatCoordinates_
        }, e.prototype.getSimplifiedGeometryInternal = function(t) {
            var n = [],
                r = [];
            return n.length = tr(this.flatCoordinates, 0, this.ends_, this.stride, Math.sqrt(t), n, 0, r), new e(n, it.XY, r)
        }, e.prototype.getType = function() {
            return "Polygon"
        }, e.prototype.intersectsExtent = function(t) {
            return br(this.getOrientedFlatCoordinates(), 0, this.ends_, this.stride, t)
        }, e.prototype.setCoordinates = function(t, e) {
            this.setLayout(e, t, 2),
            this.flatCoordinates || (this.flatCoordinates = []);
            var n = Wn(this.flatCoordinates, 0, t, this.stride, this.ends_);
            this.flatCoordinates.length = 0 === n.length ? 0 : n[n.length - 1],
            this.changed()
        }, e
    }(st.default),
    Rr = Nr;
function Ar(t, e, n, r) {
    for (var i = n || 32, o = [], s = 0; s < i; ++s)
        C(o, nn(t, e, 2 * Math.PI * s / i, r));
    return o.push(o[0], o[1]), new Nr(o, it.XY, [o.length])
}
function Dr(t) {
    var e = t[0],
        n = t[1],
        r = t[2],
        i = t[3],
        o = [e, n, e, i, r, i, r, n, e, n];
    return new Nr(o, it.XY, [o.length])
}
function Fr(t, e, n) {
    for (var r = e || 32, i = t.getStride(), o = t.getLayout(), s = t.getCenter(), a = i * (r + 1), u = new Array(a), l = 0; l < a; l += i) {
        u[l] = 0,
        u[l + 1] = 0;
        for (var h = 2; h < i; h++)
            u[l + h] = s[h]
    }
    var c = [u.length],
        p = new Nr(u, o, c);
    return kr(p, s, t.getRadius(), n), p
}
function kr(t, e, n, r) {
    for (var i = t.getFlatCoordinates(), o = t.getStride(), s = i.length / o - 1, a = r || 0, u = 0; u <= s; ++u) {
        var l = u * o,
            h = a + 2 * Ee(u, s) * Math.PI / s;
        i[l] = e[0] + n * Math.cos(h),
        i[l + 1] = e[1] + n * Math.sin(h)
    }
    t.changed()
}
var jr = function() {
        var t = function(e, n) {
            return t = Object.setPrototypeOf || {
                __proto__: []
            } instanceof Array && function(t, e) {
                t.__proto__ = e
            } || function(t, e) {
                for (var n in e)
                    Object.prototype.hasOwnProperty.call(e, n) && (t[n] = e[n])
            }, t(e, n)
        };
        return function(e, n) {
            if ("function" != typeof n && null !== n)
                throw new TypeError("Class extends value " + String(n) + " is not a constructor or null");
            function r() {
                this.constructor = e
            }
            t(e, n),
            e.prototype = null === n ? Object.create(n) : (r.prototype = n.prototype, new r)
        }
    }(),
    Gr = "accuracy",
    Br = "accuracyGeometry",
    qr = "altitude",
    zr = "altitudeAccuracy",
    Ur = "heading",
    Vr = "position",
    Xr = "projection",
    Hr = "speed",
    Yr = "tracking",
    Wr = "trackingOptions",
    $r = function(t) {
        function e(e) {
            var n = t.call(this, D.ERROR) || this;
            return n.code = e.code, n.message = e.message, n
        }
        return jr(e, t), e
    }(g),
    Kr = function(t) {
        function e(e) {
            var n = t.call(this) || this;
            n.on,
            n.once,
            n.un;
            var r = e || {};
            return n.position_ = null, n.transform_ = an, n.watchId_ = void 0, n.addChangeListener(Xr, n.handleProjectionChanged_), n.addChangeListener(Yr, n.handleTrackingChanged_), void 0 !== r.projection && n.setProjection(r.projection), void 0 !== r.trackingOptions && n.setTrackingOptions(r.trackingOptions), n.setTracking(void 0 !== r.tracking && r.tracking), n
        }
        return jr(e, t), e.prototype.disposeInternal = function() {
            this.setTracking(!1),
            t.prototype.disposeInternal.call(this)
        }, e.prototype.handleProjectionChanged_ = function() {
            var t = this.getProjection();
            t && (this.transform_ = dn(ln("EPSG:4326"), t), this.position_ && this.set(Vr, this.transform_(this.position_)))
        }, e.prototype.handleTrackingChanged_ = function() {
            if ("geolocation" in navigator) {
                var t = this.getTracking();
                t && void 0 === this.watchId_ ? this.watchId_ = navigator.geolocation.watchPosition(this.positionChange_.bind(this), this.positionError_.bind(this), this.getTrackingOptions()) : t || void 0 === this.watchId_ || (navigator.geolocation.clearWatch(this.watchId_), this.watchId_ = void 0)
            }
        }, e.prototype.positionChange_ = function(t) {
            var e = t.coords;
            this.set(Gr, e.accuracy),
            this.set(qr, null === e.altitude ? void 0 : e.altitude),
            this.set(zr, null === e.altitudeAccuracy ? void 0 : e.altitudeAccuracy),
            this.set(Ur, null === e.heading ? void 0 : xe(e.heading)),
            this.position_ ? (this.position_[0] = e.longitude, this.position_[1] = e.latitude) : this.position_ = [e.longitude, e.latitude];
            var n = this.transform_(this.position_);
            this.set(Vr, n),
            this.set(Hr, null === e.speed ? void 0 : e.speed);
            var r = (0, rt.circular)(this.position_, e.accuracy);
            r.applyTransform(this.transform_),
            this.set(Br, r),
            this.changed()
        }, e.prototype.positionError_ = function(t) {
            this.dispatchEvent(new $r(t))
        }, e.prototype.getAccuracy = function() {
            return this.get(Gr)
        }, e.prototype.getAccuracyGeometry = function() {
            return this.get(Br) || null
        }, e.prototype.getAltitude = function() {
            return this.get(qr)
        }, e.prototype.getAltitudeAccuracy = function() {
            return this.get(zr)
        }, e.prototype.getHeading = function() {
            return this.get(Ur)
        }, e.prototype.getPosition = function() {
            return this.get(Vr)
        }, e.prototype.getProjection = function() {
            return this.get(Xr)
        }, e.prototype.getSpeed = function() {
            return this.get(Hr)
        }, e.prototype.getTracking = function() {
            return this.get(Yr)
        }, e.prototype.getTrackingOptions = function() {
            return this.get(Wr)
        }, e.prototype.setProjection = function(t) {
            this.set(Xr, ln(t))
        }, e.prototype.setTracking = function(t) {
            this.set(Yr, t)
        }, e.prototype.setTrackingOptions = function(t) {
            this.set(Wr, t)
        }, e
    }(d.default),
    Zr = {};
t(Zr, "default", (() => Vh), (t => Vh = t));
var Jr = {};
t(Jr, "default", (() => to), (t => to = t));
var Qr = {};
t(Qr, "default", (() => Mi), (t => Mi = t));
var ti = /^#([a-f0-9]{3}|[a-f0-9]{4}(?:[a-f0-9]{2}){0,2})$/i,
    ei = /^([a-z]*)$|^hsla?\(.*\)$/i;
function ni(t) {
    return "string" == typeof t ? t : li(t)
}
function ri(t) {
    var e = document.createElement("div");
    if (e.style.color = t, "" !== e.style.color) {
        document.body.appendChild(e);
        var n = getComputedStyle(e).color;
        return document.body.removeChild(e), n
    }
    return ""
}
var ii,
    oi,
    si = (ii = {}, oi = 0, function(t) {
        var e;
        if (ii.hasOwnProperty(t))
            e = ii[t];
        else {
            if (oi >= 1024) {
                var n = 0;
                for (var r in ii)
                    0 == (3 & n++) && (delete ii[r], --oi)
            }
            e = function(t) {
                var e,
                    n,
                    r,
                    i,
                    o;
                if (ei.exec(t) && (t = ri(t)), ti.exec(t)) {
                    var s = t.length - 1,
                        a = void 0;
                    a = s <= 4 ? 1 : 2;
                    var u = 4 === s || 8 === s;
                    e = parseInt(t.substr(1 + 0 * a, a), 16),
                    n = parseInt(t.substr(1 + 1 * a, a), 16),
                    r = parseInt(t.substr(1 + 2 * a, a), 16),
                    i = u ? parseInt(t.substr(1 + 3 * a, a), 16) : 255,
                    1 == a && (e = (e << 4) + e, n = (n << 4) + n, r = (r << 4) + r, u && (i = (i << 4) + i)),
                    o = [e, n, r, i / 255]
                } else
                    0 == t.indexOf("rgba(") ? ui(o = t.slice(5, -1).split(",").map(Number)) : 0 == t.indexOf("rgb(") ? ((o = t.slice(4, -1).split(",").map(Number)).push(1), ui(o)) : J(!1, 14);
                return o
            }(t),
            ii[t] = e,
            ++oi
        }
        return e
    });
function ai(t) {
    return Array.isArray(t) ? t : si(t)
}
function ui(t) {
    return t[0] = fe(t[0] + .5 | 0, 0, 255), t[1] = fe(t[1] + .5 | 0, 0, 255), t[2] = fe(t[2] + .5 | 0, 0, 255), t[3] = fe(t[3], 0, 1), t
}
function li(t) {
    var e = t[0];
    e != (0 | e) && (e = e + .5 | 0);
    var n = t[1];
    n != (0 | n) && (n = n + .5 | 0);
    var r = t[2];
    return r != (0 | r) && (r = r + .5 | 0), "rgba(" + e + "," + n + "," + r + "," + (void 0 === t[3] ? 1 : Math.round(100 * t[3]) / 100) + ")"
}
var hi = function() {
    function t() {
        this.cache_ = {},
        this.cacheSize_ = 0,
        this.maxCacheSize_ = 32
    }
    return t.prototype.clear = function() {
        this.cache_ = {},
        this.cacheSize_ = 0
    }, t.prototype.canExpireCache = function() {
        return this.cacheSize_ > this.maxCacheSize_
    }, t.prototype.expire = function() {
        if (this.canExpireCache()) {
            var t = 0;
            for (var e in this.cache_) {
                var n = this.cache_[e];
                0 != (3 & t++) || n.hasListener() || (delete this.cache_[e], --this.cacheSize_)
            }
        }
    }, t.prototype.get = function(t, e, n) {
        var r = ci(t, e, n);
        return r in this.cache_ ? this.cache_[r] : null
    }, t.prototype.set = function(t, e, n, r) {
        var i = ci(t, e, n);
        this.cache_[i] = r,
        ++this.cacheSize_
    }, t.prototype.setSize = function(t) {
        this.maxCacheSize_ = t,
        this.expire()
    }, t
}();
function ci(t, e, n) {
    return e + ":" + t + ":" + (n ? ni(n) : "null")
}
var pi = new hi,
    fi = {};
t(fi, "inView", (() => xi), (t => xi = t)),
t(fi, "default", (() => Ei), (t => Ei = t));
var di = {};
t(di, "default", (() => vi), (t => vi = t));
var gi = {
        OPACITY: "opacity",
        VISIBLE: "visible",
        EXTENT: "extent",
        Z_INDEX: "zIndex",
        MAX_RESOLUTION: "maxResolution",
        MIN_RESOLUTION: "minResolution",
        MAX_ZOOM: "maxZoom",
        MIN_ZOOM: "minZoom",
        SOURCE: "source",
        MAP: "map"
    },
    yi = function() {
        var t = function(e, n) {
            return t = Object.setPrototypeOf || {
                __proto__: []
            } instanceof Array && function(t, e) {
                t.__proto__ = e
            } || function(t, e) {
                for (var n in e)
                    Object.prototype.hasOwnProperty.call(e, n) && (t[n] = e[n])
            }, t(e, n)
        };
        return function(e, n) {
            if ("function" != typeof n && null !== n)
                throw new TypeError("Class extends value " + String(n) + " is not a constructor or null");
            function r() {
                this.constructor = e
            }
            t(e, n),
            e.prototype = null === n ? Object.create(n) : (r.prototype = n.prototype, new r)
        }
    }(),
    vi = function(t) {
        function e(e) {
            var n = t.call(this) || this;
            n.on,
            n.once,
            n.un,
            n.background_ = e.background;
            var r = P({}, e);
            return "object" == typeof e.properties && (delete r.properties, P(r, e.properties)), r[gi.OPACITY] = void 0 !== e.opacity ? e.opacity : 1, J("number" == typeof r[gi.OPACITY], 64), r[gi.VISIBLE] = void 0 === e.visible || e.visible, r[gi.Z_INDEX] = e.zIndex, r[gi.MAX_RESOLUTION] = void 0 !== e.maxResolution ? e.maxResolution : 1 / 0, r[gi.MIN_RESOLUTION] = void 0 !== e.minResolution ? e.minResolution : 0, r[gi.MIN_ZOOM] = void 0 !== e.minZoom ? e.minZoom : -1 / 0, r[gi.MAX_ZOOM] = void 0 !== e.maxZoom ? e.maxZoom : 1 / 0, n.className_ = void 0 !== r.className ? r.className : "ol-layer", delete r.className, n.setProperties(r), n.state_ = null, n
        }
        return yi(e, t), e.prototype.getBackground = function() {
            return this.background_
        }, e.prototype.getClassName = function() {
            return this.className_
        }, e.prototype.getLayerState = function(t) {
            var e = this.state_ || {
                    layer: this,
                    managed: void 0 === t || t
                },
                n = this.getZIndex();
            return e.opacity = fe(Math.round(100 * this.getOpacity()) / 100, 0, 1), e.visible = this.getVisible(), e.extent = this.getExtent(), e.zIndex = void 0 !== n || e.managed ? n : 1 / 0, e.maxResolution = this.getMaxResolution(), e.minResolution = Math.max(this.getMinResolution(), 0), e.minZoom = this.getMinZoom(), e.maxZoom = this.getMaxZoom(), this.state_ = e, e
        }, e.prototype.getLayersArray = function(t) {
            return u()
        }, e.prototype.getLayerStatesArray = function(t) {
            return u()
        }, e.prototype.getExtent = function() {
            return this.get(gi.EXTENT)
        }, e.prototype.getMaxResolution = function() {
            return this.get(gi.MAX_RESOLUTION)
        }, e.prototype.getMinResolution = function() {
            return this.get(gi.MIN_RESOLUTION)
        }, e.prototype.getMinZoom = function() {
            return this.get(gi.MIN_ZOOM)
        }, e.prototype.getMaxZoom = function() {
            return this.get(gi.MAX_ZOOM)
        }, e.prototype.getOpacity = function() {
            return this.get(gi.OPACITY)
        }, e.prototype.getSourceState = function() {
            return u()
        }, e.prototype.getVisible = function() {
            return this.get(gi.VISIBLE)
        }, e.prototype.getZIndex = function() {
            return this.get(gi.Z_INDEX)
        }, e.prototype.setBackground = function(t) {
            this.background_ = t,
            this.changed()
        }, e.prototype.setExtent = function(t) {
            this.set(gi.EXTENT, t)
        }, e.prototype.setMaxResolution = function(t) {
            this.set(gi.MAX_RESOLUTION, t)
        }, e.prototype.setMinResolution = function(t) {
            this.set(gi.MIN_RESOLUTION, t)
        }, e.prototype.setMaxZoom = function(t) {
            this.set(gi.MAX_ZOOM, t)
        }, e.prototype.setMinZoom = function(t) {
            this.set(gi.MIN_ZOOM, t)
        }, e.prototype.setOpacity = function(t) {
            J("number" == typeof t, 64),
            this.set(gi.OPACITY, t)
        }, e.prototype.setVisible = function(t) {
            this.set(gi.VISIBLE, t)
        }, e.prototype.setZIndex = function(t) {
            this.set(gi.Z_INDEX, t)
        }, e.prototype.disposeInternal = function() {
            this.state_ && (this.state_.layer = null, this.state_ = null),
            t.prototype.disposeInternal.call(this)
        }, e
    }(d.default),
    mi = {
        PRERENDER: "prerender",
        POSTRENDER: "postrender",
        PRECOMPOSE: "precompose",
        POSTCOMPOSE: "postcompose",
        RENDERCOMPLETE: "rendercomplete"
    },
    _i = function() {
        var t = function(e, n) {
            return t = Object.setPrototypeOf || {
                __proto__: []
            } instanceof Array && function(t, e) {
                t.__proto__ = e
            } || function(t, e) {
                for (var n in e)
                    Object.prototype.hasOwnProperty.call(e, n) && (t[n] = e[n])
            }, t(e, n)
        };
        return function(e, n) {
            if ("function" != typeof n && null !== n)
                throw new TypeError("Class extends value " + String(n) + " is not a constructor or null");
            function r() {
                this.constructor = e
            }
            t(e, n),
            e.prototype = null === n ? Object.create(n) : (r.prototype = n.prototype, new r)
        }
    }();
function xi(t, e) {
    if (!t.visible)
        return !1;
    var n = e.resolution;
    if (n < t.minResolution || n >= t.maxResolution)
        return !1;
    var r = e.zoom;
    return r > t.minZoom && r <= t.maxZoom
}
var Ei = function(t) {
        function e(e) {
            var n = this,
                r = P({}, e);
            delete r.source,
            (n = t.call(this, r) || this).on,
            n.once,
            n.un,
            n.mapPrecomposeKey_ = null,
            n.mapRenderKey_ = null,
            n.sourceChangeKey_ = null,
            n.renderer_ = null,
            n.rendered = !1,
            e.render && (n.render = e.render),
            e.map && n.setMap(e.map),
            n.addChangeListener(gi.SOURCE, n.handleSourcePropertyChange_);
            var i = e.source ? e.source : null;
            return n.setSource(i), n
        }
        return _i(e, t), e.prototype.getLayersArray = function(t) {
            var e = t || [];
            return e.push(this), e
        }, e.prototype.getLayerStatesArray = function(t) {
            var e = t || [];
            return e.push(this.getLayerState()), e
        }, e.prototype.getSource = function() {
            return this.get(gi.SOURCE) || null
        }, e.prototype.getRenderSource = function() {
            return this.getSource()
        }, e.prototype.getSourceState = function() {
            var t = this.getSource();
            return t ? t.getState() : "undefined"
        }, e.prototype.handleSourceChange_ = function() {
            this.changed()
        }, e.prototype.handleSourcePropertyChange_ = function() {
            this.sourceChangeKey_ && (j(this.sourceChangeKey_), this.sourceChangeKey_ = null);
            var t = this.getSource();
            t && (this.sourceChangeKey_ = F(t, D.CHANGE, this.handleSourceChange_, this)),
            this.changed()
        }, e.prototype.getFeatures = function(t) {
            return this.renderer_ ? this.renderer_.getFeatures(t) : new Promise((function(t) {
                return t([])
            }))
        }, e.prototype.getData = function(t) {
            return this.renderer_ && this.rendered ? this.renderer_.getData(t) : null
        }, e.prototype.render = function(t, e) {
            var n = this.getRenderer();
            if (n.prepareFrame(t))
                return this.rendered = !0, n.renderFrame(t, e)
        }, e.prototype.unrender = function() {
            this.rendered = !1
        }, e.prototype.setMapInternal = function(t) {
            t || this.unrender(),
            this.set(gi.MAP, t)
        }, e.prototype.getMapInternal = function() {
            return this.get(gi.MAP)
        }, e.prototype.setMap = function(t) {
            this.mapPrecomposeKey_ && (j(this.mapPrecomposeKey_), this.mapPrecomposeKey_ = null),
            t || this.changed(),
            this.mapRenderKey_ && (j(this.mapRenderKey_), this.mapRenderKey_ = null),
            t && (this.mapPrecomposeKey_ = F(t, mi.PRECOMPOSE, (function(t) {
                var e = t.frameState.layerStatesArray,
                    n = this.getLayerState(!1);
                J(!e.some((function(t) {
                    return t.layer === n.layer
                })), 67),
                e.push(n)
            }), this), this.mapRenderKey_ = F(this, D.CHANGE, t.render, t), this.changed())
        }, e.prototype.setSource = function(t) {
            this.set(gi.SOURCE, t)
        }, e.prototype.getRenderer = function() {
            return this.renderer_ || (this.renderer_ = this.createRenderer()), this.renderer_
        }, e.prototype.hasRenderer = function() {
            return !!this.renderer_
        }, e.prototype.createRenderer = function() {
            return null
        }, e.prototype.disposeInternal = function() {
            this.renderer_ && (this.renderer_.dispose(), delete this.renderer_),
            this.setSource(null),
            t.prototype.disposeInternal.call(this)
        }, e
    }(di.default),
    wi = function() {
        var t = function(e, n) {
            return t = Object.setPrototypeOf || {
                __proto__: []
            } instanceof Array && function(t, e) {
                t.__proto__ = e
            } || function(t, e) {
                for (var n in e)
                    Object.prototype.hasOwnProperty.call(e, n) && (t[n] = e[n])
            }, t(e, n)
        };
        return function(e, n) {
            if ("function" != typeof n && null !== n)
                throw new TypeError("Class extends value " + String(n) + " is not a constructor or null");
            function r() {
                this.constructor = e
            }
            t(e, n),
            e.prototype = null === n ? Object.create(n) : (r.prototype = n.prototype, new r)
        }
    }(),
    bi = function(t) {
        function e(e) {
            var n = t.call(this) || this;
            return n.map_ = e, n
        }
        return wi(e, t), e.prototype.dispatchRenderEvent = function(t, e) {
            u()
        }, e.prototype.calculateMatrices2D = function(t) {
            var e = t.viewState,
                n = t.coordinateToPixelTransform,
                r = t.pixelToCoordinateTransform;
            bt(n, t.size[0] / 2, t.size[1] / 2, 1 / e.resolution, -1 / e.resolution, -e.rotation, -e.center[0], -e.center[1]),
            Ct(r, n)
        }, e.prototype.forEachFeatureAtCoordinate = function(t, e, n, r, i, o, s, a) {
            var u,
                l = e.viewState;
            function h(t, e, n, r) {
                return i.call(o, e, t ? n : null, r)
            }
            var c = l.projection,
                p = Qe(t.slice(), c),
                f = [[0, 0]];
            if (c.canWrapX() && r) {
                var d = re(c.getExtent());
                f.push([-d, 0], [d, 0])
            }
            for (var g = e.layerStatesArray, y = g.length, v = [], m = [], _ = 0; _ < f.length; _++)
                for (var x = y - 1; x >= 0; --x) {
                    var E = g[x],
                        w = E.layer;
                    if (w.hasRenderer() && (0, fi.inView)(E, l) && s.call(a, w)) {
                        var b = w.getRenderer(),
                            C = w.getSource();
                        if (b && C) {
                            var M = C.getWrapX() ? p : t,
                                S = h.bind(null, E.managed);
                            m[0] = M[0] + f[_][0],
                            m[1] = M[1] + f[_][1],
                            u = b.forEachFeatureAtCoordinate(m, e, n, S, v)
                        }
                        if (u)
                            return u
                    }
                }
            if (0 !== v.length) {
                var I = 1 / v.length;
                return v.forEach((function(t, e) {
                    return t.distanceSq += e * I
                })), v.sort((function(t, e) {
                    return t.distanceSq - e.distanceSq
                })), v.some((function(t) {
                    return u = t.callback(t.feature, t.layer, t.geometry)
                })), u
            }
        }, e.prototype.forEachLayerAtPixel = function(t, e, n, r, i) {
            return u()
        }, e.prototype.hasFeatureAtCoordinate = function(t, e, n, r, i, o) {
            return void 0 !== this.forEachFeatureAtCoordinate(t, e, n, r, S, this, i, o)
        }, e.prototype.getMap = function() {
            return this.map_
        }, e.prototype.renderFrame = function(t) {
            u()
        }, e.prototype.scheduleExpireIconCache = function(t) {
            pi.canExpireCache() && t.postRenderFunctions.push(Ci)
        }, e
    }(_);
function Ci(t, e) {
    pi.expire()
}
var Mi = bi,
    Si = {};
t(Si, "default", (() => Ti), (t => Ti = t));
var Ii = function() {
        var t = function(e, n) {
            return t = Object.setPrototypeOf || {
                __proto__: []
            } instanceof Array && function(t, e) {
                t.__proto__ = e
            } || function(t, e) {
                for (var n in e)
                    Object.prototype.hasOwnProperty.call(e, n) && (t[n] = e[n])
            }, t(e, n)
        };
        return function(e, n) {
            if ("function" != typeof n && null !== n)
                throw new TypeError("Class extends value " + String(n) + " is not a constructor or null");
            function r() {
                this.constructor = e
            }
            t(e, n),
            e.prototype = null === n ? Object.create(n) : (r.prototype = n.prototype, new r)
        }
    }(),
    Ti = function(t) {
        function e(e, n, r, i) {
            var o = t.call(this, e) || this;
            return o.inversePixelTransform = n, o.frameState = r, o.context = i, o
        }
        return Ii(e, t), e
    }(g),
    Pi = new RegExp(["^\\s*(?=(?:(?:[-a-z]+\\s*){0,2}(italic|oblique))?)", "(?=(?:(?:[-a-z]+\\s*){0,2}(small-caps))?)", "(?=(?:(?:[-a-z]+\\s*){0,2}(bold(?:er)?|lighter|[1-9]00 ))?)", "(?:(?:normal|\\1|\\2|\\3)\\s*){0,3}((?:xx?-)?", "(?:small|large)|medium|smaller|larger|[\\.\\d]+(?:\\%|in|[cem]m|ex|p[ctx]))", "(?:\\s*\\/\\s*(normal|[\\.\\d]+(?:\\%|in|[cem]m|ex|p[ctx])?))", "?\\s*([-,\\\"\\'\\sa-z]+?)\\s*$"].join(""), "i"),
    Li = ["style", "variant", "weight", "size", "lineHeight", "family"],
    Oi = function(t) {
        var e = t.match(Pi);
        if (!e)
            return null;
        for (var n = {
                lineHeight: "normal",
                size: "1.2em",
                style: "normal",
                weight: "normal",
                variant: "normal"
            }, r = 0, i = Li.length; r < i; ++r) {
            var o = e[r + 1];
            void 0 !== o && (n[Li[r]] = o)
        }
        return n.families = n.family.split(/,\s?/), n
    };
function Ni(t, e, n, r) {
    var i;
    return i = n && n.length ? n.shift() : vt ? new OffscreenCanvas(t || 300, e || 300) : document.createElement("canvas"), t && (i.width = t), e && (i.height = e), i.getContext("2d", r)
}
function Ri(t) {
    var e = t.canvas;
    e.width = 1,
    e.height = 1,
    t.clearRect(0, 0, 1, 1)
}
function Ai(t, e) {
    var n = e.parentNode;
    n && n.replaceChild(t, e)
}
function Di(t) {
    return t && t.parentNode ? t.parentNode.removeChild(t) : null
}
function Fi(t) {
    for (; t.lastChild;)
        t.removeChild(t.lastChild)
}
function ki(t, e) {
    for (var n = t.childNodes, r = 0;; ++r) {
        var i = n[r],
            o = e[r];
        if (!i && !o)
            break;
        i !== o && (i ? o ? t.insertBefore(o, i) : (t.removeChild(i), --r) : t.appendChild(o))
    }
}
var ji = [],
    Gi = [0, 0, 0, 0],
    Bi = new (0, d.default);
(new (0, m.default)).setSize = function() {
    console.warn("labelCache is deprecated.")
};
var qi,
    zi,
    Ui = null,
    Vi = {},
    Xi = function() {
        var t,
            e,
            n = "32px ",
            r = ["monospace", "serif"],
            i = r.length,
            o = "wmytzilWMYTZIL@#/&?$%10";
        function s(t, s, a) {
            for (var u = !0, l = 0; l < i; ++l) {
                var h = r[l];
                if (e = Wi(t + " " + s + " " + n + h, o), a != h) {
                    var c = Wi(t + " " + s + " " + n + a + "," + h, o);
                    u = u && c != e
                }
            }
            return !!u
        }
        function a() {
            for (var e = !0, n = Bi.getKeys(), r = 0, i = n.length; r < i; ++r) {
                var o = n[r];
                Bi.get(o) < 100 && (s.apply(this, o.split("\n")) ? (L(Vi), Ui = null, qi = void 0, Bi.set(o, 100)) : (Bi.set(o, Bi.get(o) + 1, !0), e = !1))
            }
            e && (clearInterval(t), t = void 0)
        }
        return function(e) {
            var n = Oi(e);
            if (n)
                for (var r = n.families, i = 0, o = r.length; i < o; ++i) {
                    var u = r[i],
                        l = n.style + "\n" + n.weight + "\n" + u;
                    void 0 === Bi.get(l) && (Bi.set(l, 100, !0), s(n.style, n.weight, u) || (Bi.set(l, 0, !0), void 0 === t && (t = setInterval(a, 32))))
                }
        }
    }(),
    Hi = function(t) {
        var e = Vi[t];
        if (null == e) {
            if (vt) {
                var n = Oi(t),
                    r = Yi(t, "Žg");
                e = (isNaN(Number(n.lineHeight)) ? 1.2 : Number(n.lineHeight)) * (r.actualBoundingBoxAscent + r.actualBoundingBoxDescent)
            } else
                zi || ((zi = document.createElement("div")).innerHTML = "M", zi.style.minHeight = "0", zi.style.maxHeight = "none", zi.style.height = "auto", zi.style.padding = "0", zi.style.border = "none", zi.style.position = "absolute", zi.style.display = "block", zi.style.left = "-99999px"),
                zi.style.font = t,
                document.body.appendChild(zi),
                e = zi.offsetHeight,
                document.body.removeChild(zi);
            Vi[t] = e
        }
        return e
    };
function Yi(t, e) {
    return Ui || (Ui = Ni(1, 1)), t != qi && (Ui.font = t, qi = Ui.font), Ui.measureText(e)
}
function Wi(t, e) {
    return Yi(t, e).width
}
function $i(t, e, n) {
    if (e in n)
        return n[e];
    var r = e.split("\n").reduce((function(e, n) {
        return Math.max(e, Wi(t, n))
    }), 0);
    return n[e] = r, r
}
function Ki(t, e) {
    for (var n = [], r = [], i = [], o = 0, s = 0, a = 0, u = 0, l = 0, h = e.length; l <= h; l += 2) {
        var c = e[l];
        if ("\n" !== c && l !== h) {
            var p = e[l + 1] || t.font,
                f = Wi(p, c);
            n.push(f),
            s += f;
            var d = Hi(p);
            r.push(d),
            u = Math.max(u, d)
        } else
            o = Math.max(o, s),
            i.push(s),
            s = 0,
            a += u
    }
    return {
        width: o,
        height: a,
        widths: n,
        heights: r,
        lineWidths: i
    }
}
function Zi(t, e, n, r, i, o, s, a, u, l, h) {
    t.save(),
    1 !== n && (t.globalAlpha *= n),
    e && t.setTransform.apply(t, e),
    r.contextInstructions ? (t.translate(u, l), t.scale(h[0], h[1]), function(t, e) {
        for (var n = t.contextInstructions, r = 0, i = n.length; r < i; r += 2)
            Array.isArray(n[r + 1]) ? e[n[r]].apply(e, n[r + 1]) : e[n[r]] = n[r + 1]
    }(r, t)) : h[0] < 0 || h[1] < 0 ? (t.translate(u, l), t.scale(h[0], h[1]), t.drawImage(r, i, o, s, a, 0, 0, s, a)) : t.drawImage(r, i, o, s, a, u, l, s * h[0], a * h[1]),
    t.restore()
}
var Ji = function() {
        var t = function(e, n) {
            return t = Object.setPrototypeOf || {
                __proto__: []
            } instanceof Array && function(t, e) {
                t.__proto__ = e
            } || function(t, e) {
                for (var n in e)
                    Object.prototype.hasOwnProperty.call(e, n) && (t[n] = e[n])
            }, t(e, n)
        };
        return function(e, n) {
            if ("function" != typeof n && null !== n)
                throw new TypeError("Class extends value " + String(n) + " is not a constructor or null");
            function r() {
                this.constructor = e
            }
            t(e, n),
            e.prototype = null === n ? Object.create(n) : (r.prototype = n.prototype, new r)
        }
    }(),
    Qi = function(t) {
        function e(e) {
            var n = t.call(this, e) || this;
            n.fontChangeListenerKey_ = F(Bi, y.PROPERTYCHANGE, e.redrawText.bind(e)),
            n.element_ = document.createElement("div");
            var r = n.element_.style;
            r.position = "absolute",
            r.width = "100%",
            r.height = "100%",
            r.zIndex = "0",
            n.element_.className = "ol-unselectable ol-layers";
            var i = e.getViewport();
            return i.insertBefore(n.element_, i.firstChild || null), n.children_ = [], n.renderedVisible_ = !0, n
        }
        return Ji(e, t), e.prototype.dispatchRenderEvent = function(t, e) {
            var n = this.getMap();
            if (n.hasListener(t)) {
                var r = new (0, Si.default)(t, void 0, e);
                n.dispatchEvent(r)
            }
        }, e.prototype.disposeInternal = function() {
            j(this.fontChangeListenerKey_),
            this.element_.parentNode.removeChild(this.element_),
            t.prototype.disposeInternal.call(this)
        }, e.prototype.renderFrame = function(t) {
            if (t) {
                this.calculateMatrices2D(t),
                this.dispatchRenderEvent(mi.PRECOMPOSE, t);
                var e = t.layerStatesArray.sort((function(t, e) {
                        return t.zIndex - e.zIndex
                    })),
                    n = t.viewState;
                this.children_.length = 0;
                for (var r = [], i = null, o = 0, s = e.length; o < s; ++o) {
                    var a = e[o];
                    t.layerIndex = o;
                    var u = a.layer,
                        l = u.getSourceState();
                    if (!(0, fi.inView)(a, n) || "ready" != l && "undefined" != l)
                        u.unrender();
                    else {
                        var h = u.render(t, i);
                        h && (h !== i && (this.children_.push(h), i = h), "getDeclutter" in u && r.push(u))
                    }
                }
                for (o = r.length - 1; o >= 0; --o)
                    r[o].renderDeclutter(t);
                ki(this.element_, this.children_),
                this.dispatchRenderEvent(mi.POSTCOMPOSE, t),
                this.renderedVisible_ || (this.element_.style.display = "", this.renderedVisible_ = !0),
                this.scheduleExpireIconCache(t)
            } else
                this.renderedVisible_ && (this.element_.style.display = "none", this.renderedVisible_ = !1)
        }, e.prototype.forEachLayerAtPixel = function(t, e, n, r, i) {
            for (var o = e.viewState, s = e.layerStatesArray, a = s.length - 1; a >= 0; --a) {
                var u = s[a],
                    l = u.layer;
                if (l.hasRenderer() && (0, fi.inView)(u, o) && i(l)) {
                    var h = l.getRenderer().getDataAtPixel(t, e, n);
                    if (h) {
                        var c = r(l, h);
                        if (c)
                            return c
                    }
                }
            }
        }, e
    }(Qr.default),
    to = Qi,
    eo = {};
t(eo, "default", (() => is), (t => is = t));
var no = {};
t(no, "GroupEvent", (() => io), (t => io = t)),
t(no, "default", (() => so), (t => so = t));
var ro = function() {
        var t = function(e, n) {
            return t = Object.setPrototypeOf || {
                __proto__: []
            } instanceof Array && function(t, e) {
                t.__proto__ = e
            } || function(t, e) {
                for (var n in e)
                    Object.prototype.hasOwnProperty.call(e, n) && (t[n] = e[n])
            }, t(e, n)
        };
        return function(e, n) {
            if ("function" != typeof n && null !== n)
                throw new TypeError("Class extends value " + String(n) + " is not a constructor or null");
            function r() {
                this.constructor = e
            }
            t(e, n),
            e.prototype = null === n ? Object.create(n) : (r.prototype = n.prototype, new r)
        }
    }(),
    io = function(t) {
        function e(e, n) {
            var r = t.call(this, e) || this;
            return r.layer = n, r
        }
        return ro(e, t), e
    }(g),
    oo = "layers",
    so = function(t) {
        function e(e) {
            var n = this,
                r = e || {},
                i = P({}, r);
            delete i.layers;
            var o = r.layers;
            return (n = t.call(this, i) || this).on, n.once, n.un, n.layersListenerKeys_ = [], n.listenerKeys_ = {}, n.addChangeListener(oo, n.handleLayersChanged_), o ? Array.isArray(o) ? o = new (0, s.default)(o.slice(), {
                unique: !0
            }) : J("function" == typeof o.getArray, 43) : o = new (0, s.default)(void 0, {
                unique: !0
            }), n.setLayers(o), n
        }
        return ro(e, t), e.prototype.handleLayerChange_ = function() {
            this.changed()
        }, e.prototype.handleLayersChanged_ = function() {
            this.layersListenerKeys_.forEach(j),
            this.layersListenerKeys_.length = 0;
            var t = this.getLayers();
            for (var e in this.layersListenerKeys_.push(F(t, H.ADD, this.handleLayersAdd_, this), F(t, H.REMOVE, this.handleLayersRemove_, this)), this.listenerKeys_)
                this.listenerKeys_[e].forEach(j);
            L(this.listenerKeys_);
            for (var n = t.getArray(), r = 0, i = n.length; r < i; r++) {
                var o = n[r];
                this.registerLayerListeners_(o),
                this.dispatchEvent(new io("addlayer", o))
            }
            this.changed()
        }, e.prototype.registerLayerListeners_ = function(t) {
            var n = [F(t, y.PROPERTYCHANGE, this.handleLayerChange_, this), F(t, D.CHANGE, this.handleLayerChange_, this)];
            t instanceof e && n.push(F(t, "addlayer", this.handleLayerGroupAdd_, this), F(t, "removelayer", this.handleLayerGroupRemove_, this)),
            this.listenerKeys_[h(t)] = n
        }, e.prototype.handleLayerGroupAdd_ = function(t) {
            this.dispatchEvent(new io("addlayer", t.layer))
        }, e.prototype.handleLayerGroupRemove_ = function(t) {
            this.dispatchEvent(new io("removelayer", t.layer))
        }, e.prototype.handleLayersAdd_ = function(t) {
            var e = t.element;
            this.registerLayerListeners_(e),
            this.dispatchEvent(new io("addlayer", e)),
            this.changed()
        }, e.prototype.handleLayersRemove_ = function(t) {
            var e = t.element,
                n = h(e);
            this.listenerKeys_[n].forEach(j),
            delete this.listenerKeys_[n],
            this.dispatchEvent(new io("removelayer", e)),
            this.changed()
        }, e.prototype.getLayers = function() {
            return this.get(oo)
        }, e.prototype.setLayers = function(t) {
            var e = this.getLayers();
            if (e)
                for (var n = e.getArray(), r = 0, i = n.length; r < i; ++r)
                    this.dispatchEvent(new io("removelayer", n[r]));
            this.set(oo, t)
        }, e.prototype.getLayersArray = function(t) {
            var e = void 0 !== t ? t : [];
            return this.getLayers().forEach((function(t) {
                t.getLayersArray(e)
            })), e
        }, e.prototype.getLayerStatesArray = function(t) {
            var e = void 0 !== t ? t : [],
                n = e.length;
            this.getLayers().forEach((function(t) {
                t.getLayerStatesArray(e)
            }));
            var r = this.getLayerState(),
                i = r.zIndex;
            t || void 0 !== r.zIndex || (i = 0);
            for (var o = n, s = e.length; o < s; o++) {
                var a = e[o];
                a.opacity *= r.opacity,
                a.visible = a.visible && r.visible,
                a.maxResolution = Math.min(a.maxResolution, r.maxResolution),
                a.minResolution = Math.max(a.minResolution, r.minResolution),
                a.minZoom = Math.max(a.minZoom, r.minZoom),
                a.maxZoom = Math.min(a.maxZoom, r.maxZoom),
                void 0 !== r.extent && (void 0 !== a.extent ? a.extent = te(a.extent, r.extent) : a.extent = r.extent),
                void 0 === a.zIndex && (a.zIndex = i)
            }
            return e
        }, e.prototype.getSourceState = function() {
            return "ready"
        }, e
    }(di.default),
    ao = {};
t(ao, "default", (() => po), (t => po = t));
var uo = {};
t(uo, "default", (() => ho), (t => ho = t));
var lo = function() {
        var t = function(e, n) {
            return t = Object.setPrototypeOf || {
                __proto__: []
            } instanceof Array && function(t, e) {
                t.__proto__ = e
            } || function(t, e) {
                for (var n in e)
                    Object.prototype.hasOwnProperty.call(e, n) && (t[n] = e[n])
            }, t(e, n)
        };
        return function(e, n) {
            if ("function" != typeof n && null !== n)
                throw new TypeError("Class extends value " + String(n) + " is not a constructor or null");
            function r() {
                this.constructor = e
            }
            t(e, n),
            e.prototype = null === n ? Object.create(n) : (r.prototype = n.prototype, new r)
        }
    }(),
    ho = function(t) {
        function e(e, n, r) {
            var i = t.call(this, e) || this;
            return i.map = n, i.frameState = void 0 !== r ? r : null, i
        }
        return lo(e, t), e
    }(g),
    co = function() {
        var t = function(e, n) {
            return t = Object.setPrototypeOf || {
                __proto__: []
            } instanceof Array && function(t, e) {
                t.__proto__ = e
            } || function(t, e) {
                for (var n in e)
                    Object.prototype.hasOwnProperty.call(e, n) && (t[n] = e[n])
            }, t(e, n)
        };
        return function(e, n) {
            if ("function" != typeof n && null !== n)
                throw new TypeError("Class extends value " + String(n) + " is not a constructor or null");
            function r() {
                this.constructor = e
            }
            t(e, n),
            e.prototype = null === n ? Object.create(n) : (r.prototype = n.prototype, new r)
        }
    }(),
    po = function(t) {
        function e(e, n, r, i, o, s) {
            var a = t.call(this, e, n, o) || this;
            return a.originalEvent = r, a.pixel_ = null, a.coordinate_ = null, a.dragging = void 0 !== i && i, a.activePointers = s, a
        }
        return co(e, t), Object.defineProperty(e.prototype, "pixel", {
            get: function() {
                return this.pixel_ || (this.pixel_ = this.map.getEventPixel(this.originalEvent)), this.pixel_
            },
            set: function(t) {
                this.pixel_ = t
            },
            enumerable: !1,
            configurable: !0
        }), Object.defineProperty(e.prototype, "coordinate", {
            get: function() {
                return this.coordinate_ || (this.coordinate_ = this.map.getCoordinateFromPixel(this.pixel)), this.coordinate_
            },
            set: function(t) {
                this.coordinate_ = t
            },
            enumerable: !1,
            configurable: !0
        }), e.prototype.preventDefault = function() {
            t.prototype.preventDefault.call(this),
            "preventDefault" in this.originalEvent && this.originalEvent.preventDefault()
        }, e.prototype.stopPropagation = function() {
            t.prototype.stopPropagation.call(this),
            "stopPropagation" in this.originalEvent && this.originalEvent.stopPropagation()
        }, e
    }(uo.default),
    fo = {};
t(fo, "default", (() => mo), (t => mo = t));
var go = {
        SINGLECLICK: "singleclick",
        CLICK: D.CLICK,
        DBLCLICK: D.DBLCLICK,
        POINTERDRAG: "pointerdrag",
        POINTERMOVE: "pointermove",
        POINTERDOWN: "pointerdown",
        POINTERUP: "pointerup",
        POINTEROVER: "pointerover",
        POINTEROUT: "pointerout",
        POINTERENTER: "pointerenter",
        POINTERLEAVE: "pointerleave",
        POINTERCANCEL: "pointercancel"
    },
    yo = {
        POINTERMOVE: "pointermove",
        POINTERDOWN: "pointerdown",
        POINTERUP: "pointerup",
        POINTEROVER: "pointerover",
        POINTEROUT: "pointerout",
        POINTERENTER: "pointerenter",
        POINTERLEAVE: "pointerleave",
        POINTERCANCEL: "pointercancel"
    },
    vo = function() {
        var t = function(e, n) {
            return t = Object.setPrototypeOf || {
                __proto__: []
            } instanceof Array && function(t, e) {
                t.__proto__ = e
            } || function(t, e) {
                for (var n in e)
                    Object.prototype.hasOwnProperty.call(e, n) && (t[n] = e[n])
            }, t(e, n)
        };
        return function(e, n) {
            if ("function" != typeof n && null !== n)
                throw new TypeError("Class extends value " + String(n) + " is not a constructor or null");
            function r() {
                this.constructor = e
            }
            t(e, n),
            e.prototype = null === n ? Object.create(n) : (r.prototype = n.prototype, new r)
        }
    }(),
    mo = function(t) {
        function e(e, n) {
            var r = t.call(this, e) || this;
            r.map_ = e,
            r.clickTimeoutId_,
            r.emulateClicks_ = !1,
            r.dragging_ = !1,
            r.dragListenerKeys_ = [],
            r.moveTolerance_ = void 0 === n ? 1 : n,
            r.down_ = null;
            var i = r.map_.getViewport();
            return r.activePointers_ = [], r.trackedTouches_ = {}, r.element_ = i, r.pointerdownListenerKey_ = F(i, yo.POINTERDOWN, r.handlePointerDown_, r), r.originalPointerMoveEvent_, r.relayedListenerKey_ = F(i, yo.POINTERMOVE, r.relayMoveEvent_, r), r.boundHandleTouchMove_ = r.handleTouchMove_.bind(r), r.element_.addEventListener(D.TOUCHMOVE, r.boundHandleTouchMove_, !!_t && {
                passive: !1
            }), r
        }
        return vo(e, t), e.prototype.emulateClick_ = function(t) {
            var e = new (0, ao.default)(go.CLICK, this.map_, t);
            this.dispatchEvent(e),
            void 0 !== this.clickTimeoutId_ ? (clearTimeout(this.clickTimeoutId_), this.clickTimeoutId_ = void 0, e = new (0, ao.default)(go.DBLCLICK, this.map_, t), this.dispatchEvent(e)) : this.clickTimeoutId_ = setTimeout(function() {
                this.clickTimeoutId_ = void 0;
                var e = new (0, ao.default)(go.SINGLECLICK, this.map_, t);
                this.dispatchEvent(e)
            }.bind(this), 250)
        }, e.prototype.updateActivePointers_ = function(t) {
            var e = t,
                n = e.pointerId;
            if (e.type == go.POINTERUP || e.type == go.POINTERCANCEL) {
                for (var r in delete this.trackedTouches_[n], this.trackedTouches_)
                    if (this.trackedTouches_[r].target !== e.target) {
                        delete this.trackedTouches_[r];
                        break
                    }
            } else
                e.type != go.POINTERDOWN && e.type != go.POINTERMOVE || (this.trackedTouches_[n] = e);
            this.activePointers_ = O(this.trackedTouches_)
        }, e.prototype.handlePointerUp_ = function(t) {
            this.updateActivePointers_(t);
            var e = new (0, ao.default)(go.POINTERUP, this.map_, t, void 0, void 0, this.activePointers_);
            this.dispatchEvent(e),
            this.emulateClicks_ && !e.defaultPrevented && !this.dragging_ && this.isMouseActionButton_(t) && this.emulateClick_(this.down_),
            0 === this.activePointers_.length && (this.dragListenerKeys_.forEach(j), this.dragListenerKeys_.length = 0, this.dragging_ = !1, this.down_ = null)
        }, e.prototype.isMouseActionButton_ = function(t) {
            return 0 === t.button
        }, e.prototype.handlePointerDown_ = function(t) {
            this.emulateClicks_ = 0 === this.activePointers_.length,
            this.updateActivePointers_(t);
            var e = new (0, ao.default)(go.POINTERDOWN, this.map_, t, void 0, void 0, this.activePointers_);
            for (var n in this.dispatchEvent(e), this.down_ = {}, t) {
                var r = t[n];
                this.down_[n] = "function" == typeof r ? T : r
            }
            if (0 === this.dragListenerKeys_.length) {
                var i = this.map_.getOwnerDocument();
                this.dragListenerKeys_.push(F(i, go.POINTERMOVE, this.handlePointerMove_, this), F(i, go.POINTERUP, this.handlePointerUp_, this), F(this.element_, go.POINTERCANCEL, this.handlePointerUp_, this)),
                this.element_.getRootNode && this.element_.getRootNode() !== i && this.dragListenerKeys_.push(F(this.element_.getRootNode(), go.POINTERUP, this.handlePointerUp_, this))
            }
        }, e.prototype.handlePointerMove_ = function(t) {
            if (this.isMoving_(t)) {
                this.updateActivePointers_(t),
                this.dragging_ = !0;
                var e = new (0, ao.default)(go.POINTERDRAG, this.map_, t, this.dragging_, void 0, this.activePointers_);
                this.dispatchEvent(e)
            }
        }, e.prototype.relayMoveEvent_ = function(t) {
            this.originalPointerMoveEvent_ = t;
            var e = !(!this.down_ || !this.isMoving_(t));
            this.dispatchEvent(new (0, ao.default)(go.POINTERMOVE, this.map_, t, e))
        }, e.prototype.handleTouchMove_ = function(t) {
            var e = this.originalPointerMoveEvent_;
            e && !e.defaultPrevented || "boolean" == typeof t.cancelable && !0 !== t.cancelable || t.preventDefault()
        }, e.prototype.isMoving_ = function(t) {
            return this.dragging_ || Math.abs(t.clientX - this.down_.clientX) > this.moveTolerance_ || Math.abs(t.clientY - this.down_.clientY) > this.moveTolerance_
        }, e.prototype.disposeInternal = function() {
            this.relayedListenerKey_ && (j(this.relayedListenerKey_), this.relayedListenerKey_ = null),
            this.element_.removeEventListener(D.TOUCHMOVE, this.boundHandleTouchMove_),
            this.pointerdownListenerKey_ && (j(this.pointerdownListenerKey_), this.pointerdownListenerKey_ = null),
            this.dragListenerKeys_.forEach(j),
            this.dragListenerKeys_.length = 0,
            this.element_ = null,
            t.prototype.disposeInternal.call(this)
        }, e
    }(m.default),
    _o = {
        POSTRENDER: "postrender",
        MOVESTART: "movestart",
        MOVEEND: "moveend",
        LOADSTART: "loadstart",
        LOADEND: "loadend"
    },
    xo = {
        LAYERGROUP: "layergroup",
        SIZE: "size",
        TARGET: "target",
        VIEW: "view"
    },
    Eo = {};
t(Eo, "default", (() => Mo), (t => Mo = t)),
t(Eo, "getTilePriority", (() => So), (t => So = t));
var wo = function() {
        function t(t, e) {
            this.priorityFunction_ = t,
            this.keyFunction_ = e,
            this.elements_ = [],
            this.priorities_ = [],
            this.queuedElements_ = {}
        }
        return t.prototype.clear = function() {
            this.elements_.length = 0,
            this.priorities_.length = 0,
            L(this.queuedElements_)
        }, t.prototype.dequeue = function() {
            var t = this.elements_,
                e = this.priorities_,
                n = t[0];
            1 == t.length ? (t.length = 0, e.length = 0) : (t[0] = t.pop(), e[0] = e.pop(), this.siftUp_(0));
            var r = this.keyFunction_(n);
            return delete this.queuedElements_[r], n
        }, t.prototype.enqueue = function(t) {
            J(!(this.keyFunction_(t) in this.queuedElements_), 31);
            var e = this.priorityFunction_(t);
            return Infinity != e && (this.elements_.push(t), this.priorities_.push(e), this.queuedElements_[this.keyFunction_(t)] = !0, this.siftDown_(0, this.elements_.length - 1), !0)
        }, t.prototype.getCount = function() {
            return this.elements_.length
        }, t.prototype.getLeftChildIndex_ = function(t) {
            return 2 * t + 1
        }, t.prototype.getRightChildIndex_ = function(t) {
            return 2 * t + 2
        }, t.prototype.getParentIndex_ = function(t) {
            return t - 1 >> 1
        }, t.prototype.heapify_ = function() {
            var t;
            for (t = (this.elements_.length >> 1) - 1; t >= 0; t--)
                this.siftUp_(t)
        }, t.prototype.isEmpty = function() {
            return 0 === this.elements_.length
        }, t.prototype.isKeyQueued = function(t) {
            return t in this.queuedElements_
        }, t.prototype.isQueued = function(t) {
            return this.isKeyQueued(this.keyFunction_(t))
        }, t.prototype.siftUp_ = function(t) {
            for (var e = this.elements_, n = this.priorities_, r = e.length, i = e[t], o = n[t], s = t; t < r >> 1;) {
                var a = this.getLeftChildIndex_(t),
                    u = this.getRightChildIndex_(t),
                    l = u < r && n[u] < n[a] ? u : a;
                e[t] = e[l],
                n[t] = n[l],
                t = l
            }
            e[t] = i,
            n[t] = o,
            this.siftDown_(s, t)
        }, t.prototype.siftDown_ = function(t, e) {
            for (var n = this.elements_, r = this.priorities_, i = n[e], o = r[e]; e > t;) {
                var s = this.getParentIndex_(e);
                if (!(r[s] > o))
                    break;
                n[e] = n[s],
                r[e] = r[s],
                e = s
            }
            n[e] = i,
            r[e] = o
        }, t.prototype.reprioritize = function() {
            var t,
                e,
                n,
                r = this.priorityFunction_,
                i = this.elements_,
                o = this.priorities_,
                s = 0,
                a = i.length;
            for (e = 0; e < a; ++e)
                Infinity == (n = r(t = i[e])) ? delete this.queuedElements_[this.keyFunction_(t)] : (o[s] = n, i[s++] = t);
            i.length = s,
            o.length = s,
            this.heapify_()
        }, t
    }(),
    bo = {
        IDLE: 0,
        LOADING: 1,
        LOADED: 2,
        ERROR: 3,
        EMPTY: 4
    },
    Co = function() {
        var t = function(e, n) {
            return t = Object.setPrototypeOf || {
                __proto__: []
            } instanceof Array && function(t, e) {
                t.__proto__ = e
            } || function(t, e) {
                for (var n in e)
                    Object.prototype.hasOwnProperty.call(e, n) && (t[n] = e[n])
            }, t(e, n)
        };
        return function(e, n) {
            if ("function" != typeof n && null !== n)
                throw new TypeError("Class extends value " + String(n) + " is not a constructor or null");
            function r() {
                this.constructor = e
            }
            t(e, n),
            e.prototype = null === n ? Object.create(n) : (r.prototype = n.prototype, new r)
        }
    }(),
    Mo = function(t) {
        function e(e, n) {
            var r = t.call(this, (function(t) {
                return e.apply(null, t)
            }), (function(t) {
                return t[0].getKey()
            })) || this;
            return r.boundHandleTileChange_ = r.handleTileChange.bind(r), r.tileChangeCallback_ = n, r.tilesLoading_ = 0, r.tilesLoadingKeys_ = {}, r
        }
        return Co(e, t), e.prototype.enqueue = function(e) {
            var n = t.prototype.enqueue.call(this, e);
            n && e[0].addEventListener(D.CHANGE, this.boundHandleTileChange_);
            return n
        }, e.prototype.getTilesLoading = function() {
            return this.tilesLoading_
        }, e.prototype.handleTileChange = function(t) {
            var e = t.target,
                n = e.getState();
            if (n === bo.LOADED || n === bo.ERROR || n === bo.EMPTY) {
                e.removeEventListener(D.CHANGE, this.boundHandleTileChange_);
                var r = e.getKey();
                r in this.tilesLoadingKeys_ && (delete this.tilesLoadingKeys_[r], --this.tilesLoading_),
                this.tileChangeCallback_()
            }
        }, e.prototype.loadMoreTiles = function(t, e) {
            for (var n, r, i = 0; this.tilesLoading_ < t && i < e && this.getCount() > 0;)
                r = (n = this.dequeue()[0]).getKey(),
                n.getState() !== bo.IDLE || r in this.tilesLoadingKeys_ || (this.tilesLoadingKeys_[r] = !0, ++this.tilesLoading_, ++i, n.load())
        }, e
    }(wo);
function So(t, e, n, r, i) {
    if (!t || !(n in t.wantedTiles))
        return Infinity;
    if (!t.wantedTiles[n][e.getKey()])
        return Infinity;
    var o = t.viewState.center,
        s = r[0] - o[0],
        a = r[1] - o[1];
    return 65536 * Math.log(i) + Math.sqrt(s * s + a * a) / i
}
var Io = {};
t(Io, "createResolutionConstraint", (() => Yo), (t => Yo = t)),
t(Io, "createCenterConstraint", (() => Ho), (t => Ho = t)),
t(Io, "createRotationConstraint", (() => Wo), (t => Wo = t)),
t(Io, "isNoopAnimation", (() => $o), (t => $o = t)),
t(Io, "default", (() => Zo), (t => Zo = t));
var To = {
        ANIMATING: 0,
        INTERACTING: 1
    },
    Po = {
        CENTER: "center",
        RESOLUTION: "resolution",
        ROTATION: "rotation"
    };
function Lo(t, e, n) {
    return function(r, i, o, s, a) {
        if (r) {
            if (!i && !e)
                return r;
            var u = e ? 0 : o[0] * i,
                l = e ? 0 : o[1] * i,
                h = a ? a[0] : 0,
                c = a ? a[1] : 0,
                p = t[0] + u / 2 + h,
                f = t[2] - u / 2 + h,
                d = t[1] + l / 2 + c,
                g = t[3] - l / 2 + c;
            p > f && (f = p = (f + p) / 2),
            d > g && (g = d = (g + d) / 2);
            var y = fe(r[0], p, f),
                v = fe(r[1], d, g);
            if (s && n && i) {
                var m = 30 * i;
                y += -m * Math.log(1 + Math.max(0, p - r[0]) / m) + m * Math.log(1 + Math.max(0, r[0] - f) / m),
                v += -m * Math.log(1 + Math.max(0, d - r[1]) / m) + m * Math.log(1 + Math.max(0, r[1] - g) / m)
            }
            return [y, v]
        }
    }
}
function Oo(t) {
    return t
}
function No(t, e, n, r) {
    var i = re(e) / n[0],
        o = Qt(e) / n[1];
    return r ? Math.min(t, Math.max(i, o)) : Math.min(t, Math.min(i, o))
}
function Ro(t, e, n) {
    var r = Math.min(t, e);
    return r *= Math.log(1 + 50 * Math.max(0, t / e - 1)) / 50 + 1, n && (r = Math.max(r, n), r /= Math.log(1 + 50 * Math.max(0, n / t - 1)) / 50 + 1), fe(r, n / 2, 2 * e)
}
function Ao(t, e, n, r) {
    return function(i, o, s, a) {
        if (void 0 !== i) {
            var u = t[0],
                l = t[t.length - 1],
                h = n ? No(u, n, s, r) : u;
            if (a)
                return void 0 === e || e ? Ro(i, h, l) : fe(i, l, h);
            var c = Math.min(h, i),
                p = Math.floor(w(t, c, o));
            return t[p] > h && p < t.length - 1 ? t[p + 1] : t[p]
        }
    }
}
function Do(t, e, n, r, i, o) {
    return function(s, a, u, l) {
        if (void 0 !== s) {
            var h = i ? No(e, i, u, o) : e,
                c = void 0 !== n ? n : 0;
            if (l)
                return void 0 === r || r ? Ro(s, h, c) : fe(s, c, h);
            var p = Math.ceil(Math.log(e / h) / Math.log(t) - 1e-9),
                f = -a * (.5 - 1e-9) + .5,
                d = Math.min(h, s),
                g = Math.floor(Math.log(e / d) / Math.log(t) + f),
                y = Math.max(p, g);
            return fe(e / Math.pow(t, y), c, h)
        }
    }
}
function Fo(t, e, n, r, i) {
    return function(o, s, a, u) {
        if (void 0 !== o) {
            var l = r ? No(t, r, a, i) : t;
            return (void 0 === n || n) && u ? Ro(o, l, e) : fe(o, e, l)
        }
    }
}
function ko(t) {
    return void 0 !== t ? 0 : void 0
}
function jo(t) {
    return void 0 !== t ? t : void 0
}
function Go(t) {
    return Math.pow(t, 3)
}
function Bo(t) {
    return 1 - Go(1 - t)
}
function qo(t) {
    return 3 * t * t - 2 * t * t * t
}
function zo(t) {
    return t
}
var Uo = function() {
        var t = function(e, n) {
            return t = Object.setPrototypeOf || {
                __proto__: []
            } instanceof Array && function(t, e) {
                t.__proto__ = e
            } || function(t, e) {
                for (var n in e)
                    Object.prototype.hasOwnProperty.call(e, n) && (t[n] = e[n])
            }, t(e, n)
        };
        return function(e, n) {
            if ("function" != typeof n && null !== n)
                throw new TypeError("Class extends value " + String(n) + " is not a constructor or null");
            function r() {
                this.constructor = e
            }
            t(e, n),
            e.prototype = null === n ? Object.create(n) : (r.prototype = n.prototype, new r)
        }
    }(),
    Vo = function(t) {
        function e(e) {
            var n = t.call(this) || this;
            n.on,
            n.once,
            n.un;
            var r = P({}, e);
            return n.hints_ = [0, 0], n.animations_ = [], n.updateAnimationKey_, n.projection_ = pn(r.projection, "EPSG:3857"), n.viewportSize_ = [100, 100], n.targetCenter_ = null, n.targetResolution_, n.targetRotation_, n.nextCenter_ = null, n.nextResolution_, n.nextRotation_, n.cancelAnchor_ = void 0, r.projection && on(), r.center && (r.center = Cn(r.center, n.projection_)), r.extent && (r.extent = Sn(r.extent, n.projection_)), n.applyOptions_(r), n
        }
        return Uo(e, t), e.prototype.applyOptions_ = function(t) {
            var e = P({}, t);
            for (var n in Po)
                delete e[n];
            this.setProperties(e, !0);
            var r = Yo(t);
            this.maxResolution_ = r.maxResolution,
            this.minResolution_ = r.minResolution,
            this.zoomFactor_ = r.zoomFactor,
            this.resolutions_ = t.resolutions,
            this.padding_ = t.padding,
            this.minZoom_ = r.minZoom;
            var i = Ho(t),
                o = r.constraint,
                s = Wo(t);
            this.constraints_ = {
                center: i,
                resolution: o,
                rotation: s
            },
            this.setRotation(void 0 !== t.rotation ? t.rotation : 0),
            this.setCenterInternal(void 0 !== t.center ? t.center : null),
            void 0 !== t.resolution ? this.setResolution(t.resolution) : void 0 !== t.zoom && this.setZoom(t.zoom)
        }, Object.defineProperty(e.prototype, "padding", {
            get: function() {
                return this.padding_
            },
            set: function(t) {
                var e = this.padding_;
                this.padding_ = t;
                var n = this.getCenter();
                if (n) {
                    var r = t || [0, 0, 0, 0];
                    e = e || [0, 0, 0, 0];
                    var i = this.getResolution(),
                        o = i / 2 * (r[3] - e[3] + e[1] - r[1]),
                        s = i / 2 * (r[0] - e[0] + e[2] - r[2]);
                    this.setCenterInternal([n[0] + o, n[1] - s])
                }
            },
            enumerable: !1,
            configurable: !0
        }), e.prototype.getUpdatedOptions_ = function(t) {
            var e = this.getProperties();
            return void 0 !== e.resolution ? e.resolution = this.getResolution() : e.zoom = this.getZoom(), e.center = this.getCenterInternal(), e.rotation = this.getRotation(), P({}, e, t)
        }, e.prototype.animate = function(t) {
            this.isDef() && !this.getAnimating() && this.resolveConstraints(0);
            for (var e = new Array(arguments.length), n = 0; n < e.length; ++n) {
                var r = arguments[n];
                r.center && ((r = P({}, r)).center = Cn(r.center, this.getProjection())),
                r.anchor && ((r = P({}, r)).anchor = Cn(r.anchor, this.getProjection())),
                e[n] = r
            }
            this.animateInternal.apply(this, e)
        }, e.prototype.animateInternal = function(t) {
            var e,
                n = arguments.length;
            n > 1 && "function" == typeof arguments[n - 1] && (e = arguments[n - 1], --n);
            for (var r = 0; r < n && !this.isDef(); ++r) {
                var i = arguments[r];
                i.center && this.setCenterInternal(i.center),
                void 0 !== i.zoom ? this.setZoom(i.zoom) : i.resolution && this.setResolution(i.resolution),
                void 0 !== i.rotation && this.setRotation(i.rotation)
            }
            if (r !== n) {
                for (var o = Date.now(), s = this.targetCenter_.slice(), a = this.targetResolution_, u = this.targetRotation_, l = []; r < n; ++r) {
                    var h = arguments[r],
                        c = {
                            start: o,
                            complete: !1,
                            anchor: h.anchor,
                            duration: void 0 !== h.duration ? h.duration : 1e3,
                            easing: h.easing || qo,
                            callback: e
                        };
                    if (h.center && (c.sourceCenter = s, c.targetCenter = h.center.slice(), s = c.targetCenter), void 0 !== h.zoom ? (c.sourceResolution = a, c.targetResolution = this.getResolutionForZoom(h.zoom), a = c.targetResolution) : h.resolution && (c.sourceResolution = a, c.targetResolution = h.resolution, a = c.targetResolution), void 0 !== h.rotation) {
                        c.sourceRotation = u;
                        var p = Ee(h.rotation - u + Math.PI, 2 * Math.PI) - Math.PI;
                        c.targetRotation = u + p,
                        u = c.targetRotation
                    }
                    $o(c) ? c.complete = !0 : o += c.duration,
                    l.push(c)
                }
                this.animations_.push(l),
                this.setHint(To.ANIMATING, 1),
                this.updateAnimations_()
            } else
                e && Xo(e, !0)
        }, e.prototype.getAnimating = function() {
            return this.hints_[To.ANIMATING] > 0
        }, e.prototype.getInteracting = function() {
            return this.hints_[To.INTERACTING] > 0
        }, e.prototype.cancelAnimations = function() {
            var t;
            this.setHint(To.ANIMATING, -this.hints_[To.ANIMATING]);
            for (var e = 0, n = this.animations_.length; e < n; ++e) {
                var r = this.animations_[e];
                if (r[0].callback && Xo(r[0].callback, !1), !t)
                    for (var i = 0, o = r.length; i < o; ++i) {
                        var s = r[i];
                        if (!s.complete) {
                            t = s.anchor;
                            break
                        }
                    }
            }
            this.animations_.length = 0,
            this.cancelAnchor_ = t,
            this.nextCenter_ = null,
            this.nextResolution_ = NaN,
            this.nextRotation_ = NaN
        }, e.prototype.updateAnimations_ = function() {
            if (void 0 !== this.updateAnimationKey_ && (cancelAnimationFrame(this.updateAnimationKey_), this.updateAnimationKey_ = void 0), this.getAnimating()) {
                for (var t = Date.now(), e = !1, n = this.animations_.length - 1; n >= 0; --n) {
                    for (var r = this.animations_[n], i = !0, o = 0, s = r.length; o < s; ++o) {
                        var a = r[o];
                        if (!a.complete) {
                            var u = t - a.start,
                                l = a.duration > 0 ? u / a.duration : 1;
                            l >= 1 ? (a.complete = !0, l = 1) : i = !1;
                            var h = a.easing(l);
                            if (a.sourceCenter) {
                                var c = a.sourceCenter[0],
                                    p = a.sourceCenter[1],
                                    f = a.targetCenter[0],
                                    d = a.targetCenter[1];
                                this.nextCenter_ = a.targetCenter;
                                var g = c + h * (f - c),
                                    y = p + h * (d - p);
                                this.targetCenter_ = [g, y]
                            }
                            if (a.sourceResolution && a.targetResolution) {
                                var v = 1 === h ? a.targetResolution : a.sourceResolution + h * (a.targetResolution - a.sourceResolution);
                                if (a.anchor) {
                                    var m = this.getViewportSize_(this.getRotation()),
                                        _ = this.constraints_.resolution(v, 0, m, !0);
                                    this.targetCenter_ = this.calculateCenterZoom(_, a.anchor)
                                }
                                this.nextResolution_ = a.targetResolution,
                                this.targetResolution_ = v,
                                this.applyTargetState_(!0)
                            }
                            if (void 0 !== a.sourceRotation && void 0 !== a.targetRotation) {
                                var x = 1 === h ? Ee(a.targetRotation + Math.PI, 2 * Math.PI) - Math.PI : a.sourceRotation + h * (a.targetRotation - a.sourceRotation);
                                if (a.anchor) {
                                    var E = this.constraints_.rotation(x, !0);
                                    this.targetCenter_ = this.calculateCenterRotate(E, a.anchor)
                                }
                                this.nextRotation_ = a.targetRotation,
                                this.targetRotation_ = x
                            }
                            if (this.applyTargetState_(!0), e = !0, !a.complete)
                                break
                        }
                    }
                    if (i) {
                        this.animations_[n] = null,
                        this.setHint(To.ANIMATING, -1),
                        this.nextCenter_ = null,
                        this.nextResolution_ = NaN,
                        this.nextRotation_ = NaN;
                        var w = r[0].callback;
                        w && Xo(w, !0)
                    }
                }
                this.animations_ = this.animations_.filter(Boolean),
                e && void 0 === this.updateAnimationKey_ && (this.updateAnimationKey_ = requestAnimationFrame(this.updateAnimations_.bind(this)))
            }
        }, e.prototype.calculateCenterRotate = function(t, e) {
            var n,
                r,
                i,
                o = this.getCenterInternal();
            return void 0 !== o && ($e(n = [o[0] - e[0], o[1] - e[1]], t - this.getRotation()), i = e, (r = n)[0] += +i[0], r[1] += +i[1]), n
        }, e.prototype.calculateCenterZoom = function(t, e) {
            var n,
                r = this.getCenterInternal(),
                i = this.getResolution();
            void 0 !== r && void 0 !== i && (n = [e[0] - t * (e[0] - r[0]) / i, e[1] - t * (e[1] - r[1]) / i]);
            return n
        }, e.prototype.getViewportSize_ = function(t) {
            var e = this.viewportSize_;
            if (t) {
                var n = e[0],
                    r = e[1];
                return [Math.abs(n * Math.cos(t)) + Math.abs(r * Math.sin(t)), Math.abs(n * Math.sin(t)) + Math.abs(r * Math.cos(t))]
            }
            return e
        }, e.prototype.setViewportSize = function(t) {
            this.viewportSize_ = Array.isArray(t) ? t.slice() : [100, 100],
            this.getAnimating() || this.resolveConstraints(0)
        }, e.prototype.getCenter = function() {
            var t = this.getCenterInternal();
            return t ? bn(t, this.getProjection()) : t
        }, e.prototype.getCenterInternal = function() {
            return this.get(Po.CENTER)
        }, e.prototype.getConstraints = function() {
            return this.constraints_
        }, e.prototype.getConstrainResolution = function() {
            return this.get("constrainResolution")
        }, e.prototype.getHints = function(t) {
            return void 0 !== t ? (t[0] = this.hints_[0], t[1] = this.hints_[1], t) : this.hints_.slice()
        }, e.prototype.calculateExtent = function(t) {
            return Mn(this.calculateExtentInternal(t), this.getProjection())
        }, e.prototype.calculateExtentInternal = function(t) {
            var e = t || this.getViewportSizeMinusPadding_(),
                n = this.getCenterInternal();
            J(n, 1);
            var r = this.getResolution();
            J(void 0 !== r, 2);
            var i = this.getRotation();
            return J(void 0 !== i, 3), Zt(n, r, i, e)
        }, e.prototype.getMaxResolution = function() {
            return this.maxResolution_
        }, e.prototype.getMinResolution = function() {
            return this.minResolution_
        }, e.prototype.getMaxZoom = function() {
            return this.getZoomForResolution(this.minResolution_)
        }, e.prototype.setMaxZoom = function(t) {
            this.applyOptions_(this.getUpdatedOptions_({
                maxZoom: t
            }))
        }, e.prototype.getMinZoom = function() {
            return this.getZoomForResolution(this.maxResolution_)
        }, e.prototype.setMinZoom = function(t) {
            this.applyOptions_(this.getUpdatedOptions_({
                minZoom: t
            }))
        }, e.prototype.setConstrainResolution = function(t) {
            this.applyOptions_(this.getUpdatedOptions_({
                constrainResolution: t
            }))
        }, e.prototype.getProjection = function() {
            return this.projection_
        }, e.prototype.getResolution = function() {
            return this.get(Po.RESOLUTION)
        }, e.prototype.getResolutions = function() {
            return this.resolutions_
        }, e.prototype.getResolutionForExtent = function(t, e) {
            return this.getResolutionForExtentInternal(Sn(t, this.getProjection()), e)
        }, e.prototype.getResolutionForExtentInternal = function(t, e) {
            var n = e || this.getViewportSizeMinusPadding_(),
                r = re(t) / n[0],
                i = Qt(t) / n[1];
            return Math.max(r, i)
        }, e.prototype.getResolutionForValueFunction = function(t) {
            var e = t || 2,
                n = this.getConstrainedResolution(this.maxResolution_),
                r = this.minResolution_,
                i = Math.log(n / r) / Math.log(e);
            return function(t) {
                return n / Math.pow(e, t * i)
            }
        }, e.prototype.getRotation = function() {
            return this.get(Po.ROTATION)
        }, e.prototype.getValueForResolutionFunction = function(t) {
            var e = Math.log(t || 2),
                n = this.getConstrainedResolution(this.maxResolution_),
                r = this.minResolution_,
                i = Math.log(n / r) / e;
            return function(t) {
                return Math.log(n / t) / e / i
            }
        }, e.prototype.getViewportSizeMinusPadding_ = function(t) {
            var e = this.getViewportSize_(t),
                n = this.padding_;
            return n && (e = [e[0] - n[1] - n[3], e[1] - n[0] - n[2]]), e
        }, e.prototype.getState = function() {
            var t = this.getProjection(),
                e = this.getResolution(),
                n = this.getRotation(),
                r = this.getCenterInternal(),
                i = this.padding_;
            if (i) {
                var o = this.getViewportSizeMinusPadding_();
                r = Ko(r, this.getViewportSize_(), [o[0] / 2 + i[3], o[1] / 2 + i[0]], e, n)
            }
            return {
                center: r.slice(0),
                projection: void 0 !== t ? t : null,
                resolution: e,
                nextCenter: this.nextCenter_,
                nextResolution: this.nextResolution_,
                nextRotation: this.nextRotation_,
                rotation: n,
                zoom: this.getZoom()
            }
        }, e.prototype.getZoom = function() {
            var t,
                e = this.getResolution();
            return void 0 !== e && (t = this.getZoomForResolution(e)), t
        }, e.prototype.getZoomForResolution = function(t) {
            var e,
                n,
                r = this.minZoom_ || 0;
            if (this.resolutions_) {
                var i = w(this.resolutions_, t, 1);
                r = i,
                e = this.resolutions_[i],
                n = i == this.resolutions_.length - 1 ? 2 : e / this.resolutions_[i + 1]
            } else
                e = this.maxResolution_,
                n = this.zoomFactor_;
            return r + Math.log(e / t) / Math.log(n)
        }, e.prototype.getResolutionForZoom = function(t) {
            if (this.resolutions_) {
                if (this.resolutions_.length <= 1)
                    return 0;
                var e = fe(Math.floor(t), 0, this.resolutions_.length - 2),
                    n = this.resolutions_[e] / this.resolutions_[e + 1];
                return this.resolutions_[e] / Math.pow(n, fe(t - e, 0, 1))
            }
            return this.maxResolution_ / Math.pow(this.zoomFactor_, t - this.minZoom_)
        }, e.prototype.fit = function(t, e) {
            var n;
            if (J(Array.isArray(t) || "function" == typeof t.getSimplifiedGeometry, 24), Array.isArray(t)) {
                J(!oe(t), 25);
                var r = Sn(t, this.getProjection());
                n = (0, rt.fromExtent)(r)
            } else if ("Circle" === t.getType()) {
                r = Sn(t.getExtent(), this.getProjection());
                (n = (0, rt.fromExtent)(r)).rotate(this.getRotation(), $t(r))
            } else {
                var i = wn();
                n = i ? t.clone().transform(i, this.getProjection()) : t
            }
            this.fitInternal(n, e)
        }, e.prototype.rotatedExtentForGeometry = function(t) {
            for (var e = this.getRotation(), n = Math.cos(e), r = Math.sin(-e), i = t.getFlatCoordinates(), o = t.getStride(), s = 1 / 0, a = 1 / 0, u = -1 / 0, l = -1 / 0, h = 0, c = i.length; h < c; h += o) {
                var p = i[h] * n - i[h + 1] * r,
                    f = i[h] * r + i[h + 1] * n;
                s = Math.min(s, p),
                a = Math.min(a, f),
                u = Math.max(u, p),
                l = Math.max(l, f)
            }
            return [s, a, u, l]
        }, e.prototype.fitInternal = function(t, e) {
            var n = e || {},
                r = n.size;
            r || (r = this.getViewportSizeMinusPadding_());
            var i,
                o = void 0 !== n.padding ? n.padding : [0, 0, 0, 0],
                s = void 0 !== n.nearest && n.nearest;
            i = void 0 !== n.minResolution ? n.minResolution : void 0 !== n.maxZoom ? this.getResolutionForZoom(n.maxZoom) : 0;
            var a = this.rotatedExtentForGeometry(t),
                u = this.getResolutionForExtentInternal(a, [r[0] - o[1] - o[3], r[1] - o[0] - o[2]]);
            u = isNaN(u) ? i : Math.max(u, i),
            u = this.getConstrainedResolution(u, s ? 0 : 1);
            var l = this.getRotation(),
                h = Math.sin(l),
                c = Math.cos(l),
                p = $t(a);
            p[0] += (o[1] - o[3]) / 2 * u,
            p[1] += (o[0] - o[2]) / 2 * u;
            var f = p[0] * c - p[1] * h,
                d = p[1] * c + p[0] * h,
                g = this.getConstrainedCenter([f, d], u),
                y = n.callback ? n.callback : T;
            void 0 !== n.duration ? this.animateInternal({
                resolution: u,
                center: g,
                duration: n.duration,
                easing: n.easing
            }, y) : (this.targetResolution_ = u, this.targetCenter_ = g, this.applyTargetState_(!1, !0), Xo(y, !0))
        }, e.prototype.centerOn = function(t, e, n) {
            this.centerOnInternal(Cn(t, this.getProjection()), e, n)
        }, e.prototype.centerOnInternal = function(t, e, n) {
            this.setCenterInternal(Ko(t, e, n, this.getResolution(), this.getRotation()))
        }, e.prototype.calculateCenterShift = function(t, e, n, r) {
            var i,
                o = this.padding_;
            if (o && t) {
                var s = this.getViewportSizeMinusPadding_(-n),
                    a = Ko(t, r, [s[0] / 2 + o[3], s[1] / 2 + o[0]], e, n);
                i = [t[0] - a[0], t[1] - a[1]]
            }
            return i
        }, e.prototype.isDef = function() {
            return !!this.getCenterInternal() && void 0 !== this.getResolution()
        }, e.prototype.adjustCenter = function(t) {
            var e = bn(this.targetCenter_, this.getProjection());
            this.setCenter([e[0] + t[0], e[1] + t[1]])
        }, e.prototype.adjustCenterInternal = function(t) {
            var e = this.targetCenter_;
            this.setCenterInternal([e[0] + t[0], e[1] + t[1]])
        }, e.prototype.adjustResolution = function(t, e) {
            var n = e && Cn(e, this.getProjection());
            this.adjustResolutionInternal(t, n)
        }, e.prototype.adjustResolutionInternal = function(t, e) {
            var n = this.getAnimating() || this.getInteracting(),
                r = this.getViewportSize_(this.getRotation()),
                i = this.constraints_.resolution(this.targetResolution_ * t, 0, r, n);
            e && (this.targetCenter_ = this.calculateCenterZoom(i, e)),
            this.targetResolution_ *= t,
            this.applyTargetState_()
        }, e.prototype.adjustZoom = function(t, e) {
            this.adjustResolution(Math.pow(this.zoomFactor_, -t), e)
        }, e.prototype.adjustRotation = function(t, e) {
            e && (e = Cn(e, this.getProjection())),
            this.adjustRotationInternal(t, e)
        }, e.prototype.adjustRotationInternal = function(t, e) {
            var n = this.getAnimating() || this.getInteracting(),
                r = this.constraints_.rotation(this.targetRotation_ + t, n);
            e && (this.targetCenter_ = this.calculateCenterRotate(r, e)),
            this.targetRotation_ += t,
            this.applyTargetState_()
        }, e.prototype.setCenter = function(t) {
            this.setCenterInternal(t ? Cn(t, this.getProjection()) : t)
        }, e.prototype.setCenterInternal = function(t) {
            this.targetCenter_ = t,
            this.applyTargetState_()
        }, e.prototype.setHint = function(t, e) {
            return this.hints_[t] += e, this.changed(), this.hints_[t]
        }, e.prototype.setResolution = function(t) {
            this.targetResolution_ = t,
            this.applyTargetState_()
        }, e.prototype.setRotation = function(t) {
            this.targetRotation_ = t,
            this.applyTargetState_()
        }, e.prototype.setZoom = function(t) {
            this.setResolution(this.getResolutionForZoom(t))
        }, e.prototype.applyTargetState_ = function(t, e) {
            var n = this.getAnimating() || this.getInteracting() || e,
                r = this.constraints_.rotation(this.targetRotation_, n),
                i = this.getViewportSize_(r),
                o = this.constraints_.resolution(this.targetResolution_, 0, i, n),
                s = this.constraints_.center(this.targetCenter_, o, i, n, this.calculateCenterShift(this.targetCenter_, o, r, i));
            this.get(Po.ROTATION) !== r && this.set(Po.ROTATION, r),
            this.get(Po.RESOLUTION) !== o && (this.set(Po.RESOLUTION, o), this.set("zoom", this.getZoom(), !0)),
            s && this.get(Po.CENTER) && We(this.get(Po.CENTER), s) || this.set(Po.CENTER, s),
            this.getAnimating() && !t && this.cancelAnimations(),
            this.cancelAnchor_ = void 0
        }, e.prototype.resolveConstraints = function(t, e, n) {
            var r = void 0 !== t ? t : 200,
                i = e || 0,
                o = this.constraints_.rotation(this.targetRotation_),
                s = this.getViewportSize_(o),
                a = this.constraints_.resolution(this.targetResolution_, i, s),
                u = this.constraints_.center(this.targetCenter_, a, s, !1, this.calculateCenterShift(this.targetCenter_, a, o, s));
            if (0 === r && !this.cancelAnchor_)
                return this.targetResolution_ = a, this.targetRotation_ = o, this.targetCenter_ = u, void this.applyTargetState_();
            var l = n || (0 === r ? this.cancelAnchor_ : void 0);
            this.cancelAnchor_ = void 0,
            this.getResolution() === a && this.getRotation() === o && this.getCenterInternal() && We(this.getCenterInternal(), u) || (this.getAnimating() && this.cancelAnimations(), this.animateInternal({
                rotation: o,
                center: u,
                resolution: a,
                duration: r,
                easing: Bo,
                anchor: l
            }))
        }, e.prototype.beginInteraction = function() {
            this.resolveConstraints(0),
            this.setHint(To.INTERACTING, 1)
        }, e.prototype.endInteraction = function(t, e, n) {
            var r = n && Cn(n, this.getProjection());
            this.endInteractionInternal(t, e, r)
        }, e.prototype.endInteractionInternal = function(t, e, n) {
            this.setHint(To.INTERACTING, -1),
            this.resolveConstraints(t, e, n)
        }, e.prototype.getConstrainedCenter = function(t, e) {
            var n = this.getViewportSize_(this.getRotation());
            return this.constraints_.center(t, e || this.getResolution(), n)
        }, e.prototype.getConstrainedZoom = function(t, e) {
            var n = this.getResolutionForZoom(t);
            return this.getZoomForResolution(this.getConstrainedResolution(n, e))
        }, e.prototype.getConstrainedResolution = function(t, e) {
            var n = e || 0,
                r = this.getViewportSize_(this.getRotation());
            return this.constraints_.resolution(t, n, r)
        }, e
    }(d.default);
function Xo(t, e) {
    setTimeout((function() {
        t(e)
    }), 0)
}
function Ho(t) {
    if (void 0 !== t.extent) {
        var e = void 0 === t.smoothExtentConstraint || t.smoothExtentConstraint;
        return Lo(t.extent, t.constrainOnlyCenter, e)
    }
    var n = pn(t.projection, "EPSG:3857");
    if (!0 !== t.multiWorld && n.isGlobal()) {
        var r = n.getExtent().slice();
        return r[0] = -1 / 0, r[2] = 1 / 0, Lo(r, !1, !1)
    }
    return Oo
}
function Yo(t) {
    var e,
        n,
        r,
        i = void 0 !== t.minZoom ? t.minZoom : 0,
        o = void 0 !== t.maxZoom ? t.maxZoom : 28,
        s = void 0 !== t.zoomFactor ? t.zoomFactor : 2,
        a = void 0 !== t.multiWorld && t.multiWorld,
        u = void 0 === t.smoothResolutionConstraint || t.smoothResolutionConstraint,
        l = void 0 !== t.showFullExtent && t.showFullExtent,
        h = pn(t.projection, "EPSG:3857"),
        c = h.getExtent(),
        p = t.constrainOnlyCenter,
        f = t.extent;
    if (a || f || !h.isGlobal() || (p = !1, f = c), void 0 !== t.resolutions) {
        var d = t.resolutions;
        n = d[i],
        r = void 0 !== d[o] ? d[o] : d[d.length - 1],
        e = t.constrainResolution ? Ao(d, u, !p && f, l) : Fo(n, r, u, !p && f, l)
    } else {
        var g = (c ? Math.max(re(c), Qt(c)) : 360 * lt[ct.DEGREES] / h.getMetersPerUnit()) / 256 / Math.pow(2, 0),
            y = g / Math.pow(2, 28);
        void 0 !== (n = t.maxResolution) ? i = 0 : n = g / Math.pow(s, i),
        void 0 === (r = t.minResolution) && (r = void 0 !== t.maxZoom ? void 0 !== t.maxResolution ? n / Math.pow(s, o) : g / Math.pow(s, o) : y),
        o = i + Math.floor(Math.log(n / r) / Math.log(s)),
        r = n / Math.pow(s, o - i),
        e = t.constrainResolution ? Do(s, n, r, u, !p && f, l) : Fo(n, r, u, !p && f, l)
    }
    return {
        constraint: e,
        maxResolution: n,
        minResolution: r,
        minZoom: i,
        zoomFactor: s
    }
}
function Wo(t) {
    var e,
        n,
        r,
        i;
    if (void 0 === t.enableRotation || t.enableRotation) {
        var o = t.constrainRotation;
        return void 0 === o || !0 === o ? (i = r || xe(5), function(t, e) {
            return e ? t : void 0 !== t ? Math.abs(t) <= i ? 0 : t : void 0
        }) : !1 === o ? jo : "number" == typeof o ? (e = o, n = 2 * Math.PI / e, function(t, e) {
            return e ? t : void 0 !== t ? t = Math.floor(t / n + .5) * n : void 0
        }) : jo
    }
    return ko
}
function $o(t) {
    return !(t.sourceCenter && t.targetCenter && !We(t.sourceCenter, t.targetCenter)) && (t.sourceResolution === t.targetResolution && t.sourceRotation === t.targetRotation)
}
function Ko(t, e, n, r, i) {
    var o = Math.cos(-i),
        s = Math.sin(-i),
        a = t[0] * o - t[1] * s,
        u = t[1] * o + t[0] * s;
    return [(a += (e[0] / 2 - n[0]) * r) * o - (u += (n[1] - e[1] / 2) * r) * (s = -s), u * o + a * s]
}
var Zo = Vo;
function Jo(t) {
    return t[0] > 0 && t[1] > 0
}
function Qo(t, e) {
    return Array.isArray(t) ? t : (void 0 === e ? e = [t, t] : (e[0] = t, e[1] = t), e)
}
var ts = function() {
    var t = function(e, n) {
        return t = Object.setPrototypeOf || {
            __proto__: []
        } instanceof Array && function(t, e) {
            t.__proto__ = e
        } || function(t, e) {
            for (var n in e)
                Object.prototype.hasOwnProperty.call(e, n) && (t[n] = e[n])
        }, t(e, n)
    };
    return function(e, n) {
        if ("function" != typeof n && null !== n)
            throw new TypeError("Class extends value " + String(n) + " is not a constructor or null");
        function r() {
            this.constructor = e
        }
        t(e, n),
        e.prototype = null === n ? Object.create(n) : (r.prototype = n.prototype, new r)
    }
}();
function es(t) {
    t instanceof fi.default ? t.setMapInternal(null) : t instanceof no.default && t.getLayers().forEach(es)
}
function ns(t, e) {
    if (t instanceof fi.default)
        t.setMapInternal(e);
    else if (t instanceof no.default)
        for (var n = t.getLayers().getArray(), r = 0, i = n.length; r < i; ++r)
            ns(n[r], e)
}
var rs = function(t) {
    function e(e) {
        var n = t.call(this) || this;
        n.on,
        n.once,
        n.un;
        var r = function(t) {
            var e = null;
            void 0 !== t.keyboardEventTarget && (e = "string" == typeof t.keyboardEventTarget ? document.getElementById(t.keyboardEventTarget) : t.keyboardEventTarget);
            var n,
                r,
                i,
                o = {},
                a = t.layers && "function" == typeof t.layers.getLayers ? t.layers : new (0, no.default)({
                    layers: t.layers
                });
            o[xo.LAYERGROUP] = a,
            o[xo.TARGET] = t.target,
            o[xo.VIEW] = t.view instanceof Io.default ? t.view : new (0, Io.default),
            void 0 !== t.controls && (Array.isArray(t.controls) ? n = new (0, s.default)(t.controls.slice()) : (J("function" == typeof t.controls.getArray, 47), n = t.controls));
            void 0 !== t.interactions && (Array.isArray(t.interactions) ? r = new (0, s.default)(t.interactions.slice()) : (J("function" == typeof t.interactions.getArray, 48), r = t.interactions));
            void 0 !== t.overlays ? Array.isArray(t.overlays) ? i = new (0, s.default)(t.overlays.slice()) : (J("function" == typeof t.overlays.getArray, 49), i = t.overlays) : i = new (0, s.default);
            return {
                controls: n,
                interactions: r,
                keyboardEventTarget: e,
                overlays: i,
                values: o
            }
        }(e);
        n.renderComplete_,
        n.loaded_ = !0,
        n.boundHandleBrowserEvent_ = n.handleBrowserEvent.bind(n),
        n.maxTilesLoading_ = void 0 !== e.maxTilesLoading ? e.maxTilesLoading : 16,
        n.pixelRatio_ = void 0 !== e.pixelRatio ? e.pixelRatio : yt,
        n.postRenderTimeoutHandle_,
        n.animationDelayKey_,
        n.animationDelay_ = function() {
            this.animationDelayKey_ = void 0,
            this.renderFrame_(Date.now())
        }.bind(n),
        n.coordinateToPixelTransform_ = [1, 0, 0, 1, 0, 0],
        n.pixelToCoordinateTransform_ = [1, 0, 0, 1, 0, 0],
        n.frameIndex_ = 0,
        n.frameState_ = null,
        n.previousExtent_ = null,
        n.viewPropertyListenerKey_ = null,
        n.viewChangeListenerKey_ = null,
        n.layerGroupPropertyListenerKeys_ = null,
        n.viewport_ = document.createElement("div"),
        n.viewport_.className = "ol-viewport" + ("ontouchstart" in window ? " ol-touch" : ""),
        n.viewport_.style.position = "relative",
        n.viewport_.style.overflow = "hidden",
        n.viewport_.style.width = "100%",
        n.viewport_.style.height = "100%",
        n.overlayContainer_ = document.createElement("div"),
        n.overlayContainer_.style.position = "absolute",
        n.overlayContainer_.style.zIndex = "0",
        n.overlayContainer_.style.width = "100%",
        n.overlayContainer_.style.height = "100%",
        n.overlayContainer_.style.pointerEvents = "none",
        n.overlayContainer_.className = "ol-overlaycontainer",
        n.viewport_.appendChild(n.overlayContainer_),
        n.overlayContainerStopEvent_ = document.createElement("div"),
        n.overlayContainerStopEvent_.style.position = "absolute",
        n.overlayContainerStopEvent_.style.zIndex = "0",
        n.overlayContainerStopEvent_.style.width = "100%",
        n.overlayContainerStopEvent_.style.height = "100%",
        n.overlayContainerStopEvent_.style.pointerEvents = "none",
        n.overlayContainerStopEvent_.className = "ol-overlaycontainer-stopevent",
        n.viewport_.appendChild(n.overlayContainerStopEvent_),
        n.mapBrowserEventHandler_ = null,
        n.moveTolerance_ = e.moveTolerance,
        n.keyboardEventTarget_ = r.keyboardEventTarget,
        n.targetChangeHandlerKeys_ = null,
        n.controls = r.controls || new (0, s.default),
        n.interactions = r.interactions || new (0, s.default),
        n.overlays_ = r.overlays,
        n.overlayIdIndex_ = {},
        n.renderer_ = null,
        n.postRenderFunctions_ = [],
        n.tileQueue_ = new (0, Eo.default)(n.getTilePriority.bind(n), n.handleTileChange_.bind(n)),
        n.addChangeListener(xo.LAYERGROUP, n.handleLayerGroupChanged_),
        n.addChangeListener(xo.VIEW, n.handleViewChanged_),
        n.addChangeListener(xo.SIZE, n.handleSizeChanged_),
        n.addChangeListener(xo.TARGET, n.handleTargetChanged_),
        n.setProperties(r.values);
        var i = n;
        return !e.view || e.view instanceof Io.default || e.view.then((function(t) {
            i.setView(new (0, Io.default)(t))
        })), n.controls.addEventListener(H.ADD, function(t) {
            t.element.setMap(this)
        }.bind(n)), n.controls.addEventListener(H.REMOVE, function(t) {
            t.element.setMap(null)
        }.bind(n)), n.interactions.addEventListener(H.ADD, function(t) {
            t.element.setMap(this)
        }.bind(n)), n.interactions.addEventListener(H.REMOVE, function(t) {
            t.element.setMap(null)
        }.bind(n)), n.overlays_.addEventListener(H.ADD, function(t) {
            this.addOverlayInternal_(t.element)
        }.bind(n)), n.overlays_.addEventListener(H.REMOVE, function(t) {
            var e = t.element.getId();
            void 0 !== e && delete this.overlayIdIndex_[e.toString()],
            t.element.setMap(null)
        }.bind(n)), n.controls.forEach(function(t) {
            t.setMap(this)
        }.bind(n)), n.interactions.forEach(function(t) {
            t.setMap(this)
        }.bind(n)), n.overlays_.forEach(n.addOverlayInternal_.bind(n)), n
    }
    return ts(e, t), e.prototype.createRenderer = function() {
        throw new Error("Use a map type that has a createRenderer method")
    }, e.prototype.addControl = function(t) {
        this.getControls().push(t)
    }, e.prototype.addInteraction = function(t) {
        this.getInteractions().push(t)
    }, e.prototype.addLayer = function(t) {
        this.getLayerGroup().getLayers().push(t)
    }, e.prototype.handleLayerAdd_ = function(t) {
        ns(t.layer, this)
    }, e.prototype.addOverlay = function(t) {
        this.getOverlays().push(t)
    }, e.prototype.addOverlayInternal_ = function(t) {
        var e = t.getId();
        void 0 !== e && (this.overlayIdIndex_[e.toString()] = t),
        t.setMap(this)
    }, e.prototype.disposeInternal = function() {
        this.controls.clear(),
        this.interactions.clear(),
        this.overlays_.clear(),
        this.setTarget(null),
        t.prototype.disposeInternal.call(this)
    }, e.prototype.forEachFeatureAtPixel = function(t, e, n) {
        if (this.frameState_ && this.renderer_) {
            var r = this.getCoordinateFromPixelInternal(t),
                i = void 0 !== (n = void 0 !== n ? n : {}).hitTolerance ? n.hitTolerance : 0,
                o = void 0 !== n.layerFilter ? n.layerFilter : S,
                s = !1 !== n.checkWrapped;
            return this.renderer_.forEachFeatureAtCoordinate(r, this.frameState_, i, s, e, null, o, null)
        }
    }, e.prototype.getFeaturesAtPixel = function(t, e) {
        var n = [];
        return this.forEachFeatureAtPixel(t, (function(t) {
            n.push(t)
        }), e), n
    }, e.prototype.getAllLayers = function() {
        var t = [];
        return function e(n) {
            n.forEach((function(n) {
                n instanceof no.default ? e(n.getLayers()) : t.push(n)
            }))
        }(this.getLayers()), t
    }, e.prototype.forEachLayerAtPixel = function(t, e, n) {
        if (this.frameState_ && this.renderer_) {
            var r = n || {},
                i = void 0 !== r.hitTolerance ? r.hitTolerance : 0,
                o = r.layerFilter || S;
            return this.renderer_.forEachLayerAtPixel(t, this.frameState_, i, e, o)
        }
    }, e.prototype.hasFeatureAtPixel = function(t, e) {
        if (!this.frameState_ || !this.renderer_)
            return !1;
        var n = this.getCoordinateFromPixelInternal(t),
            r = void 0 !== (e = void 0 !== e ? e : {}).layerFilter ? e.layerFilter : S,
            i = void 0 !== e.hitTolerance ? e.hitTolerance : 0,
            o = !1 !== e.checkWrapped;
        return this.renderer_.hasFeatureAtCoordinate(n, this.frameState_, i, o, r, null)
    }, e.prototype.getEventCoordinate = function(t) {
        return this.getCoordinateFromPixel(this.getEventPixel(t))
    }, e.prototype.getEventCoordinateInternal = function(t) {
        return this.getCoordinateFromPixelInternal(this.getEventPixel(t))
    }, e.prototype.getEventPixel = function(t) {
        var e = this.viewport_.getBoundingClientRect(),
            n = "changedTouches" in t ? t.changedTouches[0] : t;
        return [n.clientX - e.left, n.clientY - e.top]
    }, e.prototype.getTarget = function() {
        return this.get(xo.TARGET)
    }, e.prototype.getTargetElement = function() {
        var t = this.getTarget();
        return void 0 !== t ? "string" == typeof t ? document.getElementById(t) : t : null
    }, e.prototype.getCoordinateFromPixel = function(t) {
        return bn(this.getCoordinateFromPixelInternal(t), this.getView().getProjection())
    }, e.prototype.getCoordinateFromPixelInternal = function(t) {
        var e = this.frameState_;
        return e ? Et(e.pixelToCoordinateTransform, t.slice()) : null
    }, e.prototype.getControls = function() {
        return this.controls
    }, e.prototype.getOverlays = function() {
        return this.overlays_
    }, e.prototype.getOverlayById = function(t) {
        var e = this.overlayIdIndex_[t.toString()];
        return void 0 !== e ? e : null
    }, e.prototype.getInteractions = function() {
        return this.interactions
    }, e.prototype.getLayerGroup = function() {
        return this.get(xo.LAYERGROUP)
    }, e.prototype.setLayers = function(t) {
        var e = this.getLayerGroup();
        if (t instanceof s.default)
            e.setLayers(t);
        else {
            var n = e.getLayers();
            n.clear(),
            n.extend(t)
        }
    }, e.prototype.getLayers = function() {
        return this.getLayerGroup().getLayers()
    }, e.prototype.getLoadingOrNotReady = function() {
        for (var t = this.getLayerGroup().getLayerStatesArray(), e = 0, n = t.length; e < n; ++e) {
            var r = t[e];
            if (r.visible) {
                var i = r.layer.getRenderer();
                if (i && !i.ready)
                    return !0;
                var o = r.layer.getSource();
                if (o && o.loading)
                    return !0
            }
        }
        return !1
    }, e.prototype.getPixelFromCoordinate = function(t) {
        var e = Cn(t, this.getView().getProjection());
        return this.getPixelFromCoordinateInternal(e)
    }, e.prototype.getPixelFromCoordinateInternal = function(t) {
        var e = this.frameState_;
        return e ? Et(e.coordinateToPixelTransform, t.slice(0, 2)) : null
    }, e.prototype.getRenderer = function() {
        return this.renderer_
    }, e.prototype.getSize = function() {
        return this.get(xo.SIZE)
    }, e.prototype.getView = function() {
        return this.get(xo.VIEW)
    }, e.prototype.getViewport = function() {
        return this.viewport_
    }, e.prototype.getOverlayContainer = function() {
        return this.overlayContainer_
    }, e.prototype.getOverlayContainerStopEvent = function() {
        return this.overlayContainerStopEvent_
    }, e.prototype.getOwnerDocument = function() {
        var t = this.getTargetElement();
        return t ? t.ownerDocument : document
    }, e.prototype.getTilePriority = function(t, e, n, r) {
        return (0, Eo.getTilePriority)(this.frameState_, t, e, n, r)
    }, e.prototype.handleBrowserEvent = function(t, e) {
        var n = e || t.type,
            r = new (0, ao.default)(n, this, t);
        this.handleMapBrowserEvent(r)
    }, e.prototype.handleMapBrowserEvent = function(t) {
        if (this.frameState_) {
            var e = t.originalEvent,
                n = e.type;
            if (n === yo.POINTERDOWN || n === D.WHEEL || n === D.KEYDOWN) {
                var r = this.getOwnerDocument(),
                    i = this.viewport_.getRootNode ? this.viewport_.getRootNode() : r,
                    o = e.target;
                if (this.overlayContainerStopEvent_.contains(o) || !(i === r ? r.documentElement : i).contains(o))
                    return
            }
            if (t.frameState = this.frameState_, !1 !== this.dispatchEvent(t))
                for (var s = this.getInteractions().getArray().slice(), a = s.length - 1; a >= 0; a--) {
                    var u = s[a];
                    if (u.getMap() === this && u.getActive() && this.getTargetElement())
                        if (!u.handleEvent(t) || t.propagationStopped)
                            break
                }
        }
    }, e.prototype.handlePostRender = function() {
        var t = this.frameState_,
            e = this.tileQueue_;
        if (!e.isEmpty()) {
            var n = this.maxTilesLoading_,
                r = n;
            if (t) {
                var i = t.viewHints;
                if (i[To.ANIMATING] || i[To.INTERACTING]) {
                    var o = Date.now() - t.time > 8;
                    n = o ? 0 : 8,
                    r = o ? 0 : 2
                }
            }
            e.getTilesLoading() < n && (e.reprioritize(), e.loadMoreTiles(n, r))
        }
        t && this.renderer_ && !t.animate && (!0 === this.renderComplete_ ? (this.hasListener(mi.RENDERCOMPLETE) && this.renderer_.dispatchRenderEvent(mi.RENDERCOMPLETE, t), !1 === this.loaded_ && (this.loaded_ = !0, this.dispatchEvent(new (0, uo.default)(_o.LOADEND, this, t)))) : !0 === this.loaded_ && (this.loaded_ = !1, this.dispatchEvent(new (0, uo.default)(_o.LOADSTART, this, t))));
        for (var s = this.postRenderFunctions_, a = 0, u = s.length; a < u; ++a)
            s[a](this, t);
        s.length = 0
    }, e.prototype.handleSizeChanged_ = function() {
        this.getView() && !this.getView().getAnimating() && this.getView().resolveConstraints(0),
        this.render()
    }, e.prototype.handleTargetChanged_ = function() {
        if (this.mapBrowserEventHandler_) {
            for (var t = 0, e = this.targetChangeHandlerKeys_.length; t < e; ++t)
                j(this.targetChangeHandlerKeys_[t]);
            this.targetChangeHandlerKeys_ = null,
            this.viewport_.removeEventListener(D.CONTEXTMENU, this.boundHandleBrowserEvent_),
            this.viewport_.removeEventListener(D.WHEEL, this.boundHandleBrowserEvent_),
            this.mapBrowserEventHandler_.dispose(),
            this.mapBrowserEventHandler_ = null,
            Di(this.viewport_)
        }
        var n = this.getTargetElement();
        if (n) {
            for (var r in n.appendChild(this.viewport_), this.renderer_ || (this.renderer_ = this.createRenderer()), this.mapBrowserEventHandler_ = new (0, fo.default)(this, this.moveTolerance_), go)
                this.mapBrowserEventHandler_.addEventListener(go[r], this.handleMapBrowserEvent.bind(this));
            this.viewport_.addEventListener(D.CONTEXTMENU, this.boundHandleBrowserEvent_, !1),
            this.viewport_.addEventListener(D.WHEEL, this.boundHandleBrowserEvent_, !!_t && {
                passive: !1
            });
            var i = this.getOwnerDocument().defaultView,
                o = this.keyboardEventTarget_ ? this.keyboardEventTarget_ : n;
            this.targetChangeHandlerKeys_ = [F(o, D.KEYDOWN, this.handleBrowserEvent, this), F(o, D.KEYPRESS, this.handleBrowserEvent, this), F(i, D.RESIZE, this.updateSize, this)]
        } else
            this.renderer_ && (clearTimeout(this.postRenderTimeoutHandle_), this.postRenderTimeoutHandle_ = void 0, this.postRenderFunctions_.length = 0, this.renderer_.dispose(), this.renderer_ = null),
            this.animationDelayKey_ && (cancelAnimationFrame(this.animationDelayKey_), this.animationDelayKey_ = void 0);
        this.updateSize()
    }, e.prototype.handleTileChange_ = function() {
        this.render()
    }, e.prototype.handleViewPropertyChanged_ = function() {
        this.render()
    }, e.prototype.handleViewChanged_ = function() {
        this.viewPropertyListenerKey_ && (j(this.viewPropertyListenerKey_), this.viewPropertyListenerKey_ = null),
        this.viewChangeListenerKey_ && (j(this.viewChangeListenerKey_), this.viewChangeListenerKey_ = null);
        var t = this.getView();
        t && (this.updateViewportSize_(), this.viewPropertyListenerKey_ = F(t, y.PROPERTYCHANGE, this.handleViewPropertyChanged_, this), this.viewChangeListenerKey_ = F(t, D.CHANGE, this.handleViewPropertyChanged_, this), t.resolveConstraints(0)),
        this.render()
    }, e.prototype.handleLayerGroupChanged_ = function() {
        this.layerGroupPropertyListenerKeys_ && (this.layerGroupPropertyListenerKeys_.forEach(j), this.layerGroupPropertyListenerKeys_ = null);
        var t = this.getLayerGroup();
        t && (this.handleLayerAdd_(new (0, no.GroupEvent)("addlayer", t)), this.layerGroupPropertyListenerKeys_ = [F(t, y.PROPERTYCHANGE, this.render, this), F(t, D.CHANGE, this.render, this), F(t, "addlayer", this.handleLayerAdd_, this), F(t, "removelayer", this.handleLayerRemove_, this)]),
        this.render()
    }, e.prototype.isRendered = function() {
        return !!this.frameState_
    }, e.prototype.renderSync = function() {
        this.animationDelayKey_ && cancelAnimationFrame(this.animationDelayKey_),
        this.animationDelay_()
    }, e.prototype.redrawText = function() {
        for (var t = this.getLayerGroup().getLayerStatesArray(), e = 0, n = t.length; e < n; ++e) {
            var r = t[e].layer;
            r.hasRenderer() && r.getRenderer().handleFontsChanged()
        }
    }, e.prototype.render = function() {
        this.renderer_ && void 0 === this.animationDelayKey_ && (this.animationDelayKey_ = requestAnimationFrame(this.animationDelay_))
    }, e.prototype.removeControl = function(t) {
        return this.getControls().remove(t)
    }, e.prototype.removeInteraction = function(t) {
        return this.getInteractions().remove(t)
    }, e.prototype.removeLayer = function(t) {
        return this.getLayerGroup().getLayers().remove(t)
    }, e.prototype.handleLayerRemove_ = function(t) {
        es(t.layer)
    }, e.prototype.removeOverlay = function(t) {
        return this.getOverlays().remove(t)
    }, e.prototype.renderFrame_ = function(t) {
        var e = this,
            n = this.getSize(),
            r = this.getView(),
            i = this.frameState_,
            o = null;
        if (void 0 !== n && Jo(n) && r && r.isDef()) {
            var s = r.getHints(this.frameState_ ? this.frameState_.viewHints : void 0),
                a = r.getState();
            if (o = {
                animate: !1,
                coordinateToPixelTransform: this.coordinateToPixelTransform_,
                declutterTree: null,
                extent: Zt(a.center, a.resolution, a.rotation, n),
                index: this.frameIndex_++,
                layerIndex: 0,
                layerStatesArray: this.getLayerGroup().getLayerStatesArray(),
                pixelRatio: this.pixelRatio_,
                pixelToCoordinateTransform: this.pixelToCoordinateTransform_,
                postRenderFunctions: [],
                size: n,
                tileQueue: this.tileQueue_,
                time: t,
                usedTiles: {},
                viewState: a,
                viewHints: s,
                wantedTiles: {},
                mapId: h(this),
                renderTargets: {}
            }, a.nextCenter && a.nextResolution) {
                var u = isNaN(a.nextRotation) ? a.rotation : a.nextRotation;
                o.nextExtent = Zt(a.nextCenter, a.nextResolution, u, n)
            }
        }
        if (this.frameState_ = o, this.renderer_.renderFrame(o), o) {
            if (o.animate && this.render(), Array.prototype.push.apply(this.postRenderFunctions_, o.postRenderFunctions), i)
                (!this.previousExtent_ || !oe(this.previousExtent_) && !Bt(o.extent, this.previousExtent_)) && (this.dispatchEvent(new (0, uo.default)(_o.MOVESTART, this, i)), this.previousExtent_ = kt(this.previousExtent_));
            this.previousExtent_ && !o.viewHints[To.ANIMATING] && !o.viewHints[To.INTERACTING] && !Bt(o.extent, this.previousExtent_) && (this.dispatchEvent(new (0, uo.default)(_o.MOVEEND, this, o)), Pt(o.extent, this.previousExtent_))
        }
        this.dispatchEvent(new (0, uo.default)(_o.POSTRENDER, this, o)),
        this.renderComplete_ = this.hasListener(_o.LOADSTART) || this.hasListener(_o.LOADEND) || this.hasListener(mi.RENDERCOMPLETE) ? !this.tileQueue_.getTilesLoading() && !this.tileQueue_.getCount() && !this.getLoadingOrNotReady() : void 0,
        this.postRenderTimeoutHandle_ || (this.postRenderTimeoutHandle_ = setTimeout((function() {
            e.postRenderTimeoutHandle_ = void 0,
            e.handlePostRender()
        }), 0))
    }, e.prototype.setLayerGroup = function(t) {
        var e = this.getLayerGroup();
        e && this.handleLayerRemove_(new (0, no.GroupEvent)("removelayer", e)),
        this.set(xo.LAYERGROUP, t)
    }, e.prototype.setSize = function(t) {
        this.set(xo.SIZE, t)
    }, e.prototype.setTarget = function(t) {
        this.set(xo.TARGET, t)
    }, e.prototype.setView = function(t) {
        if (!t || t instanceof Io.default)
            this.set(xo.VIEW, t);
        else {
            this.set(xo.VIEW, new (0, Io.default));
            var e = this;
            t.then((function(t) {
                e.setView(new (0, Io.default)(t))
            }))
        }
    }, e.prototype.updateSize = function() {
        var t = this.getTargetElement(),
            e = void 0;
        if (t) {
            var n = getComputedStyle(t),
                r = t.offsetWidth - parseFloat(n.borderLeftWidth) - parseFloat(n.paddingLeft) - parseFloat(n.paddingRight) - parseFloat(n.borderRightWidth),
                i = t.offsetHeight - parseFloat(n.borderTopWidth) - parseFloat(n.paddingTop) - parseFloat(n.paddingBottom) - parseFloat(n.borderBottomWidth);
            isNaN(r) || isNaN(i) || !Jo(e = [r, i]) && (t.offsetWidth || t.offsetHeight || t.getClientRects().length) && console.warn("No map visible because the map container's width or height are 0.")
        }
        this.setSize(e),
        this.updateViewportSize_()
    }, e.prototype.updateViewportSize_ = function() {
        var t = this.getView();
        if (t) {
            var e = void 0,
                n = getComputedStyle(this.viewport_);
            n.width && n.height && (e = [parseInt(n.width, 10), parseInt(n.height, 10)]),
            t.setViewportSize(e)
        }
    }, e
}(d.default);
var is = rs,
    os = {};
t(os, "default", (() => hs), (t => hs = t));
var ss = {};
t(ss, "default", (() => us), (t => us = t));
var as = function() {
        var t = function(e, n) {
            return t = Object.setPrototypeOf || {
                __proto__: []
            } instanceof Array && function(t, e) {
                t.__proto__ = e
            } || function(t, e) {
                for (var n in e)
                    Object.prototype.hasOwnProperty.call(e, n) && (t[n] = e[n])
            }, t(e, n)
        };
        return function(e, n) {
            if ("function" != typeof n && null !== n)
                throw new TypeError("Class extends value " + String(n) + " is not a constructor or null");
            function r() {
                this.constructor = e
            }
            t(e, n),
            e.prototype = null === n ? Object.create(n) : (r.prototype = n.prototype, new r)
        }
    }(),
    us = function(t) {
        function e(e) {
            var n = t.call(this) || this,
                r = e.element;
            return !r || e.target || r.style.pointerEvents || (r.style.pointerEvents = "auto"), n.element = r || null, n.target_ = null, n.map_ = null, n.listenerKeys = [], e.render && (n.render = e.render), e.target && n.setTarget(e.target), n
        }
        return as(e, t), e.prototype.disposeInternal = function() {
            Di(this.element),
            t.prototype.disposeInternal.call(this)
        }, e.prototype.getMap = function() {
            return this.map_
        }, e.prototype.setMap = function(t) {
            this.map_ && Di(this.element);
            for (var e = 0, n = this.listenerKeys.length; e < n; ++e)
                j(this.listenerKeys[e]);
            (this.listenerKeys.length = 0, this.map_ = t, t) && ((this.target_ ? this.target_ : t.getOverlayContainerStopEvent()).appendChild(this.element), this.render !== T && this.listenerKeys.push(F(t, _o.POSTRENDER, this.render, this)), t.render())
        }, e.prototype.render = function(t) {}, e.prototype.setTarget = function(t) {
            this.target_ = "string" == typeof t ? document.getElementById(t) : t
        }, e
    }(d.default),
    ls = function() {
        var t = function(e, n) {
            return t = Object.setPrototypeOf || {
                __proto__: []
            } instanceof Array && function(t, e) {
                t.__proto__ = e
            } || function(t, e) {
                for (var n in e)
                    Object.prototype.hasOwnProperty.call(e, n) && (t[n] = e[n])
            }, t(e, n)
        };
        return function(e, n) {
            if ("function" != typeof n && null !== n)
                throw new TypeError("Class extends value " + String(n) + " is not a constructor or null");
            function r() {
                this.constructor = e
            }
            t(e, n),
            e.prototype = null === n ? Object.create(n) : (r.prototype = n.prototype, new r)
        }
    }(),
    hs = function(t) {
        function e(e) {
            var n = this,
                r = e || {};
            (n = t.call(this, {
                element: document.createElement("div"),
                render: r.render,
                target: r.target
            }) || this).ulElement_ = document.createElement("ul"),
            n.collapsed_ = void 0 === r.collapsed || r.collapsed,
            n.userCollapsed_ = n.collapsed_,
            n.overrideCollapsible_ = void 0 !== r.collapsible,
            n.collapsible_ = void 0 === r.collapsible || r.collapsible,
            n.collapsible_ || (n.collapsed_ = !1);
            var i = void 0 !== r.className ? r.className : "ol-attribution",
                o = void 0 !== r.tipLabel ? r.tipLabel : "Attributions",
                s = void 0 !== r.expandClassName ? r.expandClassName : i + "-expand",
                a = void 0 !== r.collapseLabel ? r.collapseLabel : "›",
                u = void 0 !== r.collapseClassName ? r.collapseClassName : i + "-collapse";
            "string" == typeof a ? (n.collapseLabel_ = document.createElement("span"), n.collapseLabel_.textContent = a, n.collapseLabel_.className = u) : n.collapseLabel_ = a;
            var l = void 0 !== r.label ? r.label : "i";
            "string" == typeof l ? (n.label_ = document.createElement("span"), n.label_.textContent = l, n.label_.className = s) : n.label_ = l;
            var h = n.collapsible_ && !n.collapsed_ ? n.collapseLabel_ : n.label_;
            n.toggleButton_ = document.createElement("button"),
            n.toggleButton_.setAttribute("type", "button"),
            n.toggleButton_.setAttribute("aria-expanded", String(!n.collapsed_)),
            n.toggleButton_.title = o,
            n.toggleButton_.appendChild(h),
            n.toggleButton_.addEventListener(D.CLICK, n.handleClick_.bind(n), !1);
            var c = i + " ol-unselectable ol-control" + (n.collapsed_ && n.collapsible_ ? " ol-collapsed" : "") + (n.collapsible_ ? "" : " ol-uncollapsible"),
                p = n.element;
            return p.className = c, p.appendChild(n.toggleButton_), p.appendChild(n.ulElement_), n.renderedAttributions_ = [], n.renderedVisible_ = !0, n
        }
        return ls(e, t), e.prototype.collectSourceAttributions_ = function(t) {
            for (var e = {}, n = [], r = !0, i = t.layerStatesArray, o = 0, s = i.length; o < s; ++o) {
                var a = i[o];
                if ((0, fi.inView)(a, t.viewState)) {
                    var u = a.layer.getSource();
                    if (u) {
                        var l = u.getAttributions();
                        if (l) {
                            var h = l(t);
                            if (h)
                                if (r = r && !1 !== u.getAttributionsCollapsible(), Array.isArray(h))
                                    for (var c = 0, p = h.length; c < p; ++c)
                                        h[c] in e || (n.push(h[c]), e[h[c]] = !0);
                                else
                                    h in e || (n.push(h), e[h] = !0)
                        }
                    }
                }
            }
            return this.overrideCollapsible_ || this.setCollapsible(r), n
        }, e.prototype.updateElement_ = function(t) {
            if (t) {
                var e = this.collectSourceAttributions_(t),
                    n = e.length > 0;
                if (this.renderedVisible_ != n && (this.element.style.display = n ? "" : "none", this.renderedVisible_ = n), !M(e, this.renderedAttributions_)) {
                    Fi(this.ulElement_);
                    for (var r = 0, i = e.length; r < i; ++r) {
                        var o = document.createElement("li");
                        o.innerHTML = e[r],
                        this.ulElement_.appendChild(o)
                    }
                    this.renderedAttributions_ = e
                }
            } else
                this.renderedVisible_ && (this.element.style.display = "none", this.renderedVisible_ = !1)
        }, e.prototype.handleClick_ = function(t) {
            t.preventDefault(),
            this.handleToggle_(),
            this.userCollapsed_ = this.collapsed_
        }, e.prototype.handleToggle_ = function() {
            this.element.classList.toggle("ol-collapsed"),
            this.collapsed_ ? Ai(this.collapseLabel_, this.label_) : Ai(this.label_, this.collapseLabel_),
            this.collapsed_ = !this.collapsed_,
            this.toggleButton_.setAttribute("aria-expanded", String(!this.collapsed_))
        }, e.prototype.getCollapsible = function() {
            return this.collapsible_
        }, e.prototype.setCollapsible = function(t) {
            this.collapsible_ !== t && (this.collapsible_ = t, this.element.classList.toggle("ol-uncollapsible"), this.userCollapsed_ && this.handleToggle_())
        }, e.prototype.setCollapsed = function(t) {
            this.userCollapsed_ = t,
            this.collapsible_ && this.collapsed_ !== t && this.handleToggle_()
        }, e.prototype.getCollapsed = function() {
            return this.collapsed_
        }, e.prototype.render = function(t) {
            this.updateElement_(t.frameState)
        }, e
    }(ss.default),
    cs = {};
t(cs, "default", (() => fs), (t => fs = t));
var ps = function() {
        var t = function(e, n) {
            return t = Object.setPrototypeOf || {
                __proto__: []
            } instanceof Array && function(t, e) {
                t.__proto__ = e
            } || function(t, e) {
                for (var n in e)
                    Object.prototype.hasOwnProperty.call(e, n) && (t[n] = e[n])
            }, t(e, n)
        };
        return function(e, n) {
            if ("function" != typeof n && null !== n)
                throw new TypeError("Class extends value " + String(n) + " is not a constructor or null");
            function r() {
                this.constructor = e
            }
            t(e, n),
            e.prototype = null === n ? Object.create(n) : (r.prototype = n.prototype, new r)
        }
    }(),
    fs = function(t) {
        function e(e) {
            var n = this,
                r = e || {};
            n = t.call(this, {
                element: document.createElement("div"),
                render: r.render,
                target: r.target
            }) || this;
            var i = void 0 !== r.className ? r.className : "ol-rotate",
                o = void 0 !== r.label ? r.label : "⇧",
                s = void 0 !== r.compassClassName ? r.compassClassName : "ol-compass";
            n.label_ = null,
            "string" == typeof o ? (n.label_ = document.createElement("span"), n.label_.className = s, n.label_.textContent = o) : (n.label_ = o, n.label_.classList.add(s));
            var a = r.tipLabel ? r.tipLabel : "Reset rotation",
                u = document.createElement("button");
            u.className = i + "-reset",
            u.setAttribute("type", "button"),
            u.title = a,
            u.appendChild(n.label_),
            u.addEventListener(D.CLICK, n.handleClick_.bind(n), !1);
            var l = i + " ol-unselectable ol-control",
                h = n.element;
            return h.className = l, h.appendChild(u), n.callResetNorth_ = r.resetNorth ? r.resetNorth : void 0, n.duration_ = void 0 !== r.duration ? r.duration : 250, n.autoHide_ = void 0 === r.autoHide || r.autoHide, n.rotation_ = void 0, n.autoHide_ && n.element.classList.add("ol-hidden"), n
        }
        return ps(e, t), e.prototype.handleClick_ = function(t) {
            t.preventDefault(),
            void 0 !== this.callResetNorth_ ? this.callResetNorth_() : this.resetNorth_()
        }, e.prototype.resetNorth_ = function() {
            var t = this.getMap().getView();
            if (t) {
                var e = t.getRotation();
                void 0 !== e && (this.duration_ > 0 && e % (2 * Math.PI) != 0 ? t.animate({
                    rotation: 0,
                    duration: this.duration_,
                    easing: Bo
                }) : t.setRotation(0))
            }
        }, e.prototype.render = function(t) {
            var e = t.frameState;
            if (e) {
                var n = e.viewState.rotation;
                if (n != this.rotation_) {
                    var r = "rotate(" + n + "rad)";
                    if (this.autoHide_) {
                        var i = this.element.classList.contains("ol-hidden");
                        i || 0 !== n ? i && 0 !== n && this.element.classList.remove("ol-hidden") : this.element.classList.add("ol-hidden")
                    }
                    this.label_.style.transform = r
                }
                this.rotation_ = n
            }
        }, e
    }(ss.default),
    ds = {};
t(ds, "default", (() => ys), (t => ys = t));
var gs = function() {
        var t = function(e, n) {
            return t = Object.setPrototypeOf || {
                __proto__: []
            } instanceof Array && function(t, e) {
                t.__proto__ = e
            } || function(t, e) {
                for (var n in e)
                    Object.prototype.hasOwnProperty.call(e, n) && (t[n] = e[n])
            }, t(e, n)
        };
        return function(e, n) {
            if ("function" != typeof n && null !== n)
                throw new TypeError("Class extends value " + String(n) + " is not a constructor or null");
            function r() {
                this.constructor = e
            }
            t(e, n),
            e.prototype = null === n ? Object.create(n) : (r.prototype = n.prototype, new r)
        }
    }(),
    ys = function(t) {
        function e(e) {
            var n = this,
                r = e || {};
            n = t.call(this, {
                element: document.createElement("div"),
                target: r.target
            }) || this;
            var i = void 0 !== r.className ? r.className : "ol-zoom",
                o = void 0 !== r.delta ? r.delta : 1,
                s = void 0 !== r.zoomInClassName ? r.zoomInClassName : i + "-in",
                a = void 0 !== r.zoomOutClassName ? r.zoomOutClassName : i + "-out",
                u = void 0 !== r.zoomInLabel ? r.zoomInLabel : "+",
                l = void 0 !== r.zoomOutLabel ? r.zoomOutLabel : "–",
                h = void 0 !== r.zoomInTipLabel ? r.zoomInTipLabel : "Zoom in",
                c = void 0 !== r.zoomOutTipLabel ? r.zoomOutTipLabel : "Zoom out",
                p = document.createElement("button");
            p.className = s,
            p.setAttribute("type", "button"),
            p.title = h,
            p.appendChild("string" == typeof u ? document.createTextNode(u) : u),
            p.addEventListener(D.CLICK, n.handleClick_.bind(n, o), !1);
            var f = document.createElement("button");
            f.className = a,
            f.setAttribute("type", "button"),
            f.title = c,
            f.appendChild("string" == typeof l ? document.createTextNode(l) : l),
            f.addEventListener(D.CLICK, n.handleClick_.bind(n, -o), !1);
            var d = i + " ol-unselectable ol-control",
                g = n.element;
            return g.className = d, g.appendChild(p), g.appendChild(f), n.duration_ = void 0 !== r.duration ? r.duration : 250, n
        }
        return gs(e, t), e.prototype.handleClick_ = function(t, e) {
            e.preventDefault(),
            this.zoomByDelta_(t)
        }, e.prototype.zoomByDelta_ = function(t) {
            var e = this.getMap().getView();
            if (e) {
                var n = e.getZoom();
                if (void 0 !== n) {
                    var r = e.getConstrainedZoom(n + t);
                    this.duration_ > 0 ? (e.getAnimating() && e.cancelAnimations(), e.animate({
                        zoom: r,
                        duration: this.duration_,
                        easing: Bo
                    })) : e.setZoom(r)
                }
            }
        }, e
    }(ss.default);
function vs(t) {
    var e = t || {},
        n = new (0, s.default);
    return (void 0 === e.zoom || e.zoom) && n.push(new (0, ds.default)(e.zoomOptions)), (void 0 === e.rotate || e.rotate) && n.push(new (0, cs.default)(e.rotateOptions)), (void 0 === e.attribution || e.attribution) && n.push(new (0, os.default)(e.attributionOptions)), n
}
var ms = {};
t(ms, "default", (() => Ss), (t => Ss = t));
var _s = {};
t(_s, "pan", (() => ws), (t => ws = t)),
t(_s, "zoomByDelta", (() => bs), (t => bs = t)),
t(_s, "default", (() => Cs), (t => Cs = t));
var xs = {
        ACTIVE: "active"
    },
    Es = function() {
        var t = function(e, n) {
            return t = Object.setPrototypeOf || {
                __proto__: []
            } instanceof Array && function(t, e) {
                t.__proto__ = e
            } || function(t, e) {
                for (var n in e)
                    Object.prototype.hasOwnProperty.call(e, n) && (t[n] = e[n])
            }, t(e, n)
        };
        return function(e, n) {
            if ("function" != typeof n && null !== n)
                throw new TypeError("Class extends value " + String(n) + " is not a constructor or null");
            function r() {
                this.constructor = e
            }
            t(e, n),
            e.prototype = null === n ? Object.create(n) : (r.prototype = n.prototype, new r)
        }
    }();
function ws(t, e, n) {
    var r = t.getCenterInternal();
    if (r) {
        var i = [r[0] + e[0], r[1] + e[1]];
        t.animateInternal({
            duration: void 0 !== n ? n : 250,
            easing: zo,
            center: t.getConstrainedCenter(i)
        })
    }
}
function bs(t, e, n, r) {
    var i = t.getZoom();
    if (void 0 !== i) {
        var o = t.getConstrainedZoom(i + e),
            s = t.getResolutionForZoom(o);
        t.getAnimating() && t.cancelAnimations(),
        t.animate({
            resolution: s,
            anchor: n,
            duration: void 0 !== r ? r : 250,
            easing: Bo
        })
    }
}
var Cs = function(t) {
        function e(e) {
            var n = t.call(this) || this;
            return n.on, n.once, n.un, e && e.handleEvent && (n.handleEvent = e.handleEvent), n.map_ = null, n.setActive(!0), n
        }
        return Es(e, t), e.prototype.getActive = function() {
            return this.get(xs.ACTIVE)
        }, e.prototype.getMap = function() {
            return this.map_
        }, e.prototype.handleEvent = function(t) {
            return !0
        }, e.prototype.setActive = function(t) {
            this.set(xs.ACTIVE, t)
        }, e.prototype.setMap = function(t) {
            this.map_ = t
        }, e
    }(d.default),
    Ms = function() {
        var t = function(e, n) {
            return t = Object.setPrototypeOf || {
                __proto__: []
            } instanceof Array && function(t, e) {
                t.__proto__ = e
            } || function(t, e) {
                for (var n in e)
                    Object.prototype.hasOwnProperty.call(e, n) && (t[n] = e[n])
            }, t(e, n)
        };
        return function(e, n) {
            if ("function" != typeof n && null !== n)
                throw new TypeError("Class extends value " + String(n) + " is not a constructor or null");
            function r() {
                this.constructor = e
            }
            t(e, n),
            e.prototype = null === n ? Object.create(n) : (r.prototype = n.prototype, new r)
        }
    }(),
    Ss = function(t) {
        function e(e) {
            var n = t.call(this) || this,
                r = e || {};
            return n.delta_ = r.delta ? r.delta : 1, n.duration_ = void 0 !== r.duration ? r.duration : 250, n
        }
        return Ms(e, t), e.prototype.handleEvent = function(t) {
            var e = !1;
            if (t.type == go.DBLCLICK) {
                var n = t.originalEvent,
                    r = t.map,
                    i = t.coordinate,
                    o = n.shiftKey ? -this.delta_ : this.delta_,
                    s = r.getView();
                (0, _s.zoomByDelta)(s, o, i, this.duration_),
                n.preventDefault(),
                e = !0
            }
            return !e
        }, e
    }(_s.default),
    Is = {};
t(Is, "default", (() => Xs), (t => Xs = t));
var Ts = {};
t(Ts, "centroid", (() => Ls), (t => Ls = t)),
t(Ts, "default", (() => Os), (t => Os = t));
var Ps = function() {
    var t = function(e, n) {
        return t = Object.setPrototypeOf || {
            __proto__: []
        } instanceof Array && function(t, e) {
            t.__proto__ = e
        } || function(t, e) {
            for (var n in e)
                Object.prototype.hasOwnProperty.call(e, n) && (t[n] = e[n])
        }, t(e, n)
    };
    return function(e, n) {
        if ("function" != typeof n && null !== n)
            throw new TypeError("Class extends value " + String(n) + " is not a constructor or null");
        function r() {
            this.constructor = e
        }
        t(e, n),
        e.prototype = null === n ? Object.create(n) : (r.prototype = n.prototype, new r)
    }
}();
function Ls(t) {
    for (var e = t.length, n = 0, r = 0, i = 0; i < e; i++)
        n += t[i].clientX,
        r += t[i].clientY;
    return [n / e, r / e]
}
var Os = function(t) {
    function e(e) {
        var n = this,
            r = e || {};
        return n = t.call(this, r) || this, r.handleDownEvent && (n.handleDownEvent = r.handleDownEvent), r.handleDragEvent && (n.handleDragEvent = r.handleDragEvent), r.handleMoveEvent && (n.handleMoveEvent = r.handleMoveEvent), r.handleUpEvent && (n.handleUpEvent = r.handleUpEvent), r.stopDown && (n.stopDown = r.stopDown), n.handlingDownUpSequence = !1, n.targetPointers = [], n
    }
    return Ps(e, t), e.prototype.getPointerCount = function() {
        return this.targetPointers.length
    }, e.prototype.handleDownEvent = function(t) {
        return !1
    }, e.prototype.handleDragEvent = function(t) {}, e.prototype.handleEvent = function(t) {
        if (!t.originalEvent)
            return !0;
        var e = !1;
        if (this.updateTrackedPointers_(t), this.handlingDownUpSequence) {
            if (t.type == go.POINTERDRAG)
                this.handleDragEvent(t),
                t.originalEvent.preventDefault();
            else if (t.type == go.POINTERUP) {
                var n = this.handleUpEvent(t);
                this.handlingDownUpSequence = n && this.targetPointers.length > 0
            }
        } else if (t.type == go.POINTERDOWN) {
            var r = this.handleDownEvent(t);
            this.handlingDownUpSequence = r,
            e = this.stopDown(r)
        } else
            t.type == go.POINTERMOVE && this.handleMoveEvent(t);
        return !e
    }, e.prototype.handleMoveEvent = function(t) {}, e.prototype.handleUpEvent = function(t) {
        return !1
    }, e.prototype.stopDown = function(t) {
        return t
    }, e.prototype.updateTrackedPointers_ = function(t) {
        t.activePointers && (this.targetPointers = t.activePointers)
    }, e
}(_s.default);
function Ns(t) {
    var e = arguments;
    return function(t) {
        for (var n = !0, r = 0, i = e.length; r < i && (n = n && e[r](t)); ++r)
            ;
        return n
    }
}
var Rs = function(t) {
        var e = t.originalEvent;
        return e.altKey && !(e.metaKey || e.ctrlKey) && !e.shiftKey
    },
    As = function(t) {
        var e = t.originalEvent;
        return e.altKey && !(e.metaKey || e.ctrlKey) && e.shiftKey
    },
    Ds = function(t) {
        return !t.map.getTargetElement().hasAttribute("tabindex") || function(t) {
                var e = t.map.getTargetElement(),
                    n = t.map.getOwnerDocument().activeElement;
                return e.contains(n)
            }(t)
    },
    Fs = S,
    ks = function(t) {
        var e = t.originalEvent;
        return 0 == e.button && !(dt && gt && e.ctrlKey)
    },
    js = function(t) {
        return t.type == go.SINGLECLICK
    },
    Gs = function(t) {
        var e = t.originalEvent;
        return !e.altKey && !(e.metaKey || e.ctrlKey) && !e.shiftKey
    },
    Bs = function(t) {
        var e = t.originalEvent;
        return !e.altKey && !(e.metaKey || e.ctrlKey) && e.shiftKey
    },
    qs = function(t) {
        var e = t.originalEvent,
            n = e.target.tagName;
        return "INPUT" !== n && "SELECT" !== n && "TEXTAREA" !== n && !e.target.isContentEditable
    },
    zs = function(t) {
        var e = t.originalEvent;
        return J(void 0 !== e, 56), "mouse" == e.pointerType
    },
    Us = function(t) {
        var e = t.originalEvent;
        return J(void 0 !== e, 56), e.isPrimary && 0 === e.button
    },
    Vs = function() {
        var t = function(e, n) {
            return t = Object.setPrototypeOf || {
                __proto__: []
            } instanceof Array && function(t, e) {
                t.__proto__ = e
            } || function(t, e) {
                for (var n in e)
                    Object.prototype.hasOwnProperty.call(e, n) && (t[n] = e[n])
            }, t(e, n)
        };
        return function(e, n) {
            if ("function" != typeof n && null !== n)
                throw new TypeError("Class extends value " + String(n) + " is not a constructor or null");
            function r() {
                this.constructor = e
            }
            t(e, n),
            e.prototype = null === n ? Object.create(n) : (r.prototype = n.prototype, new r)
        }
    }(),
    Xs = function(t) {
        function e(e) {
            var n = t.call(this, {
                    stopDown: I
                }) || this,
                r = e || {};
            n.kinetic_ = r.kinetic,
            n.lastCentroid = null,
            n.lastPointersCount_,
            n.panning_ = !1;
            var i = r.condition ? r.condition : Ns(Gs, Us);
            return n.condition_ = r.onFocusOnly ? Ns(Ds, i) : i, n.noKinetic_ = !1, n
        }
        return Vs(e, t), e.prototype.handleDragEvent = function(t) {
            this.panning_ || (this.panning_ = !0, this.getMap().getView().beginInteraction());
            var e,
                n,
                r = this.targetPointers,
                i = (0, Ts.centroid)(r);
            if (r.length == this.lastPointersCount_) {
                if (this.kinetic_ && this.kinetic_.update(i[0], i[1]), this.lastCentroid) {
                    var o = [this.lastCentroid[0] - i[0], i[1] - this.lastCentroid[1]],
                        s = t.map.getView();
                    e = o,
                    n = s.getResolution(),
                    e[0] *= n,
                    e[1] *= n,
                    $e(o, s.getRotation()),
                    s.adjustCenterInternal(o)
                }
            } else
                this.kinetic_ && this.kinetic_.begin();
            this.lastCentroid = i,
            this.lastPointersCount_ = r.length,
            t.originalEvent.preventDefault()
        }, e.prototype.handleUpEvent = function(t) {
            var e = t.map,
                n = e.getView();
            if (0 === this.targetPointers.length) {
                if (!this.noKinetic_ && this.kinetic_ && this.kinetic_.end()) {
                    var r = this.kinetic_.getDistance(),
                        i = this.kinetic_.getAngle(),
                        o = n.getCenterInternal(),
                        s = e.getPixelFromCoordinateInternal(o),
                        a = e.getCoordinateFromPixelInternal([s[0] - r * Math.cos(i), s[1] - r * Math.sin(i)]);
                    n.animateInternal({
                        center: n.getConstrainedCenter(a),
                        duration: 500,
                        easing: Bo
                    })
                }
                return this.panning_ && (this.panning_ = !1, n.endInteraction()), !1
            }
            return this.kinetic_ && this.kinetic_.begin(), this.lastCentroid = null, !0
        }, e.prototype.handleDownEvent = function(t) {
            if (this.targetPointers.length > 0 && this.condition_(t)) {
                var e = t.map.getView();
                return this.lastCentroid = null, e.getAnimating() && e.cancelAnimations(), this.kinetic_ && this.kinetic_.begin(), this.noKinetic_ = this.targetPointers.length > 1, !0
            }
            return !1
        }, e
    }(Ts.default),
    Hs = {};
t(Hs, "default", (() => Ws), (t => Ws = t));
var Ys = function() {
        var t = function(e, n) {
            return t = Object.setPrototypeOf || {
                __proto__: []
            } instanceof Array && function(t, e) {
                t.__proto__ = e
            } || function(t, e) {
                for (var n in e)
                    Object.prototype.hasOwnProperty.call(e, n) && (t[n] = e[n])
            }, t(e, n)
        };
        return function(e, n) {
            if ("function" != typeof n && null !== n)
                throw new TypeError("Class extends value " + String(n) + " is not a constructor or null");
            function r() {
                this.constructor = e
            }
            t(e, n),
            e.prototype = null === n ? Object.create(n) : (r.prototype = n.prototype, new r)
        }
    }(),
    Ws = function(t) {
        function e(e) {
            var n = this,
                r = e || {};
            return (n = t.call(this, {
                stopDown: I
            }) || this).condition_ = r.condition ? r.condition : As, n.lastAngle_ = void 0, n.duration_ = void 0 !== r.duration ? r.duration : 250, n
        }
        return Ys(e, t), e.prototype.handleDragEvent = function(t) {
            if (zs(t)) {
                var e = t.map,
                    n = e.getView();
                if (n.getConstraints().rotation !== ko) {
                    var r = e.getSize(),
                        i = t.pixel,
                        o = Math.atan2(r[1] / 2 - i[1], i[0] - r[0] / 2);
                    if (void 0 !== this.lastAngle_) {
                        var s = o - this.lastAngle_;
                        n.adjustRotationInternal(-s)
                    }
                    this.lastAngle_ = o
                }
            }
        }, e.prototype.handleUpEvent = function(t) {
            return !zs(t) || (t.map.getView().endInteraction(this.duration_), !1)
        }, e.prototype.handleDownEvent = function(t) {
            return !!zs(t) && (!(!ks(t) || !this.condition_(t)) && (t.map.getView().beginInteraction(), this.lastAngle_ = void 0, !0))
        }, e
    }(Ts.default),
    $s = {};
t($s, "default", (() => ua), (t => ua = t));
var Ks = {};
t(Ks, "DragBoxEvent", (() => oa), (t => oa = t)),
t(Ks, "default", (() => sa), (t => sa = t));
var Zs = {};
t(Zs, "default", (() => Qs), (t => Qs = t));
var Js = function() {
        var t = function(e, n) {
            return t = Object.setPrototypeOf || {
                __proto__: []
            } instanceof Array && function(t, e) {
                t.__proto__ = e
            } || function(t, e) {
                for (var n in e)
                    Object.prototype.hasOwnProperty.call(e, n) && (t[n] = e[n])
            }, t(e, n)
        };
        return function(e, n) {
            if ("function" != typeof n && null !== n)
                throw new TypeError("Class extends value " + String(n) + " is not a constructor or null");
            function r() {
                this.constructor = e
            }
            t(e, n),
            e.prototype = null === n ? Object.create(n) : (r.prototype = n.prototype, new r)
        }
    }(),
    Qs = function(t) {
        function e(e) {
            var n = t.call(this) || this;
            return n.geometry_ = null, n.element_ = document.createElement("div"), n.element_.style.position = "absolute", n.element_.style.pointerEvents = "auto", n.element_.className = "ol-box " + e, n.map_ = null, n.startPixel_ = null, n.endPixel_ = null, n
        }
        return Js(e, t), e.prototype.disposeInternal = function() {
            this.setMap(null)
        }, e.prototype.render_ = function() {
            var t = this.startPixel_,
                e = this.endPixel_,
                n = "px",
                r = this.element_.style;
            r.left = Math.min(t[0], e[0]) + n,
            r.top = Math.min(t[1], e[1]) + n,
            r.width = Math.abs(e[0] - t[0]) + n,
            r.height = Math.abs(e[1] - t[1]) + n
        }, e.prototype.setMap = function(t) {
            if (this.map_) {
                this.map_.getOverlayContainer().removeChild(this.element_);
                var e = this.element_.style;
                e.left = "inherit",
                e.top = "inherit",
                e.width = "inherit",
                e.height = "inherit"
            }
            this.map_ = t,
            this.map_ && this.map_.getOverlayContainer().appendChild(this.element_)
        }, e.prototype.setPixels = function(t, e) {
            this.startPixel_ = t,
            this.endPixel_ = e,
            this.createOrUpdateGeometry(),
            this.render_()
        }, e.prototype.createOrUpdateGeometry = function() {
            var t = this.startPixel_,
                e = this.endPixel_,
                n = [t, [t[0], e[1]], e, [e[0], t[1]]].map(this.map_.getCoordinateFromPixelInternal, this.map_);
            n[4] = n[0].slice(),
            this.geometry_ ? this.geometry_.setCoordinates([n]) : this.geometry_ = new (0, rt.default)([n])
        }, e.prototype.getGeometry = function() {
            return this.geometry_
        }, e
    }(_),
    ta = function() {
        var t = function(e, n) {
            return t = Object.setPrototypeOf || {
                __proto__: []
            } instanceof Array && function(t, e) {
                t.__proto__ = e
            } || function(t, e) {
                for (var n in e)
                    Object.prototype.hasOwnProperty.call(e, n) && (t[n] = e[n])
            }, t(e, n)
        };
        return function(e, n) {
            if ("function" != typeof n && null !== n)
                throw new TypeError("Class extends value " + String(n) + " is not a constructor or null");
            function r() {
                this.constructor = e
            }
            t(e, n),
            e.prototype = null === n ? Object.create(n) : (r.prototype = n.prototype, new r)
        }
    }(),
    ea = "boxstart",
    na = "boxdrag",
    ra = "boxend",
    ia = "boxcancel",
    oa = function(t) {
        function e(e, n, r) {
            var i = t.call(this, e) || this;
            return i.coordinate = n, i.mapBrowserEvent = r, i
        }
        return ta(e, t), e
    }(g),
    sa = function(t) {
        function e(e) {
            var n = t.call(this) || this;
            n.on,
            n.once,
            n.un;
            var r = e || {};
            return n.box_ = new (0, Zs.default)(r.className || "ol-dragbox"), n.minArea_ = void 0 !== r.minArea ? r.minArea : 64, r.onBoxEnd && (n.onBoxEnd = r.onBoxEnd), n.startPixel_ = null, n.condition_ = r.condition ? r.condition : ks, n.boxEndCondition_ = r.boxEndCondition ? r.boxEndCondition : n.defaultBoxEndCondition, n
        }
        return ta(e, t), e.prototype.defaultBoxEndCondition = function(t, e, n) {
            var r = n[0] - e[0],
                i = n[1] - e[1];
            return r * r + i * i >= this.minArea_
        }, e.prototype.getGeometry = function() {
            return this.box_.getGeometry()
        }, e.prototype.handleDragEvent = function(t) {
            this.box_.setPixels(this.startPixel_, t.pixel),
            this.dispatchEvent(new oa(na, t.coordinate, t))
        }, e.prototype.handleUpEvent = function(t) {
            this.box_.setMap(null);
            var e = this.boxEndCondition_(t, this.startPixel_, t.pixel);
            return e && this.onBoxEnd(t), this.dispatchEvent(new oa(e ? ra : ia, t.coordinate, t)), !1
        }, e.prototype.handleDownEvent = function(t) {
            return !!this.condition_(t) && (this.startPixel_ = t.pixel, this.box_.setMap(t.map), this.box_.setPixels(this.startPixel_, this.startPixel_), this.dispatchEvent(new oa(ea, t.coordinate, t)), !0)
        }, e.prototype.onBoxEnd = function(t) {}, e
    }(Ts.default),
    aa = function() {
        var t = function(e, n) {
            return t = Object.setPrototypeOf || {
                __proto__: []
            } instanceof Array && function(t, e) {
                t.__proto__ = e
            } || function(t, e) {
                for (var n in e)
                    Object.prototype.hasOwnProperty.call(e, n) && (t[n] = e[n])
            }, t(e, n)
        };
        return function(e, n) {
            if ("function" != typeof n && null !== n)
                throw new TypeError("Class extends value " + String(n) + " is not a constructor or null");
            function r() {
                this.constructor = e
            }
            t(e, n),
            e.prototype = null === n ? Object.create(n) : (r.prototype = n.prototype, new r)
        }
    }(),
    ua = function(t) {
        function e(e) {
            var n = this,
                r = e || {},
                i = r.condition ? r.condition : Bs;
            return (n = t.call(this, {
                condition: i,
                className: r.className || "ol-dragzoom",
                minArea: r.minArea
            }) || this).duration_ = void 0 !== r.duration ? r.duration : 200, n.out_ = void 0 !== r.out && r.out, n
        }
        return aa(e, t), e.prototype.onBoxEnd = function(t) {
            var e = this.getMap().getView(),
                n = this.getGeometry();
            if (this.out_) {
                var r = e.rotatedExtentForGeometry(n),
                    i = e.getResolutionForExtentInternal(r),
                    o = e.getResolution() / i;
                (n = n.clone()).scale(o * o)
            }
            e.fitInternal(n, {
                duration: this.duration_,
                easing: Bo
            })
        }, e
    }(Ks.default),
    la = {};
t(la, "default", (() => pa), (t => pa = t));
var ha = {
        LEFT: 37,
        UP: 38,
        RIGHT: 39,
        DOWN: 40
    },
    ca = function() {
        var t = function(e, n) {
            return t = Object.setPrototypeOf || {
                __proto__: []
            } instanceof Array && function(t, e) {
                t.__proto__ = e
            } || function(t, e) {
                for (var n in e)
                    Object.prototype.hasOwnProperty.call(e, n) && (t[n] = e[n])
            }, t(e, n)
        };
        return function(e, n) {
            if ("function" != typeof n && null !== n)
                throw new TypeError("Class extends value " + String(n) + " is not a constructor or null");
            function r() {
                this.constructor = e
            }
            t(e, n),
            e.prototype = null === n ? Object.create(n) : (r.prototype = n.prototype, new r)
        }
    }(),
    pa = function(t) {
        function e(e) {
            var n = t.call(this) || this,
                r = e || {};
            return n.defaultCondition_ = function(t) {
                return Gs(t) && qs(t)
            }, n.condition_ = void 0 !== r.condition ? r.condition : n.defaultCondition_, n.duration_ = void 0 !== r.duration ? r.duration : 100, n.pixelDelta_ = void 0 !== r.pixelDelta ? r.pixelDelta : 128, n
        }
        return ca(e, t), e.prototype.handleEvent = function(t) {
            var e = !1;
            if (t.type == D.KEYDOWN) {
                var n = t.originalEvent,
                    r = n.keyCode;
                if (this.condition_(t) && (r == ha.DOWN || r == ha.LEFT || r == ha.RIGHT || r == ha.UP)) {
                    var i = t.map.getView(),
                        o = i.getResolution() * this.pixelDelta_,
                        s = 0,
                        a = 0;
                    r == ha.DOWN ? a = -o : r == ha.LEFT ? s = -o : r == ha.RIGHT ? s = o : a = o;
                    var u = [s, a];
                    $e(u, i.getRotation()),
                    (0, _s.pan)(i, u, this.duration_),
                    n.preventDefault(),
                    e = !0
                }
            }
            return !e
        }, e
    }(_s.default),
    fa = {};
t(fa, "default", (() => ga), (t => ga = t));
var da = function() {
        var t = function(e, n) {
            return t = Object.setPrototypeOf || {
                __proto__: []
            } instanceof Array && function(t, e) {
                t.__proto__ = e
            } || function(t, e) {
                for (var n in e)
                    Object.prototype.hasOwnProperty.call(e, n) && (t[n] = e[n])
            }, t(e, n)
        };
        return function(e, n) {
            if ("function" != typeof n && null !== n)
                throw new TypeError("Class extends value " + String(n) + " is not a constructor or null");
            function r() {
                this.constructor = e
            }
            t(e, n),
            e.prototype = null === n ? Object.create(n) : (r.prototype = n.prototype, new r)
        }
    }(),
    ga = function(t) {
        function e(e) {
            var n = t.call(this) || this,
                r = e || {};
            return n.condition_ = r.condition ? r.condition : qs, n.delta_ = r.delta ? r.delta : 1, n.duration_ = void 0 !== r.duration ? r.duration : 100, n
        }
        return da(e, t), e.prototype.handleEvent = function(t) {
            var e = !1;
            if (t.type == D.KEYDOWN || t.type == D.KEYPRESS) {
                var n = t.originalEvent,
                    r = n.charCode;
                if (this.condition_(t) && (r == "+".charCodeAt(0) || r == "-".charCodeAt(0))) {
                    var i = t.map,
                        o = r == "+".charCodeAt(0) ? this.delta_ : -this.delta_,
                        s = i.getView();
                    (0, _s.zoomByDelta)(s, o, void 0, this.duration_),
                    n.preventDefault(),
                    e = !0
                }
            }
            return !e
        }, e
    }(_s.default),
    ya = function() {
        function t(t, e, n) {
            this.decay_ = t,
            this.minVelocity_ = e,
            this.delay_ = n,
            this.points_ = [],
            this.angle_ = 0,
            this.initialVelocity_ = 0
        }
        return t.prototype.begin = function() {
            this.points_.length = 0,
            this.angle_ = 0,
            this.initialVelocity_ = 0
        }, t.prototype.update = function(t, e) {
            this.points_.push(t, e, Date.now())
        }, t.prototype.end = function() {
            if (this.points_.length < 6)
                return !1;
            var t = Date.now() - this.delay_,
                e = this.points_.length - 3;
            if (this.points_[e + 2] < t)
                return !1;
            for (var n = e - 3; n > 0 && this.points_[n + 2] > t;)
                n -= 3;
            var r = this.points_[e + 2] - this.points_[n + 2];
            if (r < 1e3 / 60)
                return !1;
            var i = this.points_[e] - this.points_[n],
                o = this.points_[e + 1] - this.points_[n + 1];
            return this.angle_ = Math.atan2(o, i), this.initialVelocity_ = Math.sqrt(i * i + o * o) / r, this.initialVelocity_ > this.minVelocity_
        }, t.prototype.getDistance = function() {
            return (this.minVelocity_ - this.initialVelocity_) / this.decay_
        }, t.prototype.getAngle = function() {
            return this.angle_
        }, t
    }(),
    va = {};
t(va, "Mode", (() => _a), (t => _a = t)),
t(va, "default", (() => xa), (t => xa = t));
var ma = function() {
        var t = function(e, n) {
            return t = Object.setPrototypeOf || {
                __proto__: []
            } instanceof Array && function(t, e) {
                t.__proto__ = e
            } || function(t, e) {
                for (var n in e)
                    Object.prototype.hasOwnProperty.call(e, n) && (t[n] = e[n])
            }, t(e, n)
        };
        return function(e, n) {
            if ("function" != typeof n && null !== n)
                throw new TypeError("Class extends value " + String(n) + " is not a constructor or null");
            function r() {
                this.constructor = e
            }
            t(e, n),
            e.prototype = null === n ? Object.create(n) : (r.prototype = n.prototype, new r)
        }
    }(),
    _a = {
        TRACKPAD: "trackpad",
        WHEEL: "wheel"
    },
    xa = function(t) {
        function e(e) {
            var n = this,
                r = e || {};
            (n = t.call(this, r) || this).totalDelta_ = 0,
            n.lastDelta_ = 0,
            n.maxDelta_ = void 0 !== r.maxDelta ? r.maxDelta : 1,
            n.duration_ = void 0 !== r.duration ? r.duration : 250,
            n.timeout_ = void 0 !== r.timeout ? r.timeout : 80,
            n.useAnchor_ = void 0 === r.useAnchor || r.useAnchor,
            n.constrainResolution_ = void 0 !== r.constrainResolution && r.constrainResolution;
            var i = r.condition ? r.condition : Fs;
            return n.condition_ = r.onFocusOnly ? Ns(Ds, i) : i, n.lastAnchor_ = null, n.startTime_ = void 0, n.timeoutId_, n.mode_ = void 0, n.trackpadEventGap_ = 400, n.trackpadTimeoutId_, n.deltaPerZoom_ = 300, n
        }
        return ma(e, t), e.prototype.endInteraction_ = function() {
            this.trackpadTimeoutId_ = void 0;
            var t = this.getMap();
            t && t.getView().endInteraction(void 0, this.lastDelta_ ? this.lastDelta_ > 0 ? 1 : -1 : 0, this.lastAnchor_)
        }, e.prototype.handleEvent = function(t) {
            if (!this.condition_(t))
                return !0;
            if (t.type !== D.WHEEL)
                return !0;
            var e,
                n = t.map,
                r = t.originalEvent;
            if (r.preventDefault(), this.useAnchor_ && (this.lastAnchor_ = t.coordinate), t.type == D.WHEEL && (e = r.deltaY, ft && r.deltaMode === WheelEvent.DOM_DELTA_PIXEL && (e /= yt), r.deltaMode === WheelEvent.DOM_DELTA_LINE && (e *= 40)), 0 === e)
                return !1;
            this.lastDelta_ = e;
            var i = Date.now();
            void 0 === this.startTime_ && (this.startTime_ = i),
            (!this.mode_ || i - this.startTime_ > this.trackpadEventGap_) && (this.mode_ = Math.abs(e) < 4 ? _a.TRACKPAD : _a.WHEEL);
            var o = n.getView();
            if (this.mode_ === _a.TRACKPAD && !o.getConstrainResolution() && !this.constrainResolution_)
                return this.trackpadTimeoutId_ ? clearTimeout(this.trackpadTimeoutId_) : (o.getAnimating() && o.cancelAnimations(), o.beginInteraction()), this.trackpadTimeoutId_ = setTimeout(this.endInteraction_.bind(this), this.timeout_), o.adjustZoom(-e / this.deltaPerZoom_, this.lastAnchor_), this.startTime_ = i, !1;
            this.totalDelta_ += e;
            var s = Math.max(this.timeout_ - (i - this.startTime_), 0);
            return clearTimeout(this.timeoutId_), this.timeoutId_ = setTimeout(this.handleWheelZoom_.bind(this, n), s), !1
        }, e.prototype.handleWheelZoom_ = function(t) {
            var e = t.getView();
            e.getAnimating() && e.cancelAnimations();
            var n = -fe(this.totalDelta_, -this.maxDelta_ * this.deltaPerZoom_, this.maxDelta_ * this.deltaPerZoom_) / this.deltaPerZoom_;
            (e.getConstrainResolution() || this.constrainResolution_) && (n = n ? n > 0 ? 1 : -1 : 0),
            (0, _s.zoomByDelta)(e, n, this.lastAnchor_, this.duration_),
            this.mode_ = void 0,
            this.totalDelta_ = 0,
            this.lastAnchor_ = null,
            this.startTime_ = void 0,
            this.timeoutId_ = void 0
        }, e.prototype.setMouseAnchor = function(t) {
            this.useAnchor_ = t,
            t || (this.lastAnchor_ = null)
        }, e
    }(_s.default),
    Ea = {};
t(Ea, "default", (() => ba), (t => ba = t));
var wa = function() {
        var t = function(e, n) {
            return t = Object.setPrototypeOf || {
                __proto__: []
            } instanceof Array && function(t, e) {
                t.__proto__ = e
            } || function(t, e) {
                for (var n in e)
                    Object.prototype.hasOwnProperty.call(e, n) && (t[n] = e[n])
            }, t(e, n)
        };
        return function(e, n) {
            if ("function" != typeof n && null !== n)
                throw new TypeError("Class extends value " + String(n) + " is not a constructor or null");
            function r() {
                this.constructor = e
            }
            t(e, n),
            e.prototype = null === n ? Object.create(n) : (r.prototype = n.prototype, new r)
        }
    }(),
    ba = function(t) {
        function e(e) {
            var n = this,
                r = e || {},
                i = r;
            return i.stopDown || (i.stopDown = I), (n = t.call(this, i) || this).anchor_ = null, n.lastAngle_ = void 0, n.rotating_ = !1, n.rotationDelta_ = 0, n.threshold_ = void 0 !== r.threshold ? r.threshold : .3, n.duration_ = void 0 !== r.duration ? r.duration : 250, n
        }
        return wa(e, t), e.prototype.handleDragEvent = function(t) {
            var e = 0,
                n = this.targetPointers[0],
                r = this.targetPointers[1],
                i = Math.atan2(r.clientY - n.clientY, r.clientX - n.clientX);
            if (void 0 !== this.lastAngle_) {
                var o = i - this.lastAngle_;
                this.rotationDelta_ += o,
                !this.rotating_ && Math.abs(this.rotationDelta_) > this.threshold_ && (this.rotating_ = !0),
                e = o
            }
            this.lastAngle_ = i;
            var s = t.map,
                a = s.getView();
            if (a.getConstraints().rotation !== ko) {
                var u = s.getViewport().getBoundingClientRect(),
                    l = (0, Ts.centroid)(this.targetPointers);
                l[0] -= u.left,
                l[1] -= u.top,
                this.anchor_ = s.getCoordinateFromPixelInternal(l),
                this.rotating_ && (s.render(), a.adjustRotationInternal(e, this.anchor_))
            }
        }, e.prototype.handleUpEvent = function(t) {
            return !(this.targetPointers.length < 2) || (t.map.getView().endInteraction(this.duration_), !1)
        }, e.prototype.handleDownEvent = function(t) {
            if (this.targetPointers.length >= 2) {
                var e = t.map;
                return this.anchor_ = null, this.lastAngle_ = void 0, this.rotating_ = !1, this.rotationDelta_ = 0, this.handlingDownUpSequence || e.getView().beginInteraction(), !0
            }
            return !1
        }, e
    }(Ts.default),
    Ca = {};
t(Ca, "default", (() => Sa), (t => Sa = t));
var Ma = function() {
        var t = function(e, n) {
            return t = Object.setPrototypeOf || {
                __proto__: []
            } instanceof Array && function(t, e) {
                t.__proto__ = e
            } || function(t, e) {
                for (var n in e)
                    Object.prototype.hasOwnProperty.call(e, n) && (t[n] = e[n])
            }, t(e, n)
        };
        return function(e, n) {
            if ("function" != typeof n && null !== n)
                throw new TypeError("Class extends value " + String(n) + " is not a constructor or null");
            function r() {
                this.constructor = e
            }
            t(e, n),
            e.prototype = null === n ? Object.create(n) : (r.prototype = n.prototype, new r)
        }
    }(),
    Sa = function(t) {
        function e(e) {
            var n = this,
                r = e || {},
                i = r;
            return i.stopDown || (i.stopDown = I), (n = t.call(this, i) || this).anchor_ = null, n.duration_ = void 0 !== r.duration ? r.duration : 400, n.lastDistance_ = void 0, n.lastScaleDelta_ = 1, n
        }
        return Ma(e, t), e.prototype.handleDragEvent = function(t) {
            var e = 1,
                n = this.targetPointers[0],
                r = this.targetPointers[1],
                i = n.clientX - r.clientX,
                o = n.clientY - r.clientY,
                s = Math.sqrt(i * i + o * o);
            void 0 !== this.lastDistance_ && (e = this.lastDistance_ / s),
            this.lastDistance_ = s;
            var a = t.map,
                u = a.getView();
            1 != e && (this.lastScaleDelta_ = e);
            var l = a.getViewport().getBoundingClientRect(),
                h = (0, Ts.centroid)(this.targetPointers);
            h[0] -= l.left,
            h[1] -= l.top,
            this.anchor_ = a.getCoordinateFromPixelInternal(h),
            a.render(),
            u.adjustResolutionInternal(e, this.anchor_)
        }, e.prototype.handleUpEvent = function(t) {
            if (this.targetPointers.length < 2) {
                var e = t.map.getView(),
                    n = this.lastScaleDelta_ > 1 ? 1 : -1;
                return e.endInteraction(this.duration_, n), !1
            }
            return !0
        }, e.prototype.handleDownEvent = function(t) {
            if (this.targetPointers.length >= 2) {
                var e = t.map;
                return this.anchor_ = null, this.lastDistance_ = void 0, this.lastScaleDelta_ = 1, this.handlingDownUpSequence || e.getView().beginInteraction(), !0
            }
            return !1
        }, e
    }(Ts.default),
    Ia = {};
t(Ia, "DrawEvent", (() => Eh), (t => Eh = t)),
t(Ia, "createRegularPolygon", (() => wh), (t => wh = t)),
t(Ia, "createBox", (() => bh), (t => bh = t)),
t(Ia, "default", (() => Ch), (t => Ch = t));
var Ta = {};
t(Ta, "default", (() => Oa), (t => Oa = t));
var Pa = function() {
        var t = function(e, n) {
            return t = Object.setPrototypeOf || {
                __proto__: []
            } instanceof Array && function(t, e) {
                t.__proto__ = e
            } || function(t, e) {
                for (var n in e)
                    Object.prototype.hasOwnProperty.call(e, n) && (t[n] = e[n])
            }, t(e, n)
        };
        return function(e, n) {
            if ("function" != typeof n && null !== n)
                throw new TypeError("Class extends value " + String(n) + " is not a constructor or null");
            function r() {
                this.constructor = e
            }
            t(e, n),
            e.prototype = null === n ? Object.create(n) : (r.prototype = n.prototype, new r)
        }
    }(),
    La = function(t) {
        function e(e, n, r) {
            var i = t.call(this) || this;
            if (void 0 !== r && void 0 === n)
                i.setFlatCoordinates(r, e);
            else {
                var o = n || 0;
                i.setCenterAndRadius(e, o, r)
            }
            return i
        }
        return Pa(e, t), e.prototype.clone = function() {
            var t = new e(this.flatCoordinates.slice(), void 0, this.layout);
            return t.applyProperties(this), t
        }, e.prototype.closestPointXY = function(t, e, n, r) {
            var i = this.flatCoordinates,
                o = t - i[0],
                s = e - i[1],
                a = o * o + s * s;
            if (a < r) {
                if (0 === a)
                    for (var u = 0; u < this.stride; ++u)
                        n[u] = i[u];
                else {
                    var l = this.getRadius() / Math.sqrt(a);
                    n[0] = i[0] + l * o,
                    n[1] = i[1] + l * s;
                    for (u = 2; u < this.stride; ++u)
                        n[u] = i[u]
                }
                return n.length = this.stride, a
            }
            return r
        }, e.prototype.containsXY = function(t, e) {
            var n = this.flatCoordinates,
                r = t - n[0],
                i = e - n[1];
            return r * r + i * i <= this.getRadiusSquared_()
        }, e.prototype.getCenter = function() {
            return this.flatCoordinates.slice(0, this.stride)
        }, e.prototype.computeExtent = function(t) {
            var e = this.flatCoordinates,
                n = e[this.stride] - e[0];
            return Ft(e[0] - n, e[1] - n, e[0] + n, e[1] + n, t)
        }, e.prototype.getRadius = function() {
            return Math.sqrt(this.getRadiusSquared_())
        }, e.prototype.getRadiusSquared_ = function() {
            var t = this.flatCoordinates[this.stride] - this.flatCoordinates[0],
                e = this.flatCoordinates[this.stride + 1] - this.flatCoordinates[1];
            return t * t + e * e
        }, e.prototype.getType = function() {
            return "Circle"
        }, e.prototype.intersectsExtent = function(t) {
            if (ie(t, this.getExtent())) {
                var e = this.getCenter();
                return t[0] <= e[0] && t[2] >= e[0] || (t[1] <= e[1] && t[3] >= e[1] || Xt(t, this.intersectsCoordinate.bind(this)))
            }
            return !1
        }, e.prototype.setCenter = function(t) {
            var e = this.stride,
                n = this.flatCoordinates[e] - this.flatCoordinates[0],
                r = t.slice();
            r[e] = r[0] + n;
            for (var i = 1; i < e; ++i)
                r[e + i] = t[i];
            this.setFlatCoordinates(this.layout, r),
            this.changed()
        }, e.prototype.setCenterAndRadius = function(t, e, n) {
            this.setLayout(n, t, 0),
            this.flatCoordinates || (this.flatCoordinates = []);
            var r = this.flatCoordinates,
                i = Hn(r, 0, t, this.stride);
            r[i++] = r[0] + e;
            for (var o = 1, s = this.stride; o < s; ++o)
                r[i++] = r[o];
            r.length = i,
            this.changed()
        }, e.prototype.getCoordinates = function() {
            return null
        }, e.prototype.setCoordinates = function(t, e) {}, e.prototype.setRadius = function(t) {
            this.flatCoordinates[this.stride] = this.flatCoordinates[0] + t,
            this.changed()
        }, e.prototype.rotate = function(t, e) {
            var n = this.getCenter(),
                r = this.getStride();
            this.setCenter(Pn(n, 0, n.length, r, t, e, n)),
            this.changed()
        }, e.prototype.translate = function(t, e) {
            var n = this.getCenter(),
                r = this.getStride();
            this.setCenter(On(n, 0, n.length, r, t, e, n)),
            this.changed()
        }, e
    }(st.default);
La.prototype.transform;
var Oa = La,
    Na = {};
function Ra(t, e, n, r, i, o, s) {
    var a,
        u,
        l = (n - e) / r;
    if (1 === l)
        a = e;
    else if (2 === l)
        a = e,
        u = i;
    else if (0 !== l) {
        for (var h = t[e], c = t[e + 1], p = 0, f = [0], d = e + r; d < n; d += r) {
            var g = t[d],
                y = t[d + 1];
            p += Math.sqrt((g - h) * (g - h) + (y - c) * (y - c)),
            f.push(p),
            h = g,
            c = y
        }
        var v = i * p,
            m = x(f, v);
        m < 0 ? (u = (v - f[-m - 2]) / (f[-m - 1] - f[-m - 2]), a = e + (-m - 2) * r) : a = e + m * r
    }
    var _ = s > 1 ? s : 2,
        E = o || new Array(_);
    for (d = 0; d < _; ++d)
        E[d] = void 0 === a ? NaN : void 0 === u ? t[a + d] : we(t[a + d], t[a + r + d], u);
    return E
}
function Aa(t, e, n, r, i, o) {
    if (n == e)
        return null;
    var s;
    if (i < t[e + r - 1])
        return o ? ((s = t.slice(e, e + r))[r - 1] = i, s) : null;
    if (t[n - 1] < i)
        return o ? ((s = t.slice(n - r, n))[r - 1] = i, s) : null;
    if (i == t[e + r - 1])
        return t.slice(e, e + r);
    for (var a = e / r, u = n / r; a < u;) {
        var l = a + u >> 1;
        i < t[(l + 1) * r - 1] ? u = l : a = l + 1
    }
    var h = t[a * r - 1];
    if (i == h)
        return t.slice((a - 1) * r, (a - 1) * r + r);
    var c = (i - h) / (t[(a + 1) * r - 1] - h);
    s = [];
    for (var p = 0; p < r - 1; ++p)
        s.push(we(t[(a - 1) * r + p], t[a * r + p], c));
    return s.push(i), s
}
function Da(t, e, n, r, i, o, s) {
    if (s)
        return Aa(t, e, n[n.length - 1], r, i, o);
    var a;
    if (i < t[r - 1])
        return o ? ((a = t.slice(0, r))[r - 1] = i, a) : null;
    if (t[t.length - 1] < i)
        return o ? ((a = t.slice(t.length - r))[r - 1] = i, a) : null;
    for (var u = 0, l = n.length; u < l; ++u) {
        var h = n[u];
        if (e != h) {
            if (i < t[e + r - 1])
                return null;
            if (i <= t[h - 1])
                return Aa(t, e, h, r, i, !1);
            e = h
        }
    }
    return null
}
function Fa(t, e, n, r) {
    for (var i = t[e], o = t[e + 1], s = 0, a = e + r; a < n; a += r) {
        var u = t[a],
            l = t[a + 1];
        s += Math.sqrt((u - i) * (u - i) + (l - o) * (l - o)),
        i = u,
        o = l
    }
    return s
}
t(Na, "default", (() => Ga), (t => Ga = t));
var ka = function() {
        var t = function(e, n) {
            return t = Object.setPrototypeOf || {
                __proto__: []
            } instanceof Array && function(t, e) {
                t.__proto__ = e
            } || function(t, e) {
                for (var n in e)
                    Object.prototype.hasOwnProperty.call(e, n) && (t[n] = e[n])
            }, t(e, n)
        };
        return function(e, n) {
            if ("function" != typeof n && null !== n)
                throw new TypeError("Class extends value " + String(n) + " is not a constructor or null");
            function r() {
                this.constructor = e
            }
            t(e, n),
            e.prototype = null === n ? Object.create(n) : (r.prototype = n.prototype, new r)
        }
    }(),
    ja = function(t) {
        function e(e, n) {
            var r = t.call(this) || this;
            return r.flatMidpoint_ = null, r.flatMidpointRevision_ = -1, r.maxDelta_ = -1, r.maxDeltaRevision_ = -1, void 0 === n || Array.isArray(e[0]) ? r.setCoordinates(e, n) : r.setFlatCoordinates(n, e), r
        }
        return ka(e, t), e.prototype.appendCoordinate = function(t) {
            this.flatCoordinates ? C(this.flatCoordinates, t) : this.flatCoordinates = t.slice(),
            this.changed()
        }, e.prototype.clone = function() {
            var t = new e(this.flatCoordinates.slice(), this.layout);
            return t.applyProperties(this), t
        }, e.prototype.closestPointXY = function(t, e, n, r) {
            return r < Lt(this.getExtent(), t, e) ? r : (this.maxDeltaRevision_ != this.getRevision() && (this.maxDelta_ = Math.sqrt(Bn(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, 0)), this.maxDeltaRevision_ = this.getRevision()), Un(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, this.maxDelta_, !1, t, e, n, r))
        }, e.prototype.forEachSegment = function(t) {
            return _r(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, t)
        }, e.prototype.getCoordinateAtM = function(t, e) {
            if (this.layout != it.XYM && this.layout != it.XYZM)
                return null;
            var n = void 0 !== e && e;
            return Aa(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, t, n)
        }, e.prototype.getCoordinates = function() {
            return nr(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride)
        }, e.prototype.getCoordinateAt = function(t, e) {
            return Ra(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, t, e, this.stride)
        }, e.prototype.getLength = function() {
            return Fa(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride)
        }, e.prototype.getFlatMidpoint = function() {
            return this.flatMidpointRevision_ != this.getRevision() && (this.flatMidpoint_ = this.getCoordinateAt(.5, this.flatMidpoint_), this.flatMidpointRevision_ = this.getRevision()), this.flatMidpoint_
        }, e.prototype.getSimplifiedGeometryInternal = function(t) {
            var n = [];
            return n.length = Kn(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, t, n, 0), new e(n, it.XY)
        }, e.prototype.getType = function() {
            return "LineString"
        }, e.prototype.intersectsExtent = function(t) {
            return xr(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, t)
        }, e.prototype.setCoordinates = function(t, e) {
            this.setLayout(e, t, 1),
            this.flatCoordinates || (this.flatCoordinates = []),
            this.flatCoordinates.length = Yn(this.flatCoordinates, 0, t, this.stride),
            this.changed()
        }, e
    }(st.default),
    Ga = ja,
    Ba = {};
t(Ba, "default", (() => za), (t => za = t));
var qa = function() {
        var t = function(e, n) {
            return t = Object.setPrototypeOf || {
                __proto__: []
            } instanceof Array && function(t, e) {
                t.__proto__ = e
            } || function(t, e) {
                for (var n in e)
                    Object.prototype.hasOwnProperty.call(e, n) && (t[n] = e[n])
            }, t(e, n)
        };
        return function(e, n) {
            if ("function" != typeof n && null !== n)
                throw new TypeError("Class extends value " + String(n) + " is not a constructor or null");
            function r() {
                this.constructor = e
            }
            t(e, n),
            e.prototype = null === n ? Object.create(n) : (r.prototype = n.prototype, new r)
        }
    }(),
    za = function(t) {
        function e(e, n, r) {
            var i = t.call(this) || this;
            if (i.ends_ = [], i.maxDelta_ = -1, i.maxDeltaRevision_ = -1, Array.isArray(e[0]))
                i.setCoordinates(e, n);
            else if (void 0 !== n && r)
                i.setFlatCoordinates(n, e),
                i.ends_ = r;
            else {
                for (var o = i.getLayout(), s = e, a = [], u = [], l = 0, h = s.length; l < h; ++l) {
                    var c = s[l];
                    0 === l && (o = c.getLayout()),
                    C(a, c.getFlatCoordinates()),
                    u.push(a.length)
                }
                i.setFlatCoordinates(o, a),
                i.ends_ = u
            }
            return i
        }
        return qa(e, t), e.prototype.appendLineString = function(t) {
            this.flatCoordinates ? C(this.flatCoordinates, t.getFlatCoordinates().slice()) : this.flatCoordinates = t.getFlatCoordinates().slice(),
            this.ends_.push(this.flatCoordinates.length),
            this.changed()
        }, e.prototype.clone = function() {
            var t = new e(this.flatCoordinates.slice(), this.layout, this.ends_.slice());
            return t.applyProperties(this), t
        }, e.prototype.closestPointXY = function(t, e, n, r) {
            return r < Lt(this.getExtent(), t, e) ? r : (this.maxDeltaRevision_ != this.getRevision() && (this.maxDelta_ = Math.sqrt(qn(this.flatCoordinates, 0, this.ends_, this.stride, 0)), this.maxDeltaRevision_ = this.getRevision()), Vn(this.flatCoordinates, 0, this.ends_, this.stride, this.maxDelta_, !1, t, e, n, r))
        }, e.prototype.getCoordinateAtM = function(t, e, n) {
            if (this.layout != it.XYM && this.layout != it.XYZM || 0 === this.flatCoordinates.length)
                return null;
            var r = void 0 !== e && e,
                i = void 0 !== n && n;
            return Da(this.flatCoordinates, 0, this.ends_, this.stride, t, r, i)
        }, e.prototype.getCoordinates = function() {
            return rr(this.flatCoordinates, 0, this.ends_, this.stride)
        }, e.prototype.getEnds = function() {
            return this.ends_
        }, e.prototype.getLineString = function(t) {
            return t < 0 || this.ends_.length <= t ? null : new (0, Na.default)(this.flatCoordinates.slice(0 === t ? 0 : this.ends_[t - 1], this.ends_[t]), this.layout)
        }, e.prototype.getLineStrings = function() {
            for (var t = this.flatCoordinates, e = this.ends_, n = this.layout, r = [], i = 0, o = 0, s = e.length; o < s; ++o) {
                var a = e[o],
                    u = new (0, Na.default)(t.slice(i, a), n);
                r.push(u),
                i = a
            }
            return r
        }, e.prototype.getFlatMidpoints = function() {
            for (var t = [], e = this.flatCoordinates, n = 0, r = this.ends_, i = this.stride, o = 0, s = r.length; o < s; ++o) {
                var a = r[o];
                C(t, Ra(e, n, a, i, .5)),
                n = a
            }
            return t
        }, e.prototype.getSimplifiedGeometryInternal = function(t) {
            var n = [],
                r = [];
            return n.length = Zn(this.flatCoordinates, 0, this.ends_, this.stride, t, n, 0, r), new e(n, it.XY, r)
        }, e.prototype.getType = function() {
            return "MultiLineString"
        }, e.prototype.intersectsExtent = function(t) {
            return Er(this.flatCoordinates, 0, this.ends_, this.stride, t)
        }, e.prototype.setCoordinates = function(t, e) {
            this.setLayout(e, t, 2),
            this.flatCoordinates || (this.flatCoordinates = []);
            var n = Wn(this.flatCoordinates, 0, t, this.stride, this.ends_);
            this.flatCoordinates.length = 0 === n.length ? 0 : n[n.length - 1],
            this.changed()
        }, e
    }(st.default),
    Ua = {};
t(Ua, "default", (() => Xa), (t => Xa = t));
var Va = function() {
        var t = function(e, n) {
            return t = Object.setPrototypeOf || {
                __proto__: []
            } instanceof Array && function(t, e) {
                t.__proto__ = e
            } || function(t, e) {
                for (var n in e)
                    Object.prototype.hasOwnProperty.call(e, n) && (t[n] = e[n])
            }, t(e, n)
        };
        return function(e, n) {
            if ("function" != typeof n && null !== n)
                throw new TypeError("Class extends value " + String(n) + " is not a constructor or null");
            function r() {
                this.constructor = e
            }
            t(e, n),
            e.prototype = null === n ? Object.create(n) : (r.prototype = n.prototype, new r)
        }
    }(),
    Xa = function(t) {
        function e(e, n) {
            var r = t.call(this) || this;
            return n && !Array.isArray(e[0]) ? r.setFlatCoordinates(n, e) : r.setCoordinates(e, n), r
        }
        return Va(e, t), e.prototype.appendPoint = function(t) {
            this.flatCoordinates ? C(this.flatCoordinates, t.getFlatCoordinates()) : this.flatCoordinates = t.getFlatCoordinates().slice(),
            this.changed()
        }, e.prototype.clone = function() {
            var t = new e(this.flatCoordinates.slice(), this.layout);
            return t.applyProperties(this), t
        }, e.prototype.closestPointXY = function(t, e, n, r) {
            if (r < Lt(this.getExtent(), t, e))
                return r;
            for (var i = this.flatCoordinates, o = this.stride, s = 0, a = i.length; s < a; s += o) {
                var u = ve(t, e, i[s], i[s + 1]);
                if (u < r) {
                    r = u;
                    for (var l = 0; l < o; ++l)
                        n[l] = i[s + l];
                    n.length = o
                }
            }
            return r
        }, e.prototype.getCoordinates = function() {
            return nr(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride)
        }, e.prototype.getPoint = function(t) {
            var e = this.flatCoordinates ? this.flatCoordinates.length / this.stride : 0;
            return t < 0 || e <= t ? null : new (0, hr.default)(this.flatCoordinates.slice(t * this.stride, (t + 1) * this.stride), this.layout)
        }, e.prototype.getPoints = function() {
            for (var t = this.flatCoordinates, e = this.layout, n = this.stride, r = [], i = 0, o = t.length; i < o; i += n) {
                var s = new (0, hr.default)(t.slice(i, i + n), e);
                r.push(s)
            }
            return r
        }, e.prototype.getType = function() {
            return "MultiPoint"
        }, e.prototype.intersectsExtent = function(t) {
            for (var e = this.flatCoordinates, n = this.stride, r = 0, i = e.length; r < i; r += n) {
                if (Rt(t, e[r], e[r + 1]))
                    return !0
            }
            return !1
        }, e.prototype.setCoordinates = function(t, e) {
            this.setLayout(e, t, 1),
            this.flatCoordinates || (this.flatCoordinates = []),
            this.flatCoordinates.length = Yn(this.flatCoordinates, 0, t, this.stride),
            this.changed()
        }, e
    }(st.default),
    Ha = {};
function Ya(t, e, n, r) {
    for (var i = [], o = [1 / 0, 1 / 0, -1 / 0, -1 / 0], s = 0, a = n.length; s < a; ++s) {
        var u = n[s];
        o = Gt(t, e, u[0], r),
        i.push((o[0] + o[2]) / 2, (o[1] + o[3]) / 2),
        e = u[u.length - 1]
    }
    return i
}
t(Ha, "default", (() => $a), (t => $a = t));
var Wa = function() {
        var t = function(e, n) {
            return t = Object.setPrototypeOf || {
                __proto__: []
            } instanceof Array && function(t, e) {
                t.__proto__ = e
            } || function(t, e) {
                for (var n in e)
                    Object.prototype.hasOwnProperty.call(e, n) && (t[n] = e[n])
            }, t(e, n)
        };
        return function(e, n) {
            if ("function" != typeof n && null !== n)
                throw new TypeError("Class extends value " + String(n) + " is not a constructor or null");
            function r() {
                this.constructor = e
            }
            t(e, n),
            e.prototype = null === n ? Object.create(n) : (r.prototype = n.prototype, new r)
        }
    }(),
    $a = function(t) {
        function e(e, n, r) {
            var i = t.call(this) || this;
            if (i.endss_ = [], i.flatInteriorPointsRevision_ = -1, i.flatInteriorPoints_ = null, i.maxDelta_ = -1, i.maxDeltaRevision_ = -1, i.orientedRevision_ = -1, i.orientedFlatCoordinates_ = null, !r && !Array.isArray(e[0])) {
                for (var o = i.getLayout(), s = e, a = [], u = [], l = 0, h = s.length; l < h; ++l) {
                    var c = s[l];
                    0 === l && (o = c.getLayout());
                    for (var p = a.length, f = c.getEnds(), d = 0, g = f.length; d < g; ++d)
                        f[d] += p;
                    C(a, c.getFlatCoordinates()),
                    u.push(f)
                }
                n = o,
                e = a,
                r = u
            }
            return void 0 !== n && r ? (i.setFlatCoordinates(n, e), i.endss_ = r) : i.setCoordinates(e, n), i
        }
        return Wa(e, t), e.prototype.appendPolygon = function(t) {
            var e;
            if (this.flatCoordinates) {
                var n = this.flatCoordinates.length;
                C(this.flatCoordinates, t.getFlatCoordinates());
                for (var r = 0, i = (e = t.getEnds().slice()).length; r < i; ++r)
                    e[r] += n
            } else
                this.flatCoordinates = t.getFlatCoordinates().slice(),
                e = t.getEnds().slice(),
                this.endss_.push();
            this.endss_.push(e),
            this.changed()
        }, e.prototype.clone = function() {
            for (var t = this.endss_.length, n = new Array(t), r = 0; r < t; ++r)
                n[r] = this.endss_[r].slice();
            var i = new e(this.flatCoordinates.slice(), this.layout, n);
            return i.applyProperties(this), i
        }, e.prototype.closestPointXY = function(t, e, n, r) {
            return r < Lt(this.getExtent(), t, e) ? r : (this.maxDeltaRevision_ != this.getRevision() && (this.maxDelta_ = Math.sqrt(zn(this.flatCoordinates, 0, this.endss_, this.stride, 0)), this.maxDeltaRevision_ = this.getRevision()), Xn(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride, this.maxDelta_, !0, t, e, n, r))
        }, e.prototype.containsXY = function(t, e) {
            return yr(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride, t, e)
        }, e.prototype.getArea = function() {
            return ar(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride)
        }, e.prototype.getCoordinates = function(t) {
            var e;
            return void 0 !== t ? Lr(e = this.getOrientedFlatCoordinates().slice(), 0, this.endss_, this.stride, t) : e = this.flatCoordinates, ir(e, 0, this.endss_, this.stride)
        }, e.prototype.getEndss = function() {
            return this.endss_
        }, e.prototype.getFlatInteriorPoints = function() {
            if (this.flatInteriorPointsRevision_ != this.getRevision()) {
                var t = Ya(this.flatCoordinates, 0, this.endss_, this.stride);
                this.flatInteriorPoints_ = mr(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride, t),
                this.flatInteriorPointsRevision_ = this.getRevision()
            }
            return this.flatInteriorPoints_
        }, e.prototype.getInteriorPoints = function() {
            return new (0, Ua.default)(this.getFlatInteriorPoints().slice(), it.XYM)
        }, e.prototype.getOrientedFlatCoordinates = function() {
            if (this.orientedRevision_ != this.getRevision()) {
                var t = this.flatCoordinates;
                Tr(t, 0, this.endss_, this.stride) ? this.orientedFlatCoordinates_ = t : (this.orientedFlatCoordinates_ = t.slice(), this.orientedFlatCoordinates_.length = Lr(this.orientedFlatCoordinates_, 0, this.endss_, this.stride)),
                this.orientedRevision_ = this.getRevision()
            }
            return this.orientedFlatCoordinates_
        }, e.prototype.getSimplifiedGeometryInternal = function(t) {
            var n = [],
                r = [];
            return n.length = er(this.flatCoordinates, 0, this.endss_, this.stride, Math.sqrt(t), n, 0, r), new e(n, it.XY, r)
        }, e.prototype.getPolygon = function(t) {
            if (t < 0 || this.endss_.length <= t)
                return null;
            var e;
            if (0 === t)
                e = 0;
            else {
                var n = this.endss_[t - 1];
                e = n[n.length - 1]
            }
            var r = this.endss_[t].slice(),
                i = r[r.length - 1];
            if (0 !== e)
                for (var o = 0, s = r.length; o < s; ++o)
                    r[o] -= e;
            return new (0, rt.default)(this.flatCoordinates.slice(e, i), this.layout, r)
        }, e.prototype.getPolygons = function() {
            for (var t = this.layout, e = this.flatCoordinates, n = this.endss_, r = [], i = 0, o = 0, s = n.length; o < s; ++o) {
                var a = n[o].slice(),
                    u = a[a.length - 1];
                if (0 !== i)
                    for (var l = 0, h = a.length; l < h; ++l)
                        a[l] -= i;
                var c = new (0, rt.default)(e.slice(i, u), t, a);
                r.push(c),
                i = u
            }
            return r
        }, e.prototype.getType = function() {
            return "MultiPolygon"
        }, e.prototype.intersectsExtent = function(t) {
            return Cr(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride, t)
        }, e.prototype.setCoordinates = function(t, e) {
            this.setLayout(e, t, 3),
            this.flatCoordinates || (this.flatCoordinates = []);
            var n = $n(this.flatCoordinates, 0, t, this.stride, this.endss_);
            if (0 === n.length)
                this.flatCoordinates.length = 0;
            else {
                var r = n[n.length - 1];
                this.flatCoordinates.length = 0 === r.length ? 0 : r[r.length - 1]
            }
            this.changed()
        }, e
    }(st.default),
    Ka = {};
t(Ka, "default", (() => Zl), (t => Zl = t));
var Za = {};
t(Za, "default", (() => _u), (t => _u = t));
var Ja = o("20GDs"),
    Qa = {};
t(Qa, "default", (() => au), (t => au = t));
var tu = {};
t(tu, "default", (() => ou), (t => ou = t));
var eu = {
        IDLE: 0,
        LOADING: 1,
        LOADED: 2,
        ERROR: 3,
        EMPTY: 4
    },
    nu = function() {
        function t(t) {
            this.opacity_ = t.opacity,
            this.rotateWithView_ = t.rotateWithView,
            this.rotation_ = t.rotation,
            this.scale_ = t.scale,
            this.scaleArray_ = Qo(t.scale),
            this.displacement_ = t.displacement,
            this.declutterMode_ = t.declutterMode
        }
        return t.prototype.clone = function() {
            var e = this.getScale();
            return new t({
                opacity: this.getOpacity(),
                scale: Array.isArray(e) ? e.slice() : e,
                rotation: this.getRotation(),
                rotateWithView: this.getRotateWithView(),
                displacement: this.getDisplacement().slice(),
                declutterMode: this.getDeclutterMode()
            })
        }, t.prototype.getOpacity = function() {
            return this.opacity_
        }, t.prototype.getRotateWithView = function() {
            return this.rotateWithView_
        }, t.prototype.getRotation = function() {
            return this.rotation_
        }, t.prototype.getScale = function() {
            return this.scale_
        }, t.prototype.getScaleArray = function() {
            return this.scaleArray_
        }, t.prototype.getDisplacement = function() {
            return this.displacement_
        }, t.prototype.getDeclutterMode = function() {
            return this.declutterMode_
        }, t.prototype.getAnchor = function() {
            return u()
        }, t.prototype.getImage = function(t) {
            return u()
        }, t.prototype.getHitDetectionImage = function() {
            return u()
        }, t.prototype.getPixelRatio = function(t) {
            return 1
        }, t.prototype.getImageState = function() {
            return u()
        }, t.prototype.getImageSize = function() {
            return u()
        }, t.prototype.getOrigin = function() {
            return u()
        }, t.prototype.getSize = function() {
            return u()
        }, t.prototype.setDisplacement = function(t) {
            this.displacement_ = t
        }, t.prototype.setOpacity = function(t) {
            this.opacity_ = t
        }, t.prototype.setRotateWithView = function(t) {
            this.rotateWithView_ = t
        }, t.prototype.setRotation = function(t) {
            this.rotation_ = t
        }, t.prototype.setScale = function(t) {
            this.scale_ = t,
            this.scaleArray_ = Qo(t)
        }, t.prototype.listenImageChange = function(t) {
            u()
        }, t.prototype.load = function() {
            u()
        }, t.prototype.unlistenImageChange = function(t) {
            u()
        }, t
    }();
function ru(t) {
    return Array.isArray(t) ? li(t) : t
}
var iu = function() {
        var t = function(e, n) {
            return t = Object.setPrototypeOf || {
                __proto__: []
            } instanceof Array && function(t, e) {
                t.__proto__ = e
            } || function(t, e) {
                for (var n in e)
                    Object.prototype.hasOwnProperty.call(e, n) && (t[n] = e[n])
            }, t(e, n)
        };
        return function(e, n) {
            if ("function" != typeof n && null !== n)
                throw new TypeError("Class extends value " + String(n) + " is not a constructor or null");
            function r() {
                this.constructor = e
            }
            t(e, n),
            e.prototype = null === n ? Object.create(n) : (r.prototype = n.prototype, new r)
        }
    }(),
    ou = function(t) {
        function e(e) {
            var n = this,
                r = void 0 !== e.rotateWithView && e.rotateWithView;
            return (n = t.call(this, {
                opacity: 1,
                rotateWithView: r,
                rotation: void 0 !== e.rotation ? e.rotation : 0,
                scale: void 0 !== e.scale ? e.scale : 1,
                displacement: void 0 !== e.displacement ? e.displacement : [0, 0],
                declutterMode: e.declutterMode
            }) || this).canvas_ = void 0, n.hitDetectionCanvas_ = null, n.fill_ = void 0 !== e.fill ? e.fill : null, n.origin_ = [0, 0], n.points_ = e.points, n.radius_ = void 0 !== e.radius ? e.radius : e.radius1, n.radius2_ = e.radius2, n.angle_ = void 0 !== e.angle ? e.angle : 0, n.stroke_ = void 0 !== e.stroke ? e.stroke : null, n.size_ = null, n.renderOptions_ = null, n.render(), n
        }
        return iu(e, t), e.prototype.clone = function() {
            var t = this.getScale(),
                n = new e({
                    fill: this.getFill() ? this.getFill().clone() : void 0,
                    points: this.getPoints(),
                    radius: this.getRadius(),
                    radius2: this.getRadius2(),
                    angle: this.getAngle(),
                    stroke: this.getStroke() ? this.getStroke().clone() : void 0,
                    rotation: this.getRotation(),
                    rotateWithView: this.getRotateWithView(),
                    scale: Array.isArray(t) ? t.slice() : t,
                    displacement: this.getDisplacement().slice(),
                    declutterMode: this.getDeclutterMode()
                });
            return n.setOpacity(this.getOpacity()), n
        }, e.prototype.getAnchor = function() {
            var t = this.size_;
            if (!t)
                return null;
            var e = this.getDisplacement();
            return [t[0] / 2 - e[0], t[1] / 2 + e[1]]
        }, e.prototype.getAngle = function() {
            return this.angle_
        }, e.prototype.getFill = function() {
            return this.fill_
        }, e.prototype.setFill = function(t) {
            this.fill_ = t,
            this.render()
        }, e.prototype.getHitDetectionImage = function() {
            return this.hitDetectionCanvas_ || this.createHitDetectionCanvas_(this.renderOptions_), this.hitDetectionCanvas_
        }, e.prototype.getImage = function(t) {
            var e = this.canvas_[t];
            if (!e) {
                var n = this.renderOptions_,
                    r = Ni(n.size * t, n.size * t);
                this.draw_(n, r, t),
                e = r.canvas,
                this.canvas_[t] = e
            }
            return e
        }, e.prototype.getPixelRatio = function(t) {
            return t
        }, e.prototype.getImageSize = function() {
            return this.size_
        }, e.prototype.getImageState = function() {
            return eu.LOADED
        }, e.prototype.getOrigin = function() {
            return this.origin_
        }, e.prototype.getPoints = function() {
            return this.points_
        }, e.prototype.getRadius = function() {
            return this.radius_
        }, e.prototype.getRadius2 = function() {
            return this.radius2_
        }, e.prototype.getSize = function() {
            return this.size_
        }, e.prototype.getStroke = function() {
            return this.stroke_
        }, e.prototype.setStroke = function(t) {
            this.stroke_ = t,
            this.render()
        }, e.prototype.listenImageChange = function(t) {}, e.prototype.load = function() {}, e.prototype.unlistenImageChange = function(t) {}, e.prototype.calculateLineJoinSize_ = function(t, e, n) {
            if (0 === e || this.points_ === 1 / 0 || "bevel" !== t && "miter" !== t)
                return e;
            var r = this.radius_,
                i = void 0 === this.radius2_ ? r : this.radius2_;
            if (r < i) {
                var o = r;
                r = i,
                i = o
            }
            var s = void 0 === this.radius2_ ? this.points_ : 2 * this.points_,
                a = 2 * Math.PI / s,
                u = i * Math.sin(a),
                l = r - Math.sqrt(i * i - u * u),
                h = Math.sqrt(u * u + l * l),
                c = h / u;
            if ("miter" === t && c <= n)
                return c * e;
            var p = e / 2 / c,
                f = e / 2 * (l / h),
                d = Math.sqrt((r + p) * (r + p) + f * f) - r;
            if (void 0 === this.radius2_ || "bevel" === t)
                return 2 * d;
            var g = r * Math.sin(a),
                y = i - Math.sqrt(r * r - g * g),
                v = Math.sqrt(g * g + y * y) / g;
            if (v <= n) {
                var m = v * e / 2 - i - r;
                return 2 * Math.max(d, m)
            }
            return 2 * d
        }, e.prototype.createRenderOptions = function() {
            var t,
                e = "round",
                n = 0,
                r = null,
                i = 0,
                o = 0;
            this.stroke_ && (null === (t = this.stroke_.getColor()) && (t = "#000"), t = ru(t), void 0 === (o = this.stroke_.getWidth()) && (o = 1), r = this.stroke_.getLineDash(), i = this.stroke_.getLineDashOffset(), void 0 === (e = this.stroke_.getLineJoin()) && (e = "round"), void 0 === (n = this.stroke_.getMiterLimit()) && (n = 10));
            var s = this.calculateLineJoinSize_(e, o, n),
                a = Math.max(this.radius_, this.radius2_ || 0);
            return {
                strokeStyle: t,
                strokeWidth: o,
                size: Math.ceil(2 * a + s),
                lineDash: r,
                lineDashOffset: i,
                lineJoin: e,
                miterLimit: n
            }
        }, e.prototype.render = function() {
            this.renderOptions_ = this.createRenderOptions();
            var t = this.renderOptions_.size;
            this.canvas_ = {},
            this.size_ = [t, t]
        }, e.prototype.draw_ = function(t, e, n) {
            if (e.scale(n, n), e.translate(t.size / 2, t.size / 2), this.createPath_(e), this.fill_) {
                var r = this.fill_.getColor();
                null === r && (r = "#000"),
                e.fillStyle = ru(r),
                e.fill()
            }
            this.stroke_ && (e.strokeStyle = t.strokeStyle, e.lineWidth = t.strokeWidth, e.setLineDash && t.lineDash && (e.setLineDash(t.lineDash), e.lineDashOffset = t.lineDashOffset), e.lineJoin = t.lineJoin, e.miterLimit = t.miterLimit, e.stroke())
        }, e.prototype.createHitDetectionCanvas_ = function(t) {
            if (this.fill_) {
                var e = this.fill_.getColor(),
                    n = 0;
                if ("string" == typeof e && (e = ai(e)), null === e ? n = 1 : Array.isArray(e) && (n = 4 === e.length ? e[3] : 1), 0 === n) {
                    var r = Ni(t.size, t.size);
                    this.hitDetectionCanvas_ = r.canvas,
                    this.drawHitDetectionCanvas_(t, r)
                }
            }
            this.hitDetectionCanvas_ || (this.hitDetectionCanvas_ = this.getImage(1))
        }, e.prototype.createPath_ = function(t) {
            var e = this.points_,
                n = this.radius_;
            if (e === 1 / 0)
                t.arc(0, 0, n, 0, 2 * Math.PI);
            else {
                var r = void 0 === this.radius2_ ? n : this.radius2_;
                void 0 !== this.radius2_ && (e *= 2);
                for (var i = this.angle_ - Math.PI / 2, o = 2 * Math.PI / e, s = 0; s < e; s++) {
                    var a = i + s * o,
                        u = s % 2 == 0 ? n : r;
                    t.lineTo(u * Math.cos(a), u * Math.sin(a))
                }
                t.closePath()
            }
        }, e.prototype.drawHitDetectionCanvas_ = function(t, e) {
            e.translate(t.size / 2, t.size / 2),
            this.createPath_(e),
            e.fillStyle = "#000",
            e.fill(),
            this.stroke_ && (e.strokeStyle = t.strokeStyle, e.lineWidth = t.strokeWidth, t.lineDash && (e.setLineDash(t.lineDash), e.lineDashOffset = t.lineDashOffset), e.lineJoin = t.lineJoin, e.miterLimit = t.miterLimit, e.stroke())
        }, e
    }(nu),
    su = function() {
        var t = function(e, n) {
            return t = Object.setPrototypeOf || {
                __proto__: []
            } instanceof Array && function(t, e) {
                t.__proto__ = e
            } || function(t, e) {
                for (var n in e)
                    Object.prototype.hasOwnProperty.call(e, n) && (t[n] = e[n])
            }, t(e, n)
        };
        return function(e, n) {
            if ("function" != typeof n && null !== n)
                throw new TypeError("Class extends value " + String(n) + " is not a constructor or null");
            function r() {
                this.constructor = e
            }
            t(e, n),
            e.prototype = null === n ? Object.create(n) : (r.prototype = n.prototype, new r)
        }
    }(),
    au = function(t) {
        function e(e) {
            var n = e || {};
            return t.call(this, {
                    points: 1 / 0,
                    fill: n.fill,
                    radius: n.radius,
                    stroke: n.stroke,
                    scale: void 0 !== n.scale ? n.scale : 1,
                    rotation: void 0 !== n.rotation ? n.rotation : 0,
                    rotateWithView: void 0 !== n.rotateWithView && n.rotateWithView,
                    displacement: void 0 !== n.displacement ? n.displacement : [0, 0],
                    declutterMode: n.declutterMode
                }) || this
        }
        return su(e, t), e.prototype.clone = function() {
            var t = this.getScale(),
                n = new e({
                    fill: this.getFill() ? this.getFill().clone() : void 0,
                    stroke: this.getStroke() ? this.getStroke().clone() : void 0,
                    radius: this.getRadius(),
                    scale: Array.isArray(t) ? t.slice() : t,
                    rotation: this.getRotation(),
                    rotateWithView: this.getRotateWithView(),
                    displacement: this.getDisplacement().slice(),
                    declutterMode: this.getDeclutterMode()
                });
            return n.setOpacity(this.getOpacity()), n
        }, e.prototype.setRadius = function(t) {
            this.radius_ = t,
            this.render()
        }, e
    }(tu.default),
    uu = function() {
        function t(t) {
            var e = t || {};
            this.color_ = void 0 !== e.color ? e.color : null
        }
        return t.prototype.clone = function() {
            var e = this.getColor();
            return new t({
                color: Array.isArray(e) ? e.slice() : e || void 0
            })
        }, t.prototype.getColor = function() {
            return this.color_
        }, t.prototype.setColor = function(t) {
            this.color_ = t
        }, t
    }(),
    lu = function() {
        function t(t) {
            var e = t || {};
            this.color_ = void 0 !== e.color ? e.color : null,
            this.lineCap_ = e.lineCap,
            this.lineDash_ = void 0 !== e.lineDash ? e.lineDash : null,
            this.lineDashOffset_ = e.lineDashOffset,
            this.lineJoin_ = e.lineJoin,
            this.miterLimit_ = e.miterLimit,
            this.width_ = e.width
        }
        return t.prototype.clone = function() {
            var e = this.getColor();
            return new t({
                color: Array.isArray(e) ? e.slice() : e || void 0,
                lineCap: this.getLineCap(),
                lineDash: this.getLineDash() ? this.getLineDash().slice() : void 0,
                lineDashOffset: this.getLineDashOffset(),
                lineJoin: this.getLineJoin(),
                miterLimit: this.getMiterLimit(),
                width: this.getWidth()
            })
        }, t.prototype.getColor = function() {
            return this.color_
        }, t.prototype.getLineCap = function() {
            return this.lineCap_
        }, t.prototype.getLineDash = function() {
            return this.lineDash_
        }, t.prototype.getLineDashOffset = function() {
            return this.lineDashOffset_
        }, t.prototype.getLineJoin = function() {
            return this.lineJoin_
        }, t.prototype.getMiterLimit = function() {
            return this.miterLimit_
        }, t.prototype.getWidth = function() {
            return this.width_
        }, t.prototype.setColor = function(t) {
            this.color_ = t
        }, t.prototype.setLineCap = function(t) {
            this.lineCap_ = t
        }, t.prototype.setLineDash = function(t) {
            this.lineDash_ = t
        }, t.prototype.setLineDashOffset = function(t) {
            this.lineDashOffset_ = t
        }, t.prototype.setLineJoin = function(t) {
            this.lineJoin_ = t
        }, t.prototype.setMiterLimit = function(t) {
            this.miterLimit_ = t
        }, t.prototype.setWidth = function(t) {
            this.width_ = t
        }, t
    }(),
    hu = function() {
        function t(t) {
            var e = t || {};
            this.geometry_ = null,
            this.geometryFunction_ = gu,
            void 0 !== e.geometry && this.setGeometry(e.geometry),
            this.fill_ = void 0 !== e.fill ? e.fill : null,
            this.image_ = void 0 !== e.image ? e.image : null,
            this.renderer_ = void 0 !== e.renderer ? e.renderer : null,
            this.hitDetectionRenderer_ = void 0 !== e.hitDetectionRenderer ? e.hitDetectionRenderer : null,
            this.stroke_ = void 0 !== e.stroke ? e.stroke : null,
            this.text_ = void 0 !== e.text ? e.text : null,
            this.zIndex_ = e.zIndex
        }
        return t.prototype.clone = function() {
            var e = this.getGeometry();
            return e && "object" == typeof e && (e = e.clone()), new t({
                geometry: e,
                fill: this.getFill() ? this.getFill().clone() : void 0,
                image: this.getImage() ? this.getImage().clone() : void 0,
                renderer: this.getRenderer(),
                stroke: this.getStroke() ? this.getStroke().clone() : void 0,
                text: this.getText() ? this.getText().clone() : void 0,
                zIndex: this.getZIndex()
            })
        }, t.prototype.getRenderer = function() {
            return this.renderer_
        }, t.prototype.setRenderer = function(t) {
            this.renderer_ = t
        }, t.prototype.setHitDetectionRenderer = function(t) {
            this.hitDetectionRenderer_ = t
        }, t.prototype.getHitDetectionRenderer = function() {
            return this.hitDetectionRenderer_
        }, t.prototype.getGeometry = function() {
            return this.geometry_
        }, t.prototype.getGeometryFunction = function() {
            return this.geometryFunction_
        }, t.prototype.getFill = function() {
            return this.fill_
        }, t.prototype.setFill = function(t) {
            this.fill_ = t
        }, t.prototype.getImage = function() {
            return this.image_
        }, t.prototype.setImage = function(t) {
            this.image_ = t
        }, t.prototype.getStroke = function() {
            return this.stroke_
        }, t.prototype.setStroke = function(t) {
            this.stroke_ = t
        }, t.prototype.getText = function() {
            return this.text_
        }, t.prototype.setText = function(t) {
            this.text_ = t
        }, t.prototype.getZIndex = function() {
            return this.zIndex_
        }, t.prototype.setGeometry = function(t) {
            "function" == typeof t ? this.geometryFunction_ = t : "string" == typeof t ? this.geometryFunction_ = function(e) {
                return e.get(t)
            } : t ? void 0 !== t && (this.geometryFunction_ = function() {
                return t
            }) : this.geometryFunction_ = gu,
            this.geometry_ = t
        }, t.prototype.setZIndex = function(t) {
            this.zIndex_ = t
        }, t
    }();
function cu(t) {
    var e;
    if ("function" == typeof t)
        e = t;
    else {
        var n;
        if (Array.isArray(t))
            n = t;
        else
            J("function" == typeof t.getZIndex, 41),
            n = [t];
        e = function() {
            return n
        }
    }
    return e
}
var pu = null;
function fu(t, e) {
    if (!pu) {
        var n = new uu({
                color: "rgba(255,255,255,0.4)"
            }),
            r = new lu({
                color: "#3399CC",
                width: 1.25
            });
        pu = [new hu({
            image: new (0, Qa.default)({
                fill: n,
                stroke: r,
                radius: 5
            }),
            fill: n,
            stroke: r
        })]
    }
    return pu
}
function du() {
    var t = {},
        e = [255, 255, 255, 1],
        n = [0, 153, 255, 1];
    return t.Polygon = [new hu({
        fill: new uu({
            color: [255, 255, 255, .5]
        })
    })], t.MultiPolygon = t.Polygon, t.LineString = [new hu({
        stroke: new lu({
            color: e,
            width: 5
        })
    }), new hu({
        stroke: new lu({
            color: n,
            width: 3
        })
    })], t.MultiLineString = t.LineString, t.Circle = t.Polygon.concat(t.LineString), t.Point = [new hu({
        image: new (0, Qa.default)({
            radius: 6,
            fill: new uu({
                color: n
            }),
            stroke: new lu({
                color: e,
                width: 1.5
            })
        }),
        zIndex: 1 / 0
    })], t.MultiPoint = t.Point, t.GeometryCollection = t.Polygon.concat(t.LineString, t.Point), t
}
function gu(t) {
    return t.getGeometry()
}
var yu = hu,
    vu = function() {
        var t = function(e, n) {
            return t = Object.setPrototypeOf || {
                __proto__: []
            } instanceof Array && function(t, e) {
                t.__proto__ = e
            } || function(t, e) {
                for (var n in e)
                    Object.prototype.hasOwnProperty.call(e, n) && (t[n] = e[n])
            }, t(e, n)
        };
        return function(e, n) {
            if ("function" != typeof n && null !== n)
                throw new TypeError("Class extends value " + String(n) + " is not a constructor or null");
            function r() {
                this.constructor = e
            }
            t(e, n),
            e.prototype = null === n ? Object.create(n) : (r.prototype = n.prototype, new r)
        }
    }(),
    mu = "renderOrder",
    _u = function(t) {
        function n(e) {
            var n = this,
                r = e || {},
                i = P({}, r);
            return delete i.style, delete i.renderBuffer, delete i.updateWhileAnimating, delete i.updateWhileInteracting, (n = t.call(this, i) || this).declutter_ = void 0 !== r.declutter && r.declutter, n.renderBuffer_ = void 0 !== r.renderBuffer ? r.renderBuffer : 100, n.style_ = null, n.styleFunction_ = void 0, n.setStyle(r.style), n.updateWhileAnimating_ = void 0 !== r.updateWhileAnimating && r.updateWhileAnimating, n.updateWhileInteracting_ = void 0 !== r.updateWhileInteracting && r.updateWhileInteracting, n
        }
        return vu(n, t), n.prototype.getDeclutter = function() {
            return this.declutter_
        }, n.prototype.getFeatures = function(e) {
            return t.prototype.getFeatures.call(this, e)
        }, n.prototype.getRenderBuffer = function() {
            return this.renderBuffer_
        }, n.prototype.getRenderOrder = function() {
            return this.get(mu)
        }, n.prototype.getStyle = function() {
            return this.style_
        }, n.prototype.getStyleFunction = function() {
            return this.styleFunction_
        }, n.prototype.getUpdateWhileAnimating = function() {
            return this.updateWhileAnimating_
        }, n.prototype.getUpdateWhileInteracting = function() {
            return this.updateWhileInteracting_
        }, n.prototype.renderDeclutter = function(t) {
            t.declutterTree || (t.declutterTree = new (e(Ja))(9)),
            this.getRenderer().renderDeclutter(t)
        }, n.prototype.setRenderOrder = function(t) {
            this.set(mu, t)
        }, n.prototype.setStyle = function(t) {
            this.style_ = void 0 !== t ? t : fu,
            this.styleFunction_ = null === t ? void 0 : cu(this.style_),
            this.changed()
        }, n
    }(fi.default),
    xu = {};
t(xu, "default", (() => $l), (t => $l = t));
var Eu = {};
t(Eu, "default", (() => Lu), (t => Lu = t));
var wu = {
        BEGIN_GEOMETRY: 0,
        BEGIN_PATH: 1,
        CIRCLE: 2,
        CLOSE_PATH: 3,
        CUSTOM: 4,
        DRAW_CHARS: 5,
        DRAW_IMAGE: 6,
        END_GEOMETRY: 7,
        FILL: 8,
        MOVE_TO_LINE_TO: 9,
        SET_FILL_STYLE: 10,
        SET_STROKE_STYLE: 11,
        STROKE: 12
    },
    bu = [wu.FILL],
    Cu = [wu.STROKE],
    Mu = [wu.BEGIN_PATH],
    Su = [wu.CLOSE_PATH],
    Iu = wu,
    Tu = function() {
        function t() {}
        return t.prototype.drawCustom = function(t, e, n, r) {}, t.prototype.drawGeometry = function(t) {}, t.prototype.setStyle = function(t) {}, t.prototype.drawCircle = function(t, e) {}, t.prototype.drawFeature = function(t, e) {}, t.prototype.drawGeometryCollection = function(t, e) {}, t.prototype.drawLineString = function(t, e) {}, t.prototype.drawMultiLineString = function(t, e) {}, t.prototype.drawMultiPoint = function(t, e) {}, t.prototype.drawMultiPolygon = function(t, e) {}, t.prototype.drawPoint = function(t, e) {}, t.prototype.drawPolygon = function(t, e) {}, t.prototype.drawText = function(t, e) {}, t.prototype.setFillStrokeStyle = function(t, e) {}, t.prototype.setImageStyle = function(t, e) {}, t.prototype.setTextStyle = function(t, e) {}, t
    }(),
    Pu = function() {
        var t = function(e, n) {
            return t = Object.setPrototypeOf || {
                __proto__: []
            } instanceof Array && function(t, e) {
                t.__proto__ = e
            } || function(t, e) {
                for (var n in e)
                    Object.prototype.hasOwnProperty.call(e, n) && (t[n] = e[n])
            }, t(e, n)
        };
        return function(e, n) {
            if ("function" != typeof n && null !== n)
                throw new TypeError("Class extends value " + String(n) + " is not a constructor or null");
            function r() {
                this.constructor = e
            }
            t(e, n),
            e.prototype = null === n ? Object.create(n) : (r.prototype = n.prototype, new r)
        }
    }(),
    Lu = function(t) {
        function e(e, n, r, i) {
            var o = t.call(this) || this;
            return o.tolerance = e, o.maxExtent = n, o.pixelRatio = i, o.maxLineWidth = 0, o.resolution = r, o.beginGeometryInstruction1_ = null, o.beginGeometryInstruction2_ = null, o.bufferedMaxExtent_ = null, o.instructions = [], o.coordinates = [], o.tmpCoordinate_ = [], o.hitDetectionInstructions = [], o.state = {}, o
        }
        return Pu(e, t), e.prototype.applyPixelRatio = function(t) {
            var e = this.pixelRatio;
            return 1 == e ? t : t.map((function(t) {
                return t * e
            }))
        }, e.prototype.appendFlatPointCoordinates = function(t, e) {
            for (var n = this.getBufferedMaxExtent(), r = this.tmpCoordinate_, i = this.coordinates, o = i.length, s = 0, a = t.length; s < a; s += e)
                r[0] = t[s],
                r[1] = t[s + 1],
                Ot(n, r) && (i[o++] = r[0], i[o++] = r[1]);
            return o
        }, e.prototype.appendFlatLineCoordinates = function(t, e, n, r, i, o) {
            var s = this.coordinates,
                a = s.length,
                u = this.getBufferedMaxExtent();
            o && (e += r);
            var l,
                h,
                c,
                p = t[e],
                f = t[e + 1],
                d = this.tmpCoordinate_,
                g = !0;
            for (l = e + r; l < n; l += r)
                d[0] = t[l],
                d[1] = t[l + 1],
                (c = At(u, d)) !== h ? (g && (s[a++] = p, s[a++] = f, g = !1), s[a++] = d[0], s[a++] = d[1]) : c === St.INTERSECTING ? (s[a++] = d[0], s[a++] = d[1], g = !1) : g = !0,
                p = d[0],
                f = d[1],
                h = c;
            return (i && g || l === e + r) && (s[a++] = p, s[a++] = f), a
        }, e.prototype.drawCustomCoordinates_ = function(t, e, n, r, i) {
            for (var o = 0, s = n.length; o < s; ++o) {
                var a = n[o],
                    u = this.appendFlatLineCoordinates(t, e, a, r, !1, !1);
                i.push(u),
                e = a
            }
            return e
        }, e.prototype.drawCustom = function(t, e, n, r) {
            this.beginGeometry(t, e);
            var i,
                o,
                s,
                a,
                u,
                l = t.getType(),
                h = t.getStride(),
                c = this.coordinates.length;
            switch (l) {
            case "MultiPolygon":
                i = t.getOrientedFlatCoordinates(),
                a = [];
                var p = t.getEndss();
                u = 0;
                for (var f = 0, d = p.length; f < d; ++f) {
                    var g = [];
                    u = this.drawCustomCoordinates_(i, u, p[f], h, g),
                    a.push(g)
                }
                this.instructions.push([Iu.CUSTOM, c, a, t, n, ir]),
                this.hitDetectionInstructions.push([Iu.CUSTOM, c, a, t, r || n, ir]);
                break;
            case "Polygon":
            case "MultiLineString":
                s = [],
                i = "Polygon" == l ? t.getOrientedFlatCoordinates() : t.getFlatCoordinates(),
                u = this.drawCustomCoordinates_(i, 0, t.getEnds(), h, s),
                this.instructions.push([Iu.CUSTOM, c, s, t, n, rr]),
                this.hitDetectionInstructions.push([Iu.CUSTOM, c, s, t, r || n, rr]);
                break;
            case "LineString":
            case "Circle":
                i = t.getFlatCoordinates(),
                o = this.appendFlatLineCoordinates(i, 0, i.length, h, !1, !1),
                this.instructions.push([Iu.CUSTOM, c, o, t, n, nr]),
                this.hitDetectionInstructions.push([Iu.CUSTOM, c, o, t, r || n, nr]);
                break;
            case "MultiPoint":
                i = t.getFlatCoordinates(),
                (o = this.appendFlatPointCoordinates(i, h)) > c && (this.instructions.push([Iu.CUSTOM, c, o, t, n, nr]), this.hitDetectionInstructions.push([Iu.CUSTOM, c, o, t, r || n, nr]));
                break;
            case "Point":
                i = t.getFlatCoordinates(),
                this.coordinates.push(i[0], i[1]),
                o = this.coordinates.length,
                this.instructions.push([Iu.CUSTOM, c, o, t, n]),
                this.hitDetectionInstructions.push([Iu.CUSTOM, c, o, t, r || n])
            }
            this.endGeometry(e)
        }, e.prototype.beginGeometry = function(t, e) {
            this.beginGeometryInstruction1_ = [Iu.BEGIN_GEOMETRY, e, 0, t],
            this.instructions.push(this.beginGeometryInstruction1_),
            this.beginGeometryInstruction2_ = [Iu.BEGIN_GEOMETRY, e, 0, t],
            this.hitDetectionInstructions.push(this.beginGeometryInstruction2_)
        }, e.prototype.finish = function() {
            return {
                instructions: this.instructions,
                hitDetectionInstructions: this.hitDetectionInstructions,
                coordinates: this.coordinates
            }
        }, e.prototype.reverseHitDetectionInstructions = function() {
            var t,
                e = this.hitDetectionInstructions;
            e.reverse();
            var n,
                r,
                i = e.length,
                o = -1;
            for (t = 0; t < i; ++t)
                (r = (n = e[t])[0]) == Iu.END_GEOMETRY ? o = t : r == Iu.BEGIN_GEOMETRY && (n[2] = t, b(this.hitDetectionInstructions, o, t), o = -1)
        }, e.prototype.setFillStrokeStyle = function(t, e) {
            var n = this.state;
            if (t) {
                var r = t.getColor();
                n.fillStyle = ru(r || "#000")
            } else
                n.fillStyle = void 0;
            if (e) {
                var i = e.getColor();
                n.strokeStyle = ru(i || "#000");
                var o = e.getLineCap();
                n.lineCap = void 0 !== o ? o : "round";
                var s = e.getLineDash();
                n.lineDash = s ? s.slice() : ji;
                var a = e.getLineDashOffset();
                n.lineDashOffset = a || 0;
                var u = e.getLineJoin();
                n.lineJoin = void 0 !== u ? u : "round";
                var l = e.getWidth();
                n.lineWidth = void 0 !== l ? l : 1;
                var h = e.getMiterLimit();
                n.miterLimit = void 0 !== h ? h : 10,
                n.lineWidth > this.maxLineWidth && (this.maxLineWidth = n.lineWidth, this.bufferedMaxExtent_ = null)
            } else
                n.strokeStyle = void 0,
                n.lineCap = void 0,
                n.lineDash = null,
                n.lineDashOffset = void 0,
                n.lineJoin = void 0,
                n.lineWidth = void 0,
                n.miterLimit = void 0
        }, e.prototype.createFill = function(t) {
            var e = t.fillStyle,
                n = [Iu.SET_FILL_STYLE, e];
            return "string" != typeof e && n.push(!0), n
        }, e.prototype.applyStroke = function(t) {
            this.instructions.push(this.createStroke(t))
        }, e.prototype.createStroke = function(t) {
            return [Iu.SET_STROKE_STYLE, t.strokeStyle, t.lineWidth * this.pixelRatio, t.lineCap, t.lineJoin, t.miterLimit, this.applyPixelRatio(t.lineDash), t.lineDashOffset * this.pixelRatio]
        }, e.prototype.updateFillStyle = function(t, e) {
            var n = t.fillStyle;
            "string" == typeof n && t.currentFillStyle == n || (void 0 !== n && this.instructions.push(e.call(this, t)), t.currentFillStyle = n)
        }, e.prototype.updateStrokeStyle = function(t, e) {
            var n = t.strokeStyle,
                r = t.lineCap,
                i = t.lineDash,
                o = t.lineDashOffset,
                s = t.lineJoin,
                a = t.lineWidth,
                u = t.miterLimit;
            (t.currentStrokeStyle != n || t.currentLineCap != r || i != t.currentLineDash && !M(t.currentLineDash, i) || t.currentLineDashOffset != o || t.currentLineJoin != s || t.currentLineWidth != a || t.currentMiterLimit != u) && (void 0 !== n && e.call(this, t), t.currentStrokeStyle = n, t.currentLineCap = r, t.currentLineDash = i, t.currentLineDashOffset = o, t.currentLineJoin = s, t.currentLineWidth = a, t.currentMiterLimit = u)
        }, e.prototype.endGeometry = function(t) {
            this.beginGeometryInstruction1_[2] = this.instructions.length,
            this.beginGeometryInstruction1_ = null,
            this.beginGeometryInstruction2_[2] = this.hitDetectionInstructions.length,
            this.beginGeometryInstruction2_ = null;
            var e = [Iu.END_GEOMETRY, t];
            this.instructions.push(e),
            this.hitDetectionInstructions.push(e)
        }, e.prototype.getBufferedMaxExtent = function() {
            if (!this.bufferedMaxExtent_ && (this.bufferedMaxExtent_ = Pt(this.maxExtent), this.maxLineWidth > 0)) {
                var t = this.resolution * (this.maxLineWidth + 1) / 2;
                Tt(this.bufferedMaxExtent_, t, this.bufferedMaxExtent_)
            }
            return this.bufferedMaxExtent_
        }, e
    }(Tu),
    Ou = {};
t(Ou, "default", (() => Ru), (t => Ru = t));
var Nu = function() {
        var t = function(e, n) {
            return t = Object.setPrototypeOf || {
                __proto__: []
            } instanceof Array && function(t, e) {
                t.__proto__ = e
            } || function(t, e) {
                for (var n in e)
                    Object.prototype.hasOwnProperty.call(e, n) && (t[n] = e[n])
            }, t(e, n)
        };
        return function(e, n) {
            if ("function" != typeof n && null !== n)
                throw new TypeError("Class extends value " + String(n) + " is not a constructor or null");
            function r() {
                this.constructor = e
            }
            t(e, n),
            e.prototype = null === n ? Object.create(n) : (r.prototype = n.prototype, new r)
        }
    }(),
    Ru = function(t) {
        function e(e, n, r, i) {
            var o = t.call(this, e, n, r, i) || this;
            return o.hitDetectionImage_ = null, o.image_ = null, o.imagePixelRatio_ = void 0, o.anchorX_ = void 0, o.anchorY_ = void 0, o.height_ = void 0, o.opacity_ = void 0, o.originX_ = void 0, o.originY_ = void 0, o.rotateWithView_ = void 0, o.rotation_ = void 0, o.scale_ = void 0, o.width_ = void 0, o.declutterMode_ = void 0, o.declutterImageWithText_ = void 0, o
        }
        return Nu(e, t), e.prototype.drawPoint = function(t, e) {
            if (this.image_) {
                this.beginGeometry(t, e);
                var n = t.getFlatCoordinates(),
                    r = t.getStride(),
                    i = this.coordinates.length,
                    o = this.appendFlatPointCoordinates(n, r);
                this.instructions.push([Iu.DRAW_IMAGE, i, o, this.image_, this.anchorX_ * this.imagePixelRatio_, this.anchorY_ * this.imagePixelRatio_, Math.ceil(this.height_ * this.imagePixelRatio_), this.opacity_, this.originX_ * this.imagePixelRatio_, this.originY_ * this.imagePixelRatio_, this.rotateWithView_, this.rotation_, [this.scale_[0] * this.pixelRatio / this.imagePixelRatio_, this.scale_[1] * this.pixelRatio / this.imagePixelRatio_], Math.ceil(this.width_ * this.imagePixelRatio_), this.declutterMode_, this.declutterImageWithText_]),
                this.hitDetectionInstructions.push([Iu.DRAW_IMAGE, i, o, this.hitDetectionImage_, this.anchorX_, this.anchorY_, this.height_, this.opacity_, this.originX_, this.originY_, this.rotateWithView_, this.rotation_, this.scale_, this.width_, this.declutterMode_, this.declutterImageWithText_]),
                this.endGeometry(e)
            }
        }, e.prototype.drawMultiPoint = function(t, e) {
            if (this.image_) {
                this.beginGeometry(t, e);
                var n = t.getFlatCoordinates(),
                    r = t.getStride(),
                    i = this.coordinates.length,
                    o = this.appendFlatPointCoordinates(n, r);
                this.instructions.push([Iu.DRAW_IMAGE, i, o, this.image_, this.anchorX_ * this.imagePixelRatio_, this.anchorY_ * this.imagePixelRatio_, Math.ceil(this.height_ * this.imagePixelRatio_), this.opacity_, this.originX_ * this.imagePixelRatio_, this.originY_ * this.imagePixelRatio_, this.rotateWithView_, this.rotation_, [this.scale_[0] * this.pixelRatio / this.imagePixelRatio_, this.scale_[1] * this.pixelRatio / this.imagePixelRatio_], Math.ceil(this.width_ * this.imagePixelRatio_), this.declutterMode_, this.declutterImageWithText_]),
                this.hitDetectionInstructions.push([Iu.DRAW_IMAGE, i, o, this.hitDetectionImage_, this.anchorX_, this.anchorY_, this.height_, this.opacity_, this.originX_, this.originY_, this.rotateWithView_, this.rotation_, this.scale_, this.width_, this.declutterMode_, this.declutterImageWithText_]),
                this.endGeometry(e)
            }
        }, e.prototype.finish = function() {
            return this.reverseHitDetectionInstructions(), this.anchorX_ = void 0, this.anchorY_ = void 0, this.hitDetectionImage_ = null, this.image_ = null, this.imagePixelRatio_ = void 0, this.height_ = void 0, this.scale_ = void 0, this.opacity_ = void 0, this.originX_ = void 0, this.originY_ = void 0, this.rotateWithView_ = void 0, this.rotation_ = void 0, this.width_ = void 0, t.prototype.finish.call(this)
        }, e.prototype.setImageStyle = function(t, e) {
            var n = t.getAnchor(),
                r = t.getSize(),
                i = t.getOrigin();
            this.imagePixelRatio_ = t.getPixelRatio(this.pixelRatio),
            this.anchorX_ = n[0],
            this.anchorY_ = n[1],
            this.hitDetectionImage_ = t.getHitDetectionImage(),
            this.image_ = t.getImage(this.pixelRatio),
            this.height_ = r[1],
            this.opacity_ = t.getOpacity(),
            this.originX_ = i[0],
            this.originY_ = i[1],
            this.rotateWithView_ = t.getRotateWithView(),
            this.rotation_ = t.getRotation(),
            this.scale_ = t.getScaleArray(),
            this.width_ = r[0],
            this.declutterMode_ = t.getDeclutterMode(),
            this.declutterImageWithText_ = e
        }, e
    }(Eu.default),
    Au = {};
t(Au, "default", (() => Fu), (t => Fu = t));
var Du = function() {
        var t = function(e, n) {
            return t = Object.setPrototypeOf || {
                __proto__: []
            } instanceof Array && function(t, e) {
                t.__proto__ = e
            } || function(t, e) {
                for (var n in e)
                    Object.prototype.hasOwnProperty.call(e, n) && (t[n] = e[n])
            }, t(e, n)
        };
        return function(e, n) {
            if ("function" != typeof n && null !== n)
                throw new TypeError("Class extends value " + String(n) + " is not a constructor or null");
            function r() {
                this.constructor = e
            }
            t(e, n),
            e.prototype = null === n ? Object.create(n) : (r.prototype = n.prototype, new r)
        }
    }(),
    Fu = function(t) {
        function e(e, n, r, i) {
            return t.call(this, e, n, r, i) || this
        }
        return Du(e, t), e.prototype.drawFlatCoordinates_ = function(t, e, n, r) {
            var i = this.coordinates.length,
                o = this.appendFlatLineCoordinates(t, e, n, r, !1, !1),
                s = [Iu.MOVE_TO_LINE_TO, i, o];
            return this.instructions.push(s), this.hitDetectionInstructions.push(s), n
        }, e.prototype.drawLineString = function(t, e) {
            var n = this.state,
                r = n.strokeStyle,
                i = n.lineWidth;
            if (void 0 !== r && void 0 !== i) {
                this.updateStrokeStyle(n, this.applyStroke),
                this.beginGeometry(t, e),
                this.hitDetectionInstructions.push([Iu.SET_STROKE_STYLE, n.strokeStyle, n.lineWidth, n.lineCap, n.lineJoin, n.miterLimit, ji, 0], Mu);
                var o = t.getFlatCoordinates(),
                    s = t.getStride();
                this.drawFlatCoordinates_(o, 0, o.length, s),
                this.hitDetectionInstructions.push(Cu),
                this.endGeometry(e)
            }
        }, e.prototype.drawMultiLineString = function(t, e) {
            var n = this.state,
                r = n.strokeStyle,
                i = n.lineWidth;
            if (void 0 !== r && void 0 !== i) {
                this.updateStrokeStyle(n, this.applyStroke),
                this.beginGeometry(t, e),
                this.hitDetectionInstructions.push([Iu.SET_STROKE_STYLE, n.strokeStyle, n.lineWidth, n.lineCap, n.lineJoin, n.miterLimit, n.lineDash, n.lineDashOffset], Mu);
                for (var o = t.getEnds(), s = t.getFlatCoordinates(), a = t.getStride(), u = 0, l = 0, h = o.length; l < h; ++l)
                    u = this.drawFlatCoordinates_(s, u, o[l], a);
                this.hitDetectionInstructions.push(Cu),
                this.endGeometry(e)
            }
        }, e.prototype.finish = function() {
            var e = this.state;
            return null != e.lastStroke && e.lastStroke != this.coordinates.length && this.instructions.push(Cu), this.reverseHitDetectionInstructions(), this.state = null, t.prototype.finish.call(this)
        }, e.prototype.applyStroke = function(e) {
            null != e.lastStroke && e.lastStroke != this.coordinates.length && (this.instructions.push(Cu), e.lastStroke = this.coordinates.length),
            e.lastStroke = 0,
            t.prototype.applyStroke.call(this, e),
            this.instructions.push(Mu)
        }, e
    }(Eu.default),
    ku = {};
t(ku, "default", (() => Gu), (t => Gu = t));
var ju = function() {
        var t = function(e, n) {
            return t = Object.setPrototypeOf || {
                __proto__: []
            } instanceof Array && function(t, e) {
                t.__proto__ = e
            } || function(t, e) {
                for (var n in e)
                    Object.prototype.hasOwnProperty.call(e, n) && (t[n] = e[n])
            }, t(e, n)
        };
        return function(e, n) {
            if ("function" != typeof n && null !== n)
                throw new TypeError("Class extends value " + String(n) + " is not a constructor or null");
            function r() {
                this.constructor = e
            }
            t(e, n),
            e.prototype = null === n ? Object.create(n) : (r.prototype = n.prototype, new r)
        }
    }(),
    Gu = function(t) {
        function e(e, n, r, i) {
            return t.call(this, e, n, r, i) || this
        }
        return ju(e, t), e.prototype.drawFlatCoordinatess_ = function(t, e, n, r) {
            var i = this.state,
                o = void 0 !== i.fillStyle,
                s = void 0 !== i.strokeStyle,
                a = n.length;
            this.instructions.push(Mu),
            this.hitDetectionInstructions.push(Mu);
            for (var u = 0; u < a; ++u) {
                var l = n[u],
                    h = this.coordinates.length,
                    c = this.appendFlatLineCoordinates(t, e, l, r, !0, !s),
                    p = [Iu.MOVE_TO_LINE_TO, h, c];
                this.instructions.push(p),
                this.hitDetectionInstructions.push(p),
                s && (this.instructions.push(Su), this.hitDetectionInstructions.push(Su)),
                e = l
            }
            return o && (this.instructions.push(bu), this.hitDetectionInstructions.push(bu)), s && (this.instructions.push(Cu), this.hitDetectionInstructions.push(Cu)), e
        }, e.prototype.drawCircle = function(t, e) {
            var n = this.state,
                r = n.fillStyle,
                i = n.strokeStyle;
            if (void 0 !== r || void 0 !== i) {
                this.setFillStrokeStyles_(),
                this.beginGeometry(t, e),
                void 0 !== n.fillStyle && this.hitDetectionInstructions.push([Iu.SET_FILL_STYLE, "#000"]),
                void 0 !== n.strokeStyle && this.hitDetectionInstructions.push([Iu.SET_STROKE_STYLE, n.strokeStyle, n.lineWidth, n.lineCap, n.lineJoin, n.miterLimit, n.lineDash, n.lineDashOffset]);
                var o = t.getFlatCoordinates(),
                    s = t.getStride(),
                    a = this.coordinates.length;
                this.appendFlatLineCoordinates(o, 0, o.length, s, !1, !1);
                var u = [Iu.CIRCLE, a];
                this.instructions.push(Mu, u),
                this.hitDetectionInstructions.push(Mu, u),
                void 0 !== n.fillStyle && (this.instructions.push(bu), this.hitDetectionInstructions.push(bu)),
                void 0 !== n.strokeStyle && (this.instructions.push(Cu), this.hitDetectionInstructions.push(Cu)),
                this.endGeometry(e)
            }
        }, e.prototype.drawPolygon = function(t, e) {
            var n = this.state,
                r = n.fillStyle,
                i = n.strokeStyle;
            if (void 0 !== r || void 0 !== i) {
                this.setFillStrokeStyles_(),
                this.beginGeometry(t, e),
                void 0 !== n.fillStyle && this.hitDetectionInstructions.push([Iu.SET_FILL_STYLE, "#000"]),
                void 0 !== n.strokeStyle && this.hitDetectionInstructions.push([Iu.SET_STROKE_STYLE, n.strokeStyle, n.lineWidth, n.lineCap, n.lineJoin, n.miterLimit, n.lineDash, n.lineDashOffset]);
                var o = t.getEnds(),
                    s = t.getOrientedFlatCoordinates(),
                    a = t.getStride();
                this.drawFlatCoordinatess_(s, 0, o, a),
                this.endGeometry(e)
            }
        }, e.prototype.drawMultiPolygon = function(t, e) {
            var n = this.state,
                r = n.fillStyle,
                i = n.strokeStyle;
            if (void 0 !== r || void 0 !== i) {
                this.setFillStrokeStyles_(),
                this.beginGeometry(t, e),
                void 0 !== n.fillStyle && this.hitDetectionInstructions.push([Iu.SET_FILL_STYLE, "#000"]),
                void 0 !== n.strokeStyle && this.hitDetectionInstructions.push([Iu.SET_STROKE_STYLE, n.strokeStyle, n.lineWidth, n.lineCap, n.lineJoin, n.miterLimit, n.lineDash, n.lineDashOffset]);
                for (var o = t.getEndss(), s = t.getOrientedFlatCoordinates(), a = t.getStride(), u = 0, l = 0, h = o.length; l < h; ++l)
                    u = this.drawFlatCoordinatess_(s, u, o[l], a);
                this.endGeometry(e)
            }
        }, e.prototype.finish = function() {
            this.reverseHitDetectionInstructions(),
            this.state = null;
            var e = this.tolerance;
            if (0 !== e)
                for (var n = this.coordinates, r = 0, i = n.length; r < i; ++r)
                    n[r] = Jn(n[r], e);
            return t.prototype.finish.call(this)
        }, e.prototype.setFillStrokeStyles_ = function() {
            var t = this.state;
            void 0 !== t.fillStyle && this.updateFillStyle(t, this.createFill),
            void 0 !== t.strokeStyle && this.updateStrokeStyle(t, this.applyStroke)
        }, e
    }(Eu.default),
    Bu = {};
t(Bu, "TEXT_ALIGN", (() => Vu), (t => Vu = t)),
t(Bu, "default", (() => Xu), (t => Xu = t));
var qu = {
    POINT: "point",
    LINE: "line"
};
function zu(t, e, n, r, i) {
    var o,
        s,
        a,
        u,
        l,
        h,
        c,
        p,
        f,
        d = n,
        g = n,
        y = 0,
        v = 0,
        m = n;
    for (o = n; o < r; o += i) {
        var _ = e[o],
            x = e[o + 1];
        void 0 !== u && (p = _ - u, f = x - l, a = Math.sqrt(p * p + f * f), void 0 !== h && (v += s, Math.acos((h * p + c * f) / (s * a)) > t && (v > y && (y = v, d = m, g = o), v = 0, m = o - i)), s = a, h = p, c = f),
        u = _,
        l = x
    }
    return (v += a) > y ? [m, o] : [d, g]
}
var Uu = function() {
        var t = function(e, n) {
            return t = Object.setPrototypeOf || {
                __proto__: []
            } instanceof Array && function(t, e) {
                t.__proto__ = e
            } || function(t, e) {
                for (var n in e)
                    Object.prototype.hasOwnProperty.call(e, n) && (t[n] = e[n])
            }, t(e, n)
        };
        return function(e, n) {
            if ("function" != typeof n && null !== n)
                throw new TypeError("Class extends value " + String(n) + " is not a constructor or null");
            function r() {
                this.constructor = e
            }
            t(e, n),
            e.prototype = null === n ? Object.create(n) : (r.prototype = n.prototype, new r)
        }
    }(),
    Vu = {
        left: 0,
        end: 0,
        center: .5,
        right: 1,
        start: 1,
        top: 0,
        middle: .5,
        hanging: .2,
        alphabetic: .8,
        ideographic: .8,
        bottom: 1
    },
    Xu = function(t) {
        function e(e, n, r, i) {
            var o = t.call(this, e, n, r, i) || this;
            return o.labels_ = null, o.text_ = "", o.textOffsetX_ = 0, o.textOffsetY_ = 0, o.textRotateWithView_ = void 0, o.textRotation_ = 0, o.textFillState_ = null, o.fillStates = {}, o.textStrokeState_ = null, o.strokeStates = {}, o.textState_ = {}, o.textStates = {}, o.textKey_ = "", o.fillKey_ = "", o.strokeKey_ = "", o.declutterImageWithText_ = void 0, o
        }
        return Uu(e, t), e.prototype.finish = function() {
            var e = t.prototype.finish.call(this);
            return e.textStates = this.textStates, e.fillStates = this.fillStates, e.strokeStates = this.strokeStates, e
        }, e.prototype.drawText = function(t, e) {
            var n = this.textFillState_,
                r = this.textStrokeState_,
                i = this.textState_;
            if ("" !== this.text_ && i && (n || r)) {
                var o = this.coordinates,
                    s = o.length,
                    a = t.getType(),
                    u = null,
                    l = t.getStride();
                if (i.placement !== qu.LINE || "LineString" != a && "MultiLineString" != a && "Polygon" != a && "MultiPolygon" != a) {
                    var h = i.overflow ? null : [];
                    switch (a) {
                    case "Point":
                    case "MultiPoint":
                        u = t.getFlatCoordinates();
                        break;
                    case "LineString":
                        u = t.getFlatMidpoint();
                        break;
                    case "Circle":
                        u = t.getCenter();
                        break;
                    case "MultiLineString":
                        u = t.getFlatMidpoints(),
                        l = 2;
                        break;
                    case "Polygon":
                        u = t.getFlatInteriorPoint(),
                        i.overflow || h.push(u[2] / this.resolution),
                        l = 3;
                        break;
                    case "MultiPolygon":
                        var c = t.getFlatInteriorPoints();
                        u = [];
                        for (w = 0, b = c.length; w < b; w += 3)
                            i.overflow || h.push(c[w + 2] / this.resolution),
                            u.push(c[w], c[w + 1]);
                        if (0 === u.length)
                            return;
                        l = 2
                    }
                    if ((L = this.appendFlatPointCoordinates(u, l)) === s)
                        return;
                    if (h && (L - s) / 2 != u.length / l) {
                        var p = s / 2;
                        h = h.filter((function(t, e) {
                            var n = o[2 * (p + e)] === u[e * l] && o[2 * (p + e) + 1] === u[e * l + 1];
                            return n || --p, n
                        }))
                    }
                    this.saveTextStates_(),
                    (i.backgroundFill || i.backgroundStroke) && (this.setFillStrokeStyle(i.backgroundFill, i.backgroundStroke), i.backgroundFill && (this.updateFillStyle(this.state, this.createFill), this.hitDetectionInstructions.push(this.createFill(this.state))), i.backgroundStroke && (this.updateStrokeStyle(this.state, this.applyStroke), this.hitDetectionInstructions.push(this.createStroke(this.state)))),
                    this.beginGeometry(t, e);
                    var f = i.padding;
                    if (f != Gi && (i.scale[0] < 0 || i.scale[1] < 0)) {
                        var d = i.padding[0],
                            g = i.padding[1],
                            y = i.padding[2],
                            v = i.padding[3];
                        i.scale[0] < 0 && (g = -g, v = -v),
                        i.scale[1] < 0 && (d = -d, y = -y),
                        f = [d, g, y, v]
                    }
                    var m = this.pixelRatio;
                    this.instructions.push([Iu.DRAW_IMAGE, s, L, null, NaN, NaN, NaN, 1, 0, 0, this.textRotateWithView_, this.textRotation_, [1, 1], NaN, void 0, this.declutterImageWithText_, f == Gi ? Gi : f.map((function(t) {
                        return t * m
                    })), !!i.backgroundFill, !!i.backgroundStroke, this.text_, this.textKey_, this.strokeKey_, this.fillKey_, this.textOffsetX_, this.textOffsetY_, h]);
                    var _ = 1 / m;
                    this.hitDetectionInstructions.push([Iu.DRAW_IMAGE, s, L, null, NaN, NaN, NaN, 1, 0, 0, this.textRotateWithView_, this.textRotation_, [_, _], NaN, void 0, this.declutterImageWithText_, f, !!i.backgroundFill, !!i.backgroundStroke, this.text_, this.textKey_, this.strokeKey_, this.fillKey_, this.textOffsetX_, this.textOffsetY_, h]),
                    this.endGeometry(e)
                } else {
                    if (!ie(this.getBufferedMaxExtent(), t.getExtent()))
                        return;
                    var x = void 0;
                    if (u = t.getFlatCoordinates(), "LineString" == a)
                        x = [u.length];
                    else if ("MultiLineString" == a)
                        x = t.getEnds();
                    else if ("Polygon" == a)
                        x = t.getEnds().slice(0, 1);
                    else if ("MultiPolygon" == a) {
                        var E = t.getEndss();
                        x = [];
                        for (var w = 0, b = E.length; w < b; ++w)
                            x.push(E[w][0])
                    }
                    this.beginGeometry(t, e);
                    for (var C = i.textAlign, M = 0, S = void 0, I = 0, T = x.length; I < T; ++I) {
                        if (null == C) {
                            var P = zu(i.maxAngle, u, M, x[I], l);
                            M = P[0],
                            S = P[1]
                        } else
                            S = x[I];
                        for (var w = M; w < S; w += l)
                            o.push(u[w], u[w + 1]);
                        var L = o.length;
                        M = x[I],
                        this.drawChars_(s, L),
                        s = L
                    }
                    this.endGeometry(e)
                }
            }
        }, e.prototype.saveTextStates_ = function() {
            var t = this.textStrokeState_,
                e = this.textState_,
                n = this.textFillState_,
                r = this.strokeKey_;
            t && (r in this.strokeStates || (this.strokeStates[r] = {
                strokeStyle: t.strokeStyle,
                lineCap: t.lineCap,
                lineDashOffset: t.lineDashOffset,
                lineWidth: t.lineWidth,
                lineJoin: t.lineJoin,
                miterLimit: t.miterLimit,
                lineDash: t.lineDash
            }));
            var i = this.textKey_;
            i in this.textStates || (this.textStates[i] = {
                font: e.font,
                textAlign: e.textAlign || "center",
                justify: e.justify,
                textBaseline: e.textBaseline || "middle",
                scale: e.scale
            });
            var o = this.fillKey_;
            n && (o in this.fillStates || (this.fillStates[o] = {
                fillStyle: n.fillStyle
            }))
        }, e.prototype.drawChars_ = function(t, e) {
            var n = this.textStrokeState_,
                r = this.textState_,
                i = this.strokeKey_,
                o = this.textKey_,
                s = this.fillKey_;
            this.saveTextStates_();
            var a = this.pixelRatio,
                u = Vu[r.textBaseline],
                l = this.textOffsetY_ * a,
                h = this.text_,
                c = n ? n.lineWidth * Math.abs(r.scale[0]) / 2 : 0;
            this.instructions.push([Iu.DRAW_CHARS, t, e, u, r.overflow, s, r.maxAngle, a, l, i, c * a, h, o, 1]),
            this.hitDetectionInstructions.push([Iu.DRAW_CHARS, t, e, u, r.overflow, s, r.maxAngle, 1, l, i, c, h, o, 1 / a])
        }, e.prototype.setTextStyle = function(t, e) {
            var n,
                r,
                i;
            if (t) {
                var o = t.getFill();
                o ? ((r = this.textFillState_) || (r = {}, this.textFillState_ = r), r.fillStyle = ru(o.getColor() || "#000")) : (r = null, this.textFillState_ = r);
                var s = t.getStroke();
                if (s) {
                    (i = this.textStrokeState_) || (i = {}, this.textStrokeState_ = i);
                    var a = s.getLineDash(),
                        u = s.getLineDashOffset(),
                        l = s.getWidth(),
                        c = s.getMiterLimit();
                    i.lineCap = s.getLineCap() || "round",
                    i.lineDash = a ? a.slice() : ji,
                    i.lineDashOffset = void 0 === u ? 0 : u,
                    i.lineJoin = s.getLineJoin() || "round",
                    i.lineWidth = void 0 === l ? 1 : l,
                    i.miterLimit = void 0 === c ? 10 : c,
                    i.strokeStyle = ru(s.getColor() || "#000")
                } else
                    i = null,
                    this.textStrokeState_ = i;
                n = this.textState_;
                var p = t.getFont() || "10px sans-serif";
                Xi(p);
                var f = t.getScaleArray();
                n.overflow = t.getOverflow(),
                n.font = p,
                n.maxAngle = t.getMaxAngle(),
                n.placement = t.getPlacement(),
                n.textAlign = t.getTextAlign(),
                n.justify = t.getJustify(),
                n.textBaseline = t.getTextBaseline() || "middle",
                n.backgroundFill = t.getBackgroundFill(),
                n.backgroundStroke = t.getBackgroundStroke(),
                n.padding = t.getPadding() || Gi,
                n.scale = void 0 === f ? [1, 1] : f;
                var d = t.getOffsetX(),
                    g = t.getOffsetY(),
                    y = t.getRotateWithView(),
                    v = t.getRotation();
                this.text_ = t.getText() || "",
                this.textOffsetX_ = void 0 === d ? 0 : d,
                this.textOffsetY_ = void 0 === g ? 0 : g,
                this.textRotateWithView_ = void 0 !== y && y,
                this.textRotation_ = void 0 === v ? 0 : v,
                this.strokeKey_ = i ? ("string" == typeof i.strokeStyle ? i.strokeStyle : h(i.strokeStyle)) + i.lineCap + i.lineDashOffset + "|" + i.lineWidth + i.lineJoin + i.miterLimit + "[" + i.lineDash.join() + "]" : "",
                this.textKey_ = n.font + n.scale + (n.textAlign || "?") + (n.justify || "?") + (n.textBaseline || "?"),
                this.fillKey_ = r ? "string" == typeof r.fillStyle ? r.fillStyle : "|" + h(r.fillStyle) : ""
            } else
                this.text_ = "";
            this.declutterImageWithText_ = e
        }, e
    }(Eu.default),
    Hu = {
        Circle: ku.default,
        Default: Eu.default,
        Image: Ou.default,
        LineString: Au.default,
        Polygon: ku.default,
        Text: Bu.default
    },
    Yu = function() {
        function t(t, e, n, r) {
            this.tolerance_ = t,
            this.maxExtent_ = e,
            this.pixelRatio_ = r,
            this.resolution_ = n,
            this.buildersByZIndex_ = {}
        }
        return t.prototype.finish = function() {
            var t = {};
            for (var e in this.buildersByZIndex_) {
                t[e] = t[e] || {};
                var n = this.buildersByZIndex_[e];
                for (var r in n) {
                    var i = n[r].finish();
                    t[e][r] = i
                }
            }
            return t
        }, t.prototype.getBuilder = function(t, e) {
            var n = void 0 !== t ? t.toString() : "0",
                r = this.buildersByZIndex_[n];
            void 0 === r && (r = {}, this.buildersByZIndex_[n] = r);
            var i = r[e];
            void 0 === i && (i = new (0, Hu[e])(this.tolerance_, this.maxExtent_, this.resolution_, this.pixelRatio_), r[e] = i);
            return i
        }, t
    }(),
    Wu = {};
t(Wu, "canvasPool", (() => tl), (t => tl = t)),
t(Wu, "default", (() => nl), (t => nl = t));
var $u = {};
t($u, "default", (() => Ju), (t => Ju = t));
var Ku = function() {
        var t = function(e, n) {
            return t = Object.setPrototypeOf || {
                __proto__: []
            } instanceof Array && function(t, e) {
                t.__proto__ = e
            } || function(t, e) {
                for (var n in e)
                    Object.prototype.hasOwnProperty.call(e, n) && (t[n] = e[n])
            }, t(e, n)
        };
        return function(e, n) {
            if ("function" != typeof n && null !== n)
                throw new TypeError("Class extends value " + String(n) + " is not a constructor or null");
            function r() {
                this.constructor = e
            }
            t(e, n),
            e.prototype = null === n ? Object.create(n) : (r.prototype = n.prototype, new r)
        }
    }(),
    Zu = function(t) {
        function e(e) {
            var n = t.call(this) || this;
            return n.ready = !0, n.boundHandleImageChange_ = n.handleImageChange_.bind(n), n.layer_ = e, n.declutterExecutorGroup = null, n
        }
        return Ku(e, t), e.prototype.getFeatures = function(t) {
            return u()
        }, e.prototype.getData = function(t) {
            return null
        }, e.prototype.prepareFrame = function(t) {
            return u()
        }, e.prototype.renderFrame = function(t, e) {
            return u()
        }, e.prototype.loadedTileCallback = function(t, e, n) {
            t[e] || (t[e] = {}),
            t[e][n.tileCoord.toString()] = n
        }, e.prototype.createLoadedTileFinder = function(t, e, n) {
            return function(r, i) {
                var o = this.loadedTileCallback.bind(this, n, r);
                return t.forEachLoadedTile(e, r, i, o)
            }.bind(this)
        }, e.prototype.forEachFeatureAtCoordinate = function(t, e, n, r, i) {}, e.prototype.getDataAtPixel = function(t, e, n) {
            return null
        }, e.prototype.getLayer = function() {
            return this.layer_
        }, e.prototype.handleFontsChanged = function() {}, e.prototype.handleImageChange_ = function(t) {
            t.target.getState() === eu.LOADED && this.renderIfReadyAndVisible()
        }, e.prototype.loadImage = function(t) {
            var e = t.getState();
            return e != eu.LOADED && e != eu.ERROR && t.addEventListener(D.CHANGE, this.boundHandleImageChange_), e == eu.IDLE && (t.load(), e = t.getState()), e == eu.LOADED
        }, e.prototype.renderIfReadyAndVisible = function() {
            var t = this.getLayer();
            t && t.getVisible() && "ready" === t.getSourceState() && t.changed()
        }, e.prototype.disposeInternal = function() {
            delete this.layer_,
            t.prototype.disposeInternal.call(this)
        }, e
    }(v.default),
    Ju = Zu,
    Qu = function() {
        var t = function(e, n) {
            return t = Object.setPrototypeOf || {
                __proto__: []
            } instanceof Array && function(t, e) {
                t.__proto__ = e
            } || function(t, e) {
                for (var n in e)
                    Object.prototype.hasOwnProperty.call(e, n) && (t[n] = e[n])
            }, t(e, n)
        };
        return function(e, n) {
            if ("function" != typeof n && null !== n)
                throw new TypeError("Class extends value " + String(n) + " is not a constructor or null");
            function r() {
                this.constructor = e
            }
            t(e, n),
            e.prototype = null === n ? Object.create(n) : (r.prototype = n.prototype, new r)
        }
    }(),
    tl = [],
    el = null;
var nl = function(t) {
    function e(e) {
        var n = t.call(this, e) || this;
        return n.container = null, n.renderedResolution, n.tempTransform = [1, 0, 0, 1, 0, 0], n.pixelTransform = [1, 0, 0, 1, 0, 0], n.inversePixelTransform = [1, 0, 0, 1, 0, 0], n.context = null, n.containerReused = !1, n.pixelContext_ = null, n.frameState = null, n
    }
    return Qu(e, t), e.prototype.getImageData = function(t, e, n) {
        var r,
            i;
        el || ((r = document.createElement("canvas")).width = 1, r.height = 1, el = r.getContext("2d")),
        el.clearRect(0, 0, 1, 1);
        try {
            el.drawImage(t, e, n, 1, 1, 0, 0, 1, 1),
            i = el.getImageData(0, 0, 1, 1).data
        } catch (t) {
            return el = null, null
        }
        return i
    }, e.prototype.getBackground = function(t) {
        var e = this.getLayer().getBackground();
        return "function" == typeof e && (e = e(t.viewState.resolution)), e || void 0
    }, e.prototype.useContainer = function(t, e, n) {
        var r,
            i,
            o = this.getLayer().getClassName();
        t && t.className === o && (!n || t && t.style.backgroundColor && M(ai(t.style.backgroundColor), ai(n))) && ((a = t.firstElementChild) instanceof HTMLCanvasElement && (i = a.getContext("2d")));
        if (i && i.canvas.style.transform === e ? (this.container = t, this.context = i, this.containerReused = !0) : this.containerReused && (this.container = null, this.context = null, this.containerReused = !1), !this.container) {
            (r = document.createElement("div")).className = o;
            var s = r.style;
            s.position = "absolute",
            s.width = "100%",
            s.height = "100%";
            var a = (i = Ni()).canvas;
            r.appendChild(a),
            (s = a.style).position = "absolute",
            s.left = "0",
            s.transformOrigin = "top left",
            this.container = r,
            this.context = i
        }
        this.containerReused || !n || this.container.style.backgroundColor || (this.container.style.backgroundColor = n)
    }, e.prototype.clipUnrotated = function(t, e, n) {
        var r = ee(n),
            i = ne(n),
            o = Wt(n),
            s = Yt(n);
        Et(e.coordinateToPixelTransform, r),
        Et(e.coordinateToPixelTransform, i),
        Et(e.coordinateToPixelTransform, o),
        Et(e.coordinateToPixelTransform, s);
        var a = this.inversePixelTransform;
        Et(a, r),
        Et(a, i),
        Et(a, o),
        Et(a, s),
        t.save(),
        t.beginPath(),
        t.moveTo(Math.round(r[0]), Math.round(r[1])),
        t.lineTo(Math.round(i[0]), Math.round(i[1])),
        t.lineTo(Math.round(o[0]), Math.round(o[1])),
        t.lineTo(Math.round(s[0]), Math.round(s[1])),
        t.clip()
    }, e.prototype.dispatchRenderEvent_ = function(t, e, n) {
        var r = this.getLayer();
        if (r.hasListener(t)) {
            var i = new (0, Si.default)(t, this.inversePixelTransform, n, e);
            r.dispatchEvent(i)
        }
    }, e.prototype.preRender = function(t, e) {
        this.frameState = e,
        this.dispatchRenderEvent_(mi.PRERENDER, t, e)
    }, e.prototype.postRender = function(t, e) {
        this.dispatchRenderEvent_(mi.POSTRENDER, t, e)
    }, e.prototype.getRenderTransform = function(t, e, n, r, i, o, s) {
        var a = i / 2,
            u = o / 2,
            l = r / e,
            h = -l,
            c = -t[0] + s,
            p = -t[1];
        return bt(this.tempTransform, a, u, l, h, -n, c, p)
    }, e.prototype.getDataAtPixel = function(t, e, n) {
        var r = Et(this.inversePixelTransform, t.slice()),
            i = this.context,
            o = this.getLayer().getExtent();
        if (o && !Ot(o, Et(e.pixelToCoordinateTransform, t.slice())))
            return null;
        var s,
            a = Math.round(r[0]),
            u = Math.round(r[1]),
            l = this.pixelContext_;
        if (!l) {
            var h = document.createElement("canvas");
            h.width = 1,
            h.height = 1,
            l = h.getContext("2d"),
            this.pixelContext_ = l
        }
        l.clearRect(0, 0, 1, 1);
        try {
            l.drawImage(i.canvas, a, u, 1, 1, 0, 0, 1, 1),
            s = l.getImageData(0, 0, 1, 1).data
        } catch (t) {
            return "SecurityError" === t.name ? (this.pixelContext_ = null, new Uint8Array) : s
        }
        return 0 === s[3] ? null : s
    }, e.prototype.disposeInternal = function() {
        delete this.frameState,
        t.prototype.disposeInternal.call(this)
    }, e
}($u.default);
function rl(t, e, n, r, i, o, s, a, u, l, h, c) {
    var p = t[e],
        f = t[e + 1],
        d = 0,
        g = 0,
        y = 0,
        v = 0;
    function m() {
        d = p,
        g = f,
        p = t[e += r],
        f = t[e + 1],
        v += y,
        y = Math.sqrt((p - d) * (p - d) + (f - g) * (f - g))
    }
    do {
        m()
    } while (e < n - r && v + y < o);
    for (var _ = 0 === y ? 0 : (o - v) / y, x = we(d, p, _), E = we(g, f, _), w = e - r, b = v, C = o + a * u(l, i, h); e < n - r && v + y < C;)
        m();
    var M,
        S = we(d, p, _ = 0 === y ? 0 : (C - v) / y),
        I = we(g, f, _);
    if (c) {
        var T = [x, E, S, I];
        Pn(T, 0, 4, 2, c, T, T),
        M = T[0] > T[2]
    } else
        M = x > S;
    var P,
        L = Math.PI,
        O = [],
        N = w + r === e;
    if (y = 0, v = b, p = t[e = w], f = t[e + 1], N) {
        m(),
        P = Math.atan2(f - g, p - d),
        M && (P += P > 0 ? -L : L);
        var R = (S + x) / 2,
            A = (I + E) / 2;
        return O[0] = [R, A, (C - o) / 2, P, i], O
    }
    for (var D = 0, F = (i = i.replace(/\n/g, " ")).length; D < F;) {
        m();
        var k = Math.atan2(f - g, p - d);
        if (M && (k += k > 0 ? -L : L), void 0 !== P) {
            var j = k - P;
            if (j += j > L ? -2 * L : j < -L ? 2 * L : 0, Math.abs(j) > s)
                return null
        }
        P = k;
        for (var G = D, B = 0; D < F; ++D) {
            var q = a * u(l, i[M ? F - D - 1 : D], h);
            if (e + r < n && v + y < o + B + q / 2)
                break;
            B += q
        }
        if (D !== G) {
            var z = M ? i.substring(F - G, F - D) : i.substring(G, D);
            R = we(d, p, _ = 0 === y ? 0 : (o + B / 2 - v) / y),
            A = we(g, f, _);
            O.push([R, A, B / 2, k, z]),
            o += B
        }
    }
    return O
}
var il = [1 / 0, 1 / 0, -1 / 0, -1 / 0],
    sl = [],
    al = [],
    ul = [],
    ll = [];
function hl(t) {
    return t[3].declutterBox
}
var cl = new RegExp("[" + String.fromCharCode(1425) + "-" + String.fromCharCode(2303) + String.fromCharCode(64285) + "-" + String.fromCharCode(65023) + String.fromCharCode(65136) + "-" + String.fromCharCode(65276) + String.fromCharCode(67584) + "-" + String.fromCharCode(69631) + String.fromCharCode(124928) + "-" + String.fromCharCode(126975) + "]");
function pl(t, e) {
    return "start" !== e && "end" !== e || cl.test(t) || (e = "start" === e ? "left" : "right"), Bu.TEXT_ALIGN[e]
}
function fl(t, e, n) {
    return n > 0 && t.push("\n", ""), t.push(e, ""), t
}
var dl = function() {
        function t(t, e, n, r) {
            this.overlaps = n,
            this.pixelRatio = e,
            this.resolution = t,
            this.alignFill_,
            this.instructions = r.instructions,
            this.coordinates = r.coordinates,
            this.coordinateCache_ = {},
            this.renderedTransform_ = [1, 0, 0, 1, 0, 0],
            this.hitDetectionInstructions = r.hitDetectionInstructions,
            this.pixelCoordinates_ = null,
            this.viewRotation_ = 0,
            this.fillStates = r.fillStates || {},
            this.strokeStates = r.strokeStates || {},
            this.textStates = r.textStates || {},
            this.widths_ = {},
            this.labels_ = {}
        }
        return t.prototype.createLabel = function(t, e, n, r) {
            var i = t + e + n + r;
            if (this.labels_[i])
                return this.labels_[i];
            var o = r ? this.strokeStates[r] : null,
                s = n ? this.fillStates[n] : null,
                a = this.textStates[e],
                u = this.pixelRatio,
                l = [a.scale[0] * u, a.scale[1] * u],
                h = Array.isArray(t),
                c = a.justify ? Bu.TEXT_ALIGN[a.justify] : pl(Array.isArray(t) ? t[0] : t, a.textAlign || "center"),
                p = r && o.lineWidth ? o.lineWidth : 0,
                f = h ? t : t.split("\n").reduce(fl, []),
                d = Ki(a, f),
                g = d.width,
                y = d.height,
                v = d.widths,
                m = d.heights,
                _ = d.lineWidths,
                x = g + p,
                E = [],
                w = (x + 2) * l[0],
                b = (y + p) * l[1],
                C = {
                    width: w < 0 ? Math.floor(w) : Math.ceil(w),
                    height: b < 0 ? Math.floor(b) : Math.ceil(b),
                    contextInstructions: E
                };
            (1 == l[0] && 1 == l[1] || E.push("scale", l), r) && (E.push("strokeStyle", o.strokeStyle), E.push("lineWidth", p), E.push("lineCap", o.lineCap), E.push("lineJoin", o.lineJoin), E.push("miterLimit", o.miterLimit), (vt ? OffscreenCanvasRenderingContext2D : CanvasRenderingContext2D).prototype.setLineDash && (E.push("setLineDash", [o.lineDash]), E.push("lineDashOffset", o.lineDashOffset)));
            n && E.push("fillStyle", s.fillStyle),
            E.push("textBaseline", "middle"),
            E.push("textAlign", "center");
            for (var M, S = .5 - c, I = c * x + S * p, T = [], P = [], L = 0, O = 0, N = 0, R = 0, A = 0, D = f.length; A < D; A += 2) {
                var F = f[A];
                if ("\n" !== F) {
                    var k = f[A + 1] || a.font;
                    k !== M && (r && T.push("font", k), n && P.push("font", k), M = k),
                    L = Math.max(L, m[N]);
                    var j = [F, I + S * v[N] + c * (v[N] - _[R]), .5 * (p + L) + O];
                    I += v[N],
                    r && T.push("strokeText", j),
                    n && P.push("fillText", j),
                    ++N
                } else
                    O += L,
                    L = 0,
                    I = c * x + S * p,
                    ++R
            }
            return Array.prototype.push.apply(E, T), Array.prototype.push.apply(E, P), this.labels_[i] = C, C
        }, t.prototype.replayTextBackground_ = function(t, e, n, r, i, o, s) {
            t.beginPath(),
            t.moveTo.apply(t, e),
            t.lineTo.apply(t, n),
            t.lineTo.apply(t, r),
            t.lineTo.apply(t, i),
            t.lineTo.apply(t, e),
            o && (this.alignFill_ = o[2], this.fill_(t)),
            s && (this.setStrokeStyle_(t, s), t.stroke())
        }, t.prototype.calculateImageOrLabelDimensions_ = function(t, e, n, r, i, o, s, a, u, l, h, c, p, f, d, g) {
            var y,
                v = n - (s *= c[0]),
                m = r - (a *= c[1]),
                _ = i + u > t ? t - u : i,
                x = o + l > e ? e - l : o,
                E = f[3] + _ * c[0] + f[1],
                w = f[0] + x * c[1] + f[2],
                b = v - f[3],
                C = m - f[0];
            return (d || 0 !== h) && (sl[0] = b, ll[0] = b, sl[1] = C, al[1] = C, al[0] = b + E, ul[0] = al[0], ul[1] = C + w, ll[1] = ul[1]), 0 !== h ? (Et(y = bt([1, 0, 0, 1, 0, 0], n, r, 1, 1, h, -n, -r), sl), Et(y, al), Et(y, ul), Et(y, ll), Ft(Math.min(sl[0], al[0], ul[0], ll[0]), Math.min(sl[1], al[1], ul[1], ll[1]), Math.max(sl[0], al[0], ul[0], ll[0]), Math.max(sl[1], al[1], ul[1], ll[1]), il)) : Ft(Math.min(b, b + E), Math.min(C, C + w), Math.max(b, b + E), Math.max(C, C + w), il), p && (v = Math.round(v), m = Math.round(m)), {
                drawImageX: v,
                drawImageY: m,
                drawImageW: _,
                drawImageH: x,
                originX: u,
                originY: l,
                declutterBox: {
                    minX: il[0],
                    minY: il[1],
                    maxX: il[2],
                    maxY: il[3],
                    value: g
                },
                canvasTransform: y,
                scale: c
            }
        }, t.prototype.replayImageOrLabel_ = function(t, e, n, r, i, o, s) {
            var a = !(!o && !s),
                u = r.declutterBox,
                l = t.canvas,
                h = s ? s[2] * r.scale[0] / 2 : 0;
            return u.minX - h <= l.width / e && u.maxX + h >= 0 && u.minY - h <= l.height / e && u.maxY + h >= 0 && (a && this.replayTextBackground_(t, sl, al, ul, ll, o, s), Zi(t, r.canvasTransform, i, n, r.originX, r.originY, r.drawImageW, r.drawImageH, r.drawImageX, r.drawImageY, r.scale)), !0
        }, t.prototype.fill_ = function(t) {
            if (this.alignFill_) {
                var e = Et(this.renderedTransform_, [0, 0]),
                    n = 512 * this.pixelRatio;
                t.save(),
                t.translate(e[0] % n, e[1] % n),
                t.rotate(this.viewRotation_)
            }
            t.fill(),
            this.alignFill_ && t.restore()
        }, t.prototype.setStrokeStyle_ = function(t, e) {
            t.strokeStyle = e[1],
            t.lineWidth = e[2],
            t.lineCap = e[3],
            t.lineJoin = e[4],
            t.miterLimit = e[5],
            t.setLineDash && (t.lineDashOffset = e[7], t.setLineDash(e[6]))
        }, t.prototype.drawLabelWithPointPlacement_ = function(t, e, n, r) {
            var i = this.textStates[e],
                o = this.createLabel(t, e, r, n),
                s = this.strokeStates[n],
                a = this.pixelRatio,
                u = pl(Array.isArray(t) ? t[0] : t, i.textAlign || "center"),
                l = Bu.TEXT_ALIGN[i.textBaseline || "middle"],
                h = s && s.lineWidth ? s.lineWidth : 0;
            return {
                label: o,
                anchorX: u * (o.width / a - 2 * i.scale[0]) + 2 * (.5 - u) * h,
                anchorY: l * o.height / a + 2 * (.5 - l) * h
            }
        }, t.prototype.execute_ = function(t, e, n, r, i, o, s, a) {
            var u,
                l,
                h;
            this.pixelCoordinates_ && M(n, this.renderedTransform_) ? u = this.pixelCoordinates_ : (this.pixelCoordinates_ || (this.pixelCoordinates_ = []), u = Tn(this.coordinates, 0, this.coordinates.length, 2, n, this.pixelCoordinates_), l = this.renderedTransform_, h = n, l[0] = h[0], l[1] = h[1], l[2] = h[2], l[3] = h[3], l[4] = h[4], l[5] = h[5]);
            for (var c, p, f, d, g, y, v, m, _, x, E, w, b, C, S, I, T = 0, P = r.length, L = 0, O = 0, N = 0, R = null, A = null, D = this.coordinateCache_, F = this.viewRotation_, k = Math.round(1e12 * Math.atan2(-n[1], n[0])) / 1e12, j = {
                    context: t,
                    pixelRatio: this.pixelRatio,
                    resolution: this.resolution,
                    rotation: F
                }, G = this.instructions != r || this.overlaps ? 0 : 200; T < P;) {
                var B = r[T];
                switch (B[0]) {
                case Iu.BEGIN_GEOMETRY:
                    b = B[1],
                    I = B[3],
                    b.getGeometry() ? void 0 === s || ie(s, I.getExtent()) ? ++T : T = B[2] + 1 : T = B[2];
                    break;
                case Iu.BEGIN_PATH:
                    O > G && (this.fill_(t), O = 0),
                    N > G && (t.stroke(), N = 0),
                    O || N || (t.beginPath(), d = NaN, g = NaN),
                    ++T;
                    break;
                case Iu.CIRCLE:
                    var q = u[L = B[1]],
                        z = u[L + 1],
                        U = u[L + 2] - q,
                        V = u[L + 3] - z,
                        X = Math.sqrt(U * U + V * V);
                    t.moveTo(q + X, z),
                    t.arc(q, z, X, 0, 2 * Math.PI, !0),
                    ++T;
                    break;
                case Iu.CLOSE_PATH:
                    t.closePath(),
                    ++T;
                    break;
                case Iu.CUSTOM:
                    L = B[1],
                    c = B[2];
                    var H = B[3],
                        Y = B[4],
                        W = 6 == B.length ? B[5] : void 0;
                    j.geometry = H,
                    j.feature = b,
                    T in D || (D[T] = []);
                    var $ = D[T];
                    W ? W(u, L, c, 2, $) : ($[0] = u[L], $[1] = u[L + 1], $.length = 2),
                    Y($, j),
                    ++T;
                    break;
                case Iu.DRAW_IMAGE:
                    L = B[1],
                    c = B[2],
                    m = B[3],
                    p = B[4],
                    f = B[5];
                    var K = B[6],
                        Z = B[7],
                        J = B[8],
                        Q = B[9],
                        tt = B[10],
                        et = B[11],
                        nt = B[12],
                        rt = B[13],
                        it = B[14],
                        ot = B[15];
                    if (!m && B.length >= 20) {
                        _ = B[19],
                        x = B[20],
                        E = B[21],
                        w = B[22];
                        var st = this.drawLabelWithPointPlacement_(_, x, E, w);
                        m = st.label,
                        B[3] = m;
                        var at = B[23];
                        p = (st.anchorX - at) * this.pixelRatio,
                        B[4] = p;
                        var ut = B[24];
                        f = (st.anchorY - ut) * this.pixelRatio,
                        B[5] = f,
                        K = m.height,
                        B[6] = K,
                        rt = m.width,
                        B[13] = rt
                    }
                    var lt = void 0;
                    B.length > 25 && (lt = B[25]);
                    var ht = void 0,
                        ct = void 0,
                        pt = void 0;
                    B.length > 17 ? (ht = B[16], ct = B[17], pt = B[18]) : (ht = Gi, ct = !1, pt = !1),
                    tt && k ? et += F : tt || k || (et -= F);
                    for (var ft = 0; L < c; L += 2)
                        if (!(lt && lt[ft++] < rt / this.pixelRatio)) {
                            var dt = [t, e, m, qt = this.calculateImageOrLabelDimensions_(m.width, m.height, u[L], u[L + 1], rt, K, p, f, J, Q, et, nt, i, ht, ct || pt, b), Z, ct ? R : null, pt ? A : null];
                            if (a) {
                                if ("none" === it)
                                    continue;
                                if ("obstacle" === it) {
                                    a.insert(qt.declutterBox);
                                    continue
                                }
                                var gt = void 0,
                                    yt = void 0;
                                if (ot) {
                                    var vt = c - L;
                                    if (!ot[vt]) {
                                        ot[vt] = dt;
                                        continue
                                    }
                                    if (gt = ot[vt], delete ot[vt], yt = hl(gt), a.collides(yt))
                                        continue
                                }
                                if (a.collides(qt.declutterBox))
                                    continue;
                                gt && (a.insert(yt), this.replayImageOrLabel_.apply(this, gt)),
                                a.insert(qt.declutterBox)
                            }
                            this.replayImageOrLabel_.apply(this, dt)
                        }
                    ++T;
                    break;
                case Iu.DRAW_CHARS:
                    var mt = B[1],
                        _t = B[2],
                        xt = B[3],
                        Et = B[4];
                    w = B[5];
                    var wt = B[6],
                        bt = B[7],
                        Ct = B[8];
                    E = B[9];
                    var Mt = B[10];
                    _ = B[11],
                    x = B[12];
                    var St = [B[13], B[13]],
                        It = this.textStates[x],
                        Tt = It.font,
                        Pt = [It.scale[0] * bt, It.scale[1] * bt],
                        Lt = void 0;
                    Tt in this.widths_ ? Lt = this.widths_[Tt] : (Lt = {}, this.widths_[Tt] = Lt);
                    var Ot = Fa(u, mt, _t, 2),
                        Nt = Math.abs(Pt[0]) * $i(Tt, _, Lt);
                    if (Et || Nt <= Ot) {
                        var Rt = this.textStates[x].textAlign,
                            At = rl(u, mt, _t, 2, _, (Ot - Nt) * Bu.TEXT_ALIGN[Rt], wt, Math.abs(Pt[0]), $i, Tt, Lt, k ? 0 : this.viewRotation_);
                        t:
                        if (At) {
                            var Dt = [],
                                Ft = void 0,
                                kt = void 0,
                                jt = void 0,
                                Gt = void 0,
                                Bt = void 0;
                            if (E)
                                for (Ft = 0, kt = At.length; Ft < kt; ++Ft) {
                                    jt = (Bt = At[Ft])[4],
                                    Gt = this.createLabel(jt, x, "", E),
                                    p = Bt[2] + (Pt[0] < 0 ? -Mt : Mt),
                                    f = xt * Gt.height + 2 * (.5 - xt) * Mt * Pt[1] / Pt[0] - Ct;
                                    var qt = this.calculateImageOrLabelDimensions_(Gt.width, Gt.height, Bt[0], Bt[1], Gt.width, Gt.height, p, f, 0, 0, Bt[3], St, !1, Gi, !1, b);
                                    if (a && a.collides(qt.declutterBox))
                                        break t;
                                    Dt.push([t, e, Gt, qt, 1, null, null])
                                }
                            if (w)
                                for (Ft = 0, kt = At.length; Ft < kt; ++Ft) {
                                    jt = (Bt = At[Ft])[4],
                                    Gt = this.createLabel(jt, x, w, ""),
                                    p = Bt[2],
                                    f = xt * Gt.height - Ct;
                                    qt = this.calculateImageOrLabelDimensions_(Gt.width, Gt.height, Bt[0], Bt[1], Gt.width, Gt.height, p, f, 0, 0, Bt[3], St, !1, Gi, !1, b);
                                    if (a && a.collides(qt.declutterBox))
                                        break t;
                                    Dt.push([t, e, Gt, qt, 1, null, null])
                                }
                            a && a.load(Dt.map(hl));
                            for (var zt = 0, Ut = Dt.length; zt < Ut; ++zt)
                                this.replayImageOrLabel_.apply(this, Dt[zt])
                        }
                    }
                    ++T;
                    break;
                case Iu.END_GEOMETRY:
                    if (void 0 !== o) {
                        var Vt = o(b = B[1], I);
                        if (Vt)
                            return Vt
                    }
                    ++T;
                    break;
                case Iu.FILL:
                    G ? O++ : this.fill_(t),
                    ++T;
                    break;
                case Iu.MOVE_TO_LINE_TO:
                    for (L = B[1], c = B[2], C = u[L], v = (S = u[L + 1]) + .5 | 0, (y = C + .5 | 0) === d && v === g || (t.moveTo(C, S), d = y, g = v), L += 2; L < c; L += 2)
                        y = (C = u[L]) + .5 | 0,
                        v = (S = u[L + 1]) + .5 | 0,
                        L != c - 2 && y === d && v === g || (t.lineTo(C, S), d = y, g = v);
                    ++T;
                    break;
                case Iu.SET_FILL_STYLE:
                    R = B,
                    this.alignFill_ = B[2],
                    O && (this.fill_(t), O = 0, N && (t.stroke(), N = 0)),
                    t.fillStyle = B[1],
                    ++T;
                    break;
                case Iu.SET_STROKE_STYLE:
                    A = B,
                    N && (t.stroke(), N = 0),
                    this.setStrokeStyle_(t, B),
                    ++T;
                    break;
                case Iu.STROKE:
                    G ? N++ : t.stroke(),
                    ++T;
                    break;
                default:
                    ++T
                }
            }
            O && this.fill_(t),
            N && t.stroke()
        }, t.prototype.execute = function(t, e, n, r, i, o) {
            this.viewRotation_ = r,
            this.execute_(t, e, n, this.instructions, i, void 0, void 0, o)
        }, t.prototype.executeHitDetection = function(t, e, n, r, i) {
            return this.viewRotation_ = n, this.execute_(t, 1, e, this.hitDetectionInstructions, !0, r, i)
        }, t
    }(),
    gl = ["Polygon", "Circle", "LineString", "Image", "Text", "Default"],
    yl = function() {
        function t(t, e, n, r, i, o) {
            this.maxExtent_ = t,
            this.overlaps_ = r,
            this.pixelRatio_ = n,
            this.resolution_ = e,
            this.renderBuffer_ = o,
            this.executorsByZIndex_ = {},
            this.hitDetectionContext_ = null,
            this.hitDetectionTransform_ = [1, 0, 0, 1, 0, 0],
            this.createExecutors_(i)
        }
        return t.prototype.clip = function(t, e) {
            var n = this.getClipCoords(e);
            t.beginPath(),
            t.moveTo(n[0], n[1]),
            t.lineTo(n[2], n[3]),
            t.lineTo(n[4], n[5]),
            t.lineTo(n[6], n[7]),
            t.clip()
        }, t.prototype.createExecutors_ = function(t) {
            for (var e in t) {
                var n = this.executorsByZIndex_[e];
                void 0 === n && (n = {}, this.executorsByZIndex_[e] = n);
                var r = t[e];
                for (var i in r) {
                    var o = r[i];
                    n[i] = new dl(this.resolution_, this.pixelRatio_, this.overlaps_, o)
                }
            }
        }, t.prototype.hasExecutors = function(t) {
            for (var e in this.executorsByZIndex_)
                for (var n = this.executorsByZIndex_[e], r = 0, i = t.length; r < i; ++r)
                    if (t[r] in n)
                        return !0;
            return !1
        }, t.prototype.forEachFeatureAtCoordinate = function(t, e, n, r, i, o) {
            var s = 2 * (r = Math.round(r)) + 1,
                a = bt(this.hitDetectionTransform_, r + .5, r + .5, 1 / e, -1 / e, -n, -t[0], -t[1]),
                u = !this.hitDetectionContext_;
            u && (this.hitDetectionContext_ = Ni(s, s));
            var l,
                h = this.hitDetectionContext_;
            h.canvas.width !== s || h.canvas.height !== s ? (h.canvas.width = s, h.canvas.height = s) : u || h.clearRect(0, 0, s, s),
            void 0 !== this.renderBuffer_ && (zt(l = [1 / 0, 1 / 0, -1 / 0, -1 / 0], t), Tt(l, e * (this.renderBuffer_ + r), l));
            var c,
                p = function(t) {
                    if (void 0 !== vl[t])
                        return vl[t];
                    for (var e = 2 * t + 1, n = t * t, r = new Array(n + 1), i = 0; i <= t; ++i)
                        for (var o = 0; o <= t; ++o) {
                            var s = i * i + o * o;
                            if (s > n)
                                break;
                            var a = r[s];
                            a || (a = [], r[s] = a),
                            a.push(4 * ((t + i) * e + (t + o)) + 3),
                            i > 0 && a.push(4 * ((t - i) * e + (t + o)) + 3),
                            o > 0 && (a.push(4 * ((t + i) * e + (t - o)) + 3), i > 0 && a.push(4 * ((t - i) * e + (t - o)) + 3))
                        }
                    for (var u = [], l = (i = 0, r.length); i < l; ++i)
                        r[i] && u.push.apply(u, r[i]);
                    return vl[t] = u, u
                }(r);
            function f(t, e) {
                for (var n = h.getImageData(0, 0, s, s).data, a = 0, u = p.length; a < u; a++)
                    if (n[p[a]] > 0) {
                        if (!o || "Image" !== c && "Text" !== c || -1 !== o.indexOf(t)) {
                            var l = (p[a] - 3) / 4,
                                f = r - l % s,
                                d = r - (l / s | 0),
                                g = i(t, e, f * f + d * d);
                            if (g)
                                return g
                        }
                        h.clearRect(0, 0, s, s);
                        break
                    }
            }
            var d,
                g,
                y,
                v,
                m,
                _ = Object.keys(this.executorsByZIndex_).map(Number);
            for (_.sort(E), d = _.length - 1; d >= 0; --d) {
                var x = _[d].toString();
                for (y = this.executorsByZIndex_[x], g = gl.length - 1; g >= 0; --g)
                    if (void 0 !== (v = y[c = gl[g]]) && (m = v.executeHitDetection(h, a, n, f, l)))
                        return m
            }
        }, t.prototype.getClipCoords = function(t) {
            var e = this.maxExtent_;
            if (!e)
                return null;
            var n = e[0],
                r = e[1],
                i = e[2],
                o = e[3],
                s = [n, r, n, o, i, o, i, r];
            return Tn(s, 0, 8, 2, t, s), s
        }, t.prototype.isEmpty = function() {
            return N(this.executorsByZIndex_)
        }, t.prototype.execute = function(t, e, n, r, i, o, s) {
            var a = Object.keys(this.executorsByZIndex_).map(Number);
            a.sort(E),
            this.maxExtent_ && (t.save(), this.clip(t, n));
            var u,
                l,
                h,
                c,
                p,
                f,
                d = o || gl;
            for (s && a.reverse(), u = 0, l = a.length; u < l; ++u) {
                var g = a[u].toString();
                for (p = this.executorsByZIndex_[g], h = 0, c = d.length; h < c; ++h) {
                    void 0 !== (f = p[d[h]]) && f.execute(t, e, n, r, i, s)
                }
            }
            this.maxExtent_ && t.restore()
        }, t
    }(),
    vl = {};
var ml = yl,
    _l = {};
t(_l, "default", (() => El), (t => El = t));
var xl = function() {
        var t = function(e, n) {
            return t = Object.setPrototypeOf || {
                __proto__: []
            } instanceof Array && function(t, e) {
                t.__proto__ = e
            } || function(t, e) {
                for (var n in e)
                    Object.prototype.hasOwnProperty.call(e, n) && (t[n] = e[n])
            }, t(e, n)
        };
        return function(e, n) {
            if ("function" != typeof n && null !== n)
                throw new TypeError("Class extends value " + String(n) + " is not a constructor or null");
            function r() {
                this.constructor = e
            }
            t(e, n),
            e.prototype = null === n ? Object.create(n) : (r.prototype = n.prototype, new r)
        }
    }(),
    El = function(t) {
        function e(e, n, r, i, o, s, a) {
            var u = t.call(this) || this;
            return u.context_ = e, u.pixelRatio_ = n, u.extent_ = r, u.transform_ = i, u.viewRotation_ = o, u.squaredTolerance_ = s, u.userTransform_ = a, u.contextFillState_ = null, u.contextStrokeState_ = null, u.contextTextState_ = null, u.fillState_ = null, u.strokeState_ = null, u.image_ = null, u.imageAnchorX_ = 0, u.imageAnchorY_ = 0, u.imageHeight_ = 0, u.imageOpacity_ = 0, u.imageOriginX_ = 0, u.imageOriginY_ = 0, u.imageRotateWithView_ = !1, u.imageRotation_ = 0, u.imageScale_ = [0, 0], u.imageWidth_ = 0, u.text_ = "", u.textOffsetX_ = 0, u.textOffsetY_ = 0, u.textRotateWithView_ = !1, u.textRotation_ = 0, u.textScale_ = [0, 0], u.textFillState_ = null, u.textStrokeState_ = null, u.textState_ = null, u.pixelCoordinates_ = [], u.tmpLocalTransform_ = [1, 0, 0, 1, 0, 0], u
        }
        return xl(e, t), e.prototype.drawImages_ = function(t, e, n, r) {
            if (this.image_) {
                var i = Tn(t, e, n, r, this.transform_, this.pixelCoordinates_),
                    o = this.context_,
                    s = this.tmpLocalTransform_,
                    a = o.globalAlpha;
                1 != this.imageOpacity_ && (o.globalAlpha = a * this.imageOpacity_);
                var u = this.imageRotation_;
                this.imageRotateWithView_ && (u += this.viewRotation_);
                for (var l = 0, h = i.length; l < h; l += 2) {
                    var c = i[l] - this.imageAnchorX_,
                        p = i[l + 1] - this.imageAnchorY_;
                    if (0 !== u || 1 != this.imageScale_[0] || 1 != this.imageScale_[1]) {
                        var f = c + this.imageAnchorX_,
                            d = p + this.imageAnchorY_;
                        bt(s, f, d, 1, 1, u, -f, -d),
                        o.setTransform.apply(o, s),
                        o.translate(f, d),
                        o.scale(this.imageScale_[0], this.imageScale_[1]),
                        o.drawImage(this.image_, this.imageOriginX_, this.imageOriginY_, this.imageWidth_, this.imageHeight_, -this.imageAnchorX_, -this.imageAnchorY_, this.imageWidth_, this.imageHeight_),
                        o.setTransform(1, 0, 0, 1, 0, 0)
                    } else
                        o.drawImage(this.image_, this.imageOriginX_, this.imageOriginY_, this.imageWidth_, this.imageHeight_, c, p, this.imageWidth_, this.imageHeight_)
                }
                1 != this.imageOpacity_ && (o.globalAlpha = a)
            }
        }, e.prototype.drawText_ = function(t, e, n, r) {
            if (this.textState_ && "" !== this.text_) {
                this.textFillState_ && this.setContextFillState_(this.textFillState_),
                this.textStrokeState_ && this.setContextStrokeState_(this.textStrokeState_),
                this.setContextTextState_(this.textState_);
                var i = Tn(t, e, n, r, this.transform_, this.pixelCoordinates_),
                    o = this.context_,
                    s = this.textRotation_;
                for (this.textRotateWithView_ && (s += this.viewRotation_); e < n; e += r) {
                    var a = i[e] + this.textOffsetX_,
                        u = i[e + 1] + this.textOffsetY_;
                    if (0 !== s || 1 != this.textScale_[0] || 1 != this.textScale_[1]) {
                        var l = bt(this.tmpLocalTransform_, a, u, 1, 1, s, -a, -u);
                        o.setTransform.apply(o, l),
                        o.translate(a, u),
                        o.scale(this.textScale_[0], this.textScale_[1]),
                        this.textStrokeState_ && o.strokeText(this.text_, 0, 0),
                        this.textFillState_ && o.fillText(this.text_, 0, 0),
                        o.setTransform(1, 0, 0, 1, 0, 0)
                    } else
                        this.textStrokeState_ && o.strokeText(this.text_, a, u),
                        this.textFillState_ && o.fillText(this.text_, a, u)
                }
            }
        }, e.prototype.moveToLineTo_ = function(t, e, n, r, i) {
            var o = this.context_,
                s = Tn(t, e, n, r, this.transform_, this.pixelCoordinates_);
            o.moveTo(s[0], s[1]);
            var a = s.length;
            i && (a -= 2);
            for (var u = 2; u < a; u += 2)
                o.lineTo(s[u], s[u + 1]);
            return i && o.closePath(), n
        }, e.prototype.drawRings_ = function(t, e, n, r) {
            for (var i = 0, o = n.length; i < o; ++i)
                e = this.moveToLineTo_(t, e, n[i], r, !0);
            return e
        }, e.prototype.drawCircle = function(t) {
            if (ie(this.extent_, t.getExtent())) {
                if (this.fillState_ || this.strokeState_) {
                    this.fillState_ && this.setContextFillState_(this.fillState_),
                    this.strokeState_ && this.setContextStrokeState_(this.strokeState_);
                    var e = (0, st.transformGeom2D)(t, this.transform_, this.pixelCoordinates_),
                        n = e[2] - e[0],
                        r = e[3] - e[1],
                        i = Math.sqrt(n * n + r * r),
                        o = this.context_;
                    o.beginPath(),
                    o.arc(e[0], e[1], i, 0, 2 * Math.PI),
                    this.fillState_ && o.fill(),
                    this.strokeState_ && o.stroke()
                }
                "" !== this.text_ && this.drawText_(t.getCenter(), 0, 2, 2)
            }
        }, e.prototype.setStyle = function(t) {
            this.setFillStrokeStyle(t.getFill(), t.getStroke()),
            this.setImageStyle(t.getImage()),
            this.setTextStyle(t.getText())
        }, e.prototype.setTransform = function(t) {
            this.transform_ = t
        }, e.prototype.drawGeometry = function(t) {
            switch (t.getType()) {
            case "Point":
                this.drawPoint(t);
                break;
            case "LineString":
                this.drawLineString(t);
                break;
            case "Polygon":
                this.drawPolygon(t);
                break;
            case "MultiPoint":
                this.drawMultiPoint(t);
                break;
            case "MultiLineString":
                this.drawMultiLineString(t);
                break;
            case "MultiPolygon":
                this.drawMultiPolygon(t);
                break;
            case "GeometryCollection":
                this.drawGeometryCollection(t);
                break;
            case "Circle":
                this.drawCircle(t)
            }
        }, e.prototype.drawFeature = function(t, e) {
            var n = e.getGeometryFunction()(t);
            n && ie(this.extent_, n.getExtent()) && (this.setStyle(e), this.drawGeometry(n))
        }, e.prototype.drawGeometryCollection = function(t) {
            for (var e = t.getGeometriesArray(), n = 0, r = e.length; n < r; ++n)
                this.drawGeometry(e[n])
        }, e.prototype.drawPoint = function(t) {
            this.squaredTolerance_ && (t = t.simplifyTransformed(this.squaredTolerance_, this.userTransform_));
            var e = t.getFlatCoordinates(),
                n = t.getStride();
            this.image_ && this.drawImages_(e, 0, e.length, n),
            "" !== this.text_ && this.drawText_(e, 0, e.length, n)
        }, e.prototype.drawMultiPoint = function(t) {
            this.squaredTolerance_ && (t = t.simplifyTransformed(this.squaredTolerance_, this.userTransform_));
            var e = t.getFlatCoordinates(),
                n = t.getStride();
            this.image_ && this.drawImages_(e, 0, e.length, n),
            "" !== this.text_ && this.drawText_(e, 0, e.length, n)
        }, e.prototype.drawLineString = function(t) {
            if (this.squaredTolerance_ && (t = t.simplifyTransformed(this.squaredTolerance_, this.userTransform_)), ie(this.extent_, t.getExtent())) {
                if (this.strokeState_) {
                    this.setContextStrokeState_(this.strokeState_);
                    var e = this.context_,
                        n = t.getFlatCoordinates();
                    e.beginPath(),
                    this.moveToLineTo_(n, 0, n.length, t.getStride(), !1),
                    e.stroke()
                }
                if ("" !== this.text_) {
                    var r = t.getFlatMidpoint();
                    this.drawText_(r, 0, 2, 2)
                }
            }
        }, e.prototype.drawMultiLineString = function(t) {
            this.squaredTolerance_ && (t = t.simplifyTransformed(this.squaredTolerance_, this.userTransform_));
            var e = t.getExtent();
            if (ie(this.extent_, e)) {
                if (this.strokeState_) {
                    this.setContextStrokeState_(this.strokeState_);
                    var n = this.context_,
                        r = t.getFlatCoordinates(),
                        i = 0,
                        o = t.getEnds(),
                        s = t.getStride();
                    n.beginPath();
                    for (var a = 0, u = o.length; a < u; ++a)
                        i = this.moveToLineTo_(r, i, o[a], s, !1);
                    n.stroke()
                }
                if ("" !== this.text_) {
                    var l = t.getFlatMidpoints();
                    this.drawText_(l, 0, l.length, 2)
                }
            }
        }, e.prototype.drawPolygon = function(t) {
            if (this.squaredTolerance_ && (t = t.simplifyTransformed(this.squaredTolerance_, this.userTransform_)), ie(this.extent_, t.getExtent())) {
                if (this.strokeState_ || this.fillState_) {
                    this.fillState_ && this.setContextFillState_(this.fillState_),
                    this.strokeState_ && this.setContextStrokeState_(this.strokeState_);
                    var e = this.context_;
                    e.beginPath(),
                    this.drawRings_(t.getOrientedFlatCoordinates(), 0, t.getEnds(), t.getStride()),
                    this.fillState_ && e.fill(),
                    this.strokeState_ && e.stroke()
                }
                if ("" !== this.text_) {
                    var n = t.getFlatInteriorPoint();
                    this.drawText_(n, 0, 2, 2)
                }
            }
        }, e.prototype.drawMultiPolygon = function(t) {
            if (this.squaredTolerance_ && (t = t.simplifyTransformed(this.squaredTolerance_, this.userTransform_)), ie(this.extent_, t.getExtent())) {
                if (this.strokeState_ || this.fillState_) {
                    this.fillState_ && this.setContextFillState_(this.fillState_),
                    this.strokeState_ && this.setContextStrokeState_(this.strokeState_);
                    var e = this.context_,
                        n = t.getOrientedFlatCoordinates(),
                        r = 0,
                        i = t.getEndss(),
                        o = t.getStride();
                    e.beginPath();
                    for (var s = 0, a = i.length; s < a; ++s) {
                        var u = i[s];
                        r = this.drawRings_(n, r, u, o)
                    }
                    this.fillState_ && e.fill(),
                    this.strokeState_ && e.stroke()
                }
                if ("" !== this.text_) {
                    var l = t.getFlatInteriorPoints();
                    this.drawText_(l, 0, l.length, 2)
                }
            }
        }, e.prototype.setContextFillState_ = function(t) {
            var e = this.context_,
                n = this.contextFillState_;
            n ? n.fillStyle != t.fillStyle && (n.fillStyle = t.fillStyle, e.fillStyle = t.fillStyle) : (e.fillStyle = t.fillStyle, this.contextFillState_ = {
                fillStyle: t.fillStyle
            })
        }, e.prototype.setContextStrokeState_ = function(t) {
            var e = this.context_,
                n = this.contextStrokeState_;
            n ? (n.lineCap != t.lineCap && (n.lineCap = t.lineCap, e.lineCap = t.lineCap), e.setLineDash && (M(n.lineDash, t.lineDash) || e.setLineDash(n.lineDash = t.lineDash), n.lineDashOffset != t.lineDashOffset && (n.lineDashOffset = t.lineDashOffset, e.lineDashOffset = t.lineDashOffset)), n.lineJoin != t.lineJoin && (n.lineJoin = t.lineJoin, e.lineJoin = t.lineJoin), n.lineWidth != t.lineWidth && (n.lineWidth = t.lineWidth, e.lineWidth = t.lineWidth), n.miterLimit != t.miterLimit && (n.miterLimit = t.miterLimit, e.miterLimit = t.miterLimit), n.strokeStyle != t.strokeStyle && (n.strokeStyle = t.strokeStyle, e.strokeStyle = t.strokeStyle)) : (e.lineCap = t.lineCap, e.setLineDash && (e.setLineDash(t.lineDash), e.lineDashOffset = t.lineDashOffset), e.lineJoin = t.lineJoin, e.lineWidth = t.lineWidth, e.miterLimit = t.miterLimit, e.strokeStyle = t.strokeStyle, this.contextStrokeState_ = {
                lineCap: t.lineCap,
                lineDash: t.lineDash,
                lineDashOffset: t.lineDashOffset,
                lineJoin: t.lineJoin,
                lineWidth: t.lineWidth,
                miterLimit: t.miterLimit,
                strokeStyle: t.strokeStyle
            })
        }, e.prototype.setContextTextState_ = function(t) {
            var e = this.context_,
                n = this.contextTextState_,
                r = t.textAlign ? t.textAlign : "center";
            n ? (n.font != t.font && (n.font = t.font, e.font = t.font), n.textAlign != r && (n.textAlign = r, e.textAlign = r), n.textBaseline != t.textBaseline && (n.textBaseline = t.textBaseline, e.textBaseline = t.textBaseline)) : (e.font = t.font, e.textAlign = r, e.textBaseline = t.textBaseline, this.contextTextState_ = {
                font: t.font,
                textAlign: r,
                textBaseline: t.textBaseline
            })
        }, e.prototype.setFillStrokeStyle = function(t, e) {
            var n = this;
            if (t) {
                var r = t.getColor();
                this.fillState_ = {
                    fillStyle: ru(r || "#000")
                }
            } else
                this.fillState_ = null;
            if (e) {
                var i = e.getColor(),
                    o = e.getLineCap(),
                    s = e.getLineDash(),
                    a = e.getLineDashOffset(),
                    u = e.getLineJoin(),
                    l = e.getWidth(),
                    h = e.getMiterLimit(),
                    c = s || ji;
                this.strokeState_ = {
                    lineCap: void 0 !== o ? o : "round",
                    lineDash: 1 === this.pixelRatio_ ? c : c.map((function(t) {
                        return t * n.pixelRatio_
                    })),
                    lineDashOffset: (a || 0) * this.pixelRatio_,
                    lineJoin: void 0 !== u ? u : "round",
                    lineWidth: (void 0 !== l ? l : 1) * this.pixelRatio_,
                    miterLimit: void 0 !== h ? h : 10,
                    strokeStyle: ru(i || "#000")
                }
            } else
                this.strokeState_ = null
        }, e.prototype.setImageStyle = function(t) {
            var e;
            if (t && (e = t.getSize())) {
                var n = t.getAnchor(),
                    r = t.getOrigin();
                this.image_ = t.getImage(this.pixelRatio_),
                this.imageAnchorX_ = n[0] * this.pixelRatio_,
                this.imageAnchorY_ = n[1] * this.pixelRatio_,
                this.imageHeight_ = e[1] * this.pixelRatio_,
                this.imageOpacity_ = t.getOpacity(),
                this.imageOriginX_ = r[0],
                this.imageOriginY_ = r[1],
                this.imageRotateWithView_ = t.getRotateWithView(),
                this.imageRotation_ = t.getRotation(),
                this.imageScale_ = t.getScaleArray(),
                this.imageWidth_ = e[0] * this.pixelRatio_
            } else
                this.image_ = null
        }, e.prototype.setTextStyle = function(t) {
            if (t) {
                var e = t.getFill();
                if (e) {
                    var n = e.getColor();
                    this.textFillState_ = {
                        fillStyle: ru(n || "#000")
                    }
                } else
                    this.textFillState_ = null;
                var r = t.getStroke();
                if (r) {
                    var i = r.getColor(),
                        o = r.getLineCap(),
                        s = r.getLineDash(),
                        a = r.getLineDashOffset(),
                        u = r.getLineJoin(),
                        l = r.getWidth(),
                        h = r.getMiterLimit();
                    this.textStrokeState_ = {
                        lineCap: void 0 !== o ? o : "round",
                        lineDash: s || ji,
                        lineDashOffset: a || 0,
                        lineJoin: void 0 !== u ? u : "round",
                        lineWidth: void 0 !== l ? l : 1,
                        miterLimit: void 0 !== h ? h : 10,
                        strokeStyle: ru(i || "#000")
                    }
                } else
                    this.textStrokeState_ = null;
                var c = t.getFont(),
                    p = t.getOffsetX(),
                    f = t.getOffsetY(),
                    d = t.getRotateWithView(),
                    g = t.getRotation(),
                    y = t.getScaleArray(),
                    v = t.getText(),
                    m = t.getTextAlign(),
                    _ = t.getTextBaseline();
                this.textState_ = {
                    font: void 0 !== c ? c : "10px sans-serif",
                    textAlign: void 0 !== m ? m : "center",
                    textBaseline: void 0 !== _ ? _ : "middle"
                },
                this.text_ = void 0 !== v ? Array.isArray(v) ? v.reduce((function(t, e, n) {
                    return t + (n % 2 ? " " : e)
                }), "") : v : "",
                this.textOffsetX_ = void 0 !== p ? this.pixelRatio_ * p : 0,
                this.textOffsetY_ = void 0 !== f ? this.pixelRatio_ * f : 0,
                this.textRotateWithView_ = void 0 !== d && d,
                this.textRotation_ = void 0 !== g ? g : 0,
                this.textScale_ = [this.pixelRatio_ * y[0], this.pixelRatio_ * y[1]]
            } else
                this.text_ = ""
        }, e
    }(Tu),
    wl = {
        FRACTION: "fraction",
        PIXELS: "pixels"
    },
    bl = {};
t(bl, "default", (() => kl), (t => kl = t));
var Cl = {
        BOTTOM_LEFT: "bottom-left",
        BOTTOM_RIGHT: "bottom-right",
        TOP_LEFT: "top-left",
        TOP_RIGHT: "top-right"
    },
    Ml = {};
t(Ml, "get", (() => Dl), (t => Dl = t));
var Sl = {};
t(Sl, "listenImage", (() => Ol), (t => Ol = t));
var Il = {};
t(Il, "default", (() => Pl), (t => Pl = t));
var Tl = function() {
        var t = function(e, n) {
            return t = Object.setPrototypeOf || {
                __proto__: []
            } instanceof Array && function(t, e) {
                t.__proto__ = e
            } || function(t, e) {
                for (var n in e)
                    Object.prototype.hasOwnProperty.call(e, n) && (t[n] = e[n])
            }, t(e, n)
        };
        return function(e, n) {
            if ("function" != typeof n && null !== n)
                throw new TypeError("Class extends value " + String(n) + " is not a constructor or null");
            function r() {
                this.constructor = e
            }
            t(e, n),
            e.prototype = null === n ? Object.create(n) : (r.prototype = n.prototype, new r)
        }
    }(),
    Pl = function(t) {
        function e(e, n, r, i) {
            var o = t.call(this) || this;
            return o.extent = e, o.pixelRatio_ = r, o.resolution = n, o.state = i, o
        }
        return Tl(e, t), e.prototype.changed = function() {
            this.dispatchEvent(D.CHANGE)
        }, e.prototype.getExtent = function() {
            return this.extent
        }, e.prototype.getImage = function() {
            return u()
        }, e.prototype.getPixelRatio = function() {
            return this.pixelRatio_
        }, e.prototype.getResolution = function() {
            return this.resolution
        }, e.prototype.getState = function() {
            return this.state
        }, e.prototype.load = function() {
            u()
        }, e
    }(m.default),
    Ll = function() {
        var t = function(e, n) {
            return t = Object.setPrototypeOf || {
                __proto__: []
            } instanceof Array && function(t, e) {
                t.__proto__ = e
            } || function(t, e) {
                for (var n in e)
                    Object.prototype.hasOwnProperty.call(e, n) && (t[n] = e[n])
            }, t(e, n)
        };
        return function(e, n) {
            if ("function" != typeof n && null !== n)
                throw new TypeError("Class extends value " + String(n) + " is not a constructor or null");
            function r() {
                this.constructor = e
            }
            t(e, n),
            e.prototype = null === n ? Object.create(n) : (r.prototype = n.prototype, new r)
        }
    }();
function Ol(t, e, n) {
    var r = t,
        i = !0,
        o = !1,
        s = !1,
        a = [k(r, D.LOAD, (function() {
            s = !0,
            o || e()
        }))];
    return r.src && mt ? (o = !0, r.decode().then((function() {
        i && e()
    })).catch((function(t) {
        i && (s ? e() : n())
    }))) : a.push(k(r, D.ERROR, n)), function() {
        i = !1,
        a.forEach(j)
    }
}
!function(t) {
    function e(e, n, r, i, o, s) {
        var a = t.call(this, e, n, r, eu.IDLE) || this;
        return a.src_ = i, a.image_ = new Image, null !== o && (a.image_.crossOrigin = o), a.unlisten_ = null, a.state = eu.IDLE, a.imageLoadFunction_ = s, a
    }
    Ll(e, t),
    e.prototype.getImage = function() {
        return this.image_
    },
    e.prototype.handleImageError_ = function() {
        this.state = eu.ERROR,
        this.unlistenImage_(),
        this.changed()
    },
    e.prototype.handleImageLoad_ = function() {
        void 0 === this.resolution && (this.resolution = Qt(this.extent) / this.image_.height),
        this.state = eu.LOADED,
        this.unlistenImage_(),
        this.changed()
    },
    e.prototype.load = function() {
        this.state != eu.IDLE && this.state != eu.ERROR || (this.state = eu.LOADING, this.changed(), this.imageLoadFunction_(this, this.src_), this.unlisten_ = Ol(this.image_, this.handleImageLoad_.bind(this), this.handleImageError_.bind(this)))
    },
    e.prototype.setImage = function(t) {
        this.image_ = t,
        this.resolution = Qt(this.extent) / this.image_.height
    },
    e.prototype.unlistenImage_ = function() {
        this.unlisten_ && (this.unlisten_(), this.unlisten_ = null)
    }
}(Il.default);
var Nl = function() {
        var t = function(e, n) {
            return t = Object.setPrototypeOf || {
                __proto__: []
            } instanceof Array && function(t, e) {
                t.__proto__ = e
            } || function(t, e) {
                for (var n in e)
                    Object.prototype.hasOwnProperty.call(e, n) && (t[n] = e[n])
            }, t(e, n)
        };
        return function(e, n) {
            if ("function" != typeof n && null !== n)
                throw new TypeError("Class extends value " + String(n) + " is not a constructor or null");
            function r() {
                this.constructor = e
            }
            t(e, n),
            e.prototype = null === n ? Object.create(n) : (r.prototype = n.prototype, new r)
        }
    }(),
    Rl = null,
    Al = function(t) {
        function e(e, n, r, i, o, s) {
            var a = t.call(this) || this;
            return a.hitDetectionImage_ = null, a.image_ = e || new Image, null !== i && (a.image_.crossOrigin = i), a.canvas_ = {}, a.color_ = s, a.unlisten_ = null, a.imageState_ = o, a.size_ = r, a.src_ = n, a.tainted_, a
        }
        return Nl(e, t), e.prototype.isTainted_ = function() {
            if (void 0 === this.tainted_ && this.imageState_ === eu.LOADED) {
                Rl || (Rl = Ni(1, 1)),
                Rl.drawImage(this.image_, 0, 0);
                try {
                    Rl.getImageData(0, 0, 1, 1),
                    this.tainted_ = !1
                } catch (t) {
                    Rl = null,
                    this.tainted_ = !0
                }
            }
            return !0 === this.tainted_
        }, e.prototype.dispatchChangeEvent_ = function() {
            this.dispatchEvent(D.CHANGE)
        }, e.prototype.handleImageError_ = function() {
            this.imageState_ = eu.ERROR,
            this.unlistenImage_(),
            this.dispatchChangeEvent_()
        }, e.prototype.handleImageLoad_ = function() {
            this.imageState_ = eu.LOADED,
            this.size_ ? (this.image_.width = this.size_[0], this.image_.height = this.size_[1]) : this.size_ = [this.image_.width, this.image_.height],
            this.unlistenImage_(),
            this.dispatchChangeEvent_()
        }, e.prototype.getImage = function(t) {
            return this.replaceColor_(t), this.canvas_[t] ? this.canvas_[t] : this.image_
        }, e.prototype.getPixelRatio = function(t) {
            return this.replaceColor_(t), this.canvas_[t] ? t : 1
        }, e.prototype.getImageState = function() {
            return this.imageState_
        }, e.prototype.getHitDetectionImage = function() {
            if (!this.hitDetectionImage_)
                if (this.isTainted_()) {
                    var t = this.size_[0],
                        e = this.size_[1],
                        n = Ni(t, e);
                    n.fillRect(0, 0, t, e),
                    this.hitDetectionImage_ = n.canvas
                } else
                    this.hitDetectionImage_ = this.image_;
            return this.hitDetectionImage_
        }, e.prototype.getSize = function() {
            return this.size_
        }, e.prototype.getSrc = function() {
            return this.src_
        }, e.prototype.load = function() {
            if (this.imageState_ == eu.IDLE) {
                this.imageState_ = eu.LOADING;
                try {
                    this.image_.src = this.src_
                } catch (t) {
                    this.handleImageError_()
                }
                this.unlisten_ = (0, Sl.listenImage)(this.image_, this.handleImageLoad_.bind(this), this.handleImageError_.bind(this))
            }
        }, e.prototype.replaceColor_ = function(t) {
            if (this.color_ && !this.canvas_[t] && this.imageState_ === eu.LOADED) {
                var e = document.createElement("canvas");
                this.canvas_[t] = e,
                e.width = Math.ceil(this.image_.width * t),
                e.height = Math.ceil(this.image_.height * t);
                var n = e.getContext("2d");
                if (n.scale(t, t), n.drawImage(this.image_, 0, 0), n.globalCompositeOperation = "multiply", "multiply" === n.globalCompositeOperation || this.isTainted_())
                    n.fillStyle = ni(this.color_),
                    n.fillRect(0, 0, e.width / t, e.height / t),
                    n.globalCompositeOperation = "destination-in",
                    n.drawImage(this.image_, 0, 0);
                else {
                    for (var r = n.getImageData(0, 0, e.width, e.height), i = r.data, o = this.color_[0] / 255, s = this.color_[1] / 255, a = this.color_[2] / 255, u = this.color_[3], l = 0, h = i.length; l < h; l += 4)
                        i[l] *= o,
                        i[l + 1] *= s,
                        i[l + 2] *= a,
                        i[l + 3] *= u;
                    n.putImageData(r, 0, 0)
                }
            }
        }, e.prototype.unlistenImage_ = function() {
            this.unlisten_ && (this.unlisten_(), this.unlisten_ = null)
        }, e
    }(m.default);
function Dl(t, e, n, r, i, o) {
    var s = pi.get(e, r, o);
    return s || (s = new Al(t, e, n, r, i, o), pi.set(e, r, o, s)), s
}
var Fl = function() {
        var t = function(e, n) {
            return t = Object.setPrototypeOf || {
                __proto__: []
            } instanceof Array && function(t, e) {
                t.__proto__ = e
            } || function(t, e) {
                for (var n in e)
                    Object.prototype.hasOwnProperty.call(e, n) && (t[n] = e[n])
            }, t(e, n)
        };
        return function(e, n) {
            if ("function" != typeof n && null !== n)
                throw new TypeError("Class extends value " + String(n) + " is not a constructor or null");
            function r() {
                this.constructor = e
            }
            t(e, n),
            e.prototype = null === n ? Object.create(n) : (r.prototype = n.prototype, new r)
        }
    }(),
    kl = function(t) {
        function e(e) {
            var n = this,
                r = e || {},
                i = void 0 !== r.opacity ? r.opacity : 1,
                o = void 0 !== r.rotation ? r.rotation : 0,
                s = void 0 !== r.scale ? r.scale : 1,
                a = void 0 !== r.rotateWithView && r.rotateWithView;
            (n = t.call(this, {
                opacity: i,
                rotation: o,
                scale: s,
                displacement: void 0 !== r.displacement ? r.displacement : [0, 0],
                rotateWithView: a,
                declutterMode: r.declutterMode
            }) || this).anchor_ = void 0 !== r.anchor ? r.anchor : [.5, .5],
            n.normalizedAnchor_ = null,
            n.anchorOrigin_ = void 0 !== r.anchorOrigin ? r.anchorOrigin : Cl.TOP_LEFT,
            n.anchorXUnits_ = void 0 !== r.anchorXUnits ? r.anchorXUnits : wl.FRACTION,
            n.anchorYUnits_ = void 0 !== r.anchorYUnits ? r.anchorYUnits : wl.FRACTION,
            n.crossOrigin_ = void 0 !== r.crossOrigin ? r.crossOrigin : null;
            var u = void 0 !== r.img ? r.img : null;
            n.imgSize_ = r.imgSize;
            var l = r.src;
            J(!(void 0 !== l && u), 4),
            J(!u || u && n.imgSize_, 5),
            void 0 !== l && 0 !== l.length || !u || (l = u.src || h(u)),
            J(void 0 !== l && l.length > 0, 6);
            var c = void 0 !== r.src ? eu.IDLE : eu.LOADED;
            return n.color_ = void 0 !== r.color ? ai(r.color) : null, n.iconImage_ = (0, Ml.get)(u, l, void 0 !== n.imgSize_ ? n.imgSize_ : null, n.crossOrigin_, c, n.color_), n.offset_ = void 0 !== r.offset ? r.offset : [0, 0], n.offsetOrigin_ = void 0 !== r.offsetOrigin ? r.offsetOrigin : Cl.TOP_LEFT, n.origin_ = null, n.size_ = void 0 !== r.size ? r.size : null, n
        }
        return Fl(e, t), e.prototype.clone = function() {
            var t = this.getScale();
            return new e({
                anchor: this.anchor_.slice(),
                anchorOrigin: this.anchorOrigin_,
                anchorXUnits: this.anchorXUnits_,
                anchorYUnits: this.anchorYUnits_,
                color: this.color_ && this.color_.slice ? this.color_.slice() : this.color_ || void 0,
                crossOrigin: this.crossOrigin_,
                imgSize: this.imgSize_,
                offset: this.offset_.slice(),
                offsetOrigin: this.offsetOrigin_,
                opacity: this.getOpacity(),
                rotateWithView: this.getRotateWithView(),
                rotation: this.getRotation(),
                scale: Array.isArray(t) ? t.slice() : t,
                size: null !== this.size_ ? this.size_.slice() : void 0,
                src: this.getSrc(),
                displacement: this.getDisplacement().slice(),
                declutterMode: this.getDeclutterMode()
            })
        }, e.prototype.getAnchor = function() {
            var t = this.normalizedAnchor_;
            if (!t) {
                t = this.anchor_;
                var e = this.getSize();
                if (this.anchorXUnits_ == wl.FRACTION || this.anchorYUnits_ == wl.FRACTION) {
                    if (!e)
                        return null;
                    t = this.anchor_.slice(),
                    this.anchorXUnits_ == wl.FRACTION && (t[0] *= e[0]),
                    this.anchorYUnits_ == wl.FRACTION && (t[1] *= e[1])
                }
                if (this.anchorOrigin_ != Cl.TOP_LEFT) {
                    if (!e)
                        return null;
                    t === this.anchor_ && (t = this.anchor_.slice()),
                    this.anchorOrigin_ != Cl.TOP_RIGHT && this.anchorOrigin_ != Cl.BOTTOM_RIGHT || (t[0] = -t[0] + e[0]),
                    this.anchorOrigin_ != Cl.BOTTOM_LEFT && this.anchorOrigin_ != Cl.BOTTOM_RIGHT || (t[1] = -t[1] + e[1])
                }
                this.normalizedAnchor_ = t
            }
            var n = this.getDisplacement();
            return [t[0] - n[0], t[1] + n[1]]
        }, e.prototype.setAnchor = function(t) {
            this.anchor_ = t,
            this.normalizedAnchor_ = null
        }, e.prototype.getColor = function() {
            return this.color_
        }, e.prototype.getImage = function(t) {
            return this.iconImage_.getImage(t)
        }, e.prototype.getPixelRatio = function(t) {
            return this.iconImage_.getPixelRatio(t)
        }, e.prototype.getImageSize = function() {
            return this.iconImage_.getSize()
        }, e.prototype.getImageState = function() {
            return this.iconImage_.getImageState()
        }, e.prototype.getHitDetectionImage = function() {
            return this.iconImage_.getHitDetectionImage()
        }, e.prototype.getOrigin = function() {
            if (this.origin_)
                return this.origin_;
            var t = this.offset_;
            if (this.offsetOrigin_ != Cl.TOP_LEFT) {
                var e = this.getSize(),
                    n = this.iconImage_.getSize();
                if (!e || !n)
                    return null;
                t = t.slice(),
                this.offsetOrigin_ != Cl.TOP_RIGHT && this.offsetOrigin_ != Cl.BOTTOM_RIGHT || (t[0] = n[0] - e[0] - t[0]),
                this.offsetOrigin_ != Cl.BOTTOM_LEFT && this.offsetOrigin_ != Cl.BOTTOM_RIGHT || (t[1] = n[1] - e[1] - t[1])
            }
            return this.origin_ = t, this.origin_
        }, e.prototype.getSrc = function() {
            return this.iconImage_.getSrc()
        }, e.prototype.getSize = function() {
            return this.size_ ? this.size_ : this.iconImage_.getSize()
        }, e.prototype.listenImageChange = function(t) {
            this.iconImage_.addEventListener(D.CHANGE, t)
        }, e.prototype.load = function() {
            this.iconImage_.load()
        }, e.prototype.unlistenImageChange = function(t) {
            this.iconImage_.removeEventListener(D.CHANGE, t)
        }, e
    }(nu),
    jl = function() {
        function t(t) {
            var e = t || {};
            this.font_ = e.font,
            this.rotation_ = e.rotation,
            this.rotateWithView_ = e.rotateWithView,
            this.scale_ = e.scale,
            this.scaleArray_ = Qo(void 0 !== e.scale ? e.scale : 1),
            this.text_ = e.text,
            this.textAlign_ = e.textAlign,
            this.justify_ = e.justify,
            this.textBaseline_ = e.textBaseline,
            this.fill_ = void 0 !== e.fill ? e.fill : new uu({
                color: "#333"
            }),
            this.maxAngle_ = void 0 !== e.maxAngle ? e.maxAngle : Math.PI / 4,
            this.placement_ = void 0 !== e.placement ? e.placement : qu.POINT,
            this.overflow_ = !!e.overflow,
            this.stroke_ = void 0 !== e.stroke ? e.stroke : null,
            this.offsetX_ = void 0 !== e.offsetX ? e.offsetX : 0,
            this.offsetY_ = void 0 !== e.offsetY ? e.offsetY : 0,
            this.backgroundFill_ = e.backgroundFill ? e.backgroundFill : null,
            this.backgroundStroke_ = e.backgroundStroke ? e.backgroundStroke : null,
            this.padding_ = void 0 === e.padding ? null : e.padding
        }
        return t.prototype.clone = function() {
            var e = this.getScale();
            return new t({
                font: this.getFont(),
                placement: this.getPlacement(),
                maxAngle: this.getMaxAngle(),
                overflow: this.getOverflow(),
                rotation: this.getRotation(),
                rotateWithView: this.getRotateWithView(),
                scale: Array.isArray(e) ? e.slice() : e,
                text: this.getText(),
                textAlign: this.getTextAlign(),
                justify: this.getJustify(),
                textBaseline: this.getTextBaseline(),
                fill: this.getFill() ? this.getFill().clone() : void 0,
                stroke: this.getStroke() ? this.getStroke().clone() : void 0,
                offsetX: this.getOffsetX(),
                offsetY: this.getOffsetY(),
                backgroundFill: this.getBackgroundFill() ? this.getBackgroundFill().clone() : void 0,
                backgroundStroke: this.getBackgroundStroke() ? this.getBackgroundStroke().clone() : void 0,
                padding: this.getPadding() || void 0
            })
        }, t.prototype.getOverflow = function() {
            return this.overflow_
        }, t.prototype.getFont = function() {
            return this.font_
        }, t.prototype.getMaxAngle = function() {
            return this.maxAngle_
        }, t.prototype.getPlacement = function() {
            return this.placement_
        }, t.prototype.getOffsetX = function() {
            return this.offsetX_
        }, t.prototype.getOffsetY = function() {
            return this.offsetY_
        }, t.prototype.getFill = function() {
            return this.fill_
        }, t.prototype.getRotateWithView = function() {
            return this.rotateWithView_
        }, t.prototype.getRotation = function() {
            return this.rotation_
        }, t.prototype.getScale = function() {
            return this.scale_
        }, t.prototype.getScaleArray = function() {
            return this.scaleArray_
        }, t.prototype.getStroke = function() {
            return this.stroke_
        }, t.prototype.getText = function() {
            return this.text_
        }, t.prototype.getTextAlign = function() {
            return this.textAlign_
        }, t.prototype.getJustify = function() {
            return this.justify_
        }, t.prototype.getTextBaseline = function() {
            return this.textBaseline_
        }, t.prototype.getBackgroundFill = function() {
            return this.backgroundFill_
        }, t.prototype.getBackgroundStroke = function() {
            return this.backgroundStroke_
        }, t.prototype.getPadding = function() {
            return this.padding_
        }, t.prototype.setOverflow = function(t) {
            this.overflow_ = t
        }, t.prototype.setFont = function(t) {
            this.font_ = t
        }, t.prototype.setMaxAngle = function(t) {
            this.maxAngle_ = t
        }, t.prototype.setOffsetX = function(t) {
            this.offsetX_ = t
        }, t.prototype.setOffsetY = function(t) {
            this.offsetY_ = t
        }, t.prototype.setPlacement = function(t) {
            this.placement_ = t
        }, t.prototype.setRotateWithView = function(t) {
            this.rotateWithView_ = t
        }, t.prototype.setFill = function(t) {
            this.fill_ = t
        }, t.prototype.setRotation = function(t) {
            this.rotation_ = t
        }, t.prototype.setScale = function(t) {
            this.scale_ = t,
            this.scaleArray_ = Qo(void 0 !== t ? t : 1)
        }, t.prototype.setStroke = function(t) {
            this.stroke_ = t
        }, t.prototype.setText = function(t) {
            this.text_ = t
        }, t.prototype.setTextAlign = function(t) {
            this.textAlign_ = t
        }, t.prototype.setJustify = function(t) {
            this.justify_ = t
        }, t.prototype.setTextBaseline = function(t) {
            this.textBaseline_ = t
        }, t.prototype.setBackgroundFill = function(t) {
            this.backgroundFill_ = t
        }, t.prototype.setBackgroundStroke = function(t) {
            this.backgroundStroke_ = t
        }, t.prototype.setPadding = function(t) {
            this.padding_ = t
        }, t
    }();
function Gl(t, e, n, r, i, o, s) {
    var a = Ni(.5 * t[0], .5 * t[1]);
    a.imageSmoothingEnabled = !1;
    for (var u = a.canvas, l = new (0, _l.default)(a, .5, i, null, s), h = n.length, c = Math.floor(16777215 / h), p = {}, f = 1; f <= h; ++f) {
        var d = n[f - 1],
            g = d.getStyleFunction() || r;
        if (r) {
            var y = g(d, o);
            if (y) {
                Array.isArray(y) || (y = [y]);
                for (var v = "#" + ("000000" + (f * c).toString(16)).slice(-6), m = 0, _ = y.length; m < _; ++m) {
                    var x = y[m],
                        w = x.getGeometryFunction()(d);
                    if (w && ie(i, w.getExtent())) {
                        var b = x.clone(),
                            C = b.getFill();
                        C && C.setColor(v);
                        var M = b.getStroke();
                        M && (M.setColor(v), M.setLineDash(null)),
                        b.setText(void 0);
                        var S = x.getImage();
                        if (S && 0 !== S.getOpacity()) {
                            var I = S.getImageSize();
                            if (!I)
                                continue;
                            var T = Ni(I[0], I[1], void 0, {
                                    alpha: !1
                                }),
                                P = T.canvas;
                            T.fillStyle = v,
                            T.fillRect(0, 0, P.width, P.height),
                            b.setImage(new (0, bl.default)({
                                img: P,
                                imgSize: I,
                                anchor: S.getAnchor(),
                                anchorXUnits: wl.PIXELS,
                                anchorYUnits: wl.PIXELS,
                                offset: S.getOrigin(),
                                opacity: 1,
                                size: S.getSize(),
                                scale: S.getScale(),
                                rotation: S.getRotation(),
                                rotateWithView: S.getRotateWithView()
                            }))
                        }
                        var L = b.getZIndex() || 0;
                        (R = p[L]) || (R = {}, p[L] = R, R.Polygon = [], R.Circle = [], R.LineString = [], R.Point = []),
                        R[w.getType().replace("Multi", "")].push(w, b)
                    }
                }
            }
        }
    }
    for (var O = Object.keys(p).map(Number).sort(E), N = (f = 0, O.length); f < N; ++f) {
        var R = p[O[f]];
        for (var A in R) {
            var D = R[A];
            for (m = 0, _ = D.length; m < _; m += 2) {
                l.setStyle(D[m + 1]);
                for (var F = 0, k = e.length; F < k; ++F)
                    l.setTransform(e[F]),
                    l.drawGeometry(D[m])
            }
        }
    }
    return a.getImageData(0, 0, u.width, u.height)
}
function Bl(t, e, n) {
    var r = [];
    if (n) {
        var i = Math.floor(.5 * Math.round(t[0])),
            o = Math.floor(.5 * Math.round(t[1])),
            s = 4 * (fe(i, 0, n.width - 1) + fe(o, 0, n.height - 1) * n.width),
            a = n.data[s],
            u = n.data[s + 1],
            l = n.data[s + 2] + 256 * (u + 256 * a),
            h = Math.floor(16777215 / e.length);
        l && l % h == 0 && r.push(e[l / h - 1])
    }
    return r
}
var ql = {
    Point: function(t, e, n, r, i) {
        var o,
            s = n.getImage(),
            a = n.getText();
        if (s) {
            if (s.getImageState() != eu.LOADED)
                return;
            var u = t;
            if (i) {
                var l = s.getDeclutterMode();
                if ("none" !== l)
                    if (u = i, "obstacle" === l) {
                        var h = t.getBuilder(n.getZIndex(), "Image");
                        h.setImageStyle(s, o),
                        h.drawPoint(e, r)
                    } else
                        a && a.getText() && (o = {})
            }
            var c = u.getBuilder(n.getZIndex(), "Image");
            c.setImageStyle(s, o),
            c.drawPoint(e, r)
        }
        if (a && a.getText()) {
            var p = t;
            i && (p = i);
            var f = p.getBuilder(n.getZIndex(), "Text");
            f.setTextStyle(a, o),
            f.drawText(e, r)
        }
    },
    LineString: function(t, e, n, r, i) {
        var o = n.getStroke();
        if (o) {
            var s = t.getBuilder(n.getZIndex(), "LineString");
            s.setFillStrokeStyle(null, o),
            s.drawLineString(e, r)
        }
        var a = n.getText();
        if (a && a.getText()) {
            var u = (i || t).getBuilder(n.getZIndex(), "Text");
            u.setTextStyle(a),
            u.drawText(e, r)
        }
    },
    Polygon: function(t, e, n, r, i) {
        var o = n.getFill(),
            s = n.getStroke();
        if (o || s) {
            var a = t.getBuilder(n.getZIndex(), "Polygon");
            a.setFillStrokeStyle(o, s),
            a.drawPolygon(e, r)
        }
        var u = n.getText();
        if (u && u.getText()) {
            var l = (i || t).getBuilder(n.getZIndex(), "Text");
            l.setTextStyle(u),
            l.drawText(e, r)
        }
    },
    MultiPoint: function(t, e, n, r, i) {
        var o,
            s = n.getImage(),
            a = n.getText();
        if (s) {
            if (s.getImageState() != eu.LOADED)
                return;
            var u = t;
            if (i) {
                var l = s.getDeclutterMode();
                if ("none" !== l)
                    if (u = i, "obstacle" === l) {
                        var h = t.getBuilder(n.getZIndex(), "Image");
                        h.setImageStyle(s, o),
                        h.drawMultiPoint(e, r)
                    } else
                        a && a.getText() && (o = {})
            }
            var c = u.getBuilder(n.getZIndex(), "Image");
            c.setImageStyle(s, o),
            c.drawMultiPoint(e, r)
        }
        if (a && a.getText()) {
            var p = t;
            i && (p = i);
            var f = p.getBuilder(n.getZIndex(), "Text");
            f.setTextStyle(a, o),
            f.drawText(e, r)
        }
    },
    MultiLineString: function(t, e, n, r, i) {
        var o = n.getStroke();
        if (o) {
            var s = t.getBuilder(n.getZIndex(), "LineString");
            s.setFillStrokeStyle(null, o),
            s.drawMultiLineString(e, r)
        }
        var a = n.getText();
        if (a && a.getText()) {
            var u = (i || t).getBuilder(n.getZIndex(), "Text");
            u.setTextStyle(a),
            u.drawText(e, r)
        }
    },
    MultiPolygon: function(t, e, n, r, i) {
        var o = n.getFill(),
            s = n.getStroke();
        if (s || o) {
            var a = t.getBuilder(n.getZIndex(), "Polygon");
            a.setFillStrokeStyle(o, s),
            a.drawMultiPolygon(e, r)
        }
        var u = n.getText();
        if (u && u.getText()) {
            var l = (i || t).getBuilder(n.getZIndex(), "Text");
            l.setTextStyle(u),
            l.drawText(e, r)
        }
    },
    GeometryCollection: function(t, e, n, r, i) {
        var o,
            s,
            a = e.getGeometriesArray();
        for (o = 0, s = a.length; o < s; ++o) {
            (0, ql[a[o].getType()])(t, a[o], n, r, i)
        }
    },
    Circle: function(t, e, n, r, i) {
        var o = n.getFill(),
            s = n.getStroke();
        if (o || s) {
            var a = t.getBuilder(n.getZIndex(), "Circle");
            a.setFillStrokeStyle(o, s),
            a.drawCircle(e, r)
        }
        var u = n.getText();
        if (u && u.getText()) {
            var l = (i || t).getBuilder(n.getZIndex(), "Text");
            l.setTextStyle(u),
            l.drawText(e, r)
        }
    }
};
function zl(t, e) {
    return parseInt(h(t), 10) - parseInt(h(e), 10)
}
function Ul(t, e) {
    var n = Vl(t, e);
    return n * n
}
function Vl(t, e) {
    return .5 * t / e
}
function Xl(t, e, n, r, i, o, s) {
    var a = !1,
        u = n.getImage();
    if (u) {
        var l = u.getImageState();
        l == eu.LOADED || l == eu.ERROR ? u.unlistenImageChange(i) : (l == eu.IDLE && u.load(), u.listenImageChange(i), a = !0)
    }
    return function(t, e, n, r, i, o) {
        var s = n.getGeometryFunction()(e);
        if (!s)
            return;
        var a = s.simplifyTransformed(r, i);
        if (n.getRenderer())
            Hl(t, a, n, e);
        else {
            (0, ql[a.getType()])(t, a, n, e, o)
        }
    }(t, e, n, r, o, s), a
}
function Hl(t, e, n, r) {
    if ("GeometryCollection" != e.getType())
        t.getBuilder(n.getZIndex(), "Default").drawCustom(e, r, n.getRenderer(), n.getHitDetectionRenderer());
    else
        for (var i = e.getGeometries(), o = 0, s = i.length; o < s; ++o)
            Hl(t, i[o], n, r)
}
var Yl = function() {
        var t = function(e, n) {
            return t = Object.setPrototypeOf || {
                __proto__: []
            } instanceof Array && function(t, e) {
                t.__proto__ = e
            } || function(t, e) {
                for (var n in e)
                    Object.prototype.hasOwnProperty.call(e, n) && (t[n] = e[n])
            }, t(e, n)
        };
        return function(e, n) {
            if ("function" != typeof n && null !== n)
                throw new TypeError("Class extends value " + String(n) + " is not a constructor or null");
            function r() {
                this.constructor = e
            }
            t(e, n),
            e.prototype = null === n ? Object.create(n) : (r.prototype = n.prototype, new r)
        }
    }(),
    Wl = function(t) {
        function e(e) {
            var n = t.call(this, e) || this;
            return n.boundHandleStyleImageChange_ = n.handleStyleImageChange_.bind(n), n.animatingOrInteracting_, n.hitDetectionImageData_ = null, n.renderedFeatures_ = null, n.renderedRevision_ = -1, n.renderedResolution_ = NaN, n.renderedExtent_ = [1 / 0, 1 / 0, -1 / 0, -1 / 0], n.wrappedRenderedExtent_ = [1 / 0, 1 / 0, -1 / 0, -1 / 0], n.renderedRotation_, n.renderedCenter_ = null, n.renderedProjection_ = null, n.renderedRenderOrder_ = null, n.replayGroup_ = null, n.replayGroupChanged = !0, n.declutterExecutorGroup = null, n.clipping = !0, n.compositionContext_ = null, n.opacity_ = 1, n
        }
        return Yl(e, t), e.prototype.renderWorlds = function(t, e, n) {
            var r = e.extent,
                i = e.viewState,
                o = i.center,
                s = i.resolution,
                a = i.projection,
                u = i.rotation,
                l = a.getExtent(),
                h = this.getLayer().getSource(),
                c = e.pixelRatio,
                p = e.viewHints,
                f = !(p[To.ANIMATING] || p[To.INTERACTING]),
                d = this.compositionContext_,
                g = Math.round(e.size[0] * c),
                y = Math.round(e.size[1] * c),
                v = h.getWrapX() && a.canWrapX(),
                m = v ? re(l) : null,
                _ = v ? Math.ceil((r[2] - l[2]) / m) + 1 : 1,
                x = v ? Math.floor((r[0] - l[0]) / m) : 0;
            do {
                var E = this.getRenderTransform(o, s, u, c, g, y, x * m);
                t.execute(d, 1, E, u, f, void 0, n)
            } while (++x < _)
        }, e.prototype.setupCompositionContext_ = function() {
            if (1 !== this.opacity_) {
                var t = Ni(this.context.canvas.width, this.context.canvas.height, Wu.canvasPool);
                this.compositionContext_ = t
            } else
                this.compositionContext_ = this.context
        }, e.prototype.releaseCompositionContext_ = function() {
            if (1 !== this.opacity_) {
                var t = this.context.globalAlpha;
                this.context.globalAlpha = this.opacity_,
                this.context.drawImage(this.compositionContext_.canvas, 0, 0),
                this.context.globalAlpha = t,
                Ri(this.compositionContext_),
                Wu.canvasPool.push(this.compositionContext_.canvas),
                this.compositionContext_ = null
            }
        }, e.prototype.renderDeclutter = function(t) {
            this.declutterExecutorGroup && (this.setupCompositionContext_(), this.renderWorlds(this.declutterExecutorGroup, t, t.declutterTree), this.releaseCompositionContext_())
        }, e.prototype.renderFrame = function(t, e) {
            var n = t.pixelRatio,
                r = t.layerStatesArray[t.layerIndex];
            wt(this.pixelTransform, 1 / n, 1 / n),
            Ct(this.inversePixelTransform, this.pixelTransform);
            var i = Mt(this.pixelTransform);
            this.useContainer(e, i, this.getBackground(t));
            var o = this.context,
                s = o.canvas,
                a = this.replayGroup_,
                u = this.declutterExecutorGroup;
            if ((!a || a.isEmpty()) && (!u || u.isEmpty()))
                return null;
            var l = Math.round(t.size[0] * n),
                h = Math.round(t.size[1] * n);
            s.width != l || s.height != h ? (s.width = l, s.height = h, s.style.transform !== i && (s.style.transform = i)) : this.containerReused || o.clearRect(0, 0, l, h),
            this.preRender(o, t);
            var c = t.viewState,
                p = c.projection;
            this.opacity_ = r.opacity,
            this.setupCompositionContext_();
            var f = !1,
                d = !0;
            if (r.extent && this.clipping) {
                var g = Sn(r.extent, p);
                (f = (d = ie(g, t.extent)) && !Nt(g, t.extent)) && this.clipUnrotated(this.compositionContext_, t, g)
            }
            return d && this.renderWorlds(a, t), f && this.compositionContext_.restore(), this.releaseCompositionContext_(), this.postRender(o, t), this.renderedRotation_ !== c.rotation && (this.renderedRotation_ = c.rotation, this.hitDetectionImageData_ = null), this.container
        }, e.prototype.getFeatures = function(t) {
            return new Promise(function(e) {
                if (!this.hitDetectionImageData_ && !this.animatingOrInteracting_) {
                    var n = [this.context.canvas.width, this.context.canvas.height];
                    Et(this.pixelTransform, n);
                    var r = this.renderedCenter_,
                        i = this.renderedResolution_,
                        o = this.renderedRotation_,
                        s = this.renderedProjection_,
                        a = this.wrappedRenderedExtent_,
                        u = this.getLayer(),
                        l = [],
                        h = .5 * n[0],
                        c = .5 * n[1];
                    l.push(this.getRenderTransform(r, i, o, .5, h, c, 0).slice());
                    var p = u.getSource(),
                        f = s.getExtent();
                    if (p.getWrapX() && s.canWrapX() && !Nt(f, a)) {
                        for (var d = a[0], g = re(f), y = 0, v = void 0; d < f[0];)
                            v = g * --y,
                            l.push(this.getRenderTransform(r, i, o, .5, h, c, v).slice()),
                            d += g;
                        for (y = 0, d = a[2]; d > f[2];)
                            v = g * ++y,
                            l.push(this.getRenderTransform(r, i, o, .5, h, c, v).slice()),
                            d -= g
                    }
                    this.hitDetectionImageData_ = Gl(n, l, this.renderedFeatures_, u.getStyleFunction(), a, i, o)
                }
                e(Bl(t, this.renderedFeatures_, this.hitDetectionImageData_))
            }.bind(this))
        }, e.prototype.forEachFeatureAtCoordinate = function(t, e, n, r, i) {
            var o = this;
            if (this.replayGroup_) {
                var s,
                    a = e.viewState.resolution,
                    u = e.viewState.rotation,
                    l = this.getLayer(),
                    c = {},
                    p = function(t, e, n) {
                        var o = h(t),
                            s = c[o];
                        if (s) {
                            if (!0 !== s && n < s.distanceSq) {
                                if (0 === n)
                                    return c[o] = !0, i.splice(i.lastIndexOf(s), 1), r(t, l, e);
                                s.geometry = e,
                                s.distanceSq = n
                            }
                        } else {
                            if (0 === n)
                                return c[o] = !0, r(t, l, e);
                            i.push(c[o] = {
                                feature: t,
                                layer: l,
                                geometry: e,
                                distanceSq: n,
                                callback: r
                            })
                        }
                    },
                    f = [this.replayGroup_];
                return this.declutterExecutorGroup && f.push(this.declutterExecutorGroup), f.some((function(r) {
                    return s = r.forEachFeatureAtCoordinate(t, a, u, n, p, r === o.declutterExecutorGroup && e.declutterTree ? e.declutterTree.all().map((function(t) {
                        return t.value
                    })) : null)
                })), s
            }
        }, e.prototype.handleFontsChanged = function() {
            var t = this.getLayer();
            t.getVisible() && this.replayGroup_ && t.changed()
        }, e.prototype.handleStyleImageChange_ = function(t) {
            this.renderIfReadyAndVisible()
        }, e.prototype.prepareFrame = function(t) {
            var e = this.getLayer(),
                n = e.getSource();
            if (!n)
                return !1;
            var r = t.viewHints[To.ANIMATING],
                i = t.viewHints[To.INTERACTING],
                o = e.getUpdateWhileAnimating(),
                s = e.getUpdateWhileInteracting();
            if (this.ready && !o && r || !s && i)
                return this.animatingOrInteracting_ = !0, !0;
            this.animatingOrInteracting_ = !1;
            var a = t.extent,
                u = t.viewState,
                l = u.projection,
                h = u.resolution,
                c = t.pixelRatio,
                p = e.getRevision(),
                f = e.getRenderBuffer(),
                d = e.getRenderOrder();
            void 0 === d && (d = zl);
            var g = u.center.slice(),
                y = Tt(a, f * h),
                v = y.slice(),
                m = [y.slice()],
                _ = l.getExtent();
            if (n.getWrapX() && l.canWrapX() && !Nt(_, t.extent)) {
                var x = re(_),
                    E = Math.max(re(y) / 2, x);
                y[0] = _[0] - E,
                y[2] = _[2] + E,
                Qe(g, l);
                var w = le(m[0], l);
                w[0] < _[0] && w[2] < _[2] ? m.push([w[0] + x, w[1], w[2] + x, w[3]]) : w[0] > _[0] && w[2] > _[2] && m.push([w[0] - x, w[1], w[2] - x, w[3]])
            }
            if (this.ready && this.renderedResolution_ == h && this.renderedRevision_ == p && this.renderedRenderOrder_ == d && Nt(this.wrappedRenderedExtent_, y))
                return M(this.renderedExtent_, v) || (this.hitDetectionImageData_ = null, this.renderedExtent_ = v), this.renderedCenter_ = g, this.replayGroupChanged = !1, !0;
            this.replayGroup_ = null;
            var b,
                C = new Yu(Vl(h, c), y, h, c);
            this.getLayer().getDeclutter() && (b = new Yu(Vl(h, c), y, h, c));
            var S,
                I = wn();
            if (I) {
                for (var T = 0, P = m.length; T < P; ++T) {
                    var L = Mn(m[T], l);
                    n.loadFeatures(L, In(h, l), I)
                }
                S = dn(I, l)
            } else
                for (T = 0, P = m.length; T < P; ++T)
                    n.loadFeatures(m[T], h, l);
            var O = Ul(h, c),
                N = !0,
                R = function(t) {
                    var n,
                        r = t.getStyleFunction() || e.getStyleFunction();
                    if (r && (n = r(t, h)), n) {
                        var i = this.renderFeature(t, O, n, C, S, b);
                        N = N && !i
                    }
                }.bind(this),
                A = Mn(y, l),
                D = n.getFeaturesInExtent(A);
            d && D.sort(d);
            for (T = 0, P = D.length; T < P; ++T)
                R(D[T]);
            this.renderedFeatures_ = D,
            this.ready = N;
            var F = C.finish(),
                k = new ml(y, h, c, n.getOverlaps(), F, e.getRenderBuffer());
            return b && (this.declutterExecutorGroup = new ml(y, h, c, n.getOverlaps(), b.finish(), e.getRenderBuffer())), this.renderedResolution_ = h, this.renderedRevision_ = p, this.renderedRenderOrder_ = d, this.renderedExtent_ = v, this.wrappedRenderedExtent_ = y, this.renderedCenter_ = g, this.renderedProjection_ = l, this.replayGroup_ = k, this.hitDetectionImageData_ = null, this.replayGroupChanged = !0, !0
        }, e.prototype.renderFeature = function(t, e, n, r, i, o) {
            if (!n)
                return !1;
            var s = !1;
            if (Array.isArray(n))
                for (var a = 0, u = n.length; a < u; ++a)
                    s = Xl(r, t, n[a], e, this.boundHandleStyleImageChange_, i, o) || s;
            else
                s = Xl(r, t, n, e, this.boundHandleStyleImageChange_, i, o);
            return s
        }, e
    }(Wu.default),
    $l = Wl,
    Kl = function() {
        var t = function(e, n) {
            return t = Object.setPrototypeOf || {
                __proto__: []
            } instanceof Array && function(t, e) {
                t.__proto__ = e
            } || function(t, e) {
                for (var n in e)
                    Object.prototype.hasOwnProperty.call(e, n) && (t[n] = e[n])
            }, t(e, n)
        };
        return function(e, n) {
            if ("function" != typeof n && null !== n)
                throw new TypeError("Class extends value " + String(n) + " is not a constructor or null");
            function r() {
                this.constructor = e
            }
            t(e, n),
            e.prototype = null === n ? Object.create(n) : (r.prototype = n.prototype, new r)
        }
    }(),
    Zl = function(t) {
        function e(e) {
            return t.call(this, e) || this
        }
        return Kl(e, t), e.prototype.createRenderer = function() {
            return new (0, xu.default)(this)
        }, e
    }(Za.default),
    Jl = {};
t(Jl, "VectorSourceEvent", (() => hh), (t => hh = t)),
t(Jl, "default", (() => ph), (t => ph = t));
Ja = o("20GDs");
var Ql = function() {
        function t(t) {
            this.rbush_ = new (e(Ja))(t),
            this.items_ = {}
        }
        return t.prototype.insert = function(t, e) {
            var n = {
                minX: t[0],
                minY: t[1],
                maxX: t[2],
                maxY: t[3],
                value: e
            };
            this.rbush_.insert(n),
            this.items_[h(e)] = n
        }, t.prototype.load = function(t, e) {
            for (var n = new Array(e.length), r = 0, i = e.length; r < i; r++) {
                var o = t[r],
                    s = e[r],
                    a = {
                        minX: o[0],
                        minY: o[1],
                        maxX: o[2],
                        maxY: o[3],
                        value: s
                    };
                n[r] = a,
                this.items_[h(s)] = a
            }
            this.rbush_.load(n)
        }, t.prototype.remove = function(t) {
            var e = h(t),
                n = this.items_[e];
            return delete this.items_[e], null !== this.rbush_.remove(n)
        }, t.prototype.update = function(t, e) {
            var n = this.items_[h(e)];
            Bt([n.minX, n.minY, n.maxX, n.maxY], t) || (this.remove(e), this.insert(t, e))
        }, t.prototype.getAll = function() {
            return this.rbush_.all().map((function(t) {
                return t.value
            }))
        }, t.prototype.getInExtent = function(t) {
            var e = {
                minX: t[0],
                minY: t[1],
                maxX: t[2],
                maxY: t[3]
            };
            return this.rbush_.search(e).map((function(t) {
                return t.value
            }))
        }, t.prototype.forEach = function(t) {
            return this.forEach_(this.getAll(), t)
        }, t.prototype.forEachInExtent = function(t, e) {
            return this.forEach_(this.getInExtent(t), e)
        }, t.prototype.forEach_ = function(t, e) {
            for (var n, r = 0, i = t.length; r < i; r++)
                if (n = e(t[r]))
                    return n;
            return n
        }, t.prototype.isEmpty = function() {
            return N(this.items_)
        }, t.prototype.clear = function() {
            this.rbush_.clear(),
            this.items_ = {}
        }, t.prototype.getExtent = function(t) {
            var e = this.rbush_.toJSON();
            return Ft(e.minX, e.minY, e.maxX, e.maxY, t)
        }, t.prototype.concat = function(t) {
            for (var e in this.rbush_.load(t.rbush_.all()), t.items_)
                this.items_[e] = t.items_[e]
        }, t
    }(),
    th = Ql,
    eh = {};
t(eh, "default", (() => ih), (t => ih = t));
var nh = function() {
    var t = function(e, n) {
        return t = Object.setPrototypeOf || {
            __proto__: []
        } instanceof Array && function(t, e) {
            t.__proto__ = e
        } || function(t, e) {
            for (var n in e)
                Object.prototype.hasOwnProperty.call(e, n) && (t[n] = e[n])
        }, t(e, n)
    };
    return function(e, n) {
        if ("function" != typeof n && null !== n)
            throw new TypeError("Class extends value " + String(n) + " is not a constructor or null");
        function r() {
            this.constructor = e
        }
        t(e, n),
        e.prototype = null === n ? Object.create(n) : (r.prototype = n.prototype, new r)
    }
}();
function rh(t) {
    return t ? Array.isArray(t) ? function(e) {
        return t
    } : "function" == typeof t ? t : function(e) {
        return [t]
    } : null
}
var ih = function(t) {
        function e(e) {
            var n = t.call(this) || this;
            n.projection = ln(e.projection),
            n.attributions_ = rh(e.attributions),
            n.attributionsCollapsible_ = void 0 === e.attributionsCollapsible || e.attributionsCollapsible,
            n.loading = !1,
            n.state_ = void 0 !== e.state ? e.state : "ready",
            n.wrapX_ = void 0 !== e.wrapX && e.wrapX,
            n.interpolate_ = !!e.interpolate,
            n.viewResolver = null,
            n.viewRejector = null;
            var r = n;
            return n.viewPromise_ = new Promise((function(t, e) {
                r.viewResolver = t,
                r.viewRejector = e
            })), n
        }
        return nh(e, t), e.prototype.getAttributions = function() {
            return this.attributions_
        }, e.prototype.getAttributionsCollapsible = function() {
            return this.attributionsCollapsible_
        }, e.prototype.getProjection = function() {
            return this.projection
        }, e.prototype.getResolutions = function() {
            return u()
        }, e.prototype.getView = function() {
            return this.viewPromise_
        }, e.prototype.getState = function() {
            return this.state_
        }, e.prototype.getWrapX = function() {
            return this.wrapX_
        }, e.prototype.getInterpolate = function() {
            return this.interpolate_
        }, e.prototype.refresh = function() {
            this.changed()
        }, e.prototype.setAttributions = function(t) {
            this.attributions_ = rh(t),
            this.changed()
        }, e.prototype.setState = function(t) {
            this.state_ = t,
            this.changed()
        }, e
    }(d.default),
    oh = {
        ADDFEATURE: "addfeature",
        CHANGEFEATURE: "changefeature",
        CLEAR: "clear",
        REMOVEFEATURE: "removefeature",
        FEATURESLOADSTART: "featuresloadstart",
        FEATURESLOADEND: "featuresloadend",
        FEATURESLOADERROR: "featuresloaderror"
    };
function sh(t, e) {
    return [[-1 / 0, -1 / 0, 1 / 0, 1 / 0]]
}
var ah = !1;
function uh(t, e) {
    return function(n, r, i, o, s) {
        var a = this;
        !function(t, e, n, r, i, o, s) {
            var a = new XMLHttpRequest;
            a.open("GET", "function" == typeof t ? t(n, r, i) : t, !0),
            "arraybuffer" == e.getType() && (a.responseType = "arraybuffer"),
            a.withCredentials = ah,
            a.onload = function(t) {
                if (!a.status || a.status >= 200 && a.status < 300) {
                    var r = e.getType(),
                        u = void 0;
                    "json" == r || "text" == r ? u = a.responseText : "xml" == r ? (u = a.responseXML) || (u = (new DOMParser).parseFromString(a.responseText, "application/xml")) : "arraybuffer" == r && (u = a.response),
                    u ? o(e.readFeatures(u, {
                        extent: n,
                        featureProjection: i
                    }), e.readProjection(u)) : s()
                } else
                    s()
            },
            a.onerror = s,
            a.send()
        }(t, e, n, r, i, (function(t, e) {
            a.addFeatures(t),
            void 0 !== o && o(t)
        }), s || T)
    }
}
var lh = function() {
        var t = function(e, n) {
            return t = Object.setPrototypeOf || {
                __proto__: []
            } instanceof Array && function(t, e) {
                t.__proto__ = e
            } || function(t, e) {
                for (var n in e)
                    Object.prototype.hasOwnProperty.call(e, n) && (t[n] = e[n])
            }, t(e, n)
        };
        return function(e, n) {
            if ("function" != typeof n && null !== n)
                throw new TypeError("Class extends value " + String(n) + " is not a constructor or null");
            function r() {
                this.constructor = e
            }
            t(e, n),
            e.prototype = null === n ? Object.create(n) : (r.prototype = n.prototype, new r)
        }
    }(),
    hh = function(t) {
        function e(e, n, r) {
            var i = t.call(this, e) || this;
            return i.feature = n, i.features = r, i
        }
        return lh(e, t), e
    }(g),
    ch = function(t) {
        function e(e) {
            var n = this,
                r = e || {};
            (n = t.call(this, {
                attributions: r.attributions,
                interpolate: !0,
                projection: void 0,
                state: "ready",
                wrapX: void 0 === r.wrapX || r.wrapX
            }) || this).on,
            n.once,
            n.un,
            n.loader_ = T,
            n.format_ = r.format,
            n.overlaps_ = void 0 === r.overlaps || r.overlaps,
            n.url_ = r.url,
            void 0 !== r.loader ? n.loader_ = r.loader : void 0 !== n.url_ && (J(n.format_, 7), n.loader_ = uh(n.url_, n.format_)),
            n.strategy_ = void 0 !== r.strategy ? r.strategy : sh;
            var i,
                o,
                a = void 0 === r.useSpatialIndex || r.useSpatialIndex;
            return n.featuresRtree_ = a ? new th : null, n.loadedExtentsRtree_ = new th, n.loadingExtentsCount_ = 0, n.nullGeometryFeatures_ = {}, n.idIndex_ = {}, n.uidIndex_ = {}, n.featureChangeKeys_ = {}, n.featuresCollection_ = null, Array.isArray(r.features) ? o = r.features : r.features && (o = (i = r.features).getArray()), a || void 0 !== i || (i = new (0, s.default)(o)), void 0 !== o && n.addFeaturesInternal(o), void 0 !== i && n.bindFeaturesCollection_(i), n
        }
        return lh(e, t), e.prototype.addFeature = function(t) {
            this.addFeatureInternal(t),
            this.changed()
        }, e.prototype.addFeatureInternal = function(t) {
            var e = h(t);
            if (this.addToIndex_(e, t)) {
                this.setupChangeEvents_(e, t);
                var n = t.getGeometry();
                if (n) {
                    var r = n.getExtent();
                    this.featuresRtree_ && this.featuresRtree_.insert(r, t)
                } else
                    this.nullGeometryFeatures_[e] = t;
                this.dispatchEvent(new hh(oh.ADDFEATURE, t))
            } else
                this.featuresCollection_ && this.featuresCollection_.remove(t)
        }, e.prototype.setupChangeEvents_ = function(t, e) {
            this.featureChangeKeys_[t] = [F(e, D.CHANGE, this.handleFeatureChange_, this), F(e, y.PROPERTYCHANGE, this.handleFeatureChange_, this)]
        }, e.prototype.addToIndex_ = function(t, e) {
            var n = !0,
                r = e.getId();
            return void 0 !== r && (r.toString() in this.idIndex_ ? n = !1 : this.idIndex_[r.toString()] = e), n && (J(!(t in this.uidIndex_), 30), this.uidIndex_[t] = e), n
        }, e.prototype.addFeatures = function(t) {
            this.addFeaturesInternal(t),
            this.changed()
        }, e.prototype.addFeaturesInternal = function(t) {
            for (var e = [], n = [], r = [], i = 0, o = t.length; i < o; i++) {
                var s = h(u = t[i]);
                this.addToIndex_(s, u) && n.push(u)
            }
            i = 0;
            for (var a = n.length; i < a; i++) {
                var u;
                s = h(u = n[i]);
                this.setupChangeEvents_(s, u);
                var l = u.getGeometry();
                if (l) {
                    var c = l.getExtent();
                    e.push(c),
                    r.push(u)
                } else
                    this.nullGeometryFeatures_[s] = u
            }
            if (this.featuresRtree_ && this.featuresRtree_.load(e, r), this.hasListener(oh.ADDFEATURE)) {
                i = 0;
                for (var p = n.length; i < p; i++)
                    this.dispatchEvent(new hh(oh.ADDFEATURE, n[i]))
            }
        }, e.prototype.bindFeaturesCollection_ = function(t) {
            var e = !1;
            this.addEventListener(oh.ADDFEATURE, (function(n) {
                e || (e = !0, t.push(n.feature), e = !1)
            })),
            this.addEventListener(oh.REMOVEFEATURE, (function(n) {
                e || (e = !0, t.remove(n.feature), e = !1)
            })),
            t.addEventListener(H.ADD, function(t) {
                e || (e = !0, this.addFeature(t.element), e = !1)
            }.bind(this)),
            t.addEventListener(H.REMOVE, function(t) {
                e || (e = !0, this.removeFeature(t.element), e = !1)
            }.bind(this)),
            this.featuresCollection_ = t
        }, e.prototype.clear = function(t) {
            if (t) {
                for (var e in this.featureChangeKeys_) {
                    this.featureChangeKeys_[e].forEach(j)
                }
                this.featuresCollection_ || (this.featureChangeKeys_ = {}, this.idIndex_ = {}, this.uidIndex_ = {})
            } else if (this.featuresRtree_) {
                var n = function(t) {
                    this.removeFeatureInternal(t)
                }.bind(this);
                for (var r in this.featuresRtree_.forEach(n), this.nullGeometryFeatures_)
                    this.removeFeatureInternal(this.nullGeometryFeatures_[r])
            }
            this.featuresCollection_ && this.featuresCollection_.clear(),
            this.featuresRtree_ && this.featuresRtree_.clear(),
            this.nullGeometryFeatures_ = {};
            var i = new hh(oh.CLEAR);
            this.dispatchEvent(i),
            this.changed()
        }, e.prototype.forEachFeature = function(t) {
            if (this.featuresRtree_)
                return this.featuresRtree_.forEach(t);
            this.featuresCollection_ && this.featuresCollection_.forEach(t)
        }, e.prototype.forEachFeatureAtCoordinateDirect = function(t, e) {
            var n = [t[0], t[1], t[0], t[1]];
            return this.forEachFeatureInExtent(n, (function(n) {
                return n.getGeometry().intersectsCoordinate(t) ? e(n) : void 0
            }))
        }, e.prototype.forEachFeatureInExtent = function(t, e) {
            if (this.featuresRtree_)
                return this.featuresRtree_.forEachInExtent(t, e);
            this.featuresCollection_ && this.featuresCollection_.forEach(e)
        }, e.prototype.forEachFeatureIntersectingExtent = function(t, e) {
            return this.forEachFeatureInExtent(t, (function(n) {
                if (n.getGeometry().intersectsExtent(t)) {
                    var r = e(n);
                    if (r)
                        return r
                }
            }))
        }, e.prototype.getFeaturesCollection = function() {
            return this.featuresCollection_
        }, e.prototype.getFeatures = function() {
            var t;
            return this.featuresCollection_ ? t = this.featuresCollection_.getArray().slice(0) : this.featuresRtree_ && (t = this.featuresRtree_.getAll(), N(this.nullGeometryFeatures_) || C(t, O(this.nullGeometryFeatures_))), t
        }, e.prototype.getFeaturesAtCoordinate = function(t) {
            var e = [];
            return this.forEachFeatureAtCoordinateDirect(t, (function(t) {
                e.push(t)
            })), e
        }, e.prototype.getFeaturesInExtent = function(t, e) {
            var n = this;
            if (this.featuresRtree_) {
                if (!(e && e.canWrapX() && this.getWrapX()))
                    return this.featuresRtree_.getInExtent(t);
                var r = he(t, e);
                return [].concat.apply([], r.map((function(t) {
                    return n.featuresRtree_.getInExtent(t)
                })))
            }
            return this.featuresCollection_ ? this.featuresCollection_.getArray().slice(0) : []
        }, e.prototype.getClosestFeatureToCoordinate = function(t, e) {
            var n = t[0],
                r = t[1],
                i = null,
                o = [NaN, NaN],
                s = 1 / 0,
                a = [-1 / 0, -1 / 0, 1 / 0, 1 / 0],
                u = e || S;
            return this.featuresRtree_.forEachInExtent(a, (function(t) {
                if (u(t)) {
                    var e = t.getGeometry(),
                        l = s;
                    if ((s = e.closestPointXY(n, r, o, s)) < l) {
                        i = t;
                        var h = Math.sqrt(s);
                        a[0] = n - h,
                        a[1] = r - h,
                        a[2] = n + h,
                        a[3] = r + h
                    }
                }
            })), i
        }, e.prototype.getExtent = function(t) {
            return this.featuresRtree_.getExtent(t)
        }, e.prototype.getFeatureById = function(t) {
            var e = this.idIndex_[t.toString()];
            return void 0 !== e ? e : null
        }, e.prototype.getFeatureByUid = function(t) {
            var e = this.uidIndex_[t];
            return void 0 !== e ? e : null
        }, e.prototype.getFormat = function() {
            return this.format_
        }, e.prototype.getOverlaps = function() {
            return this.overlaps_
        }, e.prototype.getUrl = function() {
            return this.url_
        }, e.prototype.handleFeatureChange_ = function(t) {
            var e = t.target,
                n = h(e),
                r = e.getGeometry();
            if (r) {
                var i = r.getExtent();
                n in this.nullGeometryFeatures_ ? (delete this.nullGeometryFeatures_[n], this.featuresRtree_ && this.featuresRtree_.insert(i, e)) : this.featuresRtree_ && this.featuresRtree_.update(i, e)
            } else
                n in this.nullGeometryFeatures_ || (this.featuresRtree_ && this.featuresRtree_.remove(e), this.nullGeometryFeatures_[n] = e);
            var o = e.getId();
            if (void 0 !== o) {
                var s = o.toString();
                this.idIndex_[s] !== e && (this.removeFromIdIndex_(e), this.idIndex_[s] = e)
            } else
                this.removeFromIdIndex_(e),
                this.uidIndex_[n] = e;
            this.changed(),
            this.dispatchEvent(new hh(oh.CHANGEFEATURE, e))
        }, e.prototype.hasFeature = function(t) {
            var e = t.getId();
            return void 0 !== e ? e in this.idIndex_ : h(t) in this.uidIndex_
        }, e.prototype.isEmpty = function() {
            return this.featuresRtree_ ? this.featuresRtree_.isEmpty() && N(this.nullGeometryFeatures_) : !this.featuresCollection_ || 0 === this.featuresCollection_.getLength()
        }, e.prototype.loadFeatures = function(t, e, n) {
            for (var r = this.loadedExtentsRtree_, i = this.strategy_(t, e, n), o = function(t, o) {
                    var a = i[t];
                    r.forEachInExtent(a, (function(t) {
                        return Nt(t.extent, a)
                    })) || (++s.loadingExtentsCount_, s.dispatchEvent(new hh(oh.FEATURESLOADSTART)), s.loader_.call(s, a, e, n, function(t) {
                        --this.loadingExtentsCount_,
                        this.dispatchEvent(new hh(oh.FEATURESLOADEND, void 0, t))
                    }.bind(s), function() {
                        --this.loadingExtentsCount_,
                        this.dispatchEvent(new hh(oh.FEATURESLOADERROR))
                    }.bind(s)), r.insert(a, {
                        extent: a.slice()
                    }))
                }, s = this, a = 0, u = i.length; a < u; ++a)
                o(a);
            this.loading = !(this.loader_.length < 4) && this.loadingExtentsCount_ > 0
        }, e.prototype.refresh = function() {
            this.clear(!0),
            this.loadedExtentsRtree_.clear(),
            t.prototype.refresh.call(this)
        }, e.prototype.removeLoadedExtent = function(t) {
            var e,
                n = this.loadedExtentsRtree_;
            n.forEachInExtent(t, (function(n) {
                if (Bt(n.extent, t))
                    return e = n, !0
            })),
            e && n.remove(e)
        }, e.prototype.removeFeature = function(t) {
            if (t) {
                var e = h(t);
                e in this.nullGeometryFeatures_ ? delete this.nullGeometryFeatures_[e] : this.featuresRtree_ && this.featuresRtree_.remove(t),
                this.removeFeatureInternal(t) && this.changed()
            }
        }, e.prototype.removeFeatureInternal = function(t) {
            var e = h(t),
                n = this.featureChangeKeys_[e];
            if (n) {
                n.forEach(j),
                delete this.featureChangeKeys_[e];
                var r = t.getId();
                return void 0 !== r && delete this.idIndex_[r.toString()], delete this.uidIndex_[e], this.dispatchEvent(new hh(oh.REMOVEFEATURE, t)), t
            }
        }, e.prototype.removeFromIdIndex_ = function(t) {
            var e = !1;
            for (var n in this.idIndex_)
                if (this.idIndex_[n] === t) {
                    delete this.idIndex_[n],
                    e = !0;
                    break
                }
            return e
        }, e.prototype.setLoader = function(t) {
            this.loader_ = t
        }, e.prototype.setUrl = function(t) {
            J(this.format_, 7),
            this.url_ = t,
            this.setLoader(uh(t, this.format_))
        }, e
    }(eh.default),
    ph = ch,
    fh = function() {
        var t = function(e, n) {
            return t = Object.setPrototypeOf || {
                __proto__: []
            } instanceof Array && function(t, e) {
                t.__proto__ = e
            } || function(t, e) {
                for (var n in e)
                    Object.prototype.hasOwnProperty.call(e, n) && (t[n] = e[n])
            }, t(e, n)
        };
        return function(e, n) {
            if ("function" != typeof n && null !== n)
                throw new TypeError("Class extends value " + String(n) + " is not a constructor or null");
            function r() {
                this.constructor = e
            }
            t(e, n),
            e.prototype = null === n ? Object.create(n) : (r.prototype = n.prototype, new r)
        }
    }(),
    dh = "Point",
    gh = "LineString",
    yh = "Polygon",
    vh = "Circle",
    mh = "drawstart",
    _h = "drawend",
    xh = "drawabort",
    Eh = function(t) {
        function e(e, n) {
            var r = t.call(this, e) || this;
            return r.feature = n, r
        }
        return fh(e, t), e
    }(g);
function wh(t, e) {
    return function(n, r, i) {
        var o = Cn(n[0], i),
            s = Cn(n[n.length - 1], i),
            a = Math.sqrt(Ke(o, s)),
            u = r || (0, rt.fromCircle)(new (0, Ta.default)(o), t),
            l = e;
        if (!e && 0 !== e) {
            var h = s[0] - o[0],
                c = s[1] - o[1];
            l = Math.atan2(c, h)
        }
        (0, rt.makeRegular)(u, o, a, l);
        var p = wn();
        return p && u.transform(i, p), u
    }
}
function bh() {
    return function(t, e, n) {
        var r = It([t[0], t[t.length - 1]].map((function(t) {
                return Cn(t, n)
            }))),
            i = [[Yt(r), Wt(r), ne(r), ee(r), Yt(r)]],
            o = e;
        o ? o.setCoordinates(i) : o = new (0, rt.default)(i);
        var s = wn();
        return s && o.transform(n, s), o
    }
}
var Ch = function(t) {
        function e(e) {
            var n = this,
                r = e;
            r.stopDown || (r.stopDown = I),
            (n = t.call(this, r) || this).on,
            n.once,
            n.un,
            n.shouldHandle_ = !1,
            n.downPx_ = null,
            n.downTimeout_,
            n.lastDragTime_,
            n.pointerType_,
            n.freehand_ = !1,
            n.source_ = e.source ? e.source : null,
            n.features_ = e.features ? e.features : null,
            n.snapTolerance_ = e.snapTolerance ? e.snapTolerance : 12,
            n.type_ = e.type,
            n.mode_ = function(t) {
                switch (t) {
                case "Point":
                case "MultiPoint":
                    return dh;
                case "LineString":
                case "MultiLineString":
                    return gh;
                case "Polygon":
                case "MultiPolygon":
                    return yh;
                case "Circle":
                    return vh;
                default:
                    throw new Error("Invalid type: " + t)
                }
            }(n.type_),
            n.stopClick_ = !!e.stopClick,
            n.minPoints_ = e.minPoints ? e.minPoints : n.mode_ === yh ? 3 : 2,
            n.maxPoints_ = n.mode_ === vh ? 2 : e.maxPoints ? e.maxPoints : 1 / 0,
            n.finishCondition_ = e.finishCondition ? e.finishCondition : S,
            n.geometryLayout_ = e.geometryLayout ? e.geometryLayout : it.XY;
            var i,
                o = e.geometryFunction;
            if (!o) {
                var s,
                    a = n.mode_;
                if (a === vh)
                    o = function(t, e, n) {
                        var r = e || new (0, Ta.default)([NaN, NaN]),
                            i = Cn(t[0], n),
                            o = Ke(i, Cn(t[t.length - 1], n));
                        r.setCenterAndRadius(i, Math.sqrt(o), this.geometryLayout_);
                        var s = wn();
                        return s && r.transform(n, s), r
                    };
                else
                    a === dh ? s = hr.default : a === gh ? s = Na.default : a === yh && (s = rt.default),
                    o = function(t, e, n) {
                        return e ? a === yh ? t[0].length ? e.setCoordinates([t[0].concat([t[0][0]])], this.geometryLayout_) : e.setCoordinates([], this.geometryLayout_) : e.setCoordinates(t, this.geometryLayout_) : e = new s(t, this.geometryLayout_), e
                    }
            }
            return n.geometryFunction_ = o, n.dragVertexDelay_ = void 0 !== e.dragVertexDelay ? e.dragVertexDelay : 500, n.finishCoordinate_ = null, n.sketchFeature_ = null, n.sketchPoint_ = null, n.sketchCoords_ = null, n.sketchLine_ = null, n.sketchLineCoords_ = null, n.squaredClickTolerance_ = e.clickTolerance ? e.clickTolerance * e.clickTolerance : 36, n.overlay_ = new (0, Ka.default)({
                source: new (0, Jl.default)({
                    useSpatialIndex: !1,
                    wrapX: !!e.wrapX && e.wrapX
                }),
                style: e.style ? e.style : (i = du(), function(t, e) {
                    return i[t.getGeometry().getType()]
                }),
                updateWhileInteracting: !0
            }), n.geometryName_ = e.geometryName, n.condition_ = e.condition ? e.condition : Gs, n.freehandCondition_, e.freehand ? n.freehandCondition_ = Fs : n.freehandCondition_ = e.freehandCondition ? e.freehandCondition : Bs, n.addChangeListener(xs.ACTIVE, n.updateState_), n
        }
        return fh(e, t), e.prototype.setMap = function(e) {
            t.prototype.setMap.call(this, e),
            this.updateState_()
        }, e.prototype.getOverlay = function() {
            return this.overlay_
        }, e.prototype.handleEvent = function(e) {
            e.originalEvent.type === D.CONTEXTMENU && e.originalEvent.preventDefault(),
            this.freehand_ = this.mode_ !== dh && this.freehandCondition_(e);
            var n = e.type === go.POINTERMOVE,
                r = !0;
            !this.freehand_ && this.lastDragTime_ && e.type === go.POINTERDRAG && (Date.now() - this.lastDragTime_ >= this.dragVertexDelay_ ? (this.downPx_ = e.pixel, this.shouldHandle_ = !this.freehand_, n = !0) : this.lastDragTime_ = void 0, this.shouldHandle_ && void 0 !== this.downTimeout_ && (clearTimeout(this.downTimeout_), this.downTimeout_ = void 0));
            return this.freehand_ && e.type === go.POINTERDRAG && null !== this.sketchFeature_ ? (this.addToDrawing_(e.coordinate), r = !1) : this.freehand_ && e.type === go.POINTERDOWN ? r = !1 : n && this.getPointerCount() < 2 ? (r = e.type === go.POINTERMOVE) && this.freehand_ ? (this.handlePointerMove_(e), this.shouldHandle_ && e.originalEvent.preventDefault()) : ("mouse" === e.originalEvent.pointerType || e.type === go.POINTERDRAG && void 0 === this.downTimeout_) && this.handlePointerMove_(e) : e.type === go.DBLCLICK && (r = !1), t.prototype.handleEvent.call(this, e) && r
        }, e.prototype.handleDownEvent = function(t) {
            return this.shouldHandle_ = !this.freehand_, this.freehand_ ? (this.downPx_ = t.pixel, this.finishCoordinate_ || this.startDrawing_(t.coordinate), !0) : this.condition_(t) ? (this.lastDragTime_ = Date.now(), this.downTimeout_ = setTimeout(function() {
                this.handlePointerMove_(new (0, ao.default)(go.POINTERMOVE, t.map, t.originalEvent, !1, t.frameState))
            }.bind(this), this.dragVertexDelay_), this.downPx_ = t.pixel, !0) : (this.lastDragTime_ = void 0, !1)
        }, e.prototype.handleUpEvent = function(t) {
            var e = !0;
            if (0 === this.getPointerCount())
                if (this.downTimeout_ && (clearTimeout(this.downTimeout_), this.downTimeout_ = void 0), this.handlePointerMove_(t), this.shouldHandle_) {
                    var n = !this.finishCoordinate_;
                    n && this.startDrawing_(t.coordinate),
                    !n && this.freehand_ ? this.finishDrawing() : this.freehand_ || n && this.mode_ !== dh || (this.atFinish_(t.pixel) ? this.finishCondition_(t) && this.finishDrawing() : this.addToDrawing_(t.coordinate)),
                    e = !1
                } else
                    this.freehand_ && this.abortDrawing();
            return !e && this.stopClick_ && t.preventDefault(), e
        }, e.prototype.handlePointerMove_ = function(t) {
            if (this.pointerType_ = t.originalEvent.pointerType, this.downPx_ && (!this.freehand_ && this.shouldHandle_ || this.freehand_ && !this.shouldHandle_)) {
                var e = this.downPx_,
                    n = t.pixel,
                    r = e[0] - n[0],
                    i = e[1] - n[1],
                    o = r * r + i * i;
                if (this.shouldHandle_ = this.freehand_ ? o > this.squaredClickTolerance_ : o <= this.squaredClickTolerance_, !this.shouldHandle_)
                    return
            }
            this.finishCoordinate_ ? this.modifyDrawing_(t.coordinate) : this.createOrUpdateSketchPoint_(t.coordinate.slice())
        }, e.prototype.atFinish_ = function(t) {
            var e = !1;
            if (this.sketchFeature_) {
                var n = !1,
                    r = [this.finishCoordinate_],
                    i = this.mode_;
                if (i === dh)
                    e = !0;
                else if (i === vh)
                    e = 2 === this.sketchCoords_.length;
                else if (i === gh)
                    n = this.sketchCoords_.length > this.minPoints_;
                else if (i === yh) {
                    var o = this.sketchCoords_;
                    n = o[0].length > this.minPoints_,
                    r = [o[0][0], o[0][o[0].length - 2]]
                }
                if (n)
                    for (var s = this.getMap(), a = 0, u = r.length; a < u; a++) {
                        var l = r[a],
                            h = s.getPixelFromCoordinate(l),
                            c = t[0] - h[0],
                            p = t[1] - h[1],
                            f = this.freehand_ ? 1 : this.snapTolerance_;
                        if (e = Math.sqrt(c * c + p * p) <= f) {
                            this.finishCoordinate_ = l;
                            break
                        }
                    }
            }
            return e
        }, e.prototype.createOrUpdateSketchPoint_ = function(t) {
            this.sketchPoint_ ? this.sketchPoint_.getGeometry().setCoordinates(t) : (this.sketchPoint_ = new (0, Z.default)(new (0, hr.default)(t)), this.updateSketchFeatures_())
        }, e.prototype.createOrUpdateCustomSketchLine_ = function(t) {
            this.sketchLine_ || (this.sketchLine_ = new (0, Z.default));
            var e = t.getLinearRing(0),
                n = this.sketchLine_.getGeometry();
            n ? (n.setFlatCoordinates(e.getLayout(), e.getFlatCoordinates()), n.changed()) : (n = new (0, Na.default)(e.getFlatCoordinates(), e.getLayout()), this.sketchLine_.setGeometry(n))
        }, e.prototype.startDrawing_ = function(t) {
            for (var e = this.getMap().getView().getProjection(), n = (0, st.getStrideForLayout)(this.geometryLayout_); t.length < n;)
                t.push(0);
            this.finishCoordinate_ = t,
            this.mode_ === dh ? this.sketchCoords_ = t.slice() : this.mode_ === yh ? (this.sketchCoords_ = [[t.slice(), t.slice()]], this.sketchLineCoords_ = this.sketchCoords_[0]) : this.sketchCoords_ = [t.slice(), t.slice()],
            this.sketchLineCoords_ && (this.sketchLine_ = new (0, Z.default)(new (0, Na.default)(this.sketchLineCoords_)));
            var r = this.geometryFunction_(this.sketchCoords_, void 0, e);
            this.sketchFeature_ = new (0, Z.default),
            this.geometryName_ && this.sketchFeature_.setGeometryName(this.geometryName_),
            this.sketchFeature_.setGeometry(r),
            this.updateSketchFeatures_(),
            this.dispatchEvent(new Eh(mh, this.sketchFeature_))
        }, e.prototype.modifyDrawing_ = function(t) {
            for (var e, n, r = this.getMap(), i = this.sketchFeature_.getGeometry(), o = r.getView().getProjection(), s = (0, st.getStrideForLayout)(this.geometryLayout_); t.length < s;)
                t.push(0);
            (this.mode_ === dh ? n = this.sketchCoords_ : this.mode_ === yh ? (n = (e = this.sketchCoords_[0])[e.length - 1], this.atFinish_(r.getPixelFromCoordinate(t)) && (t = this.finishCoordinate_.slice())) : n = (e = this.sketchCoords_)[e.length - 1], n[0] = t[0], n[1] = t[1], this.geometryFunction_(this.sketchCoords_, i, o), this.sketchPoint_) && this.sketchPoint_.getGeometry().setCoordinates(t);
            if ("Polygon" === i.getType() && this.mode_ !== yh)
                this.createOrUpdateCustomSketchLine_(i);
            else if (this.sketchLineCoords_) {
                this.sketchLine_.getGeometry().setCoordinates(this.sketchLineCoords_)
            }
            this.updateSketchFeatures_()
        }, e.prototype.addToDrawing_ = function(t) {
            var e,
                n,
                r = this.sketchFeature_.getGeometry(),
                i = this.getMap().getView().getProjection(),
                o = this.mode_;
            o === gh || o === vh ? (this.finishCoordinate_ = t.slice(), (n = this.sketchCoords_).length >= this.maxPoints_ && (this.freehand_ ? n.pop() : e = !0), n.push(t.slice()), this.geometryFunction_(n, r, i)) : o === yh && ((n = this.sketchCoords_[0]).length >= this.maxPoints_ && (this.freehand_ ? n.pop() : e = !0), n.push(t.slice()), e && (this.finishCoordinate_ = n[0]), this.geometryFunction_(this.sketchCoords_, r, i)),
            this.createOrUpdateSketchPoint_(t.slice()),
            this.updateSketchFeatures_(),
            e && this.finishDrawing()
        }, e.prototype.removeLastPoint = function() {
            if (this.sketchFeature_) {
                var t,
                    e = this.sketchFeature_.getGeometry(),
                    n = this.getMap().getView().getProjection(),
                    r = this.mode_;
                if (r === gh || r === vh) {
                    if ((t = this.sketchCoords_).splice(-2, 1), t.length >= 2) {
                        this.finishCoordinate_ = t[t.length - 2].slice();
                        var i = this.finishCoordinate_.slice();
                        t[t.length - 1] = i,
                        this.createOrUpdateSketchPoint_(i)
                    }
                    this.geometryFunction_(t, e, n),
                    "Polygon" === e.getType() && this.sketchLine_ && this.createOrUpdateCustomSketchLine_(e)
                } else if (r === yh) {
                    (t = this.sketchCoords_[0]).splice(-2, 1);
                    var o = this.sketchLine_.getGeometry();
                    if (t.length >= 2) {
                        i = t[t.length - 2].slice();
                        t[t.length - 1] = i,
                        this.createOrUpdateSketchPoint_(i)
                    }
                    o.setCoordinates(t),
                    this.geometryFunction_(this.sketchCoords_, e, n)
                }
                1 === t.length && this.abortDrawing(),
                this.updateSketchFeatures_()
            }
        }, e.prototype.finishDrawing = function() {
            var t = this.abortDrawing_();
            if (t) {
                var e = this.sketchCoords_,
                    n = t.getGeometry(),
                    r = this.getMap().getView().getProjection();
                this.mode_ === gh ? (e.pop(), this.geometryFunction_(e, n, r)) : this.mode_ === yh && (e[0].pop(), this.geometryFunction_(e, n, r), e = n.getCoordinates()),
                "MultiPoint" === this.type_ ? t.setGeometry(new (0, Ua.default)([e])) : "MultiLineString" === this.type_ ? t.setGeometry(new (0, Ba.default)([e])) : "MultiPolygon" === this.type_ && t.setGeometry(new (0, Ha.default)([e])),
                this.dispatchEvent(new Eh(_h, t)),
                this.features_ && this.features_.push(t),
                this.source_ && this.source_.addFeature(t)
            }
        }, e.prototype.abortDrawing_ = function() {
            this.finishCoordinate_ = null;
            var t = this.sketchFeature_;
            return this.sketchFeature_ = null, this.sketchPoint_ = null, this.sketchLine_ = null, this.overlay_.getSource().clear(!0), t
        }, e.prototype.abortDrawing = function() {
            var t = this.abortDrawing_();
            t && this.dispatchEvent(new Eh(xh, t))
        }, e.prototype.appendCoordinates = function(t) {
            var e,
                n = this.mode_,
                r = !this.sketchFeature_;
            if (r && this.startDrawing_(t[0]), n === gh || n === vh)
                e = this.sketchCoords_;
            else {
                if (n !== yh)
                    return;
                e = this.sketchCoords_ && this.sketchCoords_.length ? this.sketchCoords_[0] : []
            }
            r && e.shift(),
            e.pop();
            for (var i = 0; i < t.length; i++)
                this.addToDrawing_(t[i]);
            var o = t[t.length - 1];
            this.addToDrawing_(o),
            this.modifyDrawing_(o)
        }, e.prototype.extend = function(t) {
            var e = t.getGeometry();
            this.sketchFeature_ = t,
            this.sketchCoords_ = e.getCoordinates();
            var n = this.sketchCoords_[this.sketchCoords_.length - 1];
            this.finishCoordinate_ = n.slice(),
            this.sketchCoords_.push(n.slice()),
            this.sketchPoint_ = new (0, Z.default)(new (0, hr.default)(n)),
            this.updateSketchFeatures_(),
            this.dispatchEvent(new Eh(mh, this.sketchFeature_))
        }, e.prototype.updateSketchFeatures_ = function() {
            var t = [];
            this.sketchFeature_ && t.push(this.sketchFeature_),
            this.sketchLine_ && t.push(this.sketchLine_),
            this.sketchPoint_ && t.push(this.sketchPoint_);
            var e = this.overlay_.getSource();
            e.clear(!0),
            e.addFeatures(t)
        }, e.prototype.updateState_ = function() {
            var t = this.getMap(),
                e = this.getActive();
            t && e || this.abortDrawing(),
            this.overlay_.setMap(e ? t : null)
        }, e
    }(Ts.default),
    Mh = {};
t(Mh, "ModifyEvent", (() => Oh), (t => Oh = t)),
t(Mh, "default", (() => Fh), (t => Fh = t));
var Sh = function() {
        var t = function(e, n) {
            return t = Object.setPrototypeOf || {
                __proto__: []
            } instanceof Array && function(t, e) {
                t.__proto__ = e
            } || function(t, e) {
                for (var n in e)
                    Object.prototype.hasOwnProperty.call(e, n) && (t[n] = e[n])
            }, t(e, n)
        };
        return function(e, n) {
            if ("function" != typeof n && null !== n)
                throw new TypeError("Class extends value " + String(n) + " is not a constructor or null");
            function r() {
                this.constructor = e
            }
            t(e, n),
            e.prototype = null === n ? Object.create(n) : (r.prototype = n.prototype, new r)
        }
    }(),
    Ih = [0, 0, 0, 0],
    Th = [],
    Ph = "modifystart",
    Lh = "modifyend",
    Oh = function(t) {
        function e(e, n, r) {
            var i = t.call(this, e) || this;
            return i.features = n, i.mapBrowserEvent = r, i
        }
        return Sh(e, t), e
    }(g),
    Nh = function(t) {
        function e(e) {
            var n,
                r,
                i = t.call(this, e) || this;
            if (i.on, i.once, i.un, i.boundHandleFeatureChange_ = i.handleFeatureChange_.bind(i), i.condition_ = e.condition ? e.condition : Us, i.defaultDeleteCondition_ = function(t) {
                return Rs(t) && js(t)
            }, i.deleteCondition_ = e.deleteCondition ? e.deleteCondition : i.defaultDeleteCondition_, i.insertVertexCondition_ = e.insertVertexCondition ? e.insertVertexCondition : Fs, i.vertexFeature_ = null, i.vertexSegments_ = null, i.lastPixel_ = [0, 0], i.ignoreNextSingleClick_ = !1, i.featuresBeingModified_ = null, i.rBush_ = new th, i.pixelTolerance_ = void 0 !== e.pixelTolerance ? e.pixelTolerance : 10, i.snappedToVertex_ = !1, i.changingFeature_ = !1, i.dragSegments_ = [], i.overlay_ = new (0, Ka.default)({
                source: new (0, Jl.default)({
                    useSpatialIndex: !1,
                    wrapX: !!e.wrapX
                }),
                style: e.style ? e.style : (n = du(), function(t, e) {
                    return n.Point
                }),
                updateWhileAnimating: !0,
                updateWhileInteracting: !0
            }), i.SEGMENT_WRITERS_ = {
                Point: i.writePointGeometry_.bind(i),
                LineString: i.writeLineStringGeometry_.bind(i),
                LinearRing: i.writeLineStringGeometry_.bind(i),
                Polygon: i.writePolygonGeometry_.bind(i),
                MultiPoint: i.writeMultiPointGeometry_.bind(i),
                MultiLineString: i.writeMultiLineStringGeometry_.bind(i),
                MultiPolygon: i.writeMultiPolygonGeometry_.bind(i),
                Circle: i.writeCircleGeometry_.bind(i),
                GeometryCollection: i.writeGeometryCollectionGeometry_.bind(i)
            }, i.source_ = null, i.hitDetection_ = null, e.features ? r = e.features : e.source && (i.source_ = e.source, r = new (0, s.default)(i.source_.getFeatures()), i.source_.addEventListener(oh.ADDFEATURE, i.handleSourceAdd_.bind(i)), i.source_.addEventListener(oh.REMOVEFEATURE, i.handleSourceRemove_.bind(i))), !r)
                throw new Error("The modify interaction requires features, a source or a layer");
            return e.hitDetection && (i.hitDetection_ = e.hitDetection), i.features_ = r, i.features_.forEach(i.addFeature_.bind(i)), i.features_.addEventListener(H.ADD, i.handleFeatureAdd_.bind(i)), i.features_.addEventListener(H.REMOVE, i.handleFeatureRemove_.bind(i)), i.lastPointerEvent_ = null, i.delta_ = [0, 0], i.snapToPointer_ = void 0 === e.snapToPointer ? !i.hitDetection_ : e.snapToPointer, i
        }
        return Sh(e, t), e.prototype.addFeature_ = function(t) {
            var e = t.getGeometry();
            if (e) {
                var n = this.SEGMENT_WRITERS_[e.getType()];
                n && n(t, e)
            }
            var r = this.getMap();
            r && r.isRendered() && this.getActive() && this.handlePointerAtPixel_(this.lastPixel_, r),
            t.addEventListener(D.CHANGE, this.boundHandleFeatureChange_)
        }, e.prototype.willModifyFeatures_ = function(t, e) {
            if (!this.featuresBeingModified_) {
                this.featuresBeingModified_ = new (0, s.default);
                for (var n = this.featuresBeingModified_.getArray(), r = 0, i = e.length; r < i; ++r)
                    for (var o = e[r], a = 0, u = o.length; a < u; ++a) {
                        var l = o[a].feature;
                        l && -1 === n.indexOf(l) && this.featuresBeingModified_.push(l)
                    }
                0 === this.featuresBeingModified_.getLength() ? this.featuresBeingModified_ = null : this.dispatchEvent(new Oh(Ph, this.featuresBeingModified_, t))
            }
        }, e.prototype.removeFeature_ = function(t) {
            this.removeFeatureSegmentData_(t),
            this.vertexFeature_ && 0 === this.features_.getLength() && (this.overlay_.getSource().removeFeature(this.vertexFeature_), this.vertexFeature_ = null),
            t.removeEventListener(D.CHANGE, this.boundHandleFeatureChange_)
        }, e.prototype.removeFeatureSegmentData_ = function(t) {
            var e = this.rBush_,
                n = [];
            e.forEach((function(e) {
                t === e.feature && n.push(e)
            }));
            for (var r = n.length - 1; r >= 0; --r) {
                for (var i = n[r], o = this.dragSegments_.length - 1; o >= 0; --o)
                    this.dragSegments_[o][0] === i && this.dragSegments_.splice(o, 1);
                e.remove(i)
            }
        }, e.prototype.setActive = function(e) {
            this.vertexFeature_ && !e && (this.overlay_.getSource().removeFeature(this.vertexFeature_), this.vertexFeature_ = null),
            t.prototype.setActive.call(this, e)
        }, e.prototype.setMap = function(e) {
            this.overlay_.setMap(e),
            t.prototype.setMap.call(this, e)
        }, e.prototype.getOverlay = function() {
            return this.overlay_
        }, e.prototype.handleSourceAdd_ = function(t) {
            t.feature && this.features_.push(t.feature)
        }, e.prototype.handleSourceRemove_ = function(t) {
            t.feature && this.features_.remove(t.feature)
        }, e.prototype.handleFeatureAdd_ = function(t) {
            this.addFeature_(t.element)
        }, e.prototype.handleFeatureChange_ = function(t) {
            if (!this.changingFeature_) {
                var e = t.target;
                this.removeFeature_(e),
                this.addFeature_(e)
            }
        }, e.prototype.handleFeatureRemove_ = function(t) {
            var e = t.element;
            this.removeFeature_(e)
        }, e.prototype.writePointGeometry_ = function(t, e) {
            var n = e.getCoordinates(),
                r = {
                    feature: t,
                    geometry: e,
                    segment: [n, n]
                };
            this.rBush_.insert(e.getExtent(), r)
        }, e.prototype.writeMultiPointGeometry_ = function(t, e) {
            for (var n = e.getCoordinates(), r = 0, i = n.length; r < i; ++r) {
                var o = n[r],
                    s = {
                        feature: t,
                        geometry: e,
                        depth: [r],
                        index: r,
                        segment: [o, o]
                    };
                this.rBush_.insert(e.getExtent(), s)
            }
        }, e.prototype.writeLineStringGeometry_ = function(t, e) {
            for (var n = e.getCoordinates(), r = 0, i = n.length - 1; r < i; ++r) {
                var o = n.slice(r, r + 2),
                    s = {
                        feature: t,
                        geometry: e,
                        index: r,
                        segment: o
                    };
                this.rBush_.insert(It(o), s)
            }
        }, e.prototype.writeMultiLineStringGeometry_ = function(t, e) {
            for (var n = e.getCoordinates(), r = 0, i = n.length; r < i; ++r)
                for (var o = n[r], s = 0, a = o.length - 1; s < a; ++s) {
                    var u = o.slice(s, s + 2),
                        l = {
                            feature: t,
                            geometry: e,
                            depth: [r],
                            index: s,
                            segment: u
                        };
                    this.rBush_.insert(It(u), l)
                }
        }, e.prototype.writePolygonGeometry_ = function(t, e) {
            for (var n = e.getCoordinates(), r = 0, i = n.length; r < i; ++r)
                for (var o = n[r], s = 0, a = o.length - 1; s < a; ++s) {
                    var u = o.slice(s, s + 2),
                        l = {
                            feature: t,
                            geometry: e,
                            depth: [r],
                            index: s,
                            segment: u
                        };
                    this.rBush_.insert(It(u), l)
                }
        }, e.prototype.writeMultiPolygonGeometry_ = function(t, e) {
            for (var n = e.getCoordinates(), r = 0, i = n.length; r < i; ++r)
                for (var o = n[r], s = 0, a = o.length; s < a; ++s)
                    for (var u = o[s], l = 0, h = u.length - 1; l < h; ++l) {
                        var c = u.slice(l, l + 2),
                            p = {
                                feature: t,
                                geometry: e,
                                depth: [s, r],
                                index: l,
                                segment: c
                            };
                        this.rBush_.insert(It(c), p)
                    }
        }, e.prototype.writeCircleGeometry_ = function(t, e) {
            var n = e.getCenter(),
                r = {
                    feature: t,
                    geometry: e,
                    index: 0,
                    segment: [n, n]
                },
                i = {
                    feature: t,
                    geometry: e,
                    index: 1,
                    segment: [n, n]
                },
                o = [r, i];
            r.featureSegments = o,
            i.featureSegments = o,
            this.rBush_.insert(jt(n), r);
            var s = e,
                a = wn();
            if (a && this.getMap()) {
                var u = this.getMap().getView().getProjection();
                s = s.clone().transform(a, u),
                s = (0, rt.fromCircle)(s).transform(u, a)
            }
            this.rBush_.insert(s.getExtent(), i)
        }, e.prototype.writeGeometryCollectionGeometry_ = function(t, e) {
            for (var n = e.getGeometriesArray(), r = 0; r < n.length; ++r) {
                var i = n[r];
                (0, this.SEGMENT_WRITERS_[i.getType()])(t, i)
            }
        }, e.prototype.createOrUpdateVertexFeature_ = function(t, e, n) {
            var r = this.vertexFeature_;
            r ? r.getGeometry().setCoordinates(t) : (r = new (0, Z.default)(new (0, hr.default)(t)), this.vertexFeature_ = r, this.overlay_.getSource().addFeature(r));
            return r.set("features", e), r.set("geometries", n), r
        }, e.prototype.handleEvent = function(e) {
            return !e.originalEvent || (this.lastPointerEvent_ = e, e.map.getView().getInteracting() || e.type != go.POINTERMOVE || this.handlingDownUpSequence || this.handlePointerMove_(e), this.vertexFeature_ && this.deleteCondition_(e) && (n = !(e.type != go.SINGLECLICK || !this.ignoreNextSingleClick_) || this.removePoint()), e.type == go.SINGLECLICK && (this.ignoreNextSingleClick_ = !1), t.prototype.handleEvent.call(this, e) && !n);
            var n
        }, e.prototype.handleDragEvent = function(t) {
            this.ignoreNextSingleClick_ = !1,
            this.willModifyFeatures_(t, this.dragSegments_);
            for (var e = [t.coordinate[0] + this.delta_[0], t.coordinate[1] + this.delta_[1]], n = [], r = [], i = 0, o = this.dragSegments_.length; i < o; ++i) {
                var s = this.dragSegments_[i],
                    a = s[0],
                    u = a.feature;
                -1 === n.indexOf(u) && n.push(u);
                var l = a.geometry;
                -1 === r.indexOf(l) && r.push(l);
                for (var h = a.depth, c = void 0, p = a.segment, f = s[1]; e.length < l.getStride();)
                    e.push(p[f][e.length]);
                switch (l.getType()) {
                case "Point":
                    c = e,
                    p[0] = e,
                    p[1] = e;
                    break;
                case "MultiPoint":
                    (c = l.getCoordinates())[a.index] = e,
                    p[0] = e,
                    p[1] = e;
                    break;
                case "LineString":
                    (c = l.getCoordinates())[a.index + f] = e,
                    p[f] = e;
                    break;
                case "MultiLineString":
                case "Polygon":
                    (c = l.getCoordinates())[h[0]][a.index + f] = e,
                    p[f] = e;
                    break;
                case "MultiPolygon":
                    (c = l.getCoordinates())[h[1]][h[0]][a.index + f] = e,
                    p[f] = e;
                    break;
                case "Circle":
                    if (p[0] = e, p[1] = e, 0 === a.index)
                        this.changingFeature_ = !0,
                        l.setCenter(e),
                        this.changingFeature_ = !1;
                    else {
                        this.changingFeature_ = !0;
                        var d = t.map.getView().getProjection(),
                            g = Ze(Cn(l.getCenter(), d), Cn(e, d)),
                            y = wn();
                        if (y) {
                            var v = l.clone().transform(y, d);
                            v.setRadius(g),
                            g = v.transform(d, y).getRadius()
                        }
                        l.setRadius(g),
                        this.changingFeature_ = !1
                    }
                }
                c && this.setGeometryCoordinates_(l, c)
            }
            this.createOrUpdateVertexFeature_(e, n, r)
        }, e.prototype.handleDownEvent = function(t) {
            if (!this.condition_(t))
                return !1;
            var e = t.coordinate;
            this.handlePointerAtPixel_(t.pixel, t.map, e),
            this.dragSegments_.length = 0,
            this.featuresBeingModified_ = null;
            var n = this.vertexFeature_;
            if (n) {
                var r = t.map.getView().getProjection(),
                    i = [],
                    o = n.getGeometry().getCoordinates(),
                    s = It([o]),
                    a = this.rBush_.getInExtent(s),
                    u = {};
                a.sort(Rh);
                for (var l = 0, c = a.length; l < c; ++l) {
                    var p = a[l],
                        f = p.segment,
                        d = h(p.geometry),
                        g = p.depth;
                    if (g && (d += "-" + g.join("-")), u[d] || (u[d] = new Array(2)), "Circle" !== p.geometry.getType() || 1 !== p.index)
                        if (!We(f[0], o) || u[d][0])
                            if (!We(f[1], o) || u[d][1])
                                h(f) in this.vertexSegments_ && !u[d][0] && !u[d][1] && this.insertVertexCondition_(t) && i.push(p);
                            else {
                                if (u[d][0] && 0 === u[d][0].index) {
                                    var y = p.geometry.getCoordinates();
                                    switch (p.geometry.getType()) {
                                    case "LineString":
                                    case "MultiLineString":
                                        continue;
                                    case "MultiPolygon":
                                        y = y[g[1]];
                                    case "Polygon":
                                        if (p.index !== y[g[0]].length - 2)
                                            continue
                                    }
                                }
                                this.dragSegments_.push([p, 1]),
                                u[d][1] = p
                            }
                        else
                            this.dragSegments_.push([p, 0]),
                            u[d][0] = p;
                    else
                        We(Dh(e, p, r), o) && !u[d][0] && (this.dragSegments_.push([p, 0]), u[d][0] = p)
                }
                i.length && this.willModifyFeatures_(t, [i]);
                for (var v = i.length - 1; v >= 0; --v)
                    this.insertVertex_(i[v], o)
            }
            return !!this.vertexFeature_
        }, e.prototype.handleUpEvent = function(t) {
            for (var e = this.dragSegments_.length - 1; e >= 0; --e) {
                var n = this.dragSegments_[e][0],
                    r = n.geometry;
                if ("Circle" === r.getType()) {
                    var i = r.getCenter(),
                        o = n.featureSegments[0],
                        s = n.featureSegments[1];
                    o.segment[0] = i,
                    o.segment[1] = i,
                    s.segment[0] = i,
                    s.segment[1] = i,
                    this.rBush_.update(jt(i), o);
                    var a = r,
                        u = wn();
                    if (u) {
                        var l = t.map.getView().getProjection();
                        a = a.clone().transform(u, l),
                        a = (0, rt.fromCircle)(a).transform(l, u)
                    }
                    this.rBush_.update(a.getExtent(), s)
                } else
                    this.rBush_.update(It(n.segment), n)
            }
            return this.featuresBeingModified_ && (this.dispatchEvent(new Oh(Lh, this.featuresBeingModified_, t)), this.featuresBeingModified_ = null), !1
        }, e.prototype.handlePointerMove_ = function(t) {
            this.lastPixel_ = t.pixel,
            this.handlePointerAtPixel_(t.pixel, t.map, t.coordinate)
        }, e.prototype.handlePointerAtPixel_ = function(t, e, n) {
            var r,
                i,
                o = this,
                s = n || e.getCoordinateFromPixel(t),
                a = e.getView().getProjection();
            if (this.hitDetection_) {
                var u = "object" == typeof this.hitDetection_ ? function(t) {
                    return t === o.hitDetection_
                } : void 0;
                e.forEachFeatureAtPixel(t, (function(t, e, n) {
                    if ("Point" === (n = n || t.getGeometry()).getType() && (a = o.features_.getArray(), u = t, a.indexOf(u) >= 0)) {
                        i = n;
                        var s = n.getFlatCoordinates().slice(0, 2);
                        r = [{
                            feature: t,
                            geometry: n,
                            segment: [s, s]
                        }]
                    }
                    var a,
                        u;
                    return !0
                }), {
                    layerFilter: u
                })
            }
            if (!r) {
                var l = Mn(Tt(Sn(jt(s, Ih), a), e.getView().getResolution() * this.pixelTolerance_, Ih), a);
                r = this.rBush_.getInExtent(l)
            }
            if (r && r.length > 0) {
                var c = r.sort((function(t, e) {
                        return Ah(s, t, a) - Ah(s, e, a)
                    }))[0],
                    p = c.segment,
                    f = Dh(s, c, a),
                    d = e.getPixelFromCoordinate(f),
                    g = Ze(t, d);
                if (i || g <= this.pixelTolerance_) {
                    var y = {};
                    if (y[h(p)] = !0, this.snapToPointer_ || (this.delta_[0] = f[0] - s[0], this.delta_[1] = f[1] - s[1]), "Circle" === c.geometry.getType() && 1 === c.index)
                        this.snappedToVertex_ = !0,
                        this.createOrUpdateVertexFeature_(f, [c.feature], [c.geometry]);
                    else {
                        var v = e.getPixelFromCoordinate(p[0]),
                            m = e.getPixelFromCoordinate(p[1]),
                            _ = Ke(d, v),
                            x = Ke(d, m);
                        g = Math.sqrt(Math.min(_, x)),
                        this.snappedToVertex_ = g <= this.pixelTolerance_,
                        this.snappedToVertex_ && (f = _ > x ? p[1] : p[0]),
                        this.createOrUpdateVertexFeature_(f, [c.feature], [c.geometry]);
                        var E = {};
                        E[h(c.geometry)] = !0;
                        for (var w = 1, b = r.length; w < b; ++w) {
                            var C = r[w].segment;
                            if (!(We(p[0], C[0]) && We(p[1], C[1]) || We(p[0], C[1]) && We(p[1], C[0])))
                                break;
                            var M = h(r[w].geometry);
                            M in E || (E[M] = !0, y[h(C)] = !0)
                        }
                    }
                    return void (this.vertexSegments_ = y)
                }
            }
            this.vertexFeature_ && (this.overlay_.getSource().removeFeature(this.vertexFeature_), this.vertexFeature_ = null)
        }, e.prototype.insertVertex_ = function(t, e) {
            for (var n, r = t.segment, i = t.feature, o = t.geometry, s = t.depth, a = t.index; e.length < o.getStride();)
                e.push(0);
            switch (o.getType()) {
            case "MultiLineString":
            case "Polygon":
                (n = o.getCoordinates())[s[0]].splice(a + 1, 0, e);
                break;
            case "MultiPolygon":
                (n = o.getCoordinates())[s[1]][s[0]].splice(a + 1, 0, e);
                break;
            case "LineString":
                (n = o.getCoordinates()).splice(a + 1, 0, e);
                break;
            default:
                return
            }
            this.setGeometryCoordinates_(o, n);
            var u = this.rBush_;
            u.remove(t),
            this.updateSegmentIndices_(o, a, s, 1);
            var l = {
                segment: [r[0], e],
                feature: i,
                geometry: o,
                depth: s,
                index: a
            };
            u.insert(It(l.segment), l),
            this.dragSegments_.push([l, 1]);
            var h = {
                segment: [e, r[1]],
                feature: i,
                geometry: o,
                depth: s,
                index: a + 1
            };
            u.insert(It(h.segment), h),
            this.dragSegments_.push([h, 0]),
            this.ignoreNextSingleClick_ = !0
        }, e.prototype.removePoint = function() {
            if (this.lastPointerEvent_ && this.lastPointerEvent_.type != go.POINTERDRAG) {
                var t = this.lastPointerEvent_;
                this.willModifyFeatures_(t, this.dragSegments_);
                var e = this.removeVertex_();
                return this.featuresBeingModified_ && this.dispatchEvent(new Oh(Lh, this.featuresBeingModified_, t)), this.featuresBeingModified_ = null, e
            }
            return !1
        }, e.prototype.removeVertex_ = function() {
            var t,
                e,
                n,
                r,
                i,
                o,
                s,
                a,
                u,
                l,
                c,
                p = this.dragSegments_,
                f = {},
                d = !1;
            for (i = p.length - 1; i >= 0; --i)
                c = h((l = (n = p[i])[0]).feature),
                l.depth && (c += "-" + l.depth.join("-")),
                c in f || (f[c] = {}),
                0 === n[1] ? (f[c].right = l, f[c].index = l.index) : 1 == n[1] && (f[c].left = l, f[c].index = l.index + 1);
            for (c in f) {
                switch (u = f[c].right, s = f[c].left, (a = (o = f[c].index) - 1) < 0 && (a = 0), t = e = (r = (l = void 0 !== s ? s : u).geometry).getCoordinates(), d = !1, r.getType()) {
                case "MultiLineString":
                    e[l.depth[0]].length > 2 && (e[l.depth[0]].splice(o, 1), d = !0);
                    break;
                case "LineString":
                    e.length > 2 && (e.splice(o, 1), d = !0);
                    break;
                case "MultiPolygon":
                    t = t[l.depth[1]];
                case "Polygon":
                    (t = t[l.depth[0]]).length > 4 && (o == t.length - 1 && (o = 0), t.splice(o, 1), d = !0, 0 === o && (t.pop(), t.push(t[0]), a = t.length - 1))
                }
                if (d) {
                    this.setGeometryCoordinates_(r, e);
                    var g = [];
                    if (void 0 !== s && (this.rBush_.remove(s), g.push(s.segment[0])), void 0 !== u && (this.rBush_.remove(u), g.push(u.segment[1])), void 0 !== s && void 0 !== u) {
                        var y = {
                            depth: l.depth,
                            feature: l.feature,
                            geometry: l.geometry,
                            index: a,
                            segment: g
                        };
                        this.rBush_.insert(It(y.segment), y)
                    }
                    this.updateSegmentIndices_(r, o, l.depth, -1),
                    this.vertexFeature_ && (this.overlay_.getSource().removeFeature(this.vertexFeature_), this.vertexFeature_ = null),
                    p.length = 0
                }
            }
            return d
        }, e.prototype.setGeometryCoordinates_ = function(t, e) {
            this.changingFeature_ = !0,
            t.setCoordinates(e),
            this.changingFeature_ = !1
        }, e.prototype.updateSegmentIndices_ = function(t, e, n, r) {
            this.rBush_.forEachInExtent(t.getExtent(), (function(i) {
                i.geometry === t && (void 0 === n || void 0 === i.depth || M(i.depth, n)) && i.index > e && (i.index += r)
            }))
        }, e
    }(Ts.default);
function Rh(t, e) {
    return t.index - e.index
}
function Ah(t, e, n) {
    var r = e.geometry;
    if ("Circle" === r.getType()) {
        var i = r;
        if (1 === e.index) {
            var o = wn();
            o && (i = i.clone().transform(o, n));
            var s = Ke(i.getCenter(), Cn(t, n)),
                a = Math.sqrt(s) - i.getRadius();
            return a * a
        }
    }
    var u = Cn(t, n);
    return Th[0] = Cn(e.segment[0], n), Th[1] = Cn(e.segment[1], n), Je(u, Th)
}
function Dh(t, e, n) {
    var r = e.geometry;
    if ("Circle" === r.getType() && 1 === e.index) {
        var i = r,
            o = wn();
        return o && (i = i.clone().transform(o, n)), bn(i.getClosestPoint(Cn(t, n)), n)
    }
    var s = Cn(t, n);
    return Th[0] = Cn(e.segment[0], n), Th[1] = Cn(e.segment[1], n), bn(Ye(s, Th), n)
}
var Fh = Nh,
    kh = {};
t(kh, "default", (() => qh), (t => qh = t));
var jh = function() {
    var t = function(e, n) {
        return t = Object.setPrototypeOf || {
            __proto__: []
        } instanceof Array && function(t, e) {
            t.__proto__ = e
        } || function(t, e) {
            for (var n in e)
                Object.prototype.hasOwnProperty.call(e, n) && (t[n] = e[n])
        }, t(e, n)
    };
    return function(e, n) {
        if ("function" != typeof n && null !== n)
            throw new TypeError("Class extends value " + String(n) + " is not a constructor or null");
        function r() {
            this.constructor = e
        }
        t(e, n),
        e.prototype = null === n ? Object.create(n) : (r.prototype = n.prototype, new r)
    }
}();
function Gh(t) {
    return t.feature ? t.feature : t.element ? t.element : void 0
}
var Bh = [],
    qh = function(t) {
        function e(e) {
            var n = this,
                r = e || {},
                i = r;
            return i.handleDownEvent || (i.handleDownEvent = S), i.stopDown || (i.stopDown = I), (n = t.call(this, i) || this).source_ = r.source ? r.source : null, n.vertex_ = void 0 === r.vertex || r.vertex, n.edge_ = void 0 === r.edge || r.edge, n.features_ = r.features ? r.features : null, n.featuresListenerKeys_ = [], n.featureChangeListenerKeys_ = {}, n.indexedFeaturesExtents_ = {}, n.pendingFeatures_ = {}, n.pixelTolerance_ = void 0 !== r.pixelTolerance ? r.pixelTolerance : 10, n.rBush_ = new th, n.GEOMETRY_SEGMENTERS_ = {
                Point: n.segmentPointGeometry_.bind(n),
                LineString: n.segmentLineStringGeometry_.bind(n),
                LinearRing: n.segmentLineStringGeometry_.bind(n),
                Polygon: n.segmentPolygonGeometry_.bind(n),
                MultiPoint: n.segmentMultiPointGeometry_.bind(n),
                MultiLineString: n.segmentMultiLineStringGeometry_.bind(n),
                MultiPolygon: n.segmentMultiPolygonGeometry_.bind(n),
                GeometryCollection: n.segmentGeometryCollectionGeometry_.bind(n),
                Circle: n.segmentCircleGeometry_.bind(n)
            }, n
        }
        return jh(e, t), e.prototype.addFeature = function(t, e) {
            var n = void 0 === e || e,
                r = h(t),
                i = t.getGeometry();
            if (i) {
                var o = this.GEOMETRY_SEGMENTERS_[i.getType()];
                if (o) {
                    this.indexedFeaturesExtents_[r] = i.getExtent([1 / 0, 1 / 0, -1 / 0, -1 / 0]);
                    var s = [];
                    if (o(s, i), 1 === s.length)
                        this.rBush_.insert(It(s[0]), {
                            feature: t,
                            segment: s[0]
                        });
                    else if (s.length > 1) {
                        var a = s.map((function(t) {
                                return It(t)
                            })),
                            u = s.map((function(e) {
                                return {
                                    feature: t,
                                    segment: e
                                }
                            }));
                        this.rBush_.load(a, u)
                    }
                }
            }
            n && (this.featureChangeListenerKeys_[r] = F(t, D.CHANGE, this.handleFeatureChange_, this))
        }, e.prototype.forEachFeatureAdd_ = function(t) {
            this.addFeature(t)
        }, e.prototype.forEachFeatureRemove_ = function(t) {
            this.removeFeature(t)
        }, e.prototype.getFeatures_ = function() {
            var t;
            return this.features_ ? t = this.features_ : this.source_ && (t = this.source_.getFeatures()), t
        }, e.prototype.handleEvent = function(e) {
            var n = this.snapTo(e.pixel, e.coordinate, e.map);
            return n && (e.coordinate = n.vertex.slice(0, 2), e.pixel = n.vertexPixel), t.prototype.handleEvent.call(this, e)
        }, e.prototype.handleFeatureAdd_ = function(t) {
            var e = Gh(t);
            this.addFeature(e)
        }, e.prototype.handleFeatureRemove_ = function(t) {
            var e = Gh(t);
            this.removeFeature(e)
        }, e.prototype.handleFeatureChange_ = function(t) {
            var e = t.target;
            if (this.handlingDownUpSequence) {
                var n = h(e);
                n in this.pendingFeatures_ || (this.pendingFeatures_[n] = e)
            } else
                this.updateFeature_(e)
        }, e.prototype.handleUpEvent = function(t) {
            var e = O(this.pendingFeatures_);
            return e.length && (e.forEach(this.updateFeature_.bind(this)), this.pendingFeatures_ = {}), !1
        }, e.prototype.removeFeature = function(t, e) {
            var n = void 0 === e || e,
                r = h(t),
                i = this.indexedFeaturesExtents_[r];
            if (i) {
                var o = this.rBush_,
                    s = [];
                o.forEachInExtent(i, (function(e) {
                    t === e.feature && s.push(e)
                }));
                for (var a = s.length - 1; a >= 0; --a)
                    o.remove(s[a])
            }
            n && (j(this.featureChangeListenerKeys_[r]), delete this.featureChangeListenerKeys_[r])
        }, e.prototype.setMap = function(e) {
            var n = this.getMap(),
                r = this.featuresListenerKeys_,
                i = this.getFeatures_();
            n && (r.forEach(j), r.length = 0, i.forEach(this.forEachFeatureRemove_.bind(this))),
            t.prototype.setMap.call(this, e),
            e && (this.features_ ? r.push(F(this.features_, H.ADD, this.handleFeatureAdd_, this), F(this.features_, H.REMOVE, this.handleFeatureRemove_, this)) : this.source_ && r.push(F(this.source_, oh.ADDFEATURE, this.handleFeatureAdd_, this), F(this.source_, oh.REMOVEFEATURE, this.handleFeatureRemove_, this)), i.forEach(this.forEachFeatureAdd_.bind(this)))
        }, e.prototype.snapTo = function(t, e, n) {
            var r = It([n.getCoordinateFromPixel([t[0] - this.pixelTolerance_, t[1] + this.pixelTolerance_]), n.getCoordinateFromPixel([t[0] + this.pixelTolerance_, t[1] - this.pixelTolerance_])]),
                i = this.rBush_.getInExtent(r),
                o = i.length;
            if (0 === o)
                return null;
            var s,
                a = n.getView().getProjection(),
                u = Cn(e, a),
                l = 1 / 0,
                h = this.pixelTolerance_ * this.pixelTolerance_,
                c = function() {
                    if (s) {
                        var e = n.getPixelFromCoordinate(s);
                        if (Ke(t, e) <= h)
                            return {
                                vertex: s,
                                vertexPixel: [Math.round(e[0]), Math.round(e[1])]
                            }
                    }
                    return null
                };
            if (this.vertex_) {
                for (var p = 0; p < o; ++p) {
                    "Circle" !== (f = i[p]).feature.getGeometry().getType() && f.segment.forEach((function(t) {
                        var e = Cn(t, a),
                            n = Ke(u, e);
                        n < l && (s = t, l = n)
                    }))
                }
                if (E = c())
                    return E
            }
            if (this.edge_) {
                for (p = 0; p < o; ++p) {
                    var f,
                        d = null;
                    if ("Circle" === (f = i[p]).feature.getGeometry().getType()) {
                        var g = f.feature.getGeometry(),
                            y = wn();
                        y && (g = g.clone().transform(y, a)),
                        d = bn(He(u, g), a)
                    } else {
                        var v = f.segment,
                            m = v[0],
                            _ = v[1];
                        _ && (Bh[0] = Cn(m, a), Bh[1] = Cn(_, a), d = Ye(u, Bh))
                    }
                    if (d) {
                        var x = Ke(u, d);
                        x < l && (s = d, l = x)
                    }
                }
                var E;
                if (E = c())
                    return E
            }
            return null
        }, e.prototype.updateFeature_ = function(t) {
            this.removeFeature(t, !1),
            this.addFeature(t, !1)
        }, e.prototype.segmentCircleGeometry_ = function(t, e) {
            var n = this.getMap().getView().getProjection(),
                r = e,
                i = wn();
            i && (r = r.clone().transform(i, n));
            var o = (0, rt.fromCircle)(r);
            i && o.transform(n, i);
            for (var s = o.getCoordinates()[0], a = 0, u = s.length - 1; a < u; ++a)
                t.push(s.slice(a, a + 2))
        }, e.prototype.segmentGeometryCollectionGeometry_ = function(t, e) {
            for (var n = e.getGeometriesArray(), r = 0; r < n.length; ++r) {
                var i = this.GEOMETRY_SEGMENTERS_[n[r].getType()];
                i && i(t, n[r])
            }
        }, e.prototype.segmentLineStringGeometry_ = function(t, e) {
            for (var n = e.getCoordinates(), r = 0, i = n.length - 1; r < i; ++r)
                t.push(n.slice(r, r + 2))
        }, e.prototype.segmentMultiLineStringGeometry_ = function(t, e) {
            for (var n = e.getCoordinates(), r = 0, i = n.length; r < i; ++r)
                for (var o = n[r], s = 0, a = o.length - 1; s < a; ++s)
                    t.push(o.slice(s, s + 2))
        }, e.prototype.segmentMultiPointGeometry_ = function(t, e) {
            e.getCoordinates().forEach((function(e) {
                t.push([e])
            }))
        }, e.prototype.segmentMultiPolygonGeometry_ = function(t, e) {
            for (var n = e.getCoordinates(), r = 0, i = n.length; r < i; ++r)
                for (var o = n[r], s = 0, a = o.length; s < a; ++s)
                    for (var u = o[s], l = 0, h = u.length - 1; l < h; ++l)
                        t.push(u.slice(l, l + 2))
        }, e.prototype.segmentPointGeometry_ = function(t, e) {
            t.push([e.getCoordinates()])
        }, e.prototype.segmentPolygonGeometry_ = function(t, e) {
            for (var n = e.getCoordinates(), r = 0, i = n.length; r < i; ++r)
                for (var o = n[r], s = 0, a = o.length - 1; s < a; ++s)
                    t.push(o.slice(s, s + 2))
        }, e
    }(Ts.default);
function zh(t) {
    var e = t || {},
        n = new (0, s.default),
        r = new ya(-.005, .05, 100);
    return (void 0 === e.altShiftDragRotate || e.altShiftDragRotate) && n.push(new (0, Hs.default)), (void 0 === e.doubleClickZoom || e.doubleClickZoom) && n.push(new (0, ms.default)({
        delta: e.zoomDelta,
        duration: e.zoomDuration
    })), (void 0 === e.dragPan || e.dragPan) && n.push(new (0, Is.default)({
        onFocusOnly: e.onFocusOnly,
        kinetic: r
    })), (void 0 === e.pinchRotate || e.pinchRotate) && n.push(new (0, Ea.default)), (void 0 === e.pinchZoom || e.pinchZoom) && n.push(new (0, Ca.default)({
        duration: e.zoomDuration
    })), (void 0 === e.keyboard || e.keyboard) && (n.push(new (0, la.default)), n.push(new (0, fa.default)({
        delta: e.zoomDelta,
        duration: e.zoomDuration
    }))), (void 0 === e.mouseWheelZoom || e.mouseWheelZoom) && n.push(new (0, va.default)({
        onFocusOnly: e.onFocusOnly,
        duration: e.zoomDuration
    })), (void 0 === e.shiftDragZoom || e.shiftDragZoom) && n.push(new (0, $s.default)({
        duration: e.zoomDuration
    })), n
}
var Uh = function() {
        var t = function(e, n) {
            return t = Object.setPrototypeOf || {
                __proto__: []
            } instanceof Array && function(t, e) {
                t.__proto__ = e
            } || function(t, e) {
                for (var n in e)
                    Object.prototype.hasOwnProperty.call(e, n) && (t[n] = e[n])
            }, t(e, n)
        };
        return function(e, n) {
            if ("function" != typeof n && null !== n)
                throw new TypeError("Class extends value " + String(n) + " is not a constructor or null");
            function r() {
                this.constructor = e
            }
            t(e, n),
            e.prototype = null === n ? Object.create(n) : (r.prototype = n.prototype, new r)
        }
    }(),
    Vh = function(t) {
        function e(e) {
            return (e = P({}, e)).controls || (e.controls = vs()), e.interactions || (e.interactions = zh({
                onFocusOnly: !0
            })), t.call(this, e) || this
        }
        return Uh(e, t), e.prototype.createRenderer = function() {
            return new (0, Jr.default)(this)
        }, e
    }(eo.default),
    Xh = function() {
        function t(t) {
            this.highWaterMark = void 0 !== t ? t : 2048,
            this.count_ = 0,
            this.entries_ = {},
            this.oldest_ = null,
            this.newest_ = null
        }
        return t.prototype.canExpireCache = function() {
            return this.highWaterMark > 0 && this.getCount() > this.highWaterMark
        }, t.prototype.expireCache = function(t) {
            for (; this.canExpireCache();)
                this.pop()
        }, t.prototype.clear = function() {
            this.count_ = 0,
            this.entries_ = {},
            this.oldest_ = null,
            this.newest_ = null
        }, t.prototype.containsKey = function(t) {
            return this.entries_.hasOwnProperty(t)
        }, t.prototype.forEach = function(t) {
            for (var e = this.oldest_; e;)
                t(e.value_, e.key_, this),
                e = e.newer
        }, t.prototype.get = function(t, e) {
            var n = this.entries_[t];
            return J(void 0 !== n, 15), n === this.newest_ || (n === this.oldest_ ? (this.oldest_ = this.oldest_.newer, this.oldest_.older = null) : (n.newer.older = n.older, n.older.newer = n.newer), n.newer = null, n.older = this.newest_, this.newest_.newer = n, this.newest_ = n), n.value_
        }, t.prototype.remove = function(t) {
            var e = this.entries_[t];
            return J(void 0 !== e, 15), e === this.newest_ ? (this.newest_ = e.older, this.newest_ && (this.newest_.newer = null)) : e === this.oldest_ ? (this.oldest_ = e.newer, this.oldest_ && (this.oldest_.older = null)) : (e.newer.older = e.older, e.older.newer = e.newer), delete this.entries_[t], --this.count_, e.value_
        }, t.prototype.getCount = function() {
            return this.count_
        }, t.prototype.getKeys = function() {
            var t,
                e = new Array(this.count_),
                n = 0;
            for (t = this.newest_; t; t = t.older)
                e[n++] = t.key_;
            return e
        }, t.prototype.getValues = function() {
            var t,
                e = new Array(this.count_),
                n = 0;
            for (t = this.newest_; t; t = t.older)
                e[n++] = t.value_;
            return e
        }, t.prototype.peekLast = function() {
            return this.oldest_.value_
        }, t.prototype.peekLastKey = function() {
            return this.oldest_.key_
        }, t.prototype.peekFirstKey = function() {
            return this.newest_.key_
        }, t.prototype.peek = function(t) {
            if (this.containsKey(t))
                return this.entries_[t].value_
        }, t.prototype.pop = function() {
            var t = this.oldest_;
            return delete this.entries_[t.key_], t.newer && (t.newer.older = null), this.oldest_ = t.newer, this.oldest_ || (this.newest_ = null), --this.count_, t.value_
        }, t.prototype.replace = function(t, e) {
            this.get(t),
            this.entries_[t].value_ = e
        }, t.prototype.set = function(t, e) {
            J(!(t in this.entries_), 16);
            var n = {
                key_: t,
                newer: null,
                older: this.newest_,
                value_: e
            };
            this.newest_ ? this.newest_.newer = n : this.oldest_ = n,
            this.newest_ = n,
            this.entries_[t] = n,
            ++this.count_
        }, t.prototype.setSize = function(t) {
            this.highWaterMark = t
        }, t
    }(),
    Hh = {};
t(Hh, "ATTRIBUTION", (() => tp), (t => tp = t)),
t(Hh, "default", (() => ep), (t => ep = t));
var Yh = {};
t(Yh, "default", (() => Jc), (t => Jc = t));
var Wh = {};
t(Wh, "default", (() => Kc), (t => Kc = t));
var $h = {};
t($h, "default", (() => tc), (t => tc = t));
var Kh = {};
t(Kh, "default", (() => Jh), (t => Jh = t));
var Zh = function() {
        var t = function(e, n) {
            return t = Object.setPrototypeOf || {
                __proto__: []
            } instanceof Array && function(t, e) {
                t.__proto__ = e
            } || function(t, e) {
                for (var n in e)
                    Object.prototype.hasOwnProperty.call(e, n) && (t[n] = e[n])
            }, t(e, n)
        };
        return function(e, n) {
            if ("function" != typeof n && null !== n)
                throw new TypeError("Class extends value " + String(n) + " is not a constructor or null");
            function r() {
                this.constructor = e
            }
            t(e, n),
            e.prototype = null === n ? Object.create(n) : (r.prototype = n.prototype, new r)
        }
    }(),
    Jh = function(t) {
        function e(e, n, r) {
            var i = t.call(this) || this,
                o = r || {};
            return i.tileCoord = e, i.state = n, i.interimTile = null, i.key = "", i.transition_ = void 0 === o.transition ? 250 : o.transition, i.transitionStarts_ = {}, i.interpolate = !!o.interpolate, i
        }
        return Zh(e, t), e.prototype.changed = function() {
            this.dispatchEvent(D.CHANGE)
        }, e.prototype.release = function() {}, e.prototype.getKey = function() {
            return this.key + "/" + this.tileCoord
        }, e.prototype.getInterimTile = function() {
            if (!this.interimTile)
                return this;
            var t = this.interimTile;
            do {
                if (t.getState() == bo.LOADED)
                    return this.transition_ = 0, t;
                t = t.interimTile
            } while (t);
            return this
        }, e.prototype.refreshInterimChain = function() {
            if (this.interimTile) {
                var t = this.interimTile,
                    e = this;
                do {
                    if (t.getState() == bo.LOADED) {
                        t.interimTile = null;
                        break
                    }
                    t.getState() == bo.LOADING ? e = t : t.getState() == bo.IDLE ? e.interimTile = t.interimTile : e = t,
                    t = e.interimTile
                } while (t)
            }
        }, e.prototype.getTileCoord = function() {
            return this.tileCoord
        }, e.prototype.getState = function() {
            return this.state
        }, e.prototype.setState = function(t) {
            if (this.state !== bo.ERROR && this.state > t)
                throw new Error("Tile load sequence violation");
            this.state = t,
            this.changed()
        }, e.prototype.load = function() {
            u()
        }, e.prototype.getAlpha = function(t, e) {
            if (!this.transition_)
                return 1;
            var n = this.transitionStarts_[t];
            if (n) {
                if (-1 === n)
                    return 1
            } else
                n = e,
                this.transitionStarts_[t] = n;
            var r = e - n + 1e3 / 60;
            return r >= this.transition_ ? 1 : Go(r / this.transition_)
        }, e.prototype.inTransition = function(t) {
            return !!this.transition_ && -1 !== this.transitionStarts_[t]
        }, e.prototype.endTransition = function(t) {
            this.transition_ && (this.transitionStarts_[t] = -1)
        }, e
    }(m.default),
    Qh = function() {
        var t = function(e, n) {
            return t = Object.setPrototypeOf || {
                __proto__: []
            } instanceof Array && function(t, e) {
                t.__proto__ = e
            } || function(t, e) {
                for (var n in e)
                    Object.prototype.hasOwnProperty.call(e, n) && (t[n] = e[n])
            }, t(e, n)
        };
        return function(e, n) {
            if ("function" != typeof n && null !== n)
                throw new TypeError("Class extends value " + String(n) + " is not a constructor or null");
            function r() {
                this.constructor = e
            }
            t(e, n),
            e.prototype = null === n ? Object.create(n) : (r.prototype = n.prototype, new r)
        }
    }();
var tc = function(t) {
        function e(e, n, r, i, o, s) {
            var a = t.call(this, e, n, s) || this;
            return a.crossOrigin_ = i, a.src_ = r, a.key = r, a.image_ = new Image, null !== i && (a.image_.crossOrigin = i), a.unlisten_ = null, a.tileLoadFunction_ = o, a
        }
        return Qh(e, t), e.prototype.getImage = function() {
            return this.image_
        }, e.prototype.setImage = function(t) {
            this.image_ = t,
            this.state = bo.LOADED,
            this.unlistenImage_(),
            this.changed()
        }, e.prototype.handleImageError_ = function() {
            var t;
            this.state = bo.ERROR,
            this.unlistenImage_(),
            this.image_ = ((t = Ni(1, 1)).fillStyle = "rgba(0,0,0,0)", t.fillRect(0, 0, 1, 1), t.canvas),
            this.changed()
        }, e.prototype.handleImageLoad_ = function() {
            var t = this.image_;
            t.naturalWidth && t.naturalHeight ? this.state = bo.LOADED : this.state = bo.EMPTY,
            this.unlistenImage_(),
            this.changed()
        }, e.prototype.load = function() {
            this.state == bo.ERROR && (this.state = bo.IDLE, this.image_ = new Image, null !== this.crossOrigin_ && (this.image_.crossOrigin = this.crossOrigin_)),
            this.state == bo.IDLE && (this.state = bo.LOADING, this.changed(), this.tileLoadFunction_(this, this.src_), this.unlisten_ = (0, Sl.listenImage)(this.image_, this.handleImageLoad_.bind(this), this.handleImageError_.bind(this)))
        }, e.prototype.unlistenImage_ = function() {
            this.unlisten_ && (this.unlisten_(), this.unlisten_ = null)
        }, e
    }(Kh.default),
    ec = {};
t(ec, "default", (() => dc), (t => dc = t));
var nc,
    rc = function() {
        function t(t, e, n, r, i, o) {
            this.sourceProj_ = t,
            this.targetProj_ = e;
            var s = {},
                a = gn(this.targetProj_, this.sourceProj_);
            this.transformInv_ = function(t) {
                var e = t[0] + "/" + t[1];
                return s[e] || (s[e] = a(t)), s[e]
            },
            this.maxSourceExtent_ = r,
            this.errorThresholdSquared_ = i * i,
            this.triangles_ = [],
            this.wrapsXInSource_ = !1,
            this.canWrapXInSource_ = this.sourceProj_.canWrapX() && !!r && !!this.sourceProj_.getExtent() && re(r) == re(this.sourceProj_.getExtent()),
            this.sourceWorldWidth_ = this.sourceProj_.getExtent() ? re(this.sourceProj_.getExtent()) : null,
            this.targetWorldWidth_ = this.targetProj_.getExtent() ? re(this.targetProj_.getExtent()) : null;
            var u = ee(n),
                l = ne(n),
                h = Wt(n),
                c = Yt(n),
                p = this.transformInv_(u),
                f = this.transformInv_(l),
                d = this.transformInv_(h),
                g = this.transformInv_(c),
                y = 10 + (o ? Math.max(0, Math.ceil(ge(Ht(n) / (o * o * 65536)))) : 0);
            if (this.addQuad_(u, l, h, c, p, f, d, g, y), this.wrapsXInSource_) {
                var v = 1 / 0;
                this.triangles_.forEach((function(t, e, n) {
                    v = Math.min(v, t.source[0][0], t.source[1][0], t.source[2][0])
                })),
                this.triangles_.forEach(function(t) {
                    if (Math.max(t.source[0][0], t.source[1][0], t.source[2][0]) - v > this.sourceWorldWidth_ / 2) {
                        var e = [[t.source[0][0], t.source[0][1]], [t.source[1][0], t.source[1][1]], [t.source[2][0], t.source[2][1]]];
                        e[0][0] - v > this.sourceWorldWidth_ / 2 && (e[0][0] -= this.sourceWorldWidth_),
                        e[1][0] - v > this.sourceWorldWidth_ / 2 && (e[1][0] -= this.sourceWorldWidth_),
                        e[2][0] - v > this.sourceWorldWidth_ / 2 && (e[2][0] -= this.sourceWorldWidth_);
                        var n = Math.min(e[0][0], e[1][0], e[2][0]);
                        Math.max(e[0][0], e[1][0], e[2][0]) - n < this.sourceWorldWidth_ / 2 && (t.source = e)
                    }
                }.bind(this))
            }
            s = {}
        }
        return t.prototype.addTriangle_ = function(t, e, n, r, i, o) {
            this.triangles_.push({
                source: [r, i, o],
                target: [t, e, n]
            })
        }, t.prototype.addQuad_ = function(t, e, n, r, i, o, s, a, u) {
            var l = It([i, o, s, a]),
                h = this.sourceWorldWidth_ ? re(l) / this.sourceWorldWidth_ : null,
                c = this.sourceWorldWidth_,
                p = this.sourceProj_.canWrapX() && h > .5 && h < 1,
                f = !1;
            if (u > 0) {
                if (this.targetProj_.isGlobal() && this.targetWorldWidth_)
                    f = re(It([t, e, n, r])) / this.targetWorldWidth_ > .25 || f;
                !p && this.sourceProj_.isGlobal() && h && (f = h > .25 || f)
            }
            if (!(!f && this.maxSourceExtent_ && isFinite(l[0]) && isFinite(l[1]) && isFinite(l[2]) && isFinite(l[3])) || ie(l, this.maxSourceExtent_)) {
                var d = 0;
                if (!(f || isFinite(i[0]) && isFinite(i[1]) && isFinite(o[0]) && isFinite(o[1]) && isFinite(s[0]) && isFinite(s[1]) && isFinite(a[0]) && isFinite(a[1])))
                    if (u > 0)
                        f = !0;
                    else if (1 != (d = (isFinite(i[0]) && isFinite(i[1]) ? 0 : 8) + (isFinite(o[0]) && isFinite(o[1]) ? 0 : 4) + (isFinite(s[0]) && isFinite(s[1]) ? 0 : 2) + (isFinite(a[0]) && isFinite(a[1]) ? 0 : 1)) && 2 != d && 4 != d && 8 != d)
                        return;
                if (u > 0) {
                    if (!f) {
                        var g = [(t[0] + n[0]) / 2, (t[1] + n[1]) / 2],
                            y = this.transformInv_(g),
                            v = void 0;
                        if (p)
                            v = (Ee(i[0], c) + Ee(s[0], c)) / 2 - Ee(y[0], c);
                        else
                            v = (i[0] + s[0]) / 2 - y[0];
                        var m = (i[1] + s[1]) / 2 - y[1];
                        f = v * v + m * m > this.errorThresholdSquared_
                    }
                    if (f) {
                        if (Math.abs(t[0] - n[0]) <= Math.abs(t[1] - n[1])) {
                            var _ = [(e[0] + n[0]) / 2, (e[1] + n[1]) / 2],
                                x = this.transformInv_(_),
                                E = [(r[0] + t[0]) / 2, (r[1] + t[1]) / 2],
                                w = this.transformInv_(E);
                            this.addQuad_(t, e, _, E, i, o, x, w, u - 1),
                            this.addQuad_(E, _, n, r, w, x, s, a, u - 1)
                        } else {
                            var b = [(t[0] + e[0]) / 2, (t[1] + e[1]) / 2],
                                C = this.transformInv_(b),
                                M = [(n[0] + r[0]) / 2, (n[1] + r[1]) / 2],
                                S = this.transformInv_(M);
                            this.addQuad_(t, b, M, r, i, C, S, a, u - 1),
                            this.addQuad_(b, e, n, M, C, o, s, S, u - 1)
                        }
                        return
                    }
                }
                if (p) {
                    if (!this.canWrapXInSource_)
                        return;
                    this.wrapsXInSource_ = !0
                }
                0 == (11 & d) && this.addTriangle_(t, n, r, i, s, a),
                0 == (14 & d) && this.addTriangle_(t, n, e, i, s, o),
                d && (0 == (13 & d) && this.addTriangle_(e, r, t, o, a, i), 0 == (7 & d) && this.addTriangle_(e, r, n, o, a, s))
            }
        }, t.prototype.calculateSourceExtent = function() {
            var t = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
            return this.triangles_.forEach((function(e, n, r) {
                var i = e.source;
                zt(t, i[0]),
                zt(t, i[1]),
                zt(t, i[2])
            })), t
        }, t.prototype.getTriangles = function() {
            return this.triangles_
        }, t
    }(),
    ic = rc,
    oc = {
        imageSmoothingEnabled: !1,
        msImageSmoothingEnabled: !1
    },
    sc = {
        imageSmoothingEnabled: !0,
        msImageSmoothingEnabled: !0
    },
    ac = [];
function uc(t, e, n, r, i) {
    t.beginPath(),
    t.moveTo(0, 0),
    t.lineTo(e, n),
    t.lineTo(r, i),
    t.closePath(),
    t.save(),
    t.clip(),
    t.fillRect(0, 0, Math.max(e, r) + 1, Math.max(n, i)),
    t.restore()
}
function lc(t, e) {
    return Math.abs(t[4 * e] - 210) > 2 || Math.abs(t[4 * e + 3] - 191.25) > 2
}
function hc(t, e, n, r) {
    var i = yn(n, e, t),
        o = hn(e, r, n),
        s = e.getMetersPerUnit();
    void 0 !== s && (o *= s);
    var a = t.getMetersPerUnit();
    void 0 !== a && (o /= a);
    var u = t.getExtent();
    if (!u || Ot(u, i)) {
        var l = hn(t, o, i) / o;
        isFinite(l) && l > 0 && (o /= l)
    }
    return o
}
function cc(t, e, n, r) {
    var i = $t(n),
        o = hc(t, e, i, r);
    return (!isFinite(o) || o <= 0) && Xt(n, (function(n) {
        return o = hc(t, e, n, r), isFinite(o) && o > 0
    })), o
}
function pc(t, e, n, r, i, o, s, a, u, l, h, c) {
    var p = Ni(Math.round(n * t), Math.round(n * e), ac);
    if (c || P(p, oc), 0 === u.length)
        return p.canvas;
    function f(t) {
        return Math.round(t * n) / n
    }
    p.scale(n, n),
    p.globalCompositeOperation = "lighter";
    var d = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
    u.forEach((function(t, e, n) {
        qt(d, t.extent)
    }));
    var g = re(d),
        y = Qt(d),
        v = Ni(Math.round(n * g / r), Math.round(n * y / r));
    c || P(v, oc);
    var m = n / r;
    u.forEach((function(t, e, n) {
        var r = t.extent[0] - d[0],
            i = -(t.extent[3] - d[3]),
            o = re(t.extent),
            s = Qt(t.extent);
        t.image.width > 0 && t.image.height > 0 && v.drawImage(t.image, l, l, t.image.width - 2 * l, t.image.height - 2 * l, r * m, i * m, o * m, s * m)
    }));
    var _ = ee(s);
    return a.getTriangles().forEach((function(t, e, i) {
        var s = t.source,
            a = t.target,
            u = s[0][0],
            l = s[0][1],
            h = s[1][0],
            g = s[1][1],
            y = s[2][0],
            m = s[2][1],
            x = f((a[0][0] - _[0]) / o),
            E = f(-(a[0][1] - _[1]) / o),
            w = f((a[1][0] - _[0]) / o),
            b = f(-(a[1][1] - _[1]) / o),
            C = f((a[2][0] - _[0]) / o),
            M = f(-(a[2][1] - _[1]) / o),
            S = u,
            I = l;
        u = 0,
        l = 0;
        var T = me([[h -= S, g -= I, 0, 0, w - x], [y -= S, m -= I, 0, 0, C - x], [0, 0, h, g, b - E], [0, 0, y, m, M - E]]);
        if (T) {
            if (p.save(), p.beginPath(), function() {
                if (void 0 === nc) {
                    var t = document.createElement("canvas").getContext("2d");
                    t.globalCompositeOperation = "lighter",
                    t.fillStyle = "rgba(210, 0, 0, 0.75)",
                    uc(t, 4, 5, 4, 0),
                    uc(t, 4, 5, 0, 5);
                    var e = t.getImageData(0, 0, 3, 3).data;
                    nc = lc(e, 0) || lc(e, 4) || lc(e, 8)
                }
                return nc
            }() || !c) {
                p.moveTo(w, b);
                for (var P = x - w, L = E - b, O = 0; O < 4; O++)
                    p.lineTo(w + f((O + 1) * P / 4), b + f(O * L / 3)),
                    3 != O && p.lineTo(w + f((O + 1) * P / 4), b + f((O + 1) * L / 3));
                p.lineTo(C, M)
            } else
                p.moveTo(w, b),
                p.lineTo(x, E),
                p.lineTo(C, M);
            p.clip(),
            p.transform(T[0], T[2], T[1], T[3], x, E),
            p.translate(d[0] - S, d[3] - I),
            p.scale(r / n, -r / n),
            p.drawImage(v.canvas, 0, 0),
            p.restore()
        }
    })), h && (p.save(), p.globalCompositeOperation = "source-over", p.strokeStyle = "black", p.lineWidth = 1, a.getTriangles().forEach((function(t, e, n) {
        var r = t.target,
            i = (r[0][0] - _[0]) / o,
            s = -(r[0][1] - _[1]) / o,
            a = (r[1][0] - _[0]) / o,
            u = -(r[1][1] - _[1]) / o,
            l = (r[2][0] - _[0]) / o,
            h = -(r[2][1] - _[1]) / o;
        p.beginPath(),
        p.moveTo(a, u),
        p.lineTo(i, s),
        p.lineTo(l, h),
        p.closePath(),
        p.stroke()
    })), p.restore()), p.canvas
}
var fc = function() {
        var t = function(e, n) {
            return t = Object.setPrototypeOf || {
                __proto__: []
            } instanceof Array && function(t, e) {
                t.__proto__ = e
            } || function(t, e) {
                for (var n in e)
                    Object.prototype.hasOwnProperty.call(e, n) && (t[n] = e[n])
            }, t(e, n)
        };
        return function(e, n) {
            if ("function" != typeof n && null !== n)
                throw new TypeError("Class extends value " + String(n) + " is not a constructor or null");
            function r() {
                this.constructor = e
            }
            t(e, n),
            e.prototype = null === n ? Object.create(n) : (r.prototype = n.prototype, new r)
        }
    }(),
    dc = function(t) {
        function e(e, n, r, i, o, s, a, u, l, h, c, p) {
            var f = t.call(this, o, bo.IDLE, {
                interpolate: !!p
            }) || this;
            f.renderEdges_ = void 0 !== c && c,
            f.pixelRatio_ = a,
            f.gutter_ = u,
            f.canvas_ = null,
            f.sourceTileGrid_ = n,
            f.targetTileGrid_ = i,
            f.wrappedTileCoord_ = s || o,
            f.sourceTiles_ = [],
            f.sourcesListenerKeys_ = null,
            f.sourceZ_ = 0;
            var d = i.getTileCoordExtent(f.wrappedTileCoord_),
                g = f.targetTileGrid_.getExtent(),
                y = f.sourceTileGrid_.getExtent(),
                v = g ? te(d, g) : d;
            if (0 === Ht(v))
                return f.state = bo.EMPTY, f;
            var m = e.getExtent();
            m && (y = y ? te(y, m) : m);
            var _ = i.getResolution(f.wrappedTileCoord_[0]),
                x = cc(e, r, v, _);
            if (!isFinite(x) || x <= 0)
                return f.state = bo.EMPTY, f;
            var E = void 0 !== h ? h : .5;
            if (f.triangulation_ = new ic(e, r, v, y, x * E, _), 0 === f.triangulation_.getTriangles().length)
                return f.state = bo.EMPTY, f;
            f.sourceZ_ = n.getZForResolution(x);
            var w = f.triangulation_.calculateSourceExtent();
            if (y && (e.canWrapX() ? (w[1] = fe(w[1], y[1], y[3]), w[3] = fe(w[3], y[1], y[3])) : w = te(w, y)), Ht(w)) {
                for (var b = n.getTileRangeForExtentAndZ(w, f.sourceZ_), C = b.minX; C <= b.maxX; C++)
                    for (var M = b.minY; M <= b.maxY; M++) {
                        var S = l(f.sourceZ_, C, M, a);
                        S && f.sourceTiles_.push(S)
                    }
                0 === f.sourceTiles_.length && (f.state = bo.EMPTY)
            } else
                f.state = bo.EMPTY;
            return f
        }
        return fc(e, t), e.prototype.getImage = function() {
            return this.canvas_
        }, e.prototype.reproject_ = function() {
            var t = [];
            if (this.sourceTiles_.forEach(function(e, n, r) {
                e && e.getState() == bo.LOADED && t.push({
                    extent: this.sourceTileGrid_.getTileCoordExtent(e.tileCoord),
                    image: e.getImage()
                })
            }.bind(this)), this.sourceTiles_.length = 0, 0 === t.length)
                this.state = bo.ERROR;
            else {
                var e = this.wrappedTileCoord_[0],
                    n = this.targetTileGrid_.getTileSize(e),
                    r = "number" == typeof n ? n : n[0],
                    i = "number" == typeof n ? n : n[1],
                    o = this.targetTileGrid_.getResolution(e),
                    s = this.sourceTileGrid_.getResolution(this.sourceZ_),
                    a = this.targetTileGrid_.getTileCoordExtent(this.wrappedTileCoord_);
                this.canvas_ = pc(r, i, this.pixelRatio_, s, this.sourceTileGrid_.getExtent(), o, a, this.triangulation_, t, this.gutter_, this.renderEdges_, this.interpolate),
                this.state = bo.LOADED
            }
            this.changed()
        }, e.prototype.load = function() {
            if (this.state == bo.IDLE) {
                this.state = bo.LOADING,
                this.changed();
                var t = 0;
                this.sourcesListenerKeys_ = [],
                this.sourceTiles_.forEach(function(e, n, r) {
                    var i = e.getState();
                    if (i == bo.IDLE || i == bo.LOADING) {
                        t++;
                        var o = F(e, D.CHANGE, (function(n) {
                            var r = e.getState();
                            r != bo.LOADED && r != bo.ERROR && r != bo.EMPTY || (j(o), 0 === --t && (this.unlistenSources_(), this.reproject_()))
                        }), this);
                        this.sourcesListenerKeys_.push(o)
                    }
                }.bind(this)),
                0 === t ? setTimeout(this.reproject_.bind(this), 0) : this.sourceTiles_.forEach((function(t, e, n) {
                    t.getState() == bo.IDLE && t.load()
                }))
            }
        }, e.prototype.unlistenSources_ = function() {
            this.sourcesListenerKeys_.forEach(j),
            this.sourcesListenerKeys_ = null
        }, e.prototype.release = function() {
            this.canvas_ && (Ri(this.canvas_.getContext("2d")), ac.push(this.canvas_), this.canvas_ = null),
            t.prototype.release.call(this)
        }, e
    }(Kh.default),
    gc = {};
function yc(t, e, n, r) {
    return void 0 !== r ? (r[0] = t, r[1] = e, r[2] = n, r) : [t, e, n]
}
function vc(t, e, n) {
    return t + "/" + e + "/" + n
}
function mc(t) {
    return vc(t[0], t[1], t[2])
}
function _c(t) {
    return t.split("/").map(Number)
}
function xc(t) {
    return (t[1] << t[0]) + t[2]
}
function Ec(t, e) {
    var n = t[0],
        r = t[1],
        i = t[2];
    if (e.getMinZoom() > n || n > e.getMaxZoom())
        return !1;
    var o = e.getFullTileRange(n);
    return !o || o.containsXY(r, i)
}
t(gc, "default", (() => bc), (t => bc = t));
var wc = function() {
        var t = function(e, n) {
            return t = Object.setPrototypeOf || {
                __proto__: []
            } instanceof Array && function(t, e) {
                t.__proto__ = e
            } || function(t, e) {
                for (var n in e)
                    Object.prototype.hasOwnProperty.call(e, n) && (t[n] = e[n])
            }, t(e, n)
        };
        return function(e, n) {
            if ("function" != typeof n && null !== n)
                throw new TypeError("Class extends value " + String(n) + " is not a constructor or null");
            function r() {
                this.constructor = e
            }
            t(e, n),
            e.prototype = null === n ? Object.create(n) : (r.prototype = n.prototype, new r)
        }
    }(),
    bc = function(t) {
        function e() {
            return null !== t && t.apply(this, arguments) || this
        }
        return wc(e, t), e.prototype.expireCache = function(t) {
            for (; this.canExpireCache();) {
                if (this.peekLast().getKey() in t)
                    break;
                this.pop().release()
            }
        }, e.prototype.pruneExceptNewestZ = function() {
            if (0 !== this.getCount()) {
                var t = _c(this.peekFirstKey())[0];
                this.forEach(function(e) {
                    e.tileCoord[0] !== t && (this.remove(mc(e.tileCoord)), e.release())
                }.bind(this))
            }
        }, e
    }(Xh),
    Cc = {};
t(Cc, "default", (() => Hc), (t => Hc = t));
var Mc = {
        TILELOADSTART: "tileloadstart",
        TILELOADEND: "tileloadend",
        TILELOADERROR: "tileloaderror"
    },
    Sc = {};
t(Sc, "TileSourceEvent", (() => Bc), (t => Bc = t)),
t(Sc, "default", (() => qc), (t => qc = t));
var Ic = function() {
    function t(t, e, n, r) {
        this.minX = t,
        this.maxX = e,
        this.minY = n,
        this.maxY = r
    }
    return t.prototype.contains = function(t) {
        return this.containsXY(t[1], t[2])
    }, t.prototype.containsTileRange = function(t) {
        return this.minX <= t.minX && t.maxX <= this.maxX && this.minY <= t.minY && t.maxY <= this.maxY
    }, t.prototype.containsXY = function(t, e) {
        return this.minX <= t && t <= this.maxX && this.minY <= e && e <= this.maxY
    }, t.prototype.equals = function(t) {
        return this.minX == t.minX && this.minY == t.minY && this.maxX == t.maxX && this.maxY == t.maxY
    }, t.prototype.extend = function(t) {
        t.minX < this.minX && (this.minX = t.minX),
        t.maxX > this.maxX && (this.maxX = t.maxX),
        t.minY < this.minY && (this.minY = t.minY),
        t.maxY > this.maxY && (this.maxY = t.maxY)
    }, t.prototype.getHeight = function() {
        return this.maxY - this.minY + 1
    }, t.prototype.getSize = function() {
        return [this.getWidth(), this.getHeight()]
    }, t.prototype.getWidth = function() {
        return this.maxX - this.minX + 1
    }, t.prototype.intersects = function(t) {
        return this.minX <= t.maxX && this.maxX >= t.minX && this.minY <= t.maxY && this.maxY >= t.minY
    }, t
}();
function Tc(t, e, n, r, i) {
    return void 0 !== i ? (i.minX = t, i.maxX = e, i.minY = n, i.maxY = r, i) : new Ic(t, e, n, r)
}
var Pc = Ic,
    Lc = [0, 0, 0],
    Oc = function() {
        function t(t) {
            var e,
                n,
                r,
                i;
            if (this.minZoom = void 0 !== t.minZoom ? t.minZoom : 0, this.resolutions_ = t.resolutions, J((e = this.resolutions_, n = !0, r = function(t, e) {
                return e - t
            } || E, e.every((function(t, i) {
                if (0 === i)
                    return !0;
                var o = r(e[i - 1], t);
                return !(o > 0 || n && 0 === o)
            }))), 17), !t.origins)
                for (var o = 0, s = this.resolutions_.length - 1; o < s; ++o)
                    if (i) {
                        if (this.resolutions_[o] / this.resolutions_[o + 1] !== i) {
                            i = void 0;
                            break
                        }
                    } else
                        i = this.resolutions_[o] / this.resolutions_[o + 1];
            this.zoomFactor_ = i,
            this.maxZoom = this.resolutions_.length - 1,
            this.origin_ = void 0 !== t.origin ? t.origin : null,
            this.origins_ = null,
            void 0 !== t.origins && (this.origins_ = t.origins, J(this.origins_.length == this.resolutions_.length, 20));
            var a = t.extent;
            void 0 === a || this.origin_ || this.origins_ || (this.origin_ = ee(a)),
            J(!this.origin_ && this.origins_ || this.origin_ && !this.origins_, 18),
            this.tileSizes_ = null,
            void 0 !== t.tileSizes && (this.tileSizes_ = t.tileSizes, J(this.tileSizes_.length == this.resolutions_.length, 19)),
            this.tileSize_ = void 0 !== t.tileSize ? t.tileSize : this.tileSizes_ ? null : 256,
            J(!this.tileSize_ && this.tileSizes_ || this.tileSize_ && !this.tileSizes_, 22),
            this.extent_ = void 0 !== a ? a : null,
            this.fullTileRanges_ = null,
            this.tmpSize_ = [0, 0],
            this.tmpExtent_ = [0, 0, 0, 0],
            void 0 !== t.sizes ? this.fullTileRanges_ = t.sizes.map((function(t, e) {
                var n = new Pc(Math.min(0, t[0]), Math.max(t[0] - 1, -1), Math.min(0, t[1]), Math.max(t[1] - 1, -1));
                if (a) {
                    var r = this.getTileRangeForExtentAndZ(a, e);
                    n.minX = Math.max(r.minX, n.minX),
                    n.maxX = Math.min(r.maxX, n.maxX),
                    n.minY = Math.max(r.minY, n.minY),
                    n.maxY = Math.min(r.maxY, n.maxY)
                }
                return n
            }), this) : a && this.calculateTileRanges_(a)
        }
        return t.prototype.forEachTileCoord = function(t, e, n) {
            for (var r = this.getTileRangeForExtentAndZ(t, e), i = r.minX, o = r.maxX; i <= o; ++i)
                for (var s = r.minY, a = r.maxY; s <= a; ++s)
                    n([e, i, s])
        }, t.prototype.forEachTileCoordParentTileRange = function(t, e, n, r) {
            var i,
                o,
                s = null,
                a = t[0] - 1;
            for (2 === this.zoomFactor_ ? (i = t[1], o = t[2]) : s = this.getTileCoordExtent(t, r); a >= this.minZoom;) {
                if (e(a, 2 === this.zoomFactor_ ? Tc(i = Math.floor(i / 2), i, o = Math.floor(o / 2), o, n) : this.getTileRangeForExtentAndZ(s, a, n)))
                    return !0;
                --a
            }
            return !1
        }, t.prototype.getExtent = function() {
            return this.extent_
        }, t.prototype.getMaxZoom = function() {
            return this.maxZoom
        }, t.prototype.getMinZoom = function() {
            return this.minZoom
        }, t.prototype.getOrigin = function(t) {
            return this.origin_ ? this.origin_ : this.origins_[t]
        }, t.prototype.getResolution = function(t) {
            return this.resolutions_[t]
        }, t.prototype.getResolutions = function() {
            return this.resolutions_
        }, t.prototype.getTileCoordChildTileRange = function(t, e, n) {
            if (t[0] < this.maxZoom) {
                if (2 === this.zoomFactor_) {
                    var r = 2 * t[1],
                        i = 2 * t[2];
                    return Tc(r, r + 1, i, i + 1, e)
                }
                var o = this.getTileCoordExtent(t, n || this.tmpExtent_);
                return this.getTileRangeForExtentAndZ(o, t[0] + 1, e)
            }
            return null
        }, t.prototype.getTileRangeForTileCoordAndZ = function(t, e, n) {
            if (e > this.maxZoom || e < this.minZoom)
                return null;
            var r = t[0],
                i = t[1],
                o = t[2];
            if (e === r)
                return Tc(i, o, i, o, n);
            if (this.zoomFactor_) {
                var s = Math.pow(this.zoomFactor_, e - r),
                    a = Math.floor(i * s),
                    u = Math.floor(o * s);
                return e < r ? Tc(a, a, u, u, n) : Tc(a, Math.floor(s * (i + 1)) - 1, u, Math.floor(s * (o + 1)) - 1, n)
            }
            var l = this.getTileCoordExtent(t, this.tmpExtent_);
            return this.getTileRangeForExtentAndZ(l, e, n)
        }, t.prototype.getTileRangeExtent = function(t, e, n) {
            var r = this.getOrigin(t),
                i = this.getResolution(t),
                o = Qo(this.getTileSize(t), this.tmpSize_),
                s = r[0] + e.minX * o[0] * i,
                a = r[0] + (e.maxX + 1) * o[0] * i;
            return Ft(s, r[1] + e.minY * o[1] * i, a, r[1] + (e.maxY + 1) * o[1] * i, n)
        }, t.prototype.getTileRangeForExtentAndZ = function(t, e, n) {
            var r = Lc;
            this.getTileCoordForXYAndZ_(t[0], t[3], e, !1, r);
            var i = r[1],
                o = r[2];
            return this.getTileCoordForXYAndZ_(t[2], t[1], e, !0, r), Tc(i, r[1], o, r[2], n)
        }, t.prototype.getTileCoordCenter = function(t) {
            var e = this.getOrigin(t[0]),
                n = this.getResolution(t[0]),
                r = Qo(this.getTileSize(t[0]), this.tmpSize_);
            return [e[0] + (t[1] + .5) * r[0] * n, e[1] - (t[2] + .5) * r[1] * n]
        }, t.prototype.getTileCoordExtent = function(t, e) {
            var n = this.getOrigin(t[0]),
                r = this.getResolution(t[0]),
                i = Qo(this.getTileSize(t[0]), this.tmpSize_),
                o = n[0] + t[1] * i[0] * r,
                s = n[1] - (t[2] + 1) * i[1] * r;
            return Ft(o, s, o + i[0] * r, s + i[1] * r, e)
        }, t.prototype.getTileCoordForCoordAndResolution = function(t, e, n) {
            return this.getTileCoordForXYAndResolution_(t[0], t[1], e, !1, n)
        }, t.prototype.getTileCoordForXYAndResolution_ = function(t, e, n, r, i) {
            var o = this.getZForResolution(n),
                s = n / this.getResolution(o),
                a = this.getOrigin(o),
                u = Qo(this.getTileSize(o), this.tmpSize_),
                l = s * (t - a[0]) / n / u[0],
                h = s * (a[1] - e) / n / u[1];
            return r ? (l = Me(l, 5) - 1, h = Me(h, 5) - 1) : (l = Ce(l, 5), h = Ce(h, 5)), yc(o, l, h, i)
        }, t.prototype.getTileCoordForXYAndZ_ = function(t, e, n, r, i) {
            var o = this.getOrigin(n),
                s = this.getResolution(n),
                a = Qo(this.getTileSize(n), this.tmpSize_),
                u = (t - o[0]) / s / a[0],
                l = (o[1] - e) / s / a[1];
            return r ? (u = Me(u, 5) - 1, l = Me(l, 5) - 1) : (u = Ce(u, 5), l = Ce(l, 5)), yc(n, u, l, i)
        }, t.prototype.getTileCoordForCoordAndZ = function(t, e, n) {
            return this.getTileCoordForXYAndZ_(t[0], t[1], e, !1, n)
        }, t.prototype.getTileCoordResolution = function(t) {
            return this.resolutions_[t[0]]
        }, t.prototype.getTileSize = function(t) {
            return this.tileSize_ ? this.tileSize_ : this.tileSizes_[t]
        }, t.prototype.getFullTileRange = function(t) {
            return this.fullTileRanges_ ? this.fullTileRanges_[t] : this.extent_ ? this.getTileRangeForExtentAndZ(this.extent_, t) : null
        }, t.prototype.getZForResolution = function(t, e) {
            return fe(w(this.resolutions_, t, e || 0), this.minZoom, this.maxZoom)
        }, t.prototype.tileCoordIntersectsViewport = function(t, e) {
            return wr(e, 0, e.length, 2, this.getTileCoordExtent(t))
        }, t.prototype.calculateTileRanges_ = function(t) {
            for (var e = this.resolutions_.length, n = new Array(e), r = this.minZoom; r < e; ++r)
                n[r] = this.getTileRangeForExtentAndZ(t, r);
            this.fullTileRanges_ = n
        }, t
    }(),
    Nc = Oc;
function Rc(t) {
    var e = t.getDefaultTileGrid();
    return e || (e = function(t, e, n, r) {
        return function(t, e, n, r) {
            var i = void 0 !== r ? r : "top-left",
                o = Fc(t, e, n);
            return new Nc({
                extent: t,
                origin: Kt(t, i),
                resolutions: o,
                tileSize: n
            })
        }(kc(t), e, n, r)
    }(t), t.setDefaultTileGrid(e)), e
}
function Ac(t, e, n) {
    var r = e[0],
        i = t.getTileCoordCenter(e),
        o = kc(n);
    if (Ot(o, i))
        return e;
    var s = re(o),
        a = Math.ceil((o[0] - i[0]) / s);
    return i[0] += s * a, t.getTileCoordForCoordAndZ(i, r)
}
function Dc(t) {
    var e = t || {},
        n = e.extent || ln("EPSG:3857").getExtent(),
        r = {
            extent: n,
            minZoom: e.minZoom,
            tileSize: e.tileSize,
            resolutions: Fc(n, e.maxZoom, e.tileSize, e.maxResolution)
        };
    return new Nc(r)
}
function Fc(t, e, n, r) {
    for (var i = void 0 !== e ? e : 42, o = Qt(t), s = re(t), a = Qo(void 0 !== n ? n : 256), u = r > 0 ? r : Math.max(s / a[0], o / a[1]), l = i + 1, h = new Array(l), c = 0; c < l; ++c)
        h[c] = u / Math.pow(2, c);
    return h
}
function kc(t) {
    var e = (t = ln(t)).getExtent();
    if (!e) {
        var n = 180 * lt[ct.DEGREES] / t.getMetersPerUnit();
        e = Ft(-n, -n, n, n)
    }
    return e
}
var jc = function() {
        var t = function(e, n) {
            return t = Object.setPrototypeOf || {
                __proto__: []
            } instanceof Array && function(t, e) {
                t.__proto__ = e
            } || function(t, e) {
                for (var n in e)
                    Object.prototype.hasOwnProperty.call(e, n) && (t[n] = e[n])
            }, t(e, n)
        };
        return function(e, n) {
            if ("function" != typeof n && null !== n)
                throw new TypeError("Class extends value " + String(n) + " is not a constructor or null");
            function r() {
                this.constructor = e
            }
            t(e, n),
            e.prototype = null === n ? Object.create(n) : (r.prototype = n.prototype, new r)
        }
    }(),
    Gc = function(t) {
        function e(e) {
            var n = t.call(this, {
                attributions: e.attributions,
                attributionsCollapsible: e.attributionsCollapsible,
                projection: e.projection,
                state: e.state,
                wrapX: e.wrapX,
                interpolate: e.interpolate
            }) || this;
            n.on,
            n.once,
            n.un,
            n.opaque_ = void 0 !== e.opaque && e.opaque,
            n.tilePixelRatio_ = void 0 !== e.tilePixelRatio ? e.tilePixelRatio : 1,
            n.tileGrid = void 0 !== e.tileGrid ? e.tileGrid : null;
            return n.tileGrid && Qo(n.tileGrid.getTileSize(n.tileGrid.getMinZoom()), [256, 256]), n.tileCache = new (0, gc.default)(e.cacheSize || 0), n.tmpSize = [0, 0], n.key_ = e.key || "", n.tileOptions = {
                transition: e.transition,
                interpolate: e.interpolate
            }, n.zDirection = e.zDirection ? e.zDirection : 0, n
        }
        return jc(e, t), e.prototype.canExpireCache = function() {
            return this.tileCache.canExpireCache()
        }, e.prototype.expireCache = function(t, e) {
            var n = this.getTileCacheForProjection(t);
            n && n.expireCache(e)
        }, e.prototype.forEachLoadedTile = function(t, e, n, r) {
            var i = this.getTileCacheForProjection(t);
            if (!i)
                return !1;
            for (var o, s, a, u = !0, l = n.minX; l <= n.maxX; ++l)
                for (var h = n.minY; h <= n.maxY; ++h)
                    s = vc(e, l, h),
                    a = !1,
                    i.containsKey(s) && (a = (o = i.get(s)).getState() === bo.LOADED) && (a = !1 !== r(o)),
                    a || (u = !1);
            return u
        }, e.prototype.getGutterForProjection = function(t) {
            return 0
        }, e.prototype.getKey = function() {
            return this.key_
        }, e.prototype.setKey = function(t) {
            this.key_ !== t && (this.key_ = t, this.changed())
        }, e.prototype.getOpaque = function(t) {
            return this.opaque_
        }, e.prototype.getResolutions = function() {
            return this.tileGrid ? this.tileGrid.getResolutions() : null
        }, e.prototype.getTile = function(t, e, n, r, i) {
            return u()
        }, e.prototype.getTileGrid = function() {
            return this.tileGrid
        }, e.prototype.getTileGridForProjection = function(t) {
            return this.tileGrid ? this.tileGrid : Rc(t)
        }, e.prototype.getTileCacheForProjection = function(t) {
            var e = this.getProjection();
            return J(null === e || fn(e, t), 68), this.tileCache
        }, e.prototype.getTilePixelRatio = function(t) {
            return this.tilePixelRatio_
        }, e.prototype.getTilePixelSize = function(t, e, n) {
            var r,
                i,
                o,
                s = this.getTileGridForProjection(n),
                a = this.getTilePixelRatio(e),
                u = Qo(s.getTileSize(t), this.tmpSize);
            return 1 == a ? u : (r = u, i = a, void 0 === (o = this.tmpSize) && (o = [0, 0]), o[0] = r[0] * i + .5 | 0, o[1] = r[1] * i + .5 | 0, o)
        }, e.prototype.getTileCoordForTileUrlFunction = function(t, e) {
            var n = void 0 !== e ? e : this.getProjection(),
                r = this.getTileGridForProjection(n);
            return this.getWrapX() && n.isGlobal() && (t = Ac(r, t, n)), Ec(t, r) ? t : null
        }, e.prototype.clear = function() {
            this.tileCache.clear()
        }, e.prototype.refresh = function() {
            this.clear(),
            t.prototype.refresh.call(this)
        }, e.prototype.updateCacheSize = function(t, e) {
            var n = this.getTileCacheForProjection(e);
            t > n.highWaterMark && (n.highWaterMark = t)
        }, e.prototype.useTile = function(t, e, n, r) {}, e
    }(eh.default),
    Bc = function(t) {
        function e(e, n) {
            var r = t.call(this, e) || this;
            return r.tile = n, r
        }
        return jc(e, t), e
    }(g),
    qc = Gc;
function zc(t, e) {
    var n = /\{z\}/g,
        r = /\{x\}/g,
        i = /\{y\}/g,
        o = /\{-y\}/g;
    return function(s, a, u) {
        return s ? t.replace(n, s[0].toString()).replace(r, s[1].toString()).replace(i, s[2].toString()).replace(o, (function() {
            var t = s[0],
                n = e.getFullTileRange(t);
            return J(n, 55), (n.getHeight() - s[2] - 1).toString()
        })) : void 0
    }
}
function Uc(t, e) {
    for (var n = t.length, r = new Array(n), i = 0; i < n; ++i)
        r[i] = zc(t[i], e);
    return function(t) {
        return 1 === t.length ? t[0] : function(e, n, r) {
            if (e) {
                var i = Ee(xc(e), t.length);
                return t[i](e, n, r)
            }
        }
    }(r)
}
function Vc(t) {
    var e = [],
        n = /\{([a-z])-([a-z])\}/.exec(t);
    if (n) {
        var r = n[1].charCodeAt(0),
            i = n[2].charCodeAt(0),
            o = void 0;
        for (o = r; o <= i; ++o)
            e.push(t.replace(n[0], String.fromCharCode(o)));
        return e
    }
    if (n = /\{(\d+)-(\d+)\}/.exec(t)) {
        for (var s = parseInt(n[2], 10), a = parseInt(n[1], 10); a <= s; a++)
            e.push(t.replace(n[0], a.toString()));
        return e
    }
    return e.push(t), e
}
var Xc = function() {
        var t = function(e, n) {
            return t = Object.setPrototypeOf || {
                __proto__: []
            } instanceof Array && function(t, e) {
                t.__proto__ = e
            } || function(t, e) {
                for (var n in e)
                    Object.prototype.hasOwnProperty.call(e, n) && (t[n] = e[n])
            }, t(e, n)
        };
        return function(e, n) {
            if ("function" != typeof n && null !== n)
                throw new TypeError("Class extends value " + String(n) + " is not a constructor or null");
            function r() {
                this.constructor = e
            }
            t(e, n),
            e.prototype = null === n ? Object.create(n) : (r.prototype = n.prototype, new r)
        }
    }(),
    Hc = function(t) {
        function e(n) {
            var r = t.call(this, {
                attributions: n.attributions,
                cacheSize: n.cacheSize,
                opaque: n.opaque,
                projection: n.projection,
                state: n.state,
                tileGrid: n.tileGrid,
                tilePixelRatio: n.tilePixelRatio,
                wrapX: n.wrapX,
                transition: n.transition,
                interpolate: n.interpolate,
                key: n.key,
                attributionsCollapsible: n.attributionsCollapsible,
                zDirection: n.zDirection
            }) || this;
            return r.generateTileUrlFunction_ = r.tileUrlFunction === e.prototype.tileUrlFunction, r.tileLoadFunction = n.tileLoadFunction, n.tileUrlFunction && (r.tileUrlFunction = n.tileUrlFunction), r.urls = null, n.urls ? r.setUrls(n.urls) : n.url && r.setUrl(n.url), r.tileLoadingKeys_ = {}, r
        }
        return Xc(e, t), e.prototype.getTileLoadFunction = function() {
            return this.tileLoadFunction
        }, e.prototype.getTileUrlFunction = function() {
            return Object.getPrototypeOf(this).tileUrlFunction === this.tileUrlFunction ? this.tileUrlFunction.bind(this) : this.tileUrlFunction
        }, e.prototype.getUrls = function() {
            return this.urls
        }, e.prototype.handleTileChange = function(t) {
            var e,
                n = t.target,
                r = h(n),
                i = n.getState();
            i == bo.LOADING ? (this.tileLoadingKeys_[r] = !0, e = Mc.TILELOADSTART) : r in this.tileLoadingKeys_ && (delete this.tileLoadingKeys_[r], e = i == bo.ERROR ? Mc.TILELOADERROR : i == bo.LOADED ? Mc.TILELOADEND : void 0),
            null != e && this.dispatchEvent(new (0, Sc.TileSourceEvent)(e, n))
        }, e.prototype.setTileLoadFunction = function(t) {
            this.tileCache.clear(),
            this.tileLoadFunction = t,
            this.changed()
        }, e.prototype.setTileUrlFunction = function(t, e) {
            this.tileUrlFunction = t,
            this.tileCache.pruneExceptNewestZ(),
            void 0 !== e ? this.setKey(e) : this.changed()
        }, e.prototype.setUrl = function(t) {
            var e = Vc(t);
            this.urls = e,
            this.setUrls(e)
        }, e.prototype.setUrls = function(t) {
            this.urls = t;
            var e = t.join("\n");
            this.generateTileUrlFunction_ ? this.setTileUrlFunction(Uc(t, this.tileGrid), e) : this.setKey(e)
        }, e.prototype.tileUrlFunction = function(t, e, n) {}, e.prototype.useTile = function(t, e, n) {
            var r = vc(t, e, n);
            this.tileCache.containsKey(r) && this.tileCache.get(r)
        }, e
    }(Sc.default),
    Yc = function() {
        var t = function(e, n) {
            return t = Object.setPrototypeOf || {
                __proto__: []
            } instanceof Array && function(t, e) {
                t.__proto__ = e
            } || function(t, e) {
                for (var n in e)
                    Object.prototype.hasOwnProperty.call(e, n) && (t[n] = e[n])
            }, t(e, n)
        };
        return function(e, n) {
            if ("function" != typeof n && null !== n)
                throw new TypeError("Class extends value " + String(n) + " is not a constructor or null");
            function r() {
                this.constructor = e
            }
            t(e, n),
            e.prototype = null === n ? Object.create(n) : (r.prototype = n.prototype, new r)
        }
    }(),
    Wc = function(t) {
        function e(e) {
            var n = this,
                r = void 0 === e.imageSmoothing || e.imageSmoothing;
            return void 0 !== e.interpolate && (r = e.interpolate), (n = t.call(this, {
                attributions: e.attributions,
                cacheSize: e.cacheSize,
                opaque: e.opaque,
                projection: e.projection,
                state: e.state,
                tileGrid: e.tileGrid,
                tileLoadFunction: e.tileLoadFunction ? e.tileLoadFunction : $c,
                tilePixelRatio: e.tilePixelRatio,
                tileUrlFunction: e.tileUrlFunction,
                url: e.url,
                urls: e.urls,
                wrapX: e.wrapX,
                transition: e.transition,
                interpolate: r,
                key: e.key,
                attributionsCollapsible: e.attributionsCollapsible,
                zDirection: e.zDirection
            }) || this).crossOrigin = void 0 !== e.crossOrigin ? e.crossOrigin : null, n.tileClass = void 0 !== e.tileClass ? e.tileClass : $h.default, n.tileCacheForProjection = {}, n.tileGridForProjection = {}, n.reprojectionErrorThreshold_ = e.reprojectionErrorThreshold, n.renderReprojectionEdges_ = !1, n
        }
        return Yc(e, t), e.prototype.canExpireCache = function() {
            if (this.tileCache.canExpireCache())
                return !0;
            for (var t in this.tileCacheForProjection)
                if (this.tileCacheForProjection[t].canExpireCache())
                    return !0;
            return !1
        }, e.prototype.expireCache = function(t, e) {
            var n = this.getTileCacheForProjection(t);
            for (var r in this.tileCache.expireCache(this.tileCache == n ? e : {}), this.tileCacheForProjection) {
                var i = this.tileCacheForProjection[r];
                i.expireCache(i == n ? e : {})
            }
        }, e.prototype.getGutterForProjection = function(t) {
            return this.getProjection() && t && !fn(this.getProjection(), t) ? 0 : this.getGutter()
        }, e.prototype.getGutter = function() {
            return 0
        }, e.prototype.getKey = function() {
            var e = t.prototype.getKey.call(this);
            return this.getInterpolate() || (e += ":disable-interpolation"), e
        }, e.prototype.getOpaque = function(e) {
            return !(this.getProjection() && e && !fn(this.getProjection(), e)) && t.prototype.getOpaque.call(this, e)
        }, e.prototype.getTileGridForProjection = function(t) {
            var e = this.getProjection();
            if (!this.tileGrid || e && !fn(e, t)) {
                var n = h(t);
                return n in this.tileGridForProjection || (this.tileGridForProjection[n] = Rc(t)), this.tileGridForProjection[n]
            }
            return this.tileGrid
        }, e.prototype.getTileCacheForProjection = function(t) {
            var e = this.getProjection();
            if (!e || fn(e, t))
                return this.tileCache;
            var n = h(t);
            return n in this.tileCacheForProjection || (this.tileCacheForProjection[n] = new (0, gc.default)(this.tileCache.highWaterMark)), this.tileCacheForProjection[n]
        }, e.prototype.createTile_ = function(t, e, n, r, i, o) {
            var s = [t, e, n],
                a = this.getTileCoordForTileUrlFunction(s, i),
                u = a ? this.tileUrlFunction(a, r, i) : void 0,
                l = new this.tileClass(s, void 0 !== u ? bo.IDLE : bo.EMPTY, void 0 !== u ? u : "", this.crossOrigin, this.tileLoadFunction, this.tileOptions);
            return l.key = o, l.addEventListener(D.CHANGE, this.handleTileChange.bind(this)), l
        }, e.prototype.getTile = function(t, e, n, r, i) {
            var o = this.getProjection();
            if (o && i && !fn(o, i)) {
                var s = this.getTileCacheForProjection(i),
                    a = [t, e, n],
                    u = void 0,
                    l = mc(a);
                s.containsKey(l) && (u = s.get(l));
                var h = this.getKey();
                if (u && u.key == h)
                    return u;
                var c = this.getTileGridForProjection(o),
                    p = this.getTileGridForProjection(i),
                    f = this.getTileCoordForTileUrlFunction(a, i),
                    d = new (0, ec.default)(o, c, i, p, a, f, this.getTilePixelRatio(r), this.getGutter(), function(t, e, n, r) {
                        return this.getTileInternal(t, e, n, r, o)
                    }.bind(this), this.reprojectionErrorThreshold_, this.renderReprojectionEdges_, this.getInterpolate());
                return d.key = h, u ? (d.interimTile = u, d.refreshInterimChain(), s.replace(l, d)) : s.set(l, d), d
            }
            return this.getTileInternal(t, e, n, r, o || i)
        }, e.prototype.getTileInternal = function(t, e, n, r, i) {
            var o = null,
                s = vc(t, e, n),
                a = this.getKey();
            if (this.tileCache.containsKey(s)) {
                if ((o = this.tileCache.get(s)).key != a) {
                    var u = o;
                    o = this.createTile_(t, e, n, r, i, a),
                    u.getState() == bo.IDLE ? o.interimTile = u.interimTile : o.interimTile = u,
                    o.refreshInterimChain(),
                    this.tileCache.replace(s, o)
                }
            } else
                o = this.createTile_(t, e, n, r, i, a),
                this.tileCache.set(s, o);
            return o
        }, e.prototype.setRenderReprojectionEdges = function(t) {
            if (this.renderReprojectionEdges_ != t) {
                for (var e in this.renderReprojectionEdges_ = t, this.tileCacheForProjection)
                    this.tileCacheForProjection[e].clear();
                this.changed()
            }
        }, e.prototype.setTileGridForProjection = function(t, e) {
            var n = ln(t);
            if (n) {
                var r = h(n);
                r in this.tileGridForProjection || (this.tileGridForProjection[r] = e)
            }
        }, e
    }(Cc.default);
function $c(t, e) {
    t.getImage().src = e
}
var Kc = Wc,
    Zc = function() {
        var t = function(e, n) {
            return t = Object.setPrototypeOf || {
                __proto__: []
            } instanceof Array && function(t, e) {
                t.__proto__ = e
            } || function(t, e) {
                for (var n in e)
                    Object.prototype.hasOwnProperty.call(e, n) && (t[n] = e[n])
            }, t(e, n)
        };
        return function(e, n) {
            if ("function" != typeof n && null !== n)
                throw new TypeError("Class extends value " + String(n) + " is not a constructor or null");
            function r() {
                this.constructor = e
            }
            t(e, n),
            e.prototype = null === n ? Object.create(n) : (r.prototype = n.prototype, new r)
        }
    }(),
    Jc = function(t) {
        function e(e) {
            var n = this,
                r = e || {},
                i = void 0 === r.imageSmoothing || r.imageSmoothing;
            void 0 !== r.interpolate && (i = r.interpolate);
            var o = void 0 !== r.projection ? r.projection : "EPSG:3857",
                s = void 0 !== r.tileGrid ? r.tileGrid : Dc({
                    extent: kc(o),
                    maxResolution: r.maxResolution,
                    maxZoom: r.maxZoom,
                    minZoom: r.minZoom,
                    tileSize: r.tileSize
                });
            return (n = t.call(this, {
                attributions: r.attributions,
                cacheSize: r.cacheSize,
                crossOrigin: r.crossOrigin,
                interpolate: i,
                opaque: r.opaque,
                projection: o,
                reprojectionErrorThreshold: r.reprojectionErrorThreshold,
                tileGrid: s,
                tileLoadFunction: r.tileLoadFunction,
                tilePixelRatio: r.tilePixelRatio,
                tileUrlFunction: r.tileUrlFunction,
                url: r.url,
                urls: r.urls,
                wrapX: void 0 === r.wrapX || r.wrapX,
                transition: r.transition,
                attributionsCollapsible: r.attributionsCollapsible,
                zDirection: r.zDirection
            }) || this).gutter_ = void 0 !== r.gutter ? r.gutter : 0, n
        }
        return Zc(e, t), e.prototype.getGutter = function() {
            return this.gutter_
        }, e
    }(Wh.default),
    Qc = function() {
        var t = function(e, n) {
            return t = Object.setPrototypeOf || {
                __proto__: []
            } instanceof Array && function(t, e) {
                t.__proto__ = e
            } || function(t, e) {
                for (var n in e)
                    Object.prototype.hasOwnProperty.call(e, n) && (t[n] = e[n])
            }, t(e, n)
        };
        return function(e, n) {
            if ("function" != typeof n && null !== n)
                throw new TypeError("Class extends value " + String(n) + " is not a constructor or null");
            function r() {
                this.constructor = e
            }
            t(e, n),
            e.prototype = null === n ? Object.create(n) : (r.prototype = n.prototype, new r)
        }
    }(),
    tp = '&#169; <a href="https://www.openstreetmap.org/copyright" target="_blank">OpenStreetMap</a> contributors.',
    ep = function(t) {
        function e(e) {
            var n,
                r = e || {},
                i = void 0 === r.imageSmoothing || r.imageSmoothing;
            void 0 !== r.interpolate && (i = r.interpolate),
            n = void 0 !== r.attributions ? r.attributions : [tp];
            var o = void 0 !== r.crossOrigin ? r.crossOrigin : "anonymous",
                s = void 0 !== r.url ? r.url : "https://{a-c}.tile.openstreetmap.org/{z}/{x}/{y}.png";
            return t.call(this, {
                    attributions: n,
                    attributionsCollapsible: !1,
                    cacheSize: r.cacheSize,
                    crossOrigin: o,
                    interpolate: i,
                    maxZoom: void 0 !== r.maxZoom ? r.maxZoom : 19,
                    opaque: void 0 === r.opaque || r.opaque,
                    reprojectionErrorThreshold: r.reprojectionErrorThreshold,
                    tileLoadFunction: r.tileLoadFunction,
                    transition: r.transition,
                    url: s,
                    wrapX: r.wrapX,
                    zDirection: r.zDirection
                }) || this
        }
        return Qc(e, t), e
    }(Yh.default),
    np = {};
t(np, "default", (() => cp), (t => cp = t));
var rp = {};
t(rp, "default", (() => sp), (t => sp = t));
var ip = {
        PRELOAD: "preload",
        USE_INTERIM_TILES_ON_ERROR: "useInterimTilesOnError"
    },
    op = function() {
        var t = function(e, n) {
            return t = Object.setPrototypeOf || {
                __proto__: []
            } instanceof Array && function(t, e) {
                t.__proto__ = e
            } || function(t, e) {
                for (var n in e)
                    Object.prototype.hasOwnProperty.call(e, n) && (t[n] = e[n])
            }, t(e, n)
        };
        return function(e, n) {
            if ("function" != typeof n && null !== n)
                throw new TypeError("Class extends value " + String(n) + " is not a constructor or null");
            function r() {
                this.constructor = e
            }
            t(e, n),
            e.prototype = null === n ? Object.create(n) : (r.prototype = n.prototype, new r)
        }
    }(),
    sp = function(t) {
        function e(e) {
            var n = this,
                r = e || {},
                i = P({}, r);
            return delete i.preload, delete i.useInterimTilesOnError, (n = t.call(this, i) || this).on, n.once, n.un, n.setPreload(void 0 !== r.preload ? r.preload : 0), n.setUseInterimTilesOnError(void 0 === r.useInterimTilesOnError || r.useInterimTilesOnError), n
        }
        return op(e, t), e.prototype.getPreload = function() {
            return this.get(ip.PRELOAD)
        }, e.prototype.setPreload = function(t) {
            this.set(ip.PRELOAD, t)
        }, e.prototype.getUseInterimTilesOnError = function() {
            return this.get(ip.USE_INTERIM_TILES_ON_ERROR)
        }, e.prototype.setUseInterimTilesOnError = function(t) {
            this.set(ip.USE_INTERIM_TILES_ON_ERROR, t)
        }, e.prototype.getData = function(e) {
            return t.prototype.getData.call(this, e)
        }, e
    }(fi.default),
    ap = {};
t(ap, "default", (() => lp), (t => lp = t));
var up = function() {
        var t = function(e, n) {
            return t = Object.setPrototypeOf || {
                __proto__: []
            } instanceof Array && function(t, e) {
                t.__proto__ = e
            } || function(t, e) {
                for (var n in e)
                    Object.prototype.hasOwnProperty.call(e, n) && (t[n] = e[n])
            }, t(e, n)
        };
        return function(e, n) {
            if ("function" != typeof n && null !== n)
                throw new TypeError("Class extends value " + String(n) + " is not a constructor or null");
            function r() {
                this.constructor = e
            }
            t(e, n),
            e.prototype = null === n ? Object.create(n) : (r.prototype = n.prototype, new r)
        }
    }(),
    lp = function(t) {
        function e(e) {
            var n = t.call(this, e) || this;
            return n.extentChanged = !0, n.renderedExtent_ = null, n.renderedPixelRatio, n.renderedProjection = null, n.renderedRevision, n.renderedTiles = [], n.newTiles_ = !1, n.tmpExtent = [1 / 0, 1 / 0, -1 / 0, -1 / 0], n.tmpTileRange_ = new Pc(0, 0, 0, 0), n
        }
        return up(e, t), e.prototype.isDrawableTile = function(t) {
            var e = this.getLayer(),
                n = t.getState(),
                r = e.getUseInterimTilesOnError();
            return n == bo.LOADED || n == bo.EMPTY || n == bo.ERROR && !r
        }, e.prototype.getTile = function(t, e, n, r) {
            var i = r.pixelRatio,
                o = r.viewState.projection,
                s = this.getLayer(),
                a = s.getSource().getTile(t, e, n, i, o);
            return a.getState() == bo.ERROR && (s.getUseInterimTilesOnError() ? s.getPreload() > 0 && (this.newTiles_ = !0) : a.setState(bo.LOADED)), this.isDrawableTile(a) || (a = a.getInterimTile()), a
        }, e.prototype.getData = function(t) {
            var e = this.frameState;
            if (!e)
                return null;
            var n = this.getLayer(),
                r = Et(e.pixelToCoordinateTransform, t.slice()),
                i = n.getExtent();
            if (i && !Ot(i, r))
                return null;
            for (var o = e.pixelRatio, s = e.viewState.projection, a = e.viewState, u = n.getRenderSource(), l = u.getTileGridForProjection(a.projection), h = u.getTilePixelRatio(e.pixelRatio), c = l.getZForResolution(a.resolution); c >= l.getMinZoom(); --c) {
                var p = l.getTileCoordForCoordAndZ(r, c),
                    f = u.getTile(c, p[1], p[2], o, s);
                if (!(f instanceof $h.default || f instanceof ec.default))
                    return null;
                if (f.getState() === bo.LOADED) {
                    var d = l.getOrigin(c),
                        g = Qo(l.getTileSize(c)),
                        y = l.getResolution(c),
                        v = Math.floor(h * ((r[0] - d[0]) / y - p[1] * g[0])),
                        m = Math.floor(h * ((d[1] - r[1]) / y - p[2] * g[1])),
                        _ = Math.round(h * u.getGutterForProjection(a.projection));
                    return this.getImageData(f.getImage(), v + _, m + _)
                }
            }
            return null
        }, e.prototype.loadedTileCallback = function(e, n, r) {
            return !!this.isDrawableTile(r) && t.prototype.loadedTileCallback.call(this, e, n, r)
        }, e.prototype.prepareFrame = function(t) {
            return !!this.getLayer().getSource()
        }, e.prototype.renderFrame = function(t, e) {
            var n = t.layerStatesArray[t.layerIndex],
                r = t.viewState,
                i = r.projection,
                o = r.resolution,
                s = r.center,
                a = r.rotation,
                u = t.pixelRatio,
                l = this.getLayer(),
                c = l.getSource(),
                p = c.getRevision(),
                f = c.getTileGridForProjection(i),
                d = f.getZForResolution(o, c.zDirection),
                g = f.getResolution(d),
                y = t.extent,
                v = t.viewState.resolution,
                m = c.getTilePixelRatio(u),
                _ = Math.round(re(y) / v * u),
                x = Math.round(Qt(y) / v * u),
                w = n.extent && Sn(n.extent, i);
            w && (y = te(y, Sn(n.extent, i)));
            var b = g * _ / 2 / m,
                C = g * x / 2 / m,
                M = [s[0] - b, s[1] - C, s[0] + b, s[1] + C],
                S = f.getTileRangeForExtentAndZ(y, d),
                I = {};
            I[d] = {};
            var T = this.createLoadedTileFinder(c, i, I),
                L = this.tmpExtent,
                O = this.tmpTileRange_;
            this.newTiles_ = !1;
            for (var N = a ? Jt(r.center, v, a, t.size) : void 0, R = S.minX; R <= S.maxX; ++R)
                for (var A = S.minY; A <= S.maxY; ++A)
                    if (!a || f.tileCoordIntersectsViewport([d, R, A], N)) {
                        var D = this.getTile(d, R, A, t);
                        if (this.isDrawableTile(D)) {
                            var F = h(this);
                            if (D.getState() == bo.LOADED)
                                I[d][D.tileCoord.toString()] = D,
                                (ot = D.inTransition(F)) && 1 !== n.opacity && (D.endTransition(F), ot = !1),
                                this.newTiles_ || !ot && -1 !== this.renderedTiles.indexOf(D) || (this.newTiles_ = !0);
                            if (1 === D.getAlpha(F, t.time))
                                continue
                        }
                        var k = f.getTileCoordChildTileRange(D.tileCoord, O, L),
                            j = !1;
                        k && (j = T(d + 1, k)),
                        j || f.forEachTileCoordParentTileRange(D.tileCoord, T, O, L)
                    }
            var G = g / o * u / m;
            bt(this.pixelTransform, t.size[0] / 2, t.size[1] / 2, 1 / u, 1 / u, a, -_ / 2, -x / 2);
            var B = Mt(this.pixelTransform);
            this.useContainer(e, B, this.getBackground(t));
            var q = this.context,
                z = q.canvas;
            Ct(this.inversePixelTransform, this.pixelTransform),
            bt(this.tempTransform, _ / 2, x / 2, G, G, 0, -_ / 2, -x / 2),
            z.width != _ || z.height != x ? (z.width = _, z.height = x) : this.containerReused || q.clearRect(0, 0, _, x),
            w && this.clipUnrotated(q, t, w),
            c.getInterpolate() || P(q, oc),
            this.preRender(q, t),
            this.renderedTiles.length = 0;
            var U,
                V,
                X,
                H = Object.keys(I).map(Number);
            H.sort(E),
            1 !== n.opacity || this.containerReused && !c.getOpaque(t.viewState.projection) ? (U = [], V = []) : H = H.reverse();
            for (var Y = H.length - 1; Y >= 0; --Y) {
                var W = H[Y],
                    $ = c.getTilePixelSize(W, u, i),
                    K = f.getResolution(W) / g,
                    Z = $[0] * K * G,
                    J = $[1] * K * G,
                    Q = f.getTileCoordForCoordAndZ(ee(M), W),
                    tt = f.getTileCoordExtent(Q),
                    et = Et(this.tempTransform, [m * (tt[0] - M[0]) / g, m * (M[3] - tt[3]) / g]),
                    nt = m * c.getGutterForProjection(i),
                    rt = I[W];
                for (var it in rt) {
                    var ot,
                        st = (D = rt[it]).tileCoord,
                        at = Q[1] - st[1],
                        ut = Math.round(et[0] - (at - 1) * Z),
                        lt = Q[2] - st[2],
                        ht = Math.round(et[1] - (lt - 1) * J),
                        ct = ut - (R = Math.round(et[0] - at * Z)),
                        pt = ht - (A = Math.round(et[1] - lt * J)),
                        ft = d === W,
                        dt = !1;
                    if (!(ot = ft && 1 !== D.getAlpha(h(this), t.time)))
                        if (U) {
                            X = [R, A, R + ct, A, R + ct, A + pt, R, A + pt];
                            for (var gt = 0, yt = U.length; gt < yt; ++gt)
                                if (d !== W && W < V[gt]) {
                                    var vt = U[gt];
                                    ie([R, A, R + ct, A + pt], [vt[0], vt[3], vt[4], vt[7]]) && (dt || (q.save(), dt = !0), q.beginPath(), q.moveTo(X[0], X[1]), q.lineTo(X[2], X[3]), q.lineTo(X[4], X[5]), q.lineTo(X[6], X[7]), q.moveTo(vt[6], vt[7]), q.lineTo(vt[4], vt[5]), q.lineTo(vt[2], vt[3]), q.lineTo(vt[0], vt[1]), q.clip())
                                }
                            U.push(X),
                            V.push(W)
                        } else
                            q.clearRect(R, A, ct, pt);
                    this.drawTileImage(D, t, R, A, ct, pt, nt, ft),
                    U && !ot ? (dt && q.restore(), this.renderedTiles.unshift(D)) : this.renderedTiles.push(D),
                    this.updateUsedTiles(t.usedTiles, c, D)
                }
            }
            return this.renderedRevision = p, this.renderedResolution = g, this.extentChanged = !this.renderedExtent_ || !Bt(this.renderedExtent_, M), this.renderedExtent_ = M, this.renderedPixelRatio = u, this.renderedProjection = i, this.manageTilePyramid(t, c, f, u, i, y, d, l.getPreload()), this.scheduleExpireCache(t, c), this.postRender(q, t), n.extent && q.restore(), P(q, sc), B !== z.style.transform && (z.style.transform = B), this.container
        }, e.prototype.drawTileImage = function(t, e, n, r, i, o, s, a) {
            var u = this.getTileImage(t);
            if (u) {
                var l = h(this),
                    c = e.layerStatesArray[e.layerIndex],
                    p = c.opacity * (a ? t.getAlpha(l, e.time) : 1),
                    f = p !== this.context.globalAlpha;
                f && (this.context.save(), this.context.globalAlpha = p),
                this.context.drawImage(u, s, s, u.width - 2 * s, u.height - 2 * s, n, r, i, o),
                f && this.context.restore(),
                p !== c.opacity ? e.animate = !0 : a && t.endTransition(l)
            }
        }, e.prototype.getImage = function() {
            var t = this.context;
            return t ? t.canvas : null
        }, e.prototype.getTileImage = function(t) {
            return t.getImage()
        }, e.prototype.scheduleExpireCache = function(t, e) {
            if (e.canExpireCache()) {
                var n = function(t, e, n) {
                    var r = h(t);
                    r in n.usedTiles && t.expireCache(n.viewState.projection, n.usedTiles[r])
                }.bind(null, e);
                t.postRenderFunctions.push(n)
            }
        }, e.prototype.updateUsedTiles = function(t, e, n) {
            var r = h(e);
            r in t || (t[r] = {}),
            t[r][n.getKey()] = !0
        }, e.prototype.manageTilePyramid = function(t, e, n, r, i, o, s, a, u) {
            var l = h(e);
            l in t.wantedTiles || (t.wantedTiles[l] = {});
            var c,
                p,
                f,
                d,
                g,
                y,
                v = t.wantedTiles[l],
                m = t.tileQueue,
                _ = n.getMinZoom(),
                x = t.viewState.rotation,
                E = x ? Jt(t.viewState.center, t.viewState.resolution, x, t.size) : void 0,
                w = 0;
            for (y = _; y <= s; ++y)
                for (p = n.getTileRangeForExtentAndZ(o, y, p), f = n.getResolution(y), d = p.minX; d <= p.maxX; ++d)
                    for (g = p.minY; g <= p.maxY; ++g)
                        x && !n.tileCoordIntersectsViewport([y, d, g], E) || (s - y <= a ? (++w, (c = e.getTile(y, d, g, r, i)).getState() == bo.IDLE && (v[c.getKey()] = !0, m.isKeyQueued(c.getKey()) || m.enqueue([c, l, n.getTileCoordCenter(c.tileCoord), f])), void 0 !== u && u(c)) : e.useTile(y, d, g, i));
            e.updateCacheSize(w, i)
        }, e
    }(Wu.default),
    hp = function() {
        var t = function(e, n) {
            return t = Object.setPrototypeOf || {
                __proto__: []
            } instanceof Array && function(t, e) {
                t.__proto__ = e
            } || function(t, e) {
                for (var n in e)
                    Object.prototype.hasOwnProperty.call(e, n) && (t[n] = e[n])
            }, t(e, n)
        };
        return function(e, n) {
            if ("function" != typeof n && null !== n)
                throw new TypeError("Class extends value " + String(n) + " is not a constructor or null");
            function r() {
                this.constructor = e
            }
            t(e, n),
            e.prototype = null === n ? Object.create(n) : (r.prototype = n.prototype, new r)
        }
    }(),
    cp = function(t) {
        function e(e) {
            return t.call(this, e) || this
        }
        return hp(e, t), e.prototype.createRenderer = function() {
            return new (0, ap.default)(this)
        }, e
    }(rp.default),
    pp = {};
t(pp, "default", (() => yp), (t => yp = t));
var fp = function() {
    var t = function(e, n) {
        return t = Object.setPrototypeOf || {
            __proto__: []
        } instanceof Array && function(t, e) {
            t.__proto__ = e
        } || function(t, e) {
            for (var n in e)
                Object.prototype.hasOwnProperty.call(e, n) && (t[n] = e[n])
        }, t(e, n)
    };
    return function(e, n) {
        if ("function" != typeof n && null !== n)
            throw new TypeError("Class extends value " + String(n) + " is not a constructor or null");
        function r() {
            this.constructor = e
        }
        t(e, n),
        e.prototype = null === n ? Object.create(n) : (r.prototype = n.prototype, new r)
    }
}();
function dp(t) {
    for (var e = [], n = 0, r = t.length; n < r; ++n)
        e.push(t[n].clone());
    return e
}
var gp,
    yp = function(t) {
        function e(e) {
            var n = t.call(this) || this;
            return n.geometries_ = e || null, n.changeEventsKeys_ = [], n.listenGeometriesChange_(), n
        }
        return fp(e, t), e.prototype.unlistenGeometriesChange_ = function() {
            this.changeEventsKeys_.forEach(j),
            this.changeEventsKeys_.length = 0
        }, e.prototype.listenGeometriesChange_ = function() {
            if (this.geometries_)
                for (var t = 0, e = this.geometries_.length; t < e; ++t)
                    this.changeEventsKeys_.push(F(this.geometries_[t], D.CHANGE, this.changed, this))
        }, e.prototype.clone = function() {
            var t = new e(null);
            return t.setGeometries(this.geometries_), t.applyProperties(this), t
        }, e.prototype.closestPointXY = function(t, e, n, r) {
            if (r < Lt(this.getExtent(), t, e))
                return r;
            for (var i = this.geometries_, o = 0, s = i.length; o < s; ++o)
                r = i[o].closestPointXY(t, e, n, r);
            return r
        }, e.prototype.containsXY = function(t, e) {
            for (var n = this.geometries_, r = 0, i = n.length; r < i; ++r)
                if (n[r].containsXY(t, e))
                    return !0;
            return !1
        }, e.prototype.computeExtent = function(t) {
            kt(t);
            for (var e = this.geometries_, n = 0, r = e.length; n < r; ++n)
                qt(t, e[n].getExtent());
            return t
        }, e.prototype.getGeometries = function() {
            return dp(this.geometries_)
        }, e.prototype.getGeometriesArray = function() {
            return this.geometries_
        }, e.prototype.getGeometriesArrayRecursive = function() {
            for (var t = [], e = this.geometries_, n = 0, r = e.length; n < r; ++n)
                e[n].getType() === this.getType() ? t = t.concat(e[n].getGeometriesArrayRecursive()) : t.push(e[n]);
            return t
        }, e.prototype.getSimplifiedGeometry = function(t) {
            if (this.simplifiedGeometryRevision !== this.getRevision() && (this.simplifiedGeometryMaxMinSquaredTolerance = 0, this.simplifiedGeometryRevision = this.getRevision()), t < 0 || 0 !== this.simplifiedGeometryMaxMinSquaredTolerance && t < this.simplifiedGeometryMaxMinSquaredTolerance)
                return this;
            for (var n = [], r = this.geometries_, i = !1, o = 0, s = r.length; o < s; ++o) {
                var a = r[o],
                    u = a.getSimplifiedGeometry(t);
                n.push(u),
                u !== a && (i = !0)
            }
            if (i) {
                var l = new e(null);
                return l.setGeometriesArray(n), l
            }
            return this.simplifiedGeometryMaxMinSquaredTolerance = t, this
        }, e.prototype.getType = function() {
            return "GeometryCollection"
        }, e.prototype.intersectsExtent = function(t) {
            for (var e = this.geometries_, n = 0, r = e.length; n < r; ++n)
                if (e[n].intersectsExtent(t))
                    return !0;
            return !1
        }, e.prototype.isEmpty = function() {
            return 0 === this.geometries_.length
        }, e.prototype.rotate = function(t, e) {
            for (var n = this.geometries_, r = 0, i = n.length; r < i; ++r)
                n[r].rotate(t, e);
            this.changed()
        }, e.prototype.scale = function(t, e, n) {
            var r = n;
            r || (r = $t(this.getExtent()));
            for (var i = this.geometries_, o = 0, s = i.length; o < s; ++o)
                i[o].scale(t, e, r);
            this.changed()
        }, e.prototype.setGeometries = function(t) {
            this.setGeometriesArray(dp(t))
        }, e.prototype.setGeometriesArray = function(t) {
            this.unlistenGeometriesChange_(),
            this.geometries_ = t,
            this.listenGeometriesChange_(),
            this.changed()
        }, e.prototype.applyTransform = function(t) {
            for (var e = this.geometries_, n = 0, r = e.length; n < r; ++n)
                e[n].applyTransform(t);
            this.changed()
        }, e.prototype.translate = function(t, e) {
            for (var n = this.geometries_, r = 0, i = n.length; r < i; ++r)
                n[r].translate(t, e);
            this.changed()
        }, e.prototype.disposeInternal = function() {
            this.unlistenGeometriesChange_(),
            t.prototype.disposeInternal.call(this)
        }, e
    }(at.default),
    vp = {};
gp = function() {
    function t(t, e, n) {
        var r = new XMLHttpRequest;
        r.open("GET", t),
        r.responseType = "blob",
        r.onload = function() {
            s(r.response, e, n)
        },
        r.onerror = function() {
            console.error("could not download file")
        },
        r.send()
    }
    function e(t) {
        var e = new XMLHttpRequest;
        e.open("HEAD", t, !1);
        try {
            e.send()
        } catch (t) {}
        return 200 <= e.status && 299 >= e.status
    }
    function r(t) {
        try {
            t.dispatchEvent(new MouseEvent("click"))
        } catch (n) {
            var e = document.createEvent("MouseEvents");
            e.initMouseEvent("click", !0, !0, window, 0, 0, 0, 80, 20, !1, !1, !1, !1, 0, null),
            t.dispatchEvent(e)
        }
    }
    var i = "object" == typeof window && window.window === window ? window : "object" == typeof self && self.self === self ? self : "object" == typeof n && n.global === n ? n : void 0,
        o = i.navigator && /Macintosh/.test(navigator.userAgent) && /AppleWebKit/.test(navigator.userAgent) && !/Safari/.test(navigator.userAgent),
        s = i.saveAs || ("object" != typeof window || window !== i ? function() {} : "download" in HTMLAnchorElement.prototype && !o ? function(n, o, s) {
            var a = i.URL || i.webkitURL,
                u = document.createElement("a");
            o = o || n.name || "download",
            u.download = o,
            u.rel = "noopener",
            "string" == typeof n ? (u.href = n, u.origin === location.origin ? r(u) : e(u.href) ? t(n, o, s) : r(u, u.target = "_blank")) : (u.href = a.createObjectURL(n), setTimeout((function() {
                a.revokeObjectURL(u.href)
            }), 4e4), setTimeout((function() {
                r(u)
            }), 0))
        } : "msSaveOrOpenBlob" in navigator ? function(n, i, o) {
            if (i = i || n.name || "download", "string" != typeof n)
                navigator.msSaveOrOpenBlob(function(t, e) {
                    return void 0 === e ? e = {
                        autoBom: !1
                    } : "object" != typeof e && (console.warn("Deprecated: Expected third argument to be a object"), e = {
                        autoBom: !e
                    }), e.autoBom && /^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(t.type) ? new Blob(["\ufeff", t], {
                        type: t.type
                    }) : t
                }(n, o), i);
            else if (e(n))
                t(n, i, o);
            else {
                var s = document.createElement("a");
                s.href = n,
                s.target = "_blank",
                setTimeout((function() {
                    r(s)
                }))
            }
        } : function(e, n, r, s) {
            if ((s = s || open("", "_blank")) && (s.document.title = s.document.body.innerText = "downloading..."), "string" == typeof e)
                return t(e, n, r);
            var a = "application/octet-stream" === e.type,
                u = /constructor/i.test(i.HTMLElement) || i.safari,
                l = /CriOS\/[\d]+/.test(navigator.userAgent);
            if ((l || a && u || o) && "undefined" != typeof FileReader) {
                var h = new FileReader;
                h.onloadend = function() {
                    var t = h.result;
                    t = l ? t : t.replace(/^data:[^;]*;/, "data:attachment/file;"),
                    s ? s.location.href = t : location = t,
                    s = null
                },
                h.readAsDataURL(e)
            } else {
                var c = i.URL || i.webkitURL,
                    p = c.createObjectURL(e);
                s ? s.location = p : location.href = p,
                s = null,
                setTimeout((function() {
                    c.revokeObjectURL(p)
                }), 4e4)
            }
        });
    i.saveAs = s.saveAs = s,
    vp = s
},
"function" == typeof define && define.amd ? define([], gp) : gp();
var mp = Math.PI / 2,
    _p = Math.PI / 4,
    xp = 2 * Math.PI,
    Ep = {
        greenwich: 0,
        lisbon: -9.131906111111,
        paris: 2.337229166667,
        bogota: -74.080916666667,
        madrid: -3.687938888889,
        rome: 12.452333333333,
        bern: 7.439583333333,
        jakarta: 106.807719444444,
        ferro: -17.666666666667,
        brussels: 4.367975,
        stockholm: 18.058277777778,
        athens: 23.7163375,
        oslo: 10.722916666667
    },
    wp = {
        ft: {
            to_meter: .3048
        },
        "us-ft": {
            to_meter: 1200 / 3937
        }
    },
    bp = /[\s_\-\/\(\)]/g;
function Cp(t, e) {
    if (t[e])
        return t[e];
    for (var n, r = Object.keys(t), i = e.toLowerCase().replace(bp, ""), o = -1; ++o < r.length;)
        if ((n = r[o]).toLowerCase().replace(bp, "") === i)
            return t[n]
}
function Mp(t) {
    var e,
        n,
        r,
        i = {},
        o = t.split("+").map((function(t) {
            return t.trim()
        })).filter((function(t) {
            return t
        })).reduce((function(t, e) {
            var n = e.split("=");
            return n.push(!0), t[n[0].toLowerCase()] = n[1], t
        }), {}),
        s = {
            proj: "projName",
            datum: "datumCode",
            rf: function(t) {
                i.rf = parseFloat(t)
            },
            lat_0: function(t) {
                i.lat0 = .017453292519943295 * t
            },
            lat_1: function(t) {
                i.lat1 = .017453292519943295 * t
            },
            lat_2: function(t) {
                i.lat2 = .017453292519943295 * t
            },
            lat_ts: function(t) {
                i.lat_ts = .017453292519943295 * t
            },
            lon_0: function(t) {
                i.long0 = .017453292519943295 * t
            },
            lon_1: function(t) {
                i.long1 = .017453292519943295 * t
            },
            lon_2: function(t) {
                i.long2 = .017453292519943295 * t
            },
            alpha: function(t) {
                i.alpha = .017453292519943295 * parseFloat(t)
            },
            gamma: function(t) {
                i.rectified_grid_angle = parseFloat(t)
            },
            lonc: function(t) {
                i.longc = .017453292519943295 * t
            },
            x_0: function(t) {
                i.x0 = parseFloat(t)
            },
            y_0: function(t) {
                i.y0 = parseFloat(t)
            },
            k_0: function(t) {
                i.k0 = parseFloat(t)
            },
            k: function(t) {
                i.k0 = parseFloat(t)
            },
            a: function(t) {
                i.a = parseFloat(t)
            },
            b: function(t) {
                i.b = parseFloat(t)
            },
            r_a: function() {
                i.R_A = !0
            },
            zone: function(t) {
                i.zone = parseInt(t, 10)
            },
            south: function() {
                i.utmSouth = !0
            },
            towgs84: function(t) {
                i.datum_params = t.split(",").map((function(t) {
                    return parseFloat(t)
                }))
            },
            to_meter: function(t) {
                i.to_meter = parseFloat(t)
            },
            units: function(t) {
                i.units = t;
                var e = Cp(wp, t);
                e && (i.to_meter = e.to_meter)
            },
            from_greenwich: function(t) {
                i.from_greenwich = .017453292519943295 * t
            },
            pm: function(t) {
                var e = Cp(Ep, t);
                i.from_greenwich = .017453292519943295 * (e || parseFloat(t))
            },
            nadgrids: function(t) {
                "@null" === t ? i.datumCode = "none" : i.nadgrids = t
            },
            axis: function(t) {
                var e = "ewnsud";
                3 === t.length && -1 !== e.indexOf(t.substr(0, 1)) && -1 !== e.indexOf(t.substr(1, 1)) && -1 !== e.indexOf(t.substr(2, 1)) && (i.axis = t)
            },
            approx: function() {
                i.approx = !0
            }
        };
    for (e in o)
        n = o[e],
        e in s ? "function" == typeof (r = s[e]) ? r(n) : i[r] = n : i[e] = n;
    return "string" == typeof i.datumCode && "WGS84" !== i.datumCode && (i.datumCode = i.datumCode.toLowerCase()), i
}
var Sp = /\s/,
    Ip = /[A-Za-z]/,
    Tp = /[A-Za-z84_]/,
    Pp = /[,\]]/,
    Lp = /[\d\.E\-\+]/;
function Op(t) {
    if ("string" != typeof t)
        throw new Error("not a string");
    this.text = t.trim(),
    this.level = 0,
    this.place = 0,
    this.root = null,
    this.stack = [],
    this.currentObject = null,
    this.state = 1
}
function Np(t, e, n) {
    Array.isArray(e) && (n.unshift(e), e = null);
    var r = e ? {} : t,
        i = n.reduce((function(t, e) {
            return Rp(e, t), t
        }), r);
    e && (t[e] = i)
}
function Rp(t, e) {
    if (Array.isArray(t)) {
        var n = t.shift();
        if ("PARAMETER" === n && (n = t.shift()), 1 === t.length)
            return Array.isArray(t[0]) ? (e[n] = {}, void Rp(t[0], e[n])) : void (e[n] = t[0]);
        if (t.length)
            if ("TOWGS84" !== n) {
                if ("AXIS" === n)
                    return n in e || (e[n] = []), void e[n].push(t);
                var r;
                switch (Array.isArray(n) || (e[n] = {}), n) {
                case "UNIT":
                case "PRIMEM":
                case "VERT_DATUM":
                    return e[n] = {
                        name: t[0].toLowerCase(),
                        convert: t[1]
                    }, void (3 === t.length && Rp(t[2], e[n]));
                case "SPHEROID":
                case "ELLIPSOID":
                    return e[n] = {
                        name: t[0],
                        a: t[1],
                        rf: t[2]
                    }, void (4 === t.length && Rp(t[3], e[n]));
                case "PROJECTEDCRS":
                case "PROJCRS":
                case "GEOGCS":
                case "GEOCCS":
                case "PROJCS":
                case "LOCAL_CS":
                case "GEODCRS":
                case "GEODETICCRS":
                case "GEODETICDATUM":
                case "EDATUM":
                case "ENGINEERINGDATUM":
                case "VERT_CS":
                case "VERTCRS":
                case "VERTICALCRS":
                case "COMPD_CS":
                case "COMPOUNDCRS":
                case "ENGINEERINGCRS":
                case "ENGCRS":
                case "FITTED_CS":
                case "LOCAL_DATUM":
                case "DATUM":
                    return t[0] = ["name", t[0]], void Np(e, n, t);
                default:
                    for (r = -1; ++r < t.length;)
                        if (!Array.isArray(t[r]))
                            return Rp(t, e[n]);
                    return Np(e, n, t)
                }
            } else
                e[n] = t;
        else
            e[n] = !0
    } else
        e[t] = !0
}
Op.prototype.readCharicter = function() {
    var t = this.text[this.place++];
    if (4 !== this.state)
        for (; Sp.test(t);) {
            if (this.place >= this.text.length)
                return;
            t = this.text[this.place++]
        }
    switch (this.state) {
    case 1:
        return this.neutral(t);
    case 2:
        return this.keyword(t);
    case 4:
        return this.quoted(t);
    case 5:
        return this.afterquote(t);
    case 3:
        return this.number(t);
    case -1:
        return
    }
},
Op.prototype.afterquote = function(t) {
    if ('"' === t)
        return this.word += '"', void (this.state = 4);
    if (Pp.test(t))
        return this.word = this.word.trim(), void this.afterItem(t);
    throw new Error("havn't handled \"" + t + '" in afterquote yet, index ' + this.place)
},
Op.prototype.afterItem = function(t) {
    return "," === t ? (null !== this.word && this.currentObject.push(this.word), this.word = null, void (this.state = 1)) : "]" === t ? (this.level--, null !== this.word && (this.currentObject.push(this.word), this.word = null), this.state = 1, this.currentObject = this.stack.pop(), void (this.currentObject || (this.state = -1))) : void 0
},
Op.prototype.number = function(t) {
    if (!Lp.test(t)) {
        if (Pp.test(t))
            return this.word = parseFloat(this.word), void this.afterItem(t);
        throw new Error("havn't handled \"" + t + '" in number yet, index ' + this.place)
    }
    this.word += t
},
Op.prototype.quoted = function(t) {
    '"' !== t ? this.word += t : this.state = 5
},
Op.prototype.keyword = function(t) {
    if (Tp.test(t))
        this.word += t;
    else {
        if ("[" === t) {
            var e = [];
            return e.push(this.word), this.level++, null === this.root ? this.root = e : this.currentObject.push(e), this.stack.push(this.currentObject), this.currentObject = e, void (this.state = 1)
        }
        if (!Pp.test(t))
            throw new Error("havn't handled \"" + t + '" in keyword yet, index ' + this.place);
        this.afterItem(t)
    }
},
Op.prototype.neutral = function(t) {
    if (Ip.test(t))
        return this.word = t, void (this.state = 2);
    if ('"' === t)
        return this.word = "", void (this.state = 4);
    if (Lp.test(t))
        return this.word = t, void (this.state = 3);
    if (!Pp.test(t))
        throw new Error("havn't handled \"" + t + '" in neutral yet, index ' + this.place);
    this.afterItem(t)
},
Op.prototype.output = function() {
    for (; this.place < this.text.length;)
        this.readCharicter();
    if (-1 === this.state)
        return this.root;
    throw new Error('unable to parse string "' + this.text + '". State is ' + this.state)
};
var Ap;
function Dp(t) {
    return .017453292519943295 * t
}
function Fp(t) {
    var e = new Op(t).output(),
        n = e.shift(),
        r = e.shift();
    e.unshift(["name", r]),
    e.unshift(["type", n]);
    var i = {};
    return Rp(e, i), function(t) {
        if ("GEOGCS" === t.type ? t.projName = "longlat" : "LOCAL_CS" === t.type ? (t.projName = "identity", t.local = !0) : "object" == typeof t.PROJECTION ? t.projName = Object.keys(t.PROJECTION)[0] : t.projName = t.PROJECTION, t.AXIS) {
            for (var e = "", n = 0, r = t.AXIS.length; n < r; ++n) {
                var i = [t.AXIS[n][0].toLowerCase(), t.AXIS[n][1].toLowerCase()];
                -1 !== i[0].indexOf("north") || ("y" === i[0] || "lat" === i[0]) && "north" === i[1] ? e += "n" : -1 !== i[0].indexOf("south") || ("y" === i[0] || "lat" === i[0]) && "south" === i[1] ? e += "s" : -1 !== i[0].indexOf("east") || ("x" === i[0] || "lon" === i[0]) && "east" === i[1] ? e += "e" : -1 === i[0].indexOf("west") && ("x" !== i[0] && "lon" !== i[0] || "west" !== i[1]) || (e += "w")
            }
            2 === e.length && (e += "u"),
            3 === e.length && (t.axis = e)
        }
        t.UNIT && (t.units = t.UNIT.name.toLowerCase(), "metre" === t.units && (t.units = "meter"), t.UNIT.convert && ("GEOGCS" === t.type ? t.DATUM && t.DATUM.SPHEROID && (t.to_meter = t.UNIT.convert * t.DATUM.SPHEROID.a) : t.to_meter = t.UNIT.convert));
        var o = t.GEOGCS;
        function s(e) {
            return e * (t.to_meter || 1)
        }
        "GEOGCS" === t.type && (o = t),
        o && (o.DATUM ? t.datumCode = o.DATUM.name.toLowerCase() : t.datumCode = o.name.toLowerCase(), "d_" === t.datumCode.slice(0, 2) && (t.datumCode = t.datumCode.slice(2)), "new_zealand_geodetic_datum_1949" !== t.datumCode && "new_zealand_1949" !== t.datumCode || (t.datumCode = "nzgd49"), "wgs_1984" !== t.datumCode && "world_geodetic_system_1984" !== t.datumCode || ("Mercator_Auxiliary_Sphere" === t.PROJECTION && (t.sphere = !0), t.datumCode = "wgs84"), "_ferro" === t.datumCode.slice(-6) && (t.datumCode = t.datumCode.slice(0, -6)), "_jakarta" === t.datumCode.slice(-8) && (t.datumCode = t.datumCode.slice(0, -8)), ~t.datumCode.indexOf("belge") && (t.datumCode = "rnb72"), o.DATUM && o.DATUM.SPHEROID && (t.ellps = o.DATUM.SPHEROID.name.replace("_19", "").replace(/[Cc]larke\_18/, "clrk"), "international" === t.ellps.toLowerCase().slice(0, 13) && (t.ellps = "intl"), t.a = o.DATUM.SPHEROID.a, t.rf = parseFloat(o.DATUM.SPHEROID.rf, 10)), o.DATUM && o.DATUM.TOWGS84 && (t.datum_params = o.DATUM.TOWGS84), ~t.datumCode.indexOf("osgb_1936") && (t.datumCode = "osgb36"), ~t.datumCode.indexOf("osni_1952") && (t.datumCode = "osni52"), (~t.datumCode.indexOf("tm65") || ~t.datumCode.indexOf("geodetic_datum_of_1965")) && (t.datumCode = "ire65"), "ch1903+" === t.datumCode && (t.datumCode = "ch1903"), ~t.datumCode.indexOf("israel") && (t.datumCode = "isr93")),
        t.b && !isFinite(t.b) && (t.b = t.a),
        [["standard_parallel_1", "Standard_Parallel_1"], ["standard_parallel_1", "Latitude of 1st standard parallel"], ["standard_parallel_2", "Standard_Parallel_2"], ["standard_parallel_2", "Latitude of 2nd standard parallel"], ["false_easting", "False_Easting"], ["false_easting", "False easting"], ["false-easting", "Easting at false origin"], ["false_northing", "False_Northing"], ["false_northing", "False northing"], ["false_northing", "Northing at false origin"], ["central_meridian", "Central_Meridian"], ["central_meridian", "Longitude of natural origin"], ["central_meridian", "Longitude of false origin"], ["latitude_of_origin", "Latitude_Of_Origin"], ["latitude_of_origin", "Central_Parallel"], ["latitude_of_origin", "Latitude of natural origin"], ["latitude_of_origin", "Latitude of false origin"], ["scale_factor", "Scale_Factor"], ["k0", "scale_factor"], ["latitude_of_center", "Latitude_Of_Center"], ["latitude_of_center", "Latitude_of_center"], ["lat0", "latitude_of_center", Dp], ["longitude_of_center", "Longitude_Of_Center"], ["longitude_of_center", "Longitude_of_center"], ["longc", "longitude_of_center", Dp], ["x0", "false_easting", s], ["y0", "false_northing", s], ["long0", "central_meridian", Dp], ["lat0", "latitude_of_origin", Dp], ["lat0", "standard_parallel_1", Dp], ["lat1", "standard_parallel_1", Dp], ["lat2", "standard_parallel_2", Dp], ["azimuth", "Azimuth"], ["alpha", "azimuth", Dp], ["srsCode", "name"]].forEach((function(e) {
            return n = t, i = (r = e)[0], o = r[1], void (!(i in n) && o in n && (n[i] = n[o], 3 === r.length && (n[i] = r[2](n[i]))));
            var n,
                r,
                i,
                o
        })),
        t.long0 || !t.longc || "Albers_Conic_Equal_Area" !== t.projName && "Lambert_Azimuthal_Equal_Area" !== t.projName || (t.long0 = t.longc),
        t.lat_ts || !t.lat1 || "Stereographic_South_Pole" !== t.projName && "Polar Stereographic (variant B)" !== t.projName || (t.lat0 = Dp(t.lat1 > 0 ? 90 : -90), t.lat_ts = t.lat1)
    }(i), i
}
function kp(t) {
    var e = this;
    if (2 === arguments.length) {
        var n = arguments[1];
        "string" == typeof n ? "+" === n.charAt(0) ? kp[t] = Mp(arguments[1]) : kp[t] = Fp(arguments[1]) : kp[t] = n
    } else if (1 === arguments.length) {
        if (Array.isArray(t))
            return t.map((function(t) {
                Array.isArray(t) ? kp.apply(e, t) : kp(t)
            }));
        if ("string" == typeof t) {
            if (t in kp)
                return kp[t]
        } else
            "EPSG" in t ? kp["EPSG:" + t.EPSG] = t : "ESRI" in t ? kp["ESRI:" + t.ESRI] = t : "IAU2000" in t ? kp["IAU2000:" + t.IAU2000] = t : console.log(t);
        return
    }
}
(Ap = kp)("EPSG:4326", "+title=WGS 84 (long/lat) +proj=longlat +ellps=WGS84 +datum=WGS84 +units=degrees"),
Ap("EPSG:4269", "+title=NAD83 (long/lat) +proj=longlat +a=6378137.0 +b=6356752.31414036 +ellps=GRS80 +datum=NAD83 +units=degrees"),
Ap("EPSG:3857", "+title=WGS 84 / Pseudo-Mercator +proj=merc +a=6378137 +b=6378137 +lat_ts=0.0 +lon_0=0.0 +x_0=0.0 +y_0=0 +k=1.0 +units=m +nadgrids=@null +no_defs"),
Ap.WGS84 = Ap["EPSG:4326"],
Ap["EPSG:3785"] = Ap["EPSG:3857"],
Ap.GOOGLE = Ap["EPSG:3857"],
Ap["EPSG:900913"] = Ap["EPSG:3857"],
Ap["EPSG:102113"] = Ap["EPSG:3857"];
var jp = kp;
var Gp = ["PROJECTEDCRS", "PROJCRS", "GEOGCS", "GEOCCS", "PROJCS", "LOCAL_CS", "GEODCRS", "GEODETICCRS", "GEODETICDATUM", "ENGCRS", "ENGINEERINGCRS"];
var Bp = ["3857", "900913", "3785", "102113"];
var qp = function(t) {
    if (!function(t) {
        return "string" == typeof t
    }(t))
        return t;
    if (function(t) {
        return t in jp
    }(t))
        return jp[t];
    if (function(t) {
        return Gp.some((function(e) {
            return t.indexOf(e) > -1
        }))
    }(t)) {
        var e = Fp(t);
        if (function(t) {
            var e = Cp(t, "authority");
            if (e) {
                var n = Cp(e, "epsg");
                return n && Bp.indexOf(n) > -1
            }
        }(e))
            return jp["EPSG:3857"];
        var n = function(t) {
            var e = Cp(t, "extension");
            if (e)
                return Cp(e, "proj4")
        }(e);
        return n ? Mp(n) : e
    }
    return function(t) {
        return "+" === t[0]
    }(t) ? Mp(t) : void 0
};
function zp(t, e) {
    var n,
        r;
    if (t = t || {}, !e)
        return t;
    for (r in e)
        void 0 !== (n = e[r]) && (t[r] = n);
    return t
}
function Up(t, e, n) {
    var r = t * e;
    return n / Math.sqrt(1 - r * r)
}
function Vp(t) {
    return t < 0 ? -1 : 1
}
function Xp(t) {
    return Math.abs(t) <= 3.14159265359 ? t : t - Vp(t) * xp
}
function Hp(t, e, n) {
    var r = t * n,
        i = .5 * t;
    return r = Math.pow((1 - r) / (1 + r), i), Math.tan(.5 * (mp - e)) / r
}
function Yp(t, e) {
    for (var n, r, i = .5 * t, o = mp - 2 * Math.atan(e), s = 0; s <= 15; s++)
        if (n = t * Math.sin(o), o += r = mp - 2 * Math.atan(e * Math.pow((1 - n) / (1 + n), i)) - o, Math.abs(r) <= 1e-10)
            return o;
    return -9999
}
function Wp(t) {
    return t
}
var $p = [{
        init: function() {
            var t = this.b / this.a;
            this.es = 1 - t * t,
            "x0" in this || (this.x0 = 0),
            "y0" in this || (this.y0 = 0),
            this.e = Math.sqrt(this.es),
            this.lat_ts ? this.sphere ? this.k0 = Math.cos(this.lat_ts) : this.k0 = Up(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts)) : this.k0 || (this.k ? this.k0 = this.k : this.k0 = 1)
        },
        forward: function(t) {
            var e,
                n,
                r = t.x,
                i = t.y;
            if (57.29577951308232 * i > 90 && 57.29577951308232 * i < -90 && 57.29577951308232 * r > 180 && 57.29577951308232 * r < -180)
                return null;
            if (Math.abs(Math.abs(i) - mp) <= 1e-10)
                return null;
            if (this.sphere)
                e = this.x0 + this.a * this.k0 * Xp(r - this.long0),
                n = this.y0 + this.a * this.k0 * Math.log(Math.tan(_p + .5 * i));
            else {
                var o = Math.sin(i),
                    s = Hp(this.e, i, o);
                e = this.x0 + this.a * this.k0 * Xp(r - this.long0),
                n = this.y0 - this.a * this.k0 * Math.log(s)
            }
            return t.x = e, t.y = n, t
        },
        inverse: function(t) {
            var e,
                n,
                r = t.x - this.x0,
                i = t.y - this.y0;
            if (this.sphere)
                n = mp - 2 * Math.atan(Math.exp(-i / (this.a * this.k0)));
            else {
                var o = Math.exp(-i / (this.a * this.k0));
                if (-9999 === (n = Yp(this.e, o)))
                    return null
            }
            return e = Xp(this.long0 + r / (this.a * this.k0)), t.x = e, t.y = n, t
        },
        names: ["Mercator", "Popular Visualisation Pseudo Mercator", "Mercator_1SP", "Mercator_Auxiliary_Sphere", "merc"]
    }, {
        init: function() {},
        forward: Wp,
        inverse: Wp,
        names: ["longlat", "identity"]
    }],
    Kp = {},
    Zp = [];
function Jp(t, e) {
    var n = Zp.length;
    return t.names ? (Zp[n] = t, t.names.forEach((function(t) {
        Kp[t.toLowerCase()] = n
    })), this) : (console.log(e), !0)
}
var Qp = {
        start: function() {
            $p.forEach(Jp)
        },
        add: Jp,
        get: function(t) {
            if (!t)
                return !1;
            var e = t.toLowerCase();
            return void 0 !== Kp[e] && Zp[Kp[e]] ? Zp[Kp[e]] : void 0
        }
    },
    tf = {
        MERIT: {
            a: 6378137,
            rf: 298.257,
            ellipseName: "MERIT 1983"
        },
        SGS85: {
            a: 6378136,
            rf: 298.257,
            ellipseName: "Soviet Geodetic System 85"
        },
        GRS80: {
            a: 6378137,
            rf: 298.257222101,
            ellipseName: "GRS 1980(IUGG, 1980)"
        },
        IAU76: {
            a: 6378140,
            rf: 298.257,
            ellipseName: "IAU 1976"
        },
        airy: {
            a: 6377563.396,
            b: 6356256.91,
            ellipseName: "Airy 1830"
        },
        APL4: {
            a: 6378137,
            rf: 298.25,
            ellipseName: "Appl. Physics. 1965"
        },
        NWL9D: {
            a: 6378145,
            rf: 298.25,
            ellipseName: "Naval Weapons Lab., 1965"
        },
        mod_airy: {
            a: 6377340.189,
            b: 6356034.446,
            ellipseName: "Modified Airy"
        },
        andrae: {
            a: 6377104.43,
            rf: 300,
            ellipseName: "Andrae 1876 (Den., Iclnd.)"
        },
        aust_SA: {
            a: 6378160,
            rf: 298.25,
            ellipseName: "Australian Natl & S. Amer. 1969"
        },
        GRS67: {
            a: 6378160,
            rf: 298.247167427,
            ellipseName: "GRS 67(IUGG 1967)"
        },
        bessel: {
            a: 6377397.155,
            rf: 299.1528128,
            ellipseName: "Bessel 1841"
        },
        bess_nam: {
            a: 6377483.865,
            rf: 299.1528128,
            ellipseName: "Bessel 1841 (Namibia)"
        },
        clrk66: {
            a: 6378206.4,
            b: 6356583.8,
            ellipseName: "Clarke 1866"
        },
        clrk80: {
            a: 6378249.145,
            rf: 293.4663,
            ellipseName: "Clarke 1880 mod."
        },
        clrk58: {
            a: 6378293.645208759,
            rf: 294.2606763692654,
            ellipseName: "Clarke 1858"
        },
        CPM: {
            a: 6375738.7,
            rf: 334.29,
            ellipseName: "Comm. des Poids et Mesures 1799"
        },
        delmbr: {
            a: 6376428,
            rf: 311.5,
            ellipseName: "Delambre 1810 (Belgium)"
        },
        engelis: {
            a: 6378136.05,
            rf: 298.2566,
            ellipseName: "Engelis 1985"
        },
        evrst30: {
            a: 6377276.345,
            rf: 300.8017,
            ellipseName: "Everest 1830"
        },
        evrst48: {
            a: 6377304.063,
            rf: 300.8017,
            ellipseName: "Everest 1948"
        },
        evrst56: {
            a: 6377301.243,
            rf: 300.8017,
            ellipseName: "Everest 1956"
        },
        evrst69: {
            a: 6377295.664,
            rf: 300.8017,
            ellipseName: "Everest 1969"
        },
        evrstSS: {
            a: 6377298.556,
            rf: 300.8017,
            ellipseName: "Everest (Sabah & Sarawak)"
        },
        fschr60: {
            a: 6378166,
            rf: 298.3,
            ellipseName: "Fischer (Mercury Datum) 1960"
        },
        fschr60m: {
            a: 6378155,
            rf: 298.3,
            ellipseName: "Fischer 1960"
        },
        fschr68: {
            a: 6378150,
            rf: 298.3,
            ellipseName: "Fischer 1968"
        },
        helmert: {
            a: 6378200,
            rf: 298.3,
            ellipseName: "Helmert 1906"
        },
        hough: {
            a: 6378270,
            rf: 297,
            ellipseName: "Hough"
        },
        intl: {
            a: 6378388,
            rf: 297,
            ellipseName: "International 1909 (Hayford)"
        },
        kaula: {
            a: 6378163,
            rf: 298.24,
            ellipseName: "Kaula 1961"
        },
        lerch: {
            a: 6378139,
            rf: 298.257,
            ellipseName: "Lerch 1979"
        },
        mprts: {
            a: 6397300,
            rf: 191,
            ellipseName: "Maupertius 1738"
        },
        new_intl: {
            a: 6378157.5,
            b: 6356772.2,
            ellipseName: "New International 1967"
        },
        plessis: {
            a: 6376523,
            rf: 6355863,
            ellipseName: "Plessis 1817 (France)"
        },
        krass: {
            a: 6378245,
            rf: 298.3,
            ellipseName: "Krassovsky, 1942"
        },
        SEasia: {
            a: 6378155,
            b: 6356773.3205,
            ellipseName: "Southeast Asia"
        },
        walbeck: {
            a: 6376896,
            b: 6355834.8467,
            ellipseName: "Walbeck"
        },
        WGS60: {
            a: 6378165,
            rf: 298.3,
            ellipseName: "WGS 60"
        },
        WGS66: {
            a: 6378145,
            rf: 298.25,
            ellipseName: "WGS 66"
        },
        WGS7: {
            a: 6378135,
            rf: 298.26,
            ellipseName: "WGS 72"
        }
    },
    ef = tf.WGS84 = {
        a: 6378137,
        rf: 298.257223563,
        ellipseName: "WGS 84"
    };
function nf(t, e, n, r) {
    var i = t * t,
        o = e * e,
        s = (i - o) / i,
        a = 0;
    return r ? (i = (t *= 1 - s * (.16666666666666666 + s * (.04722222222222222 + .022156084656084655 * s))) * t, s = 0) : a = Math.sqrt(s), {
        es: s,
        e: a,
        ep2: (i - o) / o
    }
}
function rf(t, e, n, r, i) {
    if (!t) {
        var o = Cp(tf, r);
        o || (o = ef),
        t = o.a,
        e = o.b,
        n = o.rf
    }
    return n && !e && (e = (1 - 1 / n) * t), (0 === n || Math.abs(t - e) < 1e-10) && (i = !0, e = t), {
        a: t,
        b: e,
        rf: n,
        sphere: i
    }
}
tf.sphere = {
    a: 6370997,
    b: 6370997,
    ellipseName: "Normal Sphere (r=6370997)"
};
var of = {};
of.wgs84 = {
    towgs84: "0,0,0",
    ellipse: "WGS84",
    datumName: "WGS84"
},
of.ch1903 = {
    towgs84: "674.374,15.056,405.346",
    ellipse: "bessel",
    datumName: "swiss"
},
of.ggrs87 = {
    towgs84: "-199.87,74.79,246.62",
    ellipse: "GRS80",
    datumName: "Greek_Geodetic_Reference_System_1987"
},
of.nad83 = {
    towgs84: "0,0,0",
    ellipse: "GRS80",
    datumName: "North_American_Datum_1983"
},
of.nad27 = {
    nadgrids: "@conus,@alaska,@ntv2_0.gsb,@ntv1_can.dat",
    ellipse: "clrk66",
    datumName: "North_American_Datum_1927"
},
of.potsdam = {
    towgs84: "598.1,73.7,418.2,0.202,0.045,-2.455,6.7",
    ellipse: "bessel",
    datumName: "Potsdam Rauenberg 1950 DHDN"
},
of.carthage = {
    towgs84: "-263.0,6.0,431.0",
    ellipse: "clark80",
    datumName: "Carthage 1934 Tunisia"
},
of.hermannskogel = {
    towgs84: "577.326,90.129,463.919,5.137,1.474,5.297,2.4232",
    ellipse: "bessel",
    datumName: "Hermannskogel"
},
of.osni52 = {
    towgs84: "482.530,-130.596,564.557,-1.042,-0.214,-0.631,8.15",
    ellipse: "airy",
    datumName: "Irish National"
},
of.ire65 = {
    towgs84: "482.530,-130.596,564.557,-1.042,-0.214,-0.631,8.15",
    ellipse: "mod_airy",
    datumName: "Ireland 1965"
},
of.rassadiran = {
    towgs84: "-133.63,-157.5,-158.62",
    ellipse: "intl",
    datumName: "Rassadiran"
},
of.nzgd49 = {
    towgs84: "59.47,-5.04,187.44,0.47,-0.1,1.024,-4.5993",
    ellipse: "intl",
    datumName: "New Zealand Geodetic Datum 1949"
},
of.osgb36 = {
    towgs84: "446.448,-125.157,542.060,0.1502,0.2470,0.8421,-20.4894",
    ellipse: "airy",
    datumName: "Airy 1830"
},
of.s_jtsk = {
    towgs84: "589,76,480",
    ellipse: "bessel",
    datumName: "S-JTSK (Ferro)"
},
of.beduaram = {
    towgs84: "-106,-87,188",
    ellipse: "clrk80",
    datumName: "Beduaram"
},
of.gunung_segara = {
    towgs84: "-403,684,41",
    ellipse: "bessel",
    datumName: "Gunung Segara Jakarta"
},
of.rnb72 = {
    towgs84: "106.869,-52.2978,103.724,-0.33657,0.456955,-1.84218,1",
    ellipse: "intl",
    datumName: "Reseau National Belge 1972"
};
var sf = function(t, e, n, r, i, o, s) {
        var a = {};
        return a.datum_type = void 0 === t || "none" === t ? 5 : 4, e && (a.datum_params = e.map(parseFloat), 0 === a.datum_params[0] && 0 === a.datum_params[1] && 0 === a.datum_params[2] || (a.datum_type = 1), a.datum_params.length > 3 && (0 === a.datum_params[3] && 0 === a.datum_params[4] && 0 === a.datum_params[5] && 0 === a.datum_params[6] || (a.datum_type = 2, a.datum_params[3] *= 484813681109536e-20, a.datum_params[4] *= 484813681109536e-20, a.datum_params[5] *= 484813681109536e-20, a.datum_params[6] = a.datum_params[6] / 1e6 + 1))), s && (a.datum_type = 3, a.grids = s), a.a = n, a.b = r, a.es = i, a.ep2 = o, a
    },
    af = {};
function uf(t) {
    return void 0 === t ? null : t.split(",").map(lf)
}
function lf(t) {
    if (0 === t.length)
        return null;
    var e = "@" === t[0];
    return e && (t = t.slice(1)), "null" === t ? {
        name: "null",
        mandatory: !e,
        grid: null,
        isNull: !0
    } : {
        name: t,
        mandatory: !e,
        grid: af[t] || null,
        isNull: !1
    }
}
function hf(t) {
    return t / 3600 * Math.PI / 180
}
function cf(t, e, n) {
    return String.fromCharCode.apply(null, new Uint8Array(t.buffer.slice(e, n)))
}
function pf(t) {
    return t.map((function(t) {
        return [hf(t.longitudeShift), hf(t.latitudeShift)]
    }))
}
function ff(t, e, n) {
    return {
        name: cf(t, e + 8, e + 16).trim(),
        parent: cf(t, e + 24, e + 24 + 8).trim(),
        lowerLatitude: t.getFloat64(e + 72, n),
        upperLatitude: t.getFloat64(e + 88, n),
        lowerLongitude: t.getFloat64(e + 104, n),
        upperLongitude: t.getFloat64(e + 120, n),
        latitudeInterval: t.getFloat64(e + 136, n),
        longitudeInterval: t.getFloat64(e + 152, n),
        gridNodeCount: t.getInt32(e + 168, n)
    }
}
function df(t, e, n, r) {
    for (var i = e + 176, o = [], s = 0; s < n.gridNodeCount; s++) {
        var a = {
            latitudeShift: t.getFloat32(i + 16 * s, r),
            longitudeShift: t.getFloat32(i + 16 * s + 4, r),
            latitudeAccuracy: t.getFloat32(i + 16 * s + 8, r),
            longitudeAccuracy: t.getFloat32(i + 16 * s + 12, r)
        };
        o.push(a)
    }
    return o
}
function gf(t, e) {
    if (!(this instanceof gf))
        return new gf(t);
    e = e || function(t) {
        if (t)
            throw t
    };
    var n = qp(t);
    if ("object" == typeof n) {
        var r = gf.projections.get(n.projName);
        if (r) {
            if (n.datumCode && "none" !== n.datumCode) {
                var i = Cp(of, n.datumCode);
                i && (n.datum_params = n.datum_params || (i.towgs84 ? i.towgs84.split(",") : null), n.ellps = i.ellipse, n.datumName = i.datumName ? i.datumName : n.datumCode)
            }
            n.k0 = n.k0 || 1,
            n.axis = n.axis || "enu",
            n.ellps = n.ellps || "wgs84",
            n.lat1 = n.lat1 || n.lat0;
            var o = rf(n.a, n.b, n.rf, n.ellps, n.sphere),
                s = nf(o.a, o.b, o.rf, n.R_A),
                a = uf(n.nadgrids),
                u = n.datum || sf(n.datumCode, n.datum_params, o.a, o.b, s.es, s.ep2, a);
            zp(this, n),
            zp(this, r),
            this.a = o.a,
            this.b = o.b,
            this.rf = o.rf,
            this.sphere = o.sphere,
            this.es = s.es,
            this.e = s.e,
            this.ep2 = s.ep2,
            this.datum = u,
            this.init(),
            e(null, this)
        } else
            e(t)
    } else
        e(t)
}
gf.projections = Qp,
gf.projections.start();
var yf = gf;
function vf(t, e) {
    return t.datum_type === e.datum_type && (!(t.a !== e.a || Math.abs(t.es - e.es) > 5e-11) && (1 === t.datum_type ? t.datum_params[0] === e.datum_params[0] && t.datum_params[1] === e.datum_params[1] && t.datum_params[2] === e.datum_params[2] : 2 !== t.datum_type || t.datum_params[0] === e.datum_params[0] && t.datum_params[1] === e.datum_params[1] && t.datum_params[2] === e.datum_params[2] && t.datum_params[3] === e.datum_params[3] && t.datum_params[4] === e.datum_params[4] && t.datum_params[5] === e.datum_params[5] && t.datum_params[6] === e.datum_params[6]))
}
function mf(t, e, n) {
    var r,
        i,
        o,
        s,
        a = t.x,
        u = t.y,
        l = t.z ? t.z : 0;
    if (u < -mp && u > -1.001 * mp)
        u = -mp;
    else if (u > mp && u < 1.001 * mp)
        u = mp;
    else {
        if (u < -mp)
            return {
                x: -1 / 0,
                y: -1 / 0,
                z: t.z
            };
        if (u > mp)
            return {
                x: 1 / 0,
                y: 1 / 0,
                z: t.z
            }
    }
    return a > Math.PI && (a -= 2 * Math.PI), i = Math.sin(u), s = Math.cos(u), o = i * i, {
        x: ((r = n / Math.sqrt(1 - e * o)) + l) * s * Math.cos(a),
        y: (r + l) * s * Math.sin(a),
        z: (r * (1 - e) + l) * i
    }
}
function _f(t, e, n, r) {
    var i,
        o,
        s,
        a,
        u,
        l,
        h,
        c,
        p,
        f,
        d,
        g,
        y,
        v,
        m,
        _ = 1e-12,
        x = t.x,
        E = t.y,
        w = t.z ? t.z : 0;
    if (i = Math.sqrt(x * x + E * E), o = Math.sqrt(x * x + E * E + w * w), i / n < _) {
        if (v = 0, o / n < _)
            return mp, m = -r, {
                x: t.x,
                y: t.y,
                z: t.z
            }
    } else
        v = Math.atan2(E, x);
    s = w / o,
    c = (a = i / o) * (1 - e) * (u = 1 / Math.sqrt(1 - e * (2 - e) * a * a)),
    p = s * u,
    y = 0;
    do {
        y++,
        l = e * (h = n / Math.sqrt(1 - e * p * p)) / (h + (m = i * c + w * p - h * (1 - e * p * p))),
        g = (d = s * (u = 1 / Math.sqrt(1 - l * (2 - l) * a * a))) * c - (f = a * (1 - l) * u) * p,
        c = f,
        p = d
    } while (g * g > 1e-24 && y < 30);
    return {
        x: v,
        y: Math.atan(d / Math.abs(f)),
        z: m
    }
}
function xf(t, e, n) {
    if (1 === e)
        return {
            x: t.x + n[0],
            y: t.y + n[1],
            z: t.z + n[2]
        };
    if (2 === e) {
        var r = n[0],
            i = n[1],
            o = n[2],
            s = n[3],
            a = n[4],
            u = n[5],
            l = n[6];
        return {
            x: l * (t.x - u * t.y + a * t.z) + r,
            y: l * (u * t.x + t.y - s * t.z) + i,
            z: l * (-a * t.x + s * t.y + t.z) + o
        }
    }
}
function Ef(t, e, n) {
    if (1 === e)
        return {
            x: t.x - n[0],
            y: t.y - n[1],
            z: t.z - n[2]
        };
    if (2 === e) {
        var r = n[0],
            i = n[1],
            o = n[2],
            s = n[3],
            a = n[4],
            u = n[5],
            l = n[6],
            h = (t.x - r) / l,
            c = (t.y - i) / l,
            p = (t.z - o) / l;
        return {
            x: h + u * c - a * p,
            y: -u * h + c + s * p,
            z: a * h - s * c + p
        }
    }
}
function wf(t) {
    return 1 === t || 2 === t
}
function bf(t, e, n) {
    if (vf(t, e))
        return n;
    if (5 === t.datum_type || 5 === e.datum_type)
        return n;
    var r = t.a,
        i = t.es;
    if (3 === t.datum_type) {
        if (0 !== Cf(t, !1, n))
            return;
        r = 6378137,
        i = .0066943799901413165
    }
    var o = e.a,
        s = e.b,
        a = e.es;
    if (3 === e.datum_type && (o = 6378137, s = 6356752.314, a = .0066943799901413165), i === a && r === o && !wf(t.datum_type) && !wf(e.datum_type))
        return n;
    if ((n = mf(n, i, r), wf(t.datum_type) && (n = xf(n, t.datum_type, t.datum_params)), wf(e.datum_type) && (n = Ef(n, e.datum_type, e.datum_params)), n = _f(n, a, o, s), 3 === e.datum_type) && 0 !== Cf(e, !0, n))
        return;
    return n
}
function Cf(t, e, n) {
    if (null === t.grids || 0 === t.grids.length)
        return console.log("Grid shift grids not found"), -1;
    for (var r = {
            x: -n.x,
            y: n.y
        }, i = {
            x: Number.NaN,
            y: Number.NaN
        }, o = [], s = 0; s < t.grids.length; s++) {
        var a = t.grids[s];
        if (o.push(a.name), a.isNull) {
            i = r;
            break
        }
        if (a.mandatory, null !== a.grid) {
            var u = a.grid.subgrids[0],
                l = (Math.abs(u.del[1]) + Math.abs(u.del[0])) / 1e4,
                h = u.ll[0] - l,
                c = u.ll[1] - l,
                p = u.ll[0] + (u.lim[0] - 1) * u.del[0] + l,
                f = u.ll[1] + (u.lim[1] - 1) * u.del[1] + l;
            if (!(c > r.y || h > r.x || f < r.y || p < r.x || (i = Mf(r, e, u), isNaN(i.x))))
                break
        } else if (a.mandatory)
            return console.log("Unable to find mandatory grid '" + a.name + "'"), -1
    }
    return isNaN(i.x) ? (console.log("Failed to find a grid shift table for location '" + 57.29577951308232 * -r.x + " " + 57.29577951308232 * r.y + " tried: '" + o + "'"), -1) : (n.x = -i.x, n.y = i.y, 0)
}
function Mf(t, e, n) {
    var r = {
        x: Number.NaN,
        y: Number.NaN
    };
    if (isNaN(t.x))
        return r;
    var i = {
        x: t.x,
        y: t.y
    };
    i.x -= n.ll[0],
    i.y -= n.ll[1],
    i.x = Xp(i.x - Math.PI) + Math.PI;
    var o = Sf(i, n);
    if (e) {
        if (isNaN(o.x))
            return r;
        o.x = i.x - o.x,
        o.y = i.y - o.y;
        var s,
            a,
            u = 9;
        do {
            if (a = Sf(o, n), isNaN(a.x)) {
                console.log("Inverse grid shift iteration failed, presumably at grid edge.  Using first approximation.");
                break
            }
            s = {
                x: i.x - (a.x + o.x),
                y: i.y - (a.y + o.y)
            },
            o.x += s.x,
            o.y += s.y
        } while (u-- && Math.abs(s.x) > 1e-12 && Math.abs(s.y) > 1e-12);
        if (u < 0)
            return console.log("Inverse grid shift iterator failed to converge."), r;
        r.x = Xp(o.x + n.ll[0]),
        r.y = o.y + n.ll[1]
    } else
        isNaN(o.x) || (r.x = t.x + o.x, r.y = t.y + o.y);
    return r
}
function Sf(t, e) {
    var n,
        r = {
            x: t.x / e.del[0],
            y: t.y / e.del[1]
        },
        i = Math.floor(r.x),
        o = Math.floor(r.y),
        s = r.x - 1 * i,
        a = r.y - 1 * o,
        u = {
            x: Number.NaN,
            y: Number.NaN
        };
    if (i < 0 || i >= e.lim[0])
        return u;
    if (o < 0 || o >= e.lim[1])
        return u;
    n = o * e.lim[0] + i;
    var l = e.cvs[n][0],
        h = e.cvs[n][1];
    n++;
    var c = e.cvs[n][0],
        p = e.cvs[n][1];
    n += e.lim[0];
    var f = e.cvs[n][0],
        d = e.cvs[n][1];
    n--;
    var g = e.cvs[n][0],
        y = e.cvs[n][1],
        v = s * a,
        m = s * (1 - a),
        _ = (1 - s) * (1 - a),
        x = (1 - s) * a;
    return u.x = _ * l + m * c + x * g + v * f, u.y = _ * h + m * p + x * y + v * d, u
}
function If(t, e, n) {
    var r,
        i,
        o,
        s = n.x,
        a = n.y,
        u = n.z || 0,
        l = {};
    for (o = 0; o < 3; o++)
        if (!e || 2 !== o || void 0 !== n.z)
            switch (0 === o ? (r = s, i = -1 !== "ew".indexOf(t.axis[o]) ? "x" : "y") : 1 === o ? (r = a, i = -1 !== "ns".indexOf(t.axis[o]) ? "y" : "x") : (r = u, i = "z"), t.axis[o]) {
            case "e":
            case "n":
                l[i] = r;
                break;
            case "w":
            case "s":
                l[i] = -r;
                break;
            case "u":
                void 0 !== n[i] && (l.z = r);
                break;
            case "d":
                void 0 !== n[i] && (l.z = -r);
                break;
            default:
                return null
            }
    return l
}
function Tf(t) {
    var e = {
        x: t[0],
        y: t[1]
    };
    return t.length > 2 && (e.z = t[2]), t.length > 3 && (e.m = t[3]), e
}
function Pf(t) {
    Lf(t.x),
    Lf(t.y)
}
function Lf(t) {
    if ("function" == typeof Number.isFinite) {
        if (Number.isFinite(t))
            return;
        throw new TypeError("coordinates must be finite numbers")
    }
    if ("number" != typeof t || t != t || !isFinite(t))
        throw new TypeError("coordinates must be finite numbers")
}
function Of(t, e, n, r) {
    var i;
    if (Array.isArray(n) && (n = Tf(n)), Pf(n), t.datum && e.datum && function(t, e) {
        return (1 === t.datum.datum_type || 2 === t.datum.datum_type) && "WGS84" !== e.datumCode || (1 === e.datum.datum_type || 2 === e.datum.datum_type) && "WGS84" !== t.datumCode
    }(t, e) && (n = Of(t, i = new yf("WGS84"), n, r), t = i), r && "enu" !== t.axis && (n = If(t, !1, n)), "longlat" === t.projName)
        n = {
            x: .017453292519943295 * n.x,
            y: .017453292519943295 * n.y,
            z: n.z || 0
        };
    else if (t.to_meter && (n = {
        x: n.x * t.to_meter,
        y: n.y * t.to_meter,
        z: n.z || 0
    }), !(n = t.inverse(n)))
        return;
    if (t.from_greenwich && (n.x += t.from_greenwich), n = bf(t.datum, e.datum, n))
        return e.from_greenwich && (n = {
            x: n.x - e.from_greenwich,
            y: n.y,
            z: n.z || 0
        }), "longlat" === e.projName ? n = {
            x: 57.29577951308232 * n.x,
            y: 57.29577951308232 * n.y,
            z: n.z || 0
        } : (n = e.forward(n), e.to_meter && (n = {
            x: n.x / e.to_meter,
            y: n.y / e.to_meter,
            z: n.z || 0
        })), r && "enu" !== e.axis ? If(e, !0, n) : n
}
var Nf = yf("WGS84");
function Rf(t, e, n, r) {
    var i,
        o,
        s;
    return Array.isArray(n) ? (i = Of(t, e, n, r) || {
        x: NaN,
        y: NaN
    }, n.length > 2 ? void 0 !== t.name && "geocent" === t.name || void 0 !== e.name && "geocent" === e.name ? "number" == typeof i.z ? [i.x, i.y, i.z].concat(n.splice(3)) : [i.x, i.y, n[2]].concat(n.splice(3)) : [i.x, i.y].concat(n.splice(2)) : [i.x, i.y]) : (o = Of(t, e, n, r), 2 === (s = Object.keys(n)).length || s.forEach((function(r) {
        if (void 0 !== t.name && "geocent" === t.name || void 0 !== e.name && "geocent" === e.name) {
            if ("x" === r || "y" === r || "z" === r)
                return
        } else if ("x" === r || "y" === r)
            return;
        o[r] = n[r]
    })), o)
}
function Af(t) {
    return t instanceof yf ? t : t.oProj ? t.oProj : yf(t)
}
var Df = function(t, e, n) {
        t = Af(t);
        var r,
            i = !1;
        return void 0 === e ? (e = t, t = Nf, i = !0) : (void 0 !== e.x || Array.isArray(e)) && (n = e, e = t, t = Nf, i = !0), e = Af(e), n ? Rf(t, e, n) : (r = {
            forward: function(n, r) {
                return Rf(t, e, n, r)
            },
            inverse: function(n, r) {
                return Rf(e, t, n, r)
            }
        }, i && (r.oProj = e), r)
    },
    Ff = {
        forward: kf,
        inverse: function(t) {
            var e = qf(Vf(t.toUpperCase()));
            return e.lat && e.lon ? [e.lon, e.lat, e.lon, e.lat] : [e.left, e.bottom, e.right, e.top]
        },
        toPoint: jf
    };
function kf(t, e) {
    return e = e || 5, function(t, e) {
        var n = "00000" + t.easting,
            r = "00000" + t.northing;
        return t.zoneNumber + t.zoneLetter + (f = t.easting, d = t.northing, g = t.zoneNumber, y = Uf(g), v = Math.floor(f / 1e5), m = Math.floor(d / 1e5) % 20, i = v, o = m, s = y, a = s - 1, u = "AJSAJS".charCodeAt(a), l = "AFAFAF".charCodeAt(a), h = u + i - 1, c = l + o, p = !1, h > 90 && (h = h - 90 + 65 - 1, p = !0), (73 === h || u < 73 && h > 73 || (h > 73 || u < 73) && p) && h++, (79 === h || u < 79 && h > 79 || (h > 79 || u < 79) && p) && 73 == ++h && h++, h > 90 && (h = h - 90 + 65 - 1), c > 86 ? (c = c - 86 + 65 - 1, p = !0) : p = !1, (73 === c || l < 73 && c > 73 || (c > 73 || l < 73) && p) && c++, (79 === c || l < 79 && c > 79 || (c > 79 || l < 79) && p) && 73 == ++c && c++, c > 86 && (c = c - 86 + 65 - 1), String.fromCharCode(h) + String.fromCharCode(c)) + n.substr(n.length - 5, e) + r.substr(r.length - 5, e);
        var i,
            o,
            s,
            a,
            u,
            l,
            h,
            c,
            p;
        var f,
            d,
            g,
            y,
            v,
            m
    }(function(t) {
        var e,
            n,
            r,
            i,
            o,
            s,
            a,
            u,
            l = t.lat,
            h = t.lon,
            c = 6378137,
            p = .00669438,
            f = .9996,
            d = Gf(l),
            g = Gf(h);
        u = Math.floor((h + 180) / 6) + 1,
        180 === h && (u = 60);
        l >= 56 && l < 64 && h >= 3 && h < 12 && (u = 32);
        l >= 72 && l < 84 && (h >= 0 && h < 9 ? u = 31 : h >= 9 && h < 21 ? u = 33 : h >= 21 && h < 33 ? u = 35 : h >= 33 && h < 42 && (u = 37));
        a = Gf(6 * (u - 1) - 180 + 3),
        e = p / (1 - p),
        n = c / Math.sqrt(1 - p * Math.sin(d) * Math.sin(d)),
        r = Math.tan(d) * Math.tan(d),
        i = e * Math.cos(d) * Math.cos(d),
        o = Math.cos(d) * (g - a),
        s = c * ((1 - p / 4 - 3 * p * p / 64 - 5 * p * p * p / 256) * d - (3 * p / 8 + 3 * p * p / 32 + 45 * p * p * p / 1024) * Math.sin(2 * d) + (15 * p * p / 256 + 45 * p * p * p / 1024) * Math.sin(4 * d) - 35 * p * p * p / 3072 * Math.sin(6 * d));
        var y = f * n * (o + (1 - r + i) * o * o * o / 6 + (5 - 18 * r + r * r + 72 * i - 58 * e) * o * o * o * o * o / 120) + 5e5,
            v = f * (s + n * Math.tan(d) * (o * o / 2 + (5 - r + 9 * i + 4 * i * i) * o * o * o * o / 24 + (61 - 58 * r + r * r + 600 * i - 330 * e) * o * o * o * o * o * o / 720));
        l < 0 && (v += 1e7);
        return {
            northing: Math.round(v),
            easting: Math.round(y),
            zoneNumber: u,
            zoneLetter: zf(l)
        }
    }({
        lat: t[1],
        lon: t[0]
    }), e)
}
function jf(t) {
    var e = qf(Vf(t.toUpperCase()));
    return e.lat && e.lon ? [e.lon, e.lat] : [(e.left + e.right) / 2, (e.top + e.bottom) / 2]
}
function Gf(t) {
    return t * (Math.PI / 180)
}
function Bf(t) {
    return t / Math.PI * 180
}
function qf(t) {
    var e = t.northing,
        n = t.easting,
        r = t.zoneLetter,
        i = t.zoneNumber;
    if (i < 0 || i > 60)
        return null;
    var o,
        s,
        a,
        u,
        l,
        h,
        c,
        p,
        f,
        d = .9996,
        g = 6378137,
        y = .00669438,
        v = (1 - Math.sqrt(.99330562)) / (1 + Math.sqrt(.99330562)),
        m = n - 5e5,
        _ = e;
    r < "N" && (_ -= 1e7),
    c = 6 * (i - 1) - 180 + 3,
    o = .006739496752268451,
    f = (p = _ / d / 6367449.145945056) + (3 * v / 2 - 27 * v * v * v / 32) * Math.sin(2 * p) + (21 * v * v / 16 - 55 * v * v * v * v / 32) * Math.sin(4 * p) + 151 * v * v * v / 96 * Math.sin(6 * p),
    s = g / Math.sqrt(1 - y * Math.sin(f) * Math.sin(f)),
    a = Math.tan(f) * Math.tan(f),
    u = o * Math.cos(f) * Math.cos(f),
    l = .99330562 * g / Math.pow(1 - y * Math.sin(f) * Math.sin(f), 1.5),
    h = m / (s * d);
    var x = f - s * Math.tan(f) / l * (h * h / 2 - (5 + 3 * a + 10 * u - 4 * u * u - 9 * o) * h * h * h * h / 24 + (61 + 90 * a + 298 * u + 45 * a * a - 1.6983531815716497 - 3 * u * u) * h * h * h * h * h * h / 720);
    x = Bf(x);
    var E,
        w = (h - (1 + 2 * a + u) * h * h * h / 6 + (5 - 2 * u + 28 * a - 3 * u * u + 8 * o + 24 * a * a) * h * h * h * h * h / 120) / Math.cos(f);
    if (w = c + Bf(w), t.accuracy) {
        var b = qf({
            northing: t.northing + t.accuracy,
            easting: t.easting + t.accuracy,
            zoneLetter: t.zoneLetter,
            zoneNumber: t.zoneNumber
        });
        E = {
            top: b.lat,
            right: b.lon,
            bottom: x,
            left: w
        }
    } else
        E = {
            lat: x,
            lon: w
        };
    return E
}
function zf(t) {
    var e = "Z";
    return 84 >= t && t >= 72 ? e = "X" : 72 > t && t >= 64 ? e = "W" : 64 > t && t >= 56 ? e = "V" : 56 > t && t >= 48 ? e = "U" : 48 > t && t >= 40 ? e = "T" : 40 > t && t >= 32 ? e = "S" : 32 > t && t >= 24 ? e = "R" : 24 > t && t >= 16 ? e = "Q" : 16 > t && t >= 8 ? e = "P" : 8 > t && t >= 0 ? e = "N" : 0 > t && t >= -8 ? e = "M" : -8 > t && t >= -16 ? e = "L" : -16 > t && t >= -24 ? e = "K" : -24 > t && t >= -32 ? e = "J" : -32 > t && t >= -40 ? e = "H" : -40 > t && t >= -48 ? e = "G" : -48 > t && t >= -56 ? e = "F" : -56 > t && t >= -64 ? e = "E" : -64 > t && t >= -72 ? e = "D" : -72 > t && t >= -80 && (e = "C"), e
}
function Uf(t) {
    var e = t % 6;
    return 0 === e && (e = 6), e
}
function Vf(t) {
    if (t && 0 === t.length)
        throw "MGRSPoint coverting from nothing";
    for (var e, n = t.length, r = null, i = "", o = 0; !/[A-Z]/.test(e = t.charAt(o));) {
        if (o >= 2)
            throw "MGRSPoint bad conversion from: " + t;
        i += e,
        o++
    }
    var s = parseInt(i, 10);
    if (0 === o || o + 3 > n)
        throw "MGRSPoint bad conversion from: " + t;
    var a = t.charAt(o++);
    if (a <= "A" || "B" === a || "Y" === a || a >= "Z" || "I" === a || "O" === a)
        throw "MGRSPoint zone letter " + a + " not handled: " + t;
    r = t.substring(o, o += 2);
    for (var u = Uf(s), l = function(t, e) {
            var n = "AJSAJS".charCodeAt(e - 1),
                r = 1e5,
                i = !1;
            for (; n !== t.charCodeAt(0);) {
                if (73 === ++n && n++, 79 === n && n++, n > 90) {
                    if (i)
                        throw "Bad character: " + t;
                    n = 65,
                    i = !0
                }
                r += 1e5
            }
            return r
        }(r.charAt(0), u), h = function(t, e) {
            if (t > "V")
                throw "MGRSPoint given invalid Northing " + t;
            var n = "AFAFAF".charCodeAt(e - 1),
                r = 0,
                i = !1;
            for (; n !== t.charCodeAt(0);) {
                if (73 === ++n && n++, 79 === n && n++, n > 86) {
                    if (i)
                        throw "Bad character: " + t;
                    n = 65,
                    i = !0
                }
                r += 1e5
            }
            return r
        }(r.charAt(1), u); h < Xf(a);)
        h += 2e6;
    var c = n - o;
    if (c % 2 != 0)
        throw "MGRSPoint has to have an even number \nof digits after the zone letter and two 100km letters - front \nhalf for easting meters, second half for \nnorthing meters" + t;
    var p,
        f,
        d,
        g = c / 2,
        y = 0,
        v = 0;
    return g > 0 && (p = 1e5 / Math.pow(10, g), f = t.substring(o, o + g), y = parseFloat(f) * p, d = t.substring(o + g), v = parseFloat(d) * p), {
        easting: y + l,
        northing: v + h,
        zoneLetter: a,
        zoneNumber: s,
        accuracy: p
    }
}
function Xf(t) {
    var e;
    switch (t) {
    case "C":
        e = 11e5;
        break;
    case "D":
        e = 2e6;
        break;
    case "E":
        e = 28e5;
        break;
    case "F":
        e = 37e5;
        break;
    case "G":
        e = 46e5;
        break;
    case "H":
        e = 55e5;
        break;
    case "J":
        e = 64e5;
        break;
    case "K":
        e = 73e5;
        break;
    case "L":
        e = 82e5;
        break;
    case "M":
        e = 91e5;
        break;
    case "N":
        e = 0;
        break;
    case "P":
        e = 8e5;
        break;
    case "Q":
        e = 17e5;
        break;
    case "R":
        e = 26e5;
        break;
    case "S":
        e = 35e5;
        break;
    case "T":
        e = 44e5;
        break;
    case "U":
        e = 53e5;
        break;
    case "V":
        e = 62e5;
        break;
    case "W":
        e = 7e6;
        break;
    case "X":
        e = 79e5;
        break;
    default:
        e = -1
    }
    if (e >= 0)
        return e;
    throw "Invalid zone letter: " + t
}
function Hf(t, e, n) {
    if (!(this instanceof Hf))
        return new Hf(t, e, n);
    if (Array.isArray(t))
        this.x = t[0],
        this.y = t[1],
        this.z = t[2] || 0;
    else if ("object" == typeof t)
        this.x = t.x,
        this.y = t.y,
        this.z = t.z || 0;
    else if ("string" == typeof t && void 0 === e) {
        var r = t.split(",");
        this.x = parseFloat(r[0], 10),
        this.y = parseFloat(r[1], 10),
        this.z = parseFloat(r[2], 10) || 0
    } else
        this.x = t,
        this.y = e,
        this.z = n || 0;
    console.warn("proj4.Point will be removed in version 3, use proj4.toPoint")
}
Hf.fromMGRS = function(t) {
    return new Hf(jf(t))
},
Hf.prototype.toMGRS = function(t) {
    return kf([this.x, this.y], t)
};
var Yf = Hf;
function Wf(t) {
    var e = [];
    e[0] = 1 - t * (.25 + t * (.046875 + t * (.01953125 + .01068115234375 * t))),
    e[1] = t * (.75 - t * (.046875 + t * (.01953125 + .01068115234375 * t)));
    var n = t * t;
    return e[2] = n * (.46875 - t * (.013020833333333334 + .007120768229166667 * t)), n *= t, e[3] = n * (.3645833333333333 - .005696614583333333 * t), e[4] = n * t * .3076171875, e
}
function $f(t, e, n, r) {
    return n *= e, e *= e, r[0] * t - n * (r[1] + e * (r[2] + e * (r[3] + e * r[4])))
}
function Kf(t, e, n) {
    for (var r = 1 / (1 - e), i = t, o = 20; o; --o) {
        var s = Math.sin(i),
            a = 1 - e * s * s;
        if (i -= a = ($f(i, s, Math.cos(i), n) - t) * (a * Math.sqrt(a)) * r, Math.abs(a) < 1e-10)
            return i
    }
    return i
}
var Zf = {
    init: function() {
        this.x0 = void 0 !== this.x0 ? this.x0 : 0,
        this.y0 = void 0 !== this.y0 ? this.y0 : 0,
        this.long0 = void 0 !== this.long0 ? this.long0 : 0,
        this.lat0 = void 0 !== this.lat0 ? this.lat0 : 0,
        this.es && (this.en = Wf(this.es), this.ml0 = $f(this.lat0, Math.sin(this.lat0), Math.cos(this.lat0), this.en))
    },
    forward: function(t) {
        var e,
            n,
            r,
            i = t.x,
            o = t.y,
            s = Xp(i - this.long0),
            a = Math.sin(o),
            u = Math.cos(o);
        if (this.es) {
            var l = u * s,
                h = Math.pow(l, 2),
                c = this.ep2 * Math.pow(u, 2),
                p = Math.pow(c, 2),
                f = Math.abs(u) > 1e-10 ? Math.tan(o) : 0,
                d = Math.pow(f, 2),
                g = Math.pow(d, 2);
            e = 1 - this.es * Math.pow(a, 2),
            l /= Math.sqrt(e);
            var y = $f(o, a, u, this.en);
            n = this.a * (this.k0 * l * (1 + h / 6 * (1 - d + c + h / 20 * (5 - 18 * d + g + 14 * c - 58 * d * c + h / 42 * (61 + 179 * g - g * d - 479 * d))))) + this.x0,
            r = this.a * (this.k0 * (y - this.ml0 + a * s * l / 2 * (1 + h / 12 * (5 - d + 9 * c + 4 * p + h / 30 * (61 + g - 58 * d + 270 * c - 330 * d * c + h / 56 * (1385 + 543 * g - g * d - 3111 * d)))))) + this.y0
        } else {
            var v = u * Math.sin(s);
            if (Math.abs(Math.abs(v) - 1) < 1e-10)
                return 93;
            if (n = .5 * this.a * this.k0 * Math.log((1 + v) / (1 - v)) + this.x0, r = u * Math.cos(s) / Math.sqrt(1 - Math.pow(v, 2)), (v = Math.abs(r)) >= 1) {
                if (v - 1 > 1e-10)
                    return 93;
                r = 0
            } else
                r = Math.acos(r);
            o < 0 && (r = -r),
            r = this.a * this.k0 * (r - this.lat0) + this.y0
        }
        return t.x = n, t.y = r, t
    },
    inverse: function(t) {
        var e,
            n,
            r,
            i,
            o = (t.x - this.x0) * (1 / this.a),
            s = (t.y - this.y0) * (1 / this.a);
        if (this.es)
            if (n = Kf(e = this.ml0 + s / this.k0, this.es, this.en), Math.abs(n) < mp) {
                var a = Math.sin(n),
                    u = Math.cos(n),
                    l = Math.abs(u) > 1e-10 ? Math.tan(n) : 0,
                    h = this.ep2 * Math.pow(u, 2),
                    c = Math.pow(h, 2),
                    p = Math.pow(l, 2),
                    f = Math.pow(p, 2);
                e = 1 - this.es * Math.pow(a, 2);
                var d = o * Math.sqrt(e) / this.k0,
                    g = Math.pow(d, 2);
                r = n - (e *= l) * g / (1 - this.es) * .5 * (1 - g / 12 * (5 + 3 * p - 9 * h * p + h - 4 * c - g / 30 * (61 + 90 * p - 252 * h * p + 45 * f + 46 * h - g / 56 * (1385 + 3633 * p + 4095 * f + 1574 * f * p)))),
                i = Xp(this.long0 + d * (1 - g / 6 * (1 + 2 * p + h - g / 20 * (5 + 28 * p + 24 * f + 8 * h * p + 6 * h - g / 42 * (61 + 662 * p + 1320 * f + 720 * f * p)))) / u)
            } else
                r = mp * Vp(s),
                i = 0;
        else {
            var y = Math.exp(o / this.k0),
                v = .5 * (y - 1 / y),
                m = this.lat0 + s / this.k0,
                _ = Math.cos(m);
            e = Math.sqrt((1 - Math.pow(_, 2)) / (1 + Math.pow(v, 2))),
            r = Math.asin(e),
            s < 0 && (r = -r),
            i = 0 === v && 0 === _ ? 0 : Xp(Math.atan2(v, _) + this.long0)
        }
        return t.x = i, t.y = r, t
    },
    names: ["Fast_Transverse_Mercator", "Fast Transverse Mercator"]
};
function Jf(t) {
    var e = Math.exp(t);
    return e = (e - 1 / e) / 2
}
function Qf(t, e) {
    t = Math.abs(t),
    e = Math.abs(e);
    var n = Math.max(t, e),
        r = Math.min(t, e) / (n || 1);
    return n * Math.sqrt(1 + Math.pow(r, 2))
}
function td(t) {
    var e = 1 + t,
        n = e - 1;
    return 0 === n ? t : t * Math.log(e) / n
}
function ed(t) {
    var e = Math.abs(t);
    return e = td(e * (1 + e / (Qf(1, e) + 1))), t < 0 ? -e : e
}
function nd(t, e) {
    for (var n, r = 2 * Math.cos(2 * e), i = t.length - 1, o = t[i], s = 0; --i >= 0;)
        n = r * o - s + t[i],
        s = o,
        o = n;
    return e + n * Math.sin(2 * e)
}
function rd(t, e) {
    for (var n, r = 2 * Math.cos(e), i = t.length - 1, o = t[i], s = 0; --i >= 0;)
        n = r * o - s + t[i],
        s = o,
        o = n;
    return Math.sin(e) * n
}
function id(t) {
    var e = Math.exp(t);
    return e = (e + 1 / e) / 2
}
function od(t, e, n) {
    for (var r, i, o = Math.sin(e), s = Math.cos(e), a = Jf(n), u = id(n), l = 2 * s * u, h = -2 * o * a, c = t.length - 1, p = t[c], f = 0, d = 0, g = 0; --c >= 0;)
        r = d,
        i = f,
        p = l * (d = p) - r - h * (f = g) + t[c],
        g = h * d - i + l * f;
    return [(l = o * u) * p - (h = s * a) * g, l * g + h * p]
}
var sd = {
    init: function() {
        if (!this.approx && (isNaN(this.es) || this.es <= 0))
            throw new Error('Incorrect elliptical usage. Try using the +approx option in the proj string, or PROJECTION["Fast_Transverse_Mercator"] in the WKT.');
        this.approx && (Zf.init.apply(this), this.forward = Zf.forward, this.inverse = Zf.inverse),
        this.x0 = void 0 !== this.x0 ? this.x0 : 0,
        this.y0 = void 0 !== this.y0 ? this.y0 : 0,
        this.long0 = void 0 !== this.long0 ? this.long0 : 0,
        this.lat0 = void 0 !== this.lat0 ? this.lat0 : 0,
        this.cgb = [],
        this.cbg = [],
        this.utg = [],
        this.gtu = [];
        var t = this.es / (1 + Math.sqrt(1 - this.es)),
            e = t / (2 - t),
            n = e;
        this.cgb[0] = e * (2 + e * (-2 / 3 + e * (e * (116 / 45 + e * (26 / 45 + e * (-2854 / 675))) - 2))),
        this.cbg[0] = e * (e * (2 / 3 + e * (4 / 3 + e * (-82 / 45 + e * (32 / 45 + e * (4642 / 4725))))) - 2),
        n *= e,
        this.cgb[1] = n * (7 / 3 + e * (e * (-227 / 45 + e * (2704 / 315 + e * (2323 / 945))) - 1.6)),
        this.cbg[1] = n * (5 / 3 + e * (-16 / 15 + e * (-13 / 9 + e * (904 / 315 + e * (-1522 / 945))))),
        n *= e,
        this.cgb[2] = n * (56 / 15 + e * (-136 / 35 + e * (-1262 / 105 + e * (73814 / 2835)))),
        this.cbg[2] = n * (-26 / 15 + e * (34 / 21 + e * (1.6 + e * (-12686 / 2835)))),
        n *= e,
        this.cgb[3] = n * (4279 / 630 + e * (-332 / 35 + e * (-399572 / 14175))),
        this.cbg[3] = n * (1237 / 630 + e * (e * (-24832 / 14175) - 2.4)),
        n *= e,
        this.cgb[4] = n * (4174 / 315 + e * (-144838 / 6237)),
        this.cbg[4] = n * (-734 / 315 + e * (109598 / 31185)),
        n *= e,
        this.cgb[5] = n * (601676 / 22275),
        this.cbg[5] = n * (444337 / 155925),
        n = Math.pow(e, 2),
        this.Qn = this.k0 / (1 + e) * (1 + n * (.25 + n * (1 / 64 + n / 256))),
        this.utg[0] = e * (e * (2 / 3 + e * (-37 / 96 + e * (1 / 360 + e * (81 / 512 + e * (-96199 / 604800))))) - .5),
        this.gtu[0] = e * (.5 + e * (-2 / 3 + e * (.3125 + e * (41 / 180 + e * (-127 / 288 + e * (7891 / 37800)))))),
        this.utg[1] = n * (-1 / 48 + e * (-1 / 15 + e * (437 / 1440 + e * (-46 / 105 + e * (1118711 / 3870720))))),
        this.gtu[1] = n * (13 / 48 + e * (e * (557 / 1440 + e * (281 / 630 + e * (-1983433 / 1935360))) - .6)),
        n *= e,
        this.utg[2] = n * (-17 / 480 + e * (37 / 840 + e * (209 / 4480 + e * (-5569 / 90720)))),
        this.gtu[2] = n * (61 / 240 + e * (-103 / 140 + e * (15061 / 26880 + e * (167603 / 181440)))),
        n *= e,
        this.utg[3] = n * (-4397 / 161280 + e * (11 / 504 + e * (830251 / 7257600))),
        this.gtu[3] = n * (49561 / 161280 + e * (-179 / 168 + e * (6601661 / 7257600))),
        n *= e,
        this.utg[4] = n * (-4583 / 161280 + e * (108847 / 3991680)),
        this.gtu[4] = n * (34729 / 80640 + -1.713007555715889 * e),
        n *= e,
        this.utg[5] = -.03233083094085698 * n,
        this.gtu[5] = .6650675310896665 * n;
        var r = nd(this.cbg, this.lat0);
        this.Zb = -this.Qn * (r + rd(this.gtu, 2 * r))
    },
    forward: function(t) {
        var e = Xp(t.x - this.long0),
            n = t.y;
        n = nd(this.cbg, n);
        var r = Math.sin(n),
            i = Math.cos(n),
            o = Math.sin(e),
            s = Math.cos(e);
        n = Math.atan2(r, s * i),
        e = Math.atan2(o * i, Qf(r, i * s)),
        e = ed(Math.tan(e));
        var a,
            u,
            l = od(this.gtu, 2 * n, 2 * e);
        return n += l[0], e += l[1], Math.abs(e) <= 2.623395162778 ? (a = this.a * (this.Qn * e) + this.x0, u = this.a * (this.Qn * n + this.Zb) + this.y0) : (a = 1 / 0, u = 1 / 0), t.x = a, t.y = u, t
    },
    inverse: function(t) {
        var e,
            n,
            r = (t.x - this.x0) * (1 / this.a),
            i = (t.y - this.y0) * (1 / this.a);
        if (i = (i - this.Zb) / this.Qn, r /= this.Qn, Math.abs(r) <= 2.623395162778) {
            var o = od(this.utg, 2 * i, 2 * r);
            i += o[0],
            r += o[1],
            r = Math.atan(Jf(r));
            var s = Math.sin(i),
                a = Math.cos(i),
                u = Math.sin(r),
                l = Math.cos(r);
            i = Math.atan2(s * l, Qf(u, l * a)),
            e = Xp((r = Math.atan2(u, l * a)) + this.long0),
            n = nd(this.cgb, i)
        } else
            e = 1 / 0,
            n = 1 / 0;
        return t.x = e, t.y = n, t
    },
    names: ["Extended_Transverse_Mercator", "Extended Transverse Mercator", "etmerc", "Transverse_Mercator", "Transverse Mercator", "tmerc"]
};
function ad(t, e) {
    if (void 0 === t) {
        if ((t = Math.floor(30 * (Xp(e) + Math.PI) / Math.PI) + 1) < 0)
            return 0;
        if (t > 60)
            return 60
    }
    return t
}
var ud = {
    init: function() {
        var t = ad(this.zone, this.long0);
        if (void 0 === t)
            throw new Error("unknown utm zone");
        this.lat0 = 0,
        this.long0 = .017453292519943295 * (6 * Math.abs(t) - 183),
        this.x0 = 5e5,
        this.y0 = this.utmSouth ? 1e7 : 0,
        this.k0 = .9996,
        sd.init.apply(this),
        this.forward = sd.forward,
        this.inverse = sd.inverse
    },
    names: ["Universal Transverse Mercator System", "utm"],
    dependsOn: "etmerc"
};
function ld(t, e) {
    return Math.pow((1 - t) / (1 + t), e)
}
var hd = {
    init: function() {
        var t = Math.sin(this.lat0),
            e = Math.cos(this.lat0);
        e *= e,
        this.rc = Math.sqrt(1 - this.es) / (1 - this.es * t * t),
        this.C = Math.sqrt(1 + this.es * e * e / (1 - this.es)),
        this.phic0 = Math.asin(t / this.C),
        this.ratexp = .5 * this.C * this.e,
        this.K = Math.tan(.5 * this.phic0 + _p) / (Math.pow(Math.tan(.5 * this.lat0 + _p), this.C) * ld(this.e * t, this.ratexp))
    },
    forward: function(t) {
        var e = t.x,
            n = t.y;
        return t.y = 2 * Math.atan(this.K * Math.pow(Math.tan(.5 * n + _p), this.C) * ld(this.e * Math.sin(n), this.ratexp)) - mp, t.x = this.C * e, t
    },
    inverse: function(t) {
        for (var e = t.x / this.C, n = t.y, r = Math.pow(Math.tan(.5 * n + _p) / this.K, 1 / this.C), i = 20; i > 0 && (n = 2 * Math.atan(r * ld(this.e * Math.sin(t.y), -.5 * this.e)) - mp, !(Math.abs(n - t.y) < 1e-14)); --i)
            t.y = n;
        return i ? (t.x = e, t.y = n, t) : null
    },
    names: ["gauss"]
};
var cd = {
    init: function() {
        hd.init.apply(this),
        this.rc && (this.sinc0 = Math.sin(this.phic0), this.cosc0 = Math.cos(this.phic0), this.R2 = 2 * this.rc, this.title || (this.title = "Oblique Stereographic Alternative"))
    },
    forward: function(t) {
        var e,
            n,
            r,
            i;
        return t.x = Xp(t.x - this.long0), hd.forward.apply(this, [t]), e = Math.sin(t.y), n = Math.cos(t.y), r = Math.cos(t.x), i = this.k0 * this.R2 / (1 + this.sinc0 * e + this.cosc0 * n * r), t.x = i * n * Math.sin(t.x), t.y = i * (this.cosc0 * e - this.sinc0 * n * r), t.x = this.a * t.x + this.x0, t.y = this.a * t.y + this.y0, t
    },
    inverse: function(t) {
        var e,
            n,
            r,
            i,
            o;
        if (t.x = (t.x - this.x0) / this.a, t.y = (t.y - this.y0) / this.a, t.x /= this.k0, t.y /= this.k0, o = Math.sqrt(t.x * t.x + t.y * t.y)) {
            var s = 2 * Math.atan2(o, this.R2);
            e = Math.sin(s),
            n = Math.cos(s),
            i = Math.asin(n * this.sinc0 + t.y * e * this.cosc0 / o),
            r = Math.atan2(t.x * e, o * this.cosc0 * n - t.y * this.sinc0 * e)
        } else
            i = this.phic0,
            r = 0;
        return t.x = r, t.y = i, hd.inverse.apply(this, [t]), t.x = Xp(t.x + this.long0), t
    },
    names: ["Stereographic_North_Pole", "Oblique_Stereographic", "Polar_Stereographic", "sterea", "Oblique Stereographic Alternative", "Double_Stereographic"]
};
var pd = {
    init: function() {
        this.coslat0 = Math.cos(this.lat0),
        this.sinlat0 = Math.sin(this.lat0),
        this.sphere ? 1 === this.k0 && !isNaN(this.lat_ts) && Math.abs(this.coslat0) <= 1e-10 && (this.k0 = .5 * (1 + Vp(this.lat0) * Math.sin(this.lat_ts))) : (Math.abs(this.coslat0) <= 1e-10 && (this.lat0 > 0 ? this.con = 1 : this.con = -1), this.cons = Math.sqrt(Math.pow(1 + this.e, 1 + this.e) * Math.pow(1 - this.e, 1 - this.e)), 1 === this.k0 && !isNaN(this.lat_ts) && Math.abs(this.coslat0) <= 1e-10 && (this.k0 = .5 * this.cons * Up(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts)) / Hp(this.e, this.con * this.lat_ts, this.con * Math.sin(this.lat_ts))), this.ms1 = Up(this.e, this.sinlat0, this.coslat0), this.X0 = 2 * Math.atan(this.ssfn_(this.lat0, this.sinlat0, this.e)) - mp, this.cosX0 = Math.cos(this.X0), this.sinX0 = Math.sin(this.X0))
    },
    forward: function(t) {
        var e,
            n,
            r,
            i,
            o,
            s,
            a = t.x,
            u = t.y,
            l = Math.sin(u),
            h = Math.cos(u),
            c = Xp(a - this.long0);
        return Math.abs(Math.abs(a - this.long0) - Math.PI) <= 1e-10 && Math.abs(u + this.lat0) <= 1e-10 ? (t.x = NaN, t.y = NaN, t) : this.sphere ? (e = 2 * this.k0 / (1 + this.sinlat0 * l + this.coslat0 * h * Math.cos(c)), t.x = this.a * e * h * Math.sin(c) + this.x0, t.y = this.a * e * (this.coslat0 * l - this.sinlat0 * h * Math.cos(c)) + this.y0, t) : (n = 2 * Math.atan(this.ssfn_(u, l, this.e)) - mp, i = Math.cos(n), r = Math.sin(n), Math.abs(this.coslat0) <= 1e-10 ? (o = Hp(this.e, u * this.con, this.con * l), s = 2 * this.a * this.k0 * o / this.cons, t.x = this.x0 + s * Math.sin(a - this.long0), t.y = this.y0 - this.con * s * Math.cos(a - this.long0), t) : (Math.abs(this.sinlat0) < 1e-10 ? (e = 2 * this.a * this.k0 / (1 + i * Math.cos(c)), t.y = e * r) : (e = 2 * this.a * this.k0 * this.ms1 / (this.cosX0 * (1 + this.sinX0 * r + this.cosX0 * i * Math.cos(c))), t.y = e * (this.cosX0 * r - this.sinX0 * i * Math.cos(c)) + this.y0), t.x = e * i * Math.sin(c) + this.x0, t))
    },
    inverse: function(t) {
        var e,
            n,
            r,
            i,
            o;
        t.x -= this.x0,
        t.y -= this.y0;
        var s = Math.sqrt(t.x * t.x + t.y * t.y);
        if (this.sphere) {
            var a = 2 * Math.atan(s / (2 * this.a * this.k0));
            return e = this.long0, n = this.lat0, s <= 1e-10 ? (t.x = e, t.y = n, t) : (n = Math.asin(Math.cos(a) * this.sinlat0 + t.y * Math.sin(a) * this.coslat0 / s), e = Math.abs(this.coslat0) < 1e-10 ? this.lat0 > 0 ? Xp(this.long0 + Math.atan2(t.x, -1 * t.y)) : Xp(this.long0 + Math.atan2(t.x, t.y)) : Xp(this.long0 + Math.atan2(t.x * Math.sin(a), s * this.coslat0 * Math.cos(a) - t.y * this.sinlat0 * Math.sin(a))), t.x = e, t.y = n, t)
        }
        if (Math.abs(this.coslat0) <= 1e-10) {
            if (s <= 1e-10)
                return n = this.lat0, e = this.long0, t.x = e, t.y = n, t;
            t.x *= this.con,
            t.y *= this.con,
            r = s * this.cons / (2 * this.a * this.k0),
            n = this.con * Yp(this.e, r),
            e = this.con * Xp(this.con * this.long0 + Math.atan2(t.x, -1 * t.y))
        } else
            i = 2 * Math.atan(s * this.cosX0 / (2 * this.a * this.k0 * this.ms1)),
            e = this.long0,
            s <= 1e-10 ? o = this.X0 : (o = Math.asin(Math.cos(i) * this.sinX0 + t.y * Math.sin(i) * this.cosX0 / s), e = Xp(this.long0 + Math.atan2(t.x * Math.sin(i), s * this.cosX0 * Math.cos(i) - t.y * this.sinX0 * Math.sin(i)))),
            n = -1 * Yp(this.e, Math.tan(.5 * (mp + o)));
        return t.x = e, t.y = n, t
    },
    names: ["stere", "Stereographic_South_Pole", "Polar Stereographic (variant B)"],
    ssfn_: function(t, e, n) {
        return e *= n, Math.tan(.5 * (mp + t)) * Math.pow((1 - e) / (1 + e), .5 * n)
    }
};
var fd = {
    init: function() {
        var t = this.lat0;
        this.lambda0 = this.long0;
        var e = Math.sin(t),
            n = this.a,
            r = 1 / this.rf,
            i = 2 * r - Math.pow(r, 2),
            o = this.e = Math.sqrt(i);
        this.R = this.k0 * n * Math.sqrt(1 - i) / (1 - i * Math.pow(e, 2)),
        this.alpha = Math.sqrt(1 + i / (1 - i) * Math.pow(Math.cos(t), 4)),
        this.b0 = Math.asin(e / this.alpha);
        var s = Math.log(Math.tan(Math.PI / 4 + this.b0 / 2)),
            a = Math.log(Math.tan(Math.PI / 4 + t / 2)),
            u = Math.log((1 + o * e) / (1 - o * e));
        this.K = s - this.alpha * a + this.alpha * o / 2 * u
    },
    forward: function(t) {
        var e = Math.log(Math.tan(Math.PI / 4 - t.y / 2)),
            n = this.e / 2 * Math.log((1 + this.e * Math.sin(t.y)) / (1 - this.e * Math.sin(t.y))),
            r = -this.alpha * (e + n) + this.K,
            i = 2 * (Math.atan(Math.exp(r)) - Math.PI / 4),
            o = this.alpha * (t.x - this.lambda0),
            s = Math.atan(Math.sin(o) / (Math.sin(this.b0) * Math.tan(i) + Math.cos(this.b0) * Math.cos(o))),
            a = Math.asin(Math.cos(this.b0) * Math.sin(i) - Math.sin(this.b0) * Math.cos(i) * Math.cos(o));
        return t.y = this.R / 2 * Math.log((1 + Math.sin(a)) / (1 - Math.sin(a))) + this.y0, t.x = this.R * s + this.x0, t
    },
    inverse: function(t) {
        for (var e = t.x - this.x0, n = t.y - this.y0, r = e / this.R, i = 2 * (Math.atan(Math.exp(n / this.R)) - Math.PI / 4), o = Math.asin(Math.cos(this.b0) * Math.sin(i) + Math.sin(this.b0) * Math.cos(i) * Math.cos(r)), s = Math.atan(Math.sin(r) / (Math.cos(this.b0) * Math.cos(r) - Math.sin(this.b0) * Math.tan(i))), a = this.lambda0 + s / this.alpha, u = 0, l = o, h = -1e3, c = 0; Math.abs(l - h) > 1e-7;) {
            if (++c > 20)
                return;
            u = 1 / this.alpha * (Math.log(Math.tan(Math.PI / 4 + o / 2)) - this.K) + this.e * Math.log(Math.tan(Math.PI / 4 + Math.asin(this.e * Math.sin(l)) / 2)),
            h = l,
            l = 2 * Math.atan(Math.exp(u)) - Math.PI / 2
        }
        return t.x = a, t.y = l, t
    },
    names: ["somerc"]
};
var dd = {
    init: function() {
        var t,
            e,
            n,
            r,
            i,
            o,
            s,
            a,
            u,
            l,
            h,
            c,
            p,
            f = 0,
            d = 0,
            g = 0,
            y = 0,
            v = 0,
            m = 0,
            _ = 0;
        this.no_off = (p = "object" == typeof (c = this).PROJECTION ? Object.keys(c.PROJECTION)[0] : c.PROJECTION, "no_uoff" in c || "no_off" in c || -1 !== ["Hotine_Oblique_Mercator", "Hotine_Oblique_Mercator_Azimuth_Natural_Origin"].indexOf(p)),
        this.no_rot = "no_rot" in this;
        var x = !1;
        "alpha" in this && (x = !0);
        var E = !1;
        if ("rectified_grid_angle" in this && (E = !0), x && (_ = this.alpha), E && (f = .017453292519943295 * this.rectified_grid_angle), x || E)
            d = this.longc;
        else if (g = this.long1, v = this.lat1, y = this.long2, m = this.lat2, Math.abs(v - m) <= 1e-7 || (t = Math.abs(v)) <= 1e-7 || Math.abs(t - mp) <= 1e-7 || Math.abs(Math.abs(this.lat0) - mp) <= 1e-7 || Math.abs(Math.abs(m) - mp) <= 1e-7)
            throw new Error;
        var w = 1 - this.es;
        e = Math.sqrt(w),
        Math.abs(this.lat0) > 1e-10 ? (a = Math.sin(this.lat0), n = Math.cos(this.lat0), t = 1 - this.es * a * a, this.B = n * n, this.B = Math.sqrt(1 + this.es * this.B * this.B / w), this.A = this.B * this.k0 * e / t, (i = (r = this.B * e / (n * Math.sqrt(t))) * r - 1) <= 0 ? i = 0 : (i = Math.sqrt(i), this.lat0 < 0 && (i = -i)), this.E = i += r, this.E *= Math.pow(Hp(this.e, this.lat0, a), this.B)) : (this.B = 1 / e, this.A = this.k0, this.E = r = i = 1),
        x || E ? (x ? (h = Math.asin(Math.sin(_) / r), E || (f = _)) : (h = f, _ = Math.asin(r * Math.sin(h))), this.lam0 = d - Math.asin(.5 * (i - 1 / i) * Math.tan(h)) / this.B) : (o = Math.pow(Hp(this.e, v, Math.sin(v)), this.B), s = Math.pow(Hp(this.e, m, Math.sin(m)), this.B), i = this.E / o, u = (s - o) / (s + o), l = ((l = this.E * this.E) - s * o) / (l + s * o), (t = g - y) < -Math.pi ? y -= xp : t > Math.pi && (y += xp), this.lam0 = Xp(.5 * (g + y) - Math.atan(l * Math.tan(.5 * this.B * (g - y)) / u) / this.B), h = Math.atan(2 * Math.sin(this.B * Xp(g - this.lam0)) / (i - 1 / i)), f = _ = Math.asin(r * Math.sin(h))),
        this.singam = Math.sin(h),
        this.cosgam = Math.cos(h),
        this.sinrot = Math.sin(f),
        this.cosrot = Math.cos(f),
        this.rB = 1 / this.B,
        this.ArB = this.A * this.rB,
        this.BrA = 1 / this.ArB,
        this.A,
        this.B,
        this.no_off ? this.u_0 = 0 : (this.u_0 = Math.abs(this.ArB * Math.atan(Math.sqrt(r * r - 1) / Math.cos(_))), this.lat0 < 0 && (this.u_0 = -this.u_0)),
        i = .5 * h,
        this.v_pole_n = this.ArB * Math.log(Math.tan(_p - i)),
        this.v_pole_s = this.ArB * Math.log(Math.tan(_p + i))
    },
    forward: function(t) {
        var e,
            n,
            r,
            i,
            o,
            s,
            a,
            u,
            l = {};
        if (t.x = t.x - this.lam0, Math.abs(Math.abs(t.y) - mp) > 1e-10) {
            if (e = .5 * ((o = this.E / Math.pow(Hp(this.e, t.y, Math.sin(t.y)), this.B)) - (s = 1 / o)), n = .5 * (o + s), i = Math.sin(this.B * t.x), r = (e * this.singam - i * this.cosgam) / n, Math.abs(Math.abs(r) - 1) < 1e-10)
                throw new Error;
            u = .5 * this.ArB * Math.log((1 - r) / (1 + r)),
            s = Math.cos(this.B * t.x),
            a = Math.abs(s) < 1e-7 ? this.A * t.x : this.ArB * Math.atan2(e * this.cosgam + i * this.singam, s)
        } else
            u = t.y > 0 ? this.v_pole_n : this.v_pole_s,
            a = this.ArB * t.y;
        return this.no_rot ? (l.x = a, l.y = u) : (a -= this.u_0, l.x = u * this.cosrot + a * this.sinrot, l.y = a * this.cosrot - u * this.sinrot), l.x = this.a * l.x + this.x0, l.y = this.a * l.y + this.y0, l
    },
    inverse: function(t) {
        var e,
            n,
            r,
            i,
            o,
            s,
            a,
            u = {};
        if (t.x = (t.x - this.x0) * (1 / this.a), t.y = (t.y - this.y0) * (1 / this.a), this.no_rot ? (n = t.y, e = t.x) : (n = t.x * this.cosrot - t.y * this.sinrot, e = t.y * this.cosrot + t.x * this.sinrot + this.u_0), i = .5 * ((r = Math.exp(-this.BrA * n)) - 1 / r), o = .5 * (r + 1 / r), a = ((s = Math.sin(this.BrA * e)) * this.cosgam + i * this.singam) / o, Math.abs(Math.abs(a) - 1) < 1e-10)
            u.x = 0,
            u.y = a < 0 ? -mp : mp;
        else {
            if (u.y = this.E / Math.sqrt((1 + a) / (1 - a)), u.y = Yp(this.e, Math.pow(u.y, 1 / this.B)), u.y === 1 / 0)
                throw new Error;
            u.x = -this.rB * Math.atan2(i * this.cosgam - s * this.singam, Math.cos(this.BrA * e))
        }
        return u.x += this.lam0, u
    },
    names: ["Hotine_Oblique_Mercator", "Hotine Oblique Mercator", "Hotine_Oblique_Mercator_Azimuth_Natural_Origin", "Hotine_Oblique_Mercator_Two_Point_Natural_Origin", "Hotine_Oblique_Mercator_Azimuth_Center", "Oblique_Mercator", "omerc"]
};
var gd = {
    init: function() {
        if (this.lat2 || (this.lat2 = this.lat1), this.k0 || (this.k0 = 1), this.x0 = this.x0 || 0, this.y0 = this.y0 || 0, !(Math.abs(this.lat1 + this.lat2) < 1e-10)) {
            var t = this.b / this.a;
            this.e = Math.sqrt(1 - t * t);
            var e = Math.sin(this.lat1),
                n = Math.cos(this.lat1),
                r = Up(this.e, e, n),
                i = Hp(this.e, this.lat1, e),
                o = Math.sin(this.lat2),
                s = Math.cos(this.lat2),
                a = Up(this.e, o, s),
                u = Hp(this.e, this.lat2, o),
                l = Hp(this.e, this.lat0, Math.sin(this.lat0));
            Math.abs(this.lat1 - this.lat2) > 1e-10 ? this.ns = Math.log(r / a) / Math.log(i / u) : this.ns = e,
            isNaN(this.ns) && (this.ns = e),
            this.f0 = r / (this.ns * Math.pow(i, this.ns)),
            this.rh = this.a * this.f0 * Math.pow(l, this.ns),
            this.title || (this.title = "Lambert Conformal Conic")
        }
    },
    forward: function(t) {
        var e = t.x,
            n = t.y;
        Math.abs(2 * Math.abs(n) - Math.PI) <= 1e-10 && (n = Vp(n) * (mp - 2e-10));
        var r,
            i,
            o = Math.abs(Math.abs(n) - mp);
        if (o > 1e-10)
            r = Hp(this.e, n, Math.sin(n)),
            i = this.a * this.f0 * Math.pow(r, this.ns);
        else {
            if ((o = n * this.ns) <= 0)
                return null;
            i = 0
        }
        var s = this.ns * Xp(e - this.long0);
        return t.x = this.k0 * (i * Math.sin(s)) + this.x0, t.y = this.k0 * (this.rh - i * Math.cos(s)) + this.y0, t
    },
    inverse: function(t) {
        var e,
            n,
            r,
            i,
            o,
            s = (t.x - this.x0) / this.k0,
            a = this.rh - (t.y - this.y0) / this.k0;
        this.ns > 0 ? (e = Math.sqrt(s * s + a * a), n = 1) : (e = -Math.sqrt(s * s + a * a), n = -1);
        var u = 0;
        if (0 !== e && (u = Math.atan2(n * s, n * a)), 0 !== e || this.ns > 0) {
            if (n = 1 / this.ns, r = Math.pow(e / (this.a * this.f0), n), -9999 === (i = Yp(this.e, r)))
                return null
        } else
            i = -mp;
        return o = Xp(u / this.ns + this.long0), t.x = o, t.y = i, t
    },
    names: ["Lambert Tangential Conformal Conic Projection", "Lambert_Conformal_Conic", "Lambert_Conformal_Conic_1SP", "Lambert_Conformal_Conic_2SP", "lcc", "Lambert Conic Conformal (1SP)", "Lambert Conic Conformal (2SP)"]
};
var yd = {
    init: function() {
        this.a = 6377397.155,
        this.es = .006674372230614,
        this.e = Math.sqrt(this.es),
        this.lat0 || (this.lat0 = .863937979737193),
        this.long0 || (this.long0 = .4334234309119251),
        this.k0 || (this.k0 = .9999),
        this.s45 = .785398163397448,
        this.s90 = 2 * this.s45,
        this.fi0 = this.lat0,
        this.e2 = this.es,
        this.e = Math.sqrt(this.e2),
        this.alfa = Math.sqrt(1 + this.e2 * Math.pow(Math.cos(this.fi0), 4) / (1 - this.e2)),
        this.uq = 1.04216856380474,
        this.u0 = Math.asin(Math.sin(this.fi0) / this.alfa),
        this.g = Math.pow((1 + this.e * Math.sin(this.fi0)) / (1 - this.e * Math.sin(this.fi0)), this.alfa * this.e / 2),
        this.k = Math.tan(this.u0 / 2 + this.s45) / Math.pow(Math.tan(this.fi0 / 2 + this.s45), this.alfa) * this.g,
        this.k1 = this.k0,
        this.n0 = this.a * Math.sqrt(1 - this.e2) / (1 - this.e2 * Math.pow(Math.sin(this.fi0), 2)),
        this.s0 = 1.37008346281555,
        this.n = Math.sin(this.s0),
        this.ro0 = this.k1 * this.n0 / Math.tan(this.s0),
        this.ad = this.s90 - this.uq
    },
    forward: function(t) {
        var e,
            n,
            r,
            i,
            o,
            s,
            a,
            u = t.x,
            l = t.y,
            h = Xp(u - this.long0);
        return e = Math.pow((1 + this.e * Math.sin(l)) / (1 - this.e * Math.sin(l)), this.alfa * this.e / 2), n = 2 * (Math.atan(this.k * Math.pow(Math.tan(l / 2 + this.s45), this.alfa) / e) - this.s45), r = -h * this.alfa, i = Math.asin(Math.cos(this.ad) * Math.sin(n) + Math.sin(this.ad) * Math.cos(n) * Math.cos(r)), o = Math.asin(Math.cos(n) * Math.sin(r) / Math.cos(i)), s = this.n * o, a = this.ro0 * Math.pow(Math.tan(this.s0 / 2 + this.s45), this.n) / Math.pow(Math.tan(i / 2 + this.s45), this.n), t.y = a * Math.cos(s) / 1, t.x = a * Math.sin(s) / 1, this.czech || (t.y *= -1, t.x *= -1), t
    },
    inverse: function(t) {
        var e,
            n,
            r,
            i,
            o,
            s,
            a,
            u = t.x;
        t.x = t.y,
        t.y = u,
        this.czech || (t.y *= -1, t.x *= -1),
        o = Math.sqrt(t.x * t.x + t.y * t.y),
        i = Math.atan2(t.y, t.x) / Math.sin(this.s0),
        r = 2 * (Math.atan(Math.pow(this.ro0 / o, 1 / this.n) * Math.tan(this.s0 / 2 + this.s45)) - this.s45),
        e = Math.asin(Math.cos(this.ad) * Math.sin(r) - Math.sin(this.ad) * Math.cos(r) * Math.cos(i)),
        n = Math.asin(Math.cos(r) * Math.sin(i) / Math.cos(e)),
        t.x = this.long0 - n / this.alfa,
        s = e,
        a = 0;
        var l = 0;
        do {
            t.y = 2 * (Math.atan(Math.pow(this.k, -1 / this.alfa) * Math.pow(Math.tan(e / 2 + this.s45), 1 / this.alfa) * Math.pow((1 + this.e * Math.sin(s)) / (1 - this.e * Math.sin(s)), this.e / 2)) - this.s45),
            Math.abs(s - t.y) < 1e-10 && (a = 1),
            s = t.y,
            l += 1
        } while (0 === a && l < 15);
        return l >= 15 ? null : t
    },
    names: ["Krovak", "krovak"]
};
function vd(t, e, n, r, i) {
    return t * i - e * Math.sin(2 * i) + n * Math.sin(4 * i) - r * Math.sin(6 * i)
}
function md(t) {
    return 1 - .25 * t * (1 + t / 16 * (3 + 1.25 * t))
}
function _d(t) {
    return .375 * t * (1 + .25 * t * (1 + .46875 * t))
}
function xd(t) {
    return .05859375 * t * t * (1 + .75 * t)
}
function Ed(t) {
    return t * t * t * (35 / 3072)
}
function wd(t, e, n) {
    var r = e * n;
    return t / Math.sqrt(1 - r * r)
}
function bd(t) {
    return Math.abs(t) < mp ? t : t - Vp(t) * Math.PI
}
function Cd(t, e, n, r, i) {
    var o,
        s;
    o = t / e;
    for (var a = 0; a < 15; a++)
        if (o += s = (t - (e * o - n * Math.sin(2 * o) + r * Math.sin(4 * o) - i * Math.sin(6 * o))) / (e - 2 * n * Math.cos(2 * o) + 4 * r * Math.cos(4 * o) - 6 * i * Math.cos(6 * o)), Math.abs(s) <= 1e-10)
            return o;
    return NaN
}
var Md = {
    init: function() {
        this.sphere || (this.e0 = md(this.es), this.e1 = _d(this.es), this.e2 = xd(this.es), this.e3 = Ed(this.es), this.ml0 = this.a * vd(this.e0, this.e1, this.e2, this.e3, this.lat0))
    },
    forward: function(t) {
        var e,
            n,
            r = t.x,
            i = t.y;
        if (r = Xp(r - this.long0), this.sphere)
            e = this.a * Math.asin(Math.cos(i) * Math.sin(r)),
            n = this.a * (Math.atan2(Math.tan(i), Math.cos(r)) - this.lat0);
        else {
            var o = Math.sin(i),
                s = Math.cos(i),
                a = wd(this.a, this.e, o),
                u = Math.tan(i) * Math.tan(i),
                l = r * Math.cos(i),
                h = l * l,
                c = this.es * s * s / (1 - this.es);
            e = a * l * (1 - h * u * (1 / 6 - (8 - u + 8 * c) * h / 120)),
            n = this.a * vd(this.e0, this.e1, this.e2, this.e3, i) - this.ml0 + a * o / s * h * (.5 + (5 - u + 6 * c) * h / 24)
        }
        return t.x = e + this.x0, t.y = n + this.y0, t
    },
    inverse: function(t) {
        t.x -= this.x0,
        t.y -= this.y0;
        var e,
            n,
            r = t.x / this.a,
            i = t.y / this.a;
        if (this.sphere) {
            var o = i + this.lat0;
            e = Math.asin(Math.sin(o) * Math.cos(r)),
            n = Math.atan2(Math.tan(r), Math.cos(o))
        } else {
            var s = Cd(this.ml0 / this.a + i, this.e0, this.e1, this.e2, this.e3);
            if (Math.abs(Math.abs(s) - mp) <= 1e-10)
                return t.x = this.long0, t.y = mp, i < 0 && (t.y *= -1), t;
            var a = wd(this.a, this.e, Math.sin(s)),
                u = a * a * a / this.a / this.a * (1 - this.es),
                l = Math.pow(Math.tan(s), 2),
                h = r * this.a / a,
                c = h * h;
            e = s - a * Math.tan(s) / u * h * h * (.5 - (1 + 3 * l) * h * h / 24),
            n = h * (1 - c * (l / 3 + (1 + 3 * l) * l * c / 15)) / Math.cos(s)
        }
        return t.x = Xp(n + this.long0), t.y = bd(e), t
    },
    names: ["Cassini", "Cassini_Soldner", "cass"]
};
function Sd(t, e) {
    var n;
    return t > 1e-7 ? (1 - t * t) * (e / (1 - (n = t * e) * n) - .5 / t * Math.log((1 - n) / (1 + n))) : 2 * e
}
var Id = {
    init: function() {
        var t,
            e = Math.abs(this.lat0);
        if (Math.abs(e - mp) < 1e-10 ? this.mode = this.lat0 < 0 ? this.S_POLE : this.N_POLE : Math.abs(e) < 1e-10 ? this.mode = this.EQUIT : this.mode = this.OBLIQ, this.es > 0)
            switch (this.qp = Sd(this.e, 1), this.mmf = .5 / (1 - this.es), this.apa = function(t) {
                var e,
                    n = [];
                return n[0] = .3333333333333333 * t, e = t * t, n[0] += .17222222222222222 * e, n[1] = .06388888888888888 * e, e *= t, n[0] += .10257936507936508 * e, n[1] += .0664021164021164 * e, n[2] = .016415012942191543 * e, n
            }(this.es), this.mode) {
            case this.N_POLE:
            case this.S_POLE:
                this.dd = 1;
                break;
            case this.EQUIT:
                this.rq = Math.sqrt(.5 * this.qp),
                this.dd = 1 / this.rq,
                this.xmf = 1,
                this.ymf = .5 * this.qp;
                break;
            case this.OBLIQ:
                this.rq = Math.sqrt(.5 * this.qp),
                t = Math.sin(this.lat0),
                this.sinb1 = Sd(this.e, t) / this.qp,
                this.cosb1 = Math.sqrt(1 - this.sinb1 * this.sinb1),
                this.dd = Math.cos(this.lat0) / (Math.sqrt(1 - this.es * t * t) * this.rq * this.cosb1),
                this.ymf = (this.xmf = this.rq) / this.dd,
                this.xmf *= this.dd
            }
        else
            this.mode === this.OBLIQ && (this.sinph0 = Math.sin(this.lat0), this.cosph0 = Math.cos(this.lat0))
    },
    forward: function(t) {
        var e,
            n,
            r,
            i,
            o,
            s,
            a,
            u,
            l,
            h,
            c = t.x,
            p = t.y;
        if (c = Xp(c - this.long0), this.sphere) {
            if (o = Math.sin(p), h = Math.cos(p), r = Math.cos(c), this.mode === this.OBLIQ || this.mode === this.EQUIT) {
                if ((n = this.mode === this.EQUIT ? 1 + h * r : 1 + this.sinph0 * o + this.cosph0 * h * r) <= 1e-10)
                    return null;
                e = (n = Math.sqrt(2 / n)) * h * Math.sin(c),
                n *= this.mode === this.EQUIT ? o : this.cosph0 * o - this.sinph0 * h * r
            } else if (this.mode === this.N_POLE || this.mode === this.S_POLE) {
                if (this.mode === this.N_POLE && (r = -r), Math.abs(p + this.lat0) < 1e-10)
                    return null;
                n = _p - .5 * p,
                e = (n = 2 * (this.mode === this.S_POLE ? Math.cos(n) : Math.sin(n))) * Math.sin(c),
                n *= r
            }
        } else {
            switch (a = 0, u = 0, l = 0, r = Math.cos(c), i = Math.sin(c), o = Math.sin(p), s = Sd(this.e, o), this.mode !== this.OBLIQ && this.mode !== this.EQUIT || (a = s / this.qp, u = Math.sqrt(1 - a * a)), this.mode) {
            case this.OBLIQ:
                l = 1 + this.sinb1 * a + this.cosb1 * u * r;
                break;
            case this.EQUIT:
                l = 1 + u * r;
                break;
            case this.N_POLE:
                l = mp + p,
                s = this.qp - s;
                break;
            case this.S_POLE:
                l = p - mp,
                s = this.qp + s
            }
            if (Math.abs(l) < 1e-10)
                return null;
            switch (this.mode) {
            case this.OBLIQ:
            case this.EQUIT:
                l = Math.sqrt(2 / l),
                n = this.mode === this.OBLIQ ? this.ymf * l * (this.cosb1 * a - this.sinb1 * u * r) : (l = Math.sqrt(2 / (1 + u * r))) * a * this.ymf,
                e = this.xmf * l * u * i;
                break;
            case this.N_POLE:
            case this.S_POLE:
                s >= 0 ? (e = (l = Math.sqrt(s)) * i, n = r * (this.mode === this.S_POLE ? l : -l)) : e = n = 0
            }
        }
        return t.x = this.a * e + this.x0, t.y = this.a * n + this.y0, t
    },
    inverse: function(t) {
        t.x -= this.x0,
        t.y -= this.y0;
        var e,
            n,
            r,
            i,
            o,
            s,
            a,
            u,
            l,
            h,
            c = t.x / this.a,
            p = t.y / this.a;
        if (this.sphere) {
            var f,
                d = 0,
                g = 0;
            if ((n = .5 * (f = Math.sqrt(c * c + p * p))) > 1)
                return null;
            switch (n = 2 * Math.asin(n), this.mode !== this.OBLIQ && this.mode !== this.EQUIT || (g = Math.sin(n), d = Math.cos(n)), this.mode) {
            case this.EQUIT:
                n = Math.abs(f) <= 1e-10 ? 0 : Math.asin(p * g / f),
                c *= g,
                p = d * f;
                break;
            case this.OBLIQ:
                n = Math.abs(f) <= 1e-10 ? this.lat0 : Math.asin(d * this.sinph0 + p * g * this.cosph0 / f),
                c *= g * this.cosph0,
                p = (d - Math.sin(n) * this.sinph0) * f;
                break;
            case this.N_POLE:
                p = -p,
                n = mp - n;
                break;
            case this.S_POLE:
                n -= mp
            }
            e = 0 !== p || this.mode !== this.EQUIT && this.mode !== this.OBLIQ ? Math.atan2(c, p) : 0
        } else {
            if (a = 0, this.mode === this.OBLIQ || this.mode === this.EQUIT) {
                if (c /= this.dd, p *= this.dd, (s = Math.sqrt(c * c + p * p)) < 1e-10)
                    return t.x = this.long0, t.y = this.lat0, t;
                i = 2 * Math.asin(.5 * s / this.rq),
                r = Math.cos(i),
                c *= i = Math.sin(i),
                this.mode === this.OBLIQ ? (a = r * this.sinb1 + p * i * this.cosb1 / s, o = this.qp * a, p = s * this.cosb1 * r - p * this.sinb1 * i) : (a = p * i / s, o = this.qp * a, p = s * r)
            } else if (this.mode === this.N_POLE || this.mode === this.S_POLE) {
                if (this.mode === this.N_POLE && (p = -p), !(o = c * c + p * p))
                    return t.x = this.long0, t.y = this.lat0, t;
                a = 1 - o / this.qp,
                this.mode === this.S_POLE && (a = -a)
            }
            e = Math.atan2(c, p),
            u = Math.asin(a),
            l = this.apa,
            h = u + u,
            n = u + l[0] * Math.sin(h) + l[1] * Math.sin(h + h) + l[2] * Math.sin(h + h + h)
        }
        return t.x = Xp(this.long0 + e), t.y = n, t
    },
    names: ["Lambert Azimuthal Equal Area", "Lambert_Azimuthal_Equal_Area", "laea"],
    S_POLE: 1,
    N_POLE: 2,
    EQUIT: 3,
    OBLIQ: 4
};
function Td(t) {
    return Math.abs(t) > 1 && (t = t > 1 ? 1 : -1), Math.asin(t)
}
var Pd = {
    init: function() {
        Math.abs(this.lat1 + this.lat2) < 1e-10 || (this.temp = this.b / this.a, this.es = 1 - Math.pow(this.temp, 2), this.e3 = Math.sqrt(this.es), this.sin_po = Math.sin(this.lat1), this.cos_po = Math.cos(this.lat1), this.t1 = this.sin_po, this.con = this.sin_po, this.ms1 = Up(this.e3, this.sin_po, this.cos_po), this.qs1 = Sd(this.e3, this.sin_po, this.cos_po), this.sin_po = Math.sin(this.lat2), this.cos_po = Math.cos(this.lat2), this.t2 = this.sin_po, this.ms2 = Up(this.e3, this.sin_po, this.cos_po), this.qs2 = Sd(this.e3, this.sin_po, this.cos_po), this.sin_po = Math.sin(this.lat0), this.cos_po = Math.cos(this.lat0), this.t3 = this.sin_po, this.qs0 = Sd(this.e3, this.sin_po, this.cos_po), Math.abs(this.lat1 - this.lat2) > 1e-10 ? this.ns0 = (this.ms1 * this.ms1 - this.ms2 * this.ms2) / (this.qs2 - this.qs1) : this.ns0 = this.con, this.c = this.ms1 * this.ms1 + this.ns0 * this.qs1, this.rh = this.a * Math.sqrt(this.c - this.ns0 * this.qs0) / this.ns0)
    },
    forward: function(t) {
        var e = t.x,
            n = t.y;
        this.sin_phi = Math.sin(n),
        this.cos_phi = Math.cos(n);
        var r = Sd(this.e3, this.sin_phi, this.cos_phi),
            i = this.a * Math.sqrt(this.c - this.ns0 * r) / this.ns0,
            o = this.ns0 * Xp(e - this.long0),
            s = i * Math.sin(o) + this.x0,
            a = this.rh - i * Math.cos(o) + this.y0;
        return t.x = s, t.y = a, t
    },
    inverse: function(t) {
        var e,
            n,
            r,
            i,
            o,
            s;
        return t.x -= this.x0, t.y = this.rh - t.y + this.y0, this.ns0 >= 0 ? (e = Math.sqrt(t.x * t.x + t.y * t.y), r = 1) : (e = -Math.sqrt(t.x * t.x + t.y * t.y), r = -1), i = 0, 0 !== e && (i = Math.atan2(r * t.x, r * t.y)), r = e * this.ns0 / this.a, this.sphere ? s = Math.asin((this.c - r * r) / (2 * this.ns0)) : (n = (this.c - r * r) / this.ns0, s = this.phi1z(this.e3, n)), o = Xp(i / this.ns0 + this.long0), t.x = o, t.y = s, t
    },
    names: ["Albers_Conic_Equal_Area", "Albers", "aea"],
    phi1z: function(t, e) {
        var n,
            r,
            i,
            o,
            s = Td(.5 * e);
        if (t < 1e-10)
            return s;
        for (var a = t * t, u = 1; u <= 25; u++)
            if (s += o = .5 * (i = 1 - (r = t * (n = Math.sin(s))) * r) * i / Math.cos(s) * (e / (1 - a) - n / i + .5 / t * Math.log((1 - r) / (1 + r))), Math.abs(o) <= 1e-7)
                return s;
        return null
    }
};
var Ld = {
    init: function() {
        this.sin_p14 = Math.sin(this.lat0),
        this.cos_p14 = Math.cos(this.lat0),
        this.infinity_dist = 1e3 * this.a,
        this.rc = 1
    },
    forward: function(t) {
        var e,
            n,
            r,
            i,
            o,
            s,
            a,
            u = t.x,
            l = t.y;
        return r = Xp(u - this.long0), e = Math.sin(l), n = Math.cos(l), i = Math.cos(r), 1, (o = this.sin_p14 * e + this.cos_p14 * n * i) > 0 || Math.abs(o) <= 1e-10 ? (s = this.x0 + 1 * this.a * n * Math.sin(r) / o, a = this.y0 + 1 * this.a * (this.cos_p14 * e - this.sin_p14 * n * i) / o) : (s = this.x0 + this.infinity_dist * n * Math.sin(r), a = this.y0 + this.infinity_dist * (this.cos_p14 * e - this.sin_p14 * n * i)), t.x = s, t.y = a, t
    },
    inverse: function(t) {
        var e,
            n,
            r,
            i,
            o,
            s;
        return t.x = (t.x - this.x0) / this.a, t.y = (t.y - this.y0) / this.a, t.x /= this.k0, t.y /= this.k0, (e = Math.sqrt(t.x * t.x + t.y * t.y)) ? (i = Math.atan2(e, this.rc), n = Math.sin(i), s = Td((r = Math.cos(i)) * this.sin_p14 + t.y * n * this.cos_p14 / e), o = Math.atan2(t.x * n, e * this.cos_p14 * r - t.y * this.sin_p14 * n), o = Xp(this.long0 + o)) : (s = this.phic0, o = 0), t.x = o, t.y = s, t
    },
    names: ["gnom"]
};
function Od(t, e) {
    var n = 1 - (1 - t * t) / (2 * t) * Math.log((1 - t) / (1 + t));
    if (Math.abs(Math.abs(e) - n) < 1e-6)
        return e < 0 ? -1 * mp : mp;
    for (var r, i, o, s, a = Math.asin(.5 * e), u = 0; u < 30; u++)
        if (i = Math.sin(a), o = Math.cos(a), s = t * i, a += r = Math.pow(1 - s * s, 2) / (2 * o) * (e / (1 - t * t) - i / (1 - s * s) + .5 / t * Math.log((1 - s) / (1 + s))), Math.abs(r) <= 1e-10)
            return a;
    return NaN
}
var Nd = {
    init: function() {
        this.sphere || (this.k0 = Up(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts)))
    },
    forward: function(t) {
        var e,
            n,
            r = t.x,
            i = t.y,
            o = Xp(r - this.long0);
        if (this.sphere)
            e = this.x0 + this.a * o * Math.cos(this.lat_ts),
            n = this.y0 + this.a * Math.sin(i) / Math.cos(this.lat_ts);
        else {
            var s = Sd(this.e, Math.sin(i));
            e = this.x0 + this.a * this.k0 * o,
            n = this.y0 + this.a * s * .5 / this.k0
        }
        return t.x = e, t.y = n, t
    },
    inverse: function(t) {
        var e,
            n;
        return t.x -= this.x0, t.y -= this.y0, this.sphere ? (e = Xp(this.long0 + t.x / this.a / Math.cos(this.lat_ts)), n = Math.asin(t.y / this.a * Math.cos(this.lat_ts))) : (n = Od(this.e, 2 * t.y * this.k0 / this.a), e = Xp(this.long0 + t.x / (this.a * this.k0))), t.x = e, t.y = n, t
    },
    names: ["cea"]
};
var Rd = {
    init: function() {
        this.x0 = this.x0 || 0,
        this.y0 = this.y0 || 0,
        this.lat0 = this.lat0 || 0,
        this.long0 = this.long0 || 0,
        this.lat_ts = this.lat_ts || 0,
        this.title = this.title || "Equidistant Cylindrical (Plate Carre)",
        this.rc = Math.cos(this.lat_ts)
    },
    forward: function(t) {
        var e = t.x,
            n = t.y,
            r = Xp(e - this.long0),
            i = bd(n - this.lat0);
        return t.x = this.x0 + this.a * r * this.rc, t.y = this.y0 + this.a * i, t
    },
    inverse: function(t) {
        var e = t.x,
            n = t.y;
        return t.x = Xp(this.long0 + (e - this.x0) / (this.a * this.rc)), t.y = bd(this.lat0 + (n - this.y0) / this.a), t
    },
    names: ["Equirectangular", "Equidistant_Cylindrical", "eqc"]
};
var Ad = {
    init: function() {
        this.temp = this.b / this.a,
        this.es = 1 - Math.pow(this.temp, 2),
        this.e = Math.sqrt(this.es),
        this.e0 = md(this.es),
        this.e1 = _d(this.es),
        this.e2 = xd(this.es),
        this.e3 = Ed(this.es),
        this.ml0 = this.a * vd(this.e0, this.e1, this.e2, this.e3, this.lat0)
    },
    forward: function(t) {
        var e,
            n,
            r,
            i = t.x,
            o = t.y,
            s = Xp(i - this.long0);
        if (r = s * Math.sin(o), this.sphere)
            Math.abs(o) <= 1e-10 ? (e = this.a * s, n = -1 * this.a * this.lat0) : (e = this.a * Math.sin(r) / Math.tan(o), n = this.a * (bd(o - this.lat0) + (1 - Math.cos(r)) / Math.tan(o)));
        else if (Math.abs(o) <= 1e-10)
            e = this.a * s,
            n = -1 * this.ml0;
        else {
            var a = wd(this.a, this.e, Math.sin(o)) / Math.tan(o);
            e = a * Math.sin(r),
            n = this.a * vd(this.e0, this.e1, this.e2, this.e3, o) - this.ml0 + a * (1 - Math.cos(r))
        }
        return t.x = e + this.x0, t.y = n + this.y0, t
    },
    inverse: function(t) {
        var e,
            n,
            r,
            i,
            o,
            s,
            a,
            u,
            l;
        if (r = t.x - this.x0, i = t.y - this.y0, this.sphere)
            if (Math.abs(i + this.a * this.lat0) <= 1e-10)
                e = Xp(r / this.a + this.long0),
                n = 0;
            else {
                var h;
                for (s = this.lat0 + i / this.a, a = r * r / this.a / this.a + s * s, u = s, o = 20; o; --o)
                    if (u += l = -1 * (s * (u * (h = Math.tan(u)) + 1) - u - .5 * (u * u + a) * h) / ((u - s) / h - 1), Math.abs(l) <= 1e-10) {
                        n = u;
                        break
                    }
                e = Xp(this.long0 + Math.asin(r * Math.tan(u) / this.a) / Math.sin(n))
            }
        else if (Math.abs(i + this.ml0) <= 1e-10)
            n = 0,
            e = Xp(this.long0 + r / this.a);
        else {
            var c,
                p,
                f,
                d,
                g;
            for (s = (this.ml0 + i) / this.a, a = r * r / this.a / this.a + s * s, u = s, o = 20; o; --o)
                if (g = this.e * Math.sin(u), c = Math.sqrt(1 - g * g) * Math.tan(u), p = this.a * vd(this.e0, this.e1, this.e2, this.e3, u), f = this.e0 - 2 * this.e1 * Math.cos(2 * u) + 4 * this.e2 * Math.cos(4 * u) - 6 * this.e3 * Math.cos(6 * u), u -= l = (s * (c * (d = p / this.a) + 1) - d - .5 * c * (d * d + a)) / (this.es * Math.sin(2 * u) * (d * d + a - 2 * s * d) / (4 * c) + (s - d) * (c * f - 2 / Math.sin(2 * u)) - f), Math.abs(l) <= 1e-10) {
                    n = u;
                    break
                }
            c = Math.sqrt(1 - this.es * Math.pow(Math.sin(n), 2)) * Math.tan(n),
            e = Xp(this.long0 + Math.asin(r * c / this.a) / Math.sin(n))
        }
        return t.x = e, t.y = n, t
    },
    names: ["Polyconic", "poly"]
};
var Dd = {
    init: function() {
        this.A = [],
        this.A[1] = .6399175073,
        this.A[2] = -.1358797613,
        this.A[3] = .063294409,
        this.A[4] = -.02526853,
        this.A[5] = .0117879,
        this.A[6] = -.0055161,
        this.A[7] = .0026906,
        this.A[8] = -.001333,
        this.A[9] = 67e-5,
        this.A[10] = -34e-5,
        this.B_re = [],
        this.B_im = [],
        this.B_re[1] = .7557853228,
        this.B_im[1] = 0,
        this.B_re[2] = .249204646,
        this.B_im[2] = .003371507,
        this.B_re[3] = -.001541739,
        this.B_im[3] = .04105856,
        this.B_re[4] = -.10162907,
        this.B_im[4] = .01727609,
        this.B_re[5] = -.26623489,
        this.B_im[5] = -.36249218,
        this.B_re[6] = -.6870983,
        this.B_im[6] = -1.1651967,
        this.C_re = [],
        this.C_im = [],
        this.C_re[1] = 1.3231270439,
        this.C_im[1] = 0,
        this.C_re[2] = -.577245789,
        this.C_im[2] = -.007809598,
        this.C_re[3] = .508307513,
        this.C_im[3] = -.112208952,
        this.C_re[4] = -.15094762,
        this.C_im[4] = .18200602,
        this.C_re[5] = 1.01418179,
        this.C_im[5] = 1.64497696,
        this.C_re[6] = 1.9660549,
        this.C_im[6] = 2.5127645,
        this.D = [],
        this.D[1] = 1.5627014243,
        this.D[2] = .5185406398,
        this.D[3] = -.03333098,
        this.D[4] = -.1052906,
        this.D[5] = -.0368594,
        this.D[6] = .007317,
        this.D[7] = .0122,
        this.D[8] = .00394,
        this.D[9] = -.0013
    },
    forward: function(t) {
        var e,
            n = t.x,
            r = (t.y - this.lat0) / 484813681109536e-20 * 1e-5,
            i = n - this.long0,
            o = 1,
            s = 0;
        for (e = 1; e <= 10; e++)
            o *= r,
            s += this.A[e] * o;
        var a,
            u = s,
            l = i,
            h = 1,
            c = 0,
            p = 0,
            f = 0;
        for (e = 1; e <= 6; e++)
            a = c * u + h * l,
            h = h * u - c * l,
            c = a,
            p = p + this.B_re[e] * h - this.B_im[e] * c,
            f = f + this.B_im[e] * h + this.B_re[e] * c;
        return t.x = f * this.a + this.x0, t.y = p * this.a + this.y0, t
    },
    inverse: function(t) {
        var e,
            n,
            r = t.x,
            i = t.y,
            o = r - this.x0,
            s = (i - this.y0) / this.a,
            a = o / this.a,
            u = 1,
            l = 0,
            h = 0,
            c = 0;
        for (e = 1; e <= 6; e++)
            n = l * s + u * a,
            u = u * s - l * a,
            l = n,
            h = h + this.C_re[e] * u - this.C_im[e] * l,
            c = c + this.C_im[e] * u + this.C_re[e] * l;
        for (var p = 0; p < this.iterations; p++) {
            var f,
                d = h,
                g = c,
                y = s,
                v = a;
            for (e = 2; e <= 6; e++)
                f = g * h + d * c,
                d = d * h - g * c,
                g = f,
                y += (e - 1) * (this.B_re[e] * d - this.B_im[e] * g),
                v += (e - 1) * (this.B_im[e] * d + this.B_re[e] * g);
            d = 1,
            g = 0;
            var m = this.B_re[1],
                _ = this.B_im[1];
            for (e = 2; e <= 6; e++)
                f = g * h + d * c,
                d = d * h - g * c,
                g = f,
                m += e * (this.B_re[e] * d - this.B_im[e] * g),
                _ += e * (this.B_im[e] * d + this.B_re[e] * g);
            var x = m * m + _ * _;
            h = (y * m + v * _) / x,
            c = (v * m - y * _) / x
        }
        var E = h,
            w = c,
            b = 1,
            C = 0;
        for (e = 1; e <= 9; e++)
            b *= E,
            C += this.D[e] * b;
        var M = this.lat0 + 484813681109536e-20 * C * 1e5,
            S = this.long0 + w;
        return t.x = S, t.y = M, t
    },
    names: ["New_Zealand_Map_Grid", "nzmg"]
};
var Fd = {
    init: function() {},
    forward: function(t) {
        var e = t.x,
            n = t.y,
            r = Xp(e - this.long0),
            i = this.x0 + this.a * r,
            o = this.y0 + this.a * Math.log(Math.tan(Math.PI / 4 + n / 2.5)) * 1.25;
        return t.x = i, t.y = o, t
    },
    inverse: function(t) {
        t.x -= this.x0,
        t.y -= this.y0;
        var e = Xp(this.long0 + t.x / this.a),
            n = 2.5 * (Math.atan(Math.exp(.8 * t.y / this.a)) - Math.PI / 4);
        return t.x = e, t.y = n, t
    },
    names: ["Miller_Cylindrical", "mill"]
};
var kd = {
    init: function() {
        this.sphere ? (this.n = 1, this.m = 0, this.es = 0, this.C_y = Math.sqrt((this.m + 1) / this.n), this.C_x = this.C_y / (this.m + 1)) : this.en = Wf(this.es)
    },
    forward: function(t) {
        var e,
            n,
            r = t.x,
            i = t.y;
        if (r = Xp(r - this.long0), this.sphere) {
            if (this.m)
                for (var o = this.n * Math.sin(i), s = 20; s; --s) {
                    var a = (this.m * i + Math.sin(i) - o) / (this.m + Math.cos(i));
                    if (i -= a, Math.abs(a) < 1e-10)
                        break
                }
            else
                i = 1 !== this.n ? Math.asin(this.n * Math.sin(i)) : i;
            e = this.a * this.C_x * r * (this.m + Math.cos(i)),
            n = this.a * this.C_y * i
        } else {
            var u = Math.sin(i),
                l = Math.cos(i);
            n = this.a * $f(i, u, l, this.en),
            e = this.a * r * l / Math.sqrt(1 - this.es * u * u)
        }
        return t.x = e, t.y = n, t
    },
    inverse: function(t) {
        var e,
            n,
            r;
        return t.x -= this.x0, n = t.x / this.a, t.y -= this.y0, e = t.y / this.a, this.sphere ? (e /= this.C_y, n /= this.C_x * (this.m + Math.cos(e)), this.m ? e = Td((this.m * e + Math.sin(e)) / this.n) : 1 !== this.n && (e = Td(Math.sin(e) / this.n)), n = Xp(n + this.long0), e = bd(e)) : (e = Kf(t.y / this.a, this.es, this.en), (r = Math.abs(e)) < mp ? (r = Math.sin(e), n = Xp(this.long0 + t.x * Math.sqrt(1 - this.es * r * r) / (this.a * Math.cos(e)))) : r - 1e-10 < mp && (n = this.long0)), t.x = n, t.y = e, t
    },
    names: ["Sinusoidal", "sinu"]
};
var jd = {
    init: function() {},
    forward: function(t) {
        for (var e = t.x, n = t.y, r = Xp(e - this.long0), i = n, o = Math.PI * Math.sin(n);;) {
            var s = -(i + Math.sin(i) - o) / (1 + Math.cos(i));
            if (i += s, Math.abs(s) < 1e-10)
                break
        }
        i /= 2,
        Math.PI / 2 - Math.abs(n) < 1e-10 && (r = 0);
        var a = .900316316158 * this.a * r * Math.cos(i) + this.x0,
            u = 1.4142135623731 * this.a * Math.sin(i) + this.y0;
        return t.x = a, t.y = u, t
    },
    inverse: function(t) {
        var e,
            n;
        t.x -= this.x0,
        t.y -= this.y0,
        n = t.y / (1.4142135623731 * this.a),
        Math.abs(n) > .999999999999 && (n = .999999999999),
        e = Math.asin(n);
        var r = Xp(this.long0 + t.x / (.900316316158 * this.a * Math.cos(e)));
        r < -Math.PI && (r = -Math.PI),
        r > Math.PI && (r = Math.PI),
        n = (2 * e + Math.sin(2 * e)) / Math.PI,
        Math.abs(n) > 1 && (n = 1);
        var i = Math.asin(n);
        return t.x = r, t.y = i, t
    },
    names: ["Mollweide", "moll"]
};
var Gd = {
    init: function() {
        Math.abs(this.lat1 + this.lat2) < 1e-10 || (this.lat2 = this.lat2 || this.lat1, this.temp = this.b / this.a, this.es = 1 - Math.pow(this.temp, 2), this.e = Math.sqrt(this.es), this.e0 = md(this.es), this.e1 = _d(this.es), this.e2 = xd(this.es), this.e3 = Ed(this.es), this.sinphi = Math.sin(this.lat1), this.cosphi = Math.cos(this.lat1), this.ms1 = Up(this.e, this.sinphi, this.cosphi), this.ml1 = vd(this.e0, this.e1, this.e2, this.e3, this.lat1), Math.abs(this.lat1 - this.lat2) < 1e-10 ? this.ns = this.sinphi : (this.sinphi = Math.sin(this.lat2), this.cosphi = Math.cos(this.lat2), this.ms2 = Up(this.e, this.sinphi, this.cosphi), this.ml2 = vd(this.e0, this.e1, this.e2, this.e3, this.lat2), this.ns = (this.ms1 - this.ms2) / (this.ml2 - this.ml1)), this.g = this.ml1 + this.ms1 / this.ns, this.ml0 = vd(this.e0, this.e1, this.e2, this.e3, this.lat0), this.rh = this.a * (this.g - this.ml0))
    },
    forward: function(t) {
        var e,
            n = t.x,
            r = t.y;
        if (this.sphere)
            e = this.a * (this.g - r);
        else {
            var i = vd(this.e0, this.e1, this.e2, this.e3, r);
            e = this.a * (this.g - i)
        }
        var o = this.ns * Xp(n - this.long0),
            s = this.x0 + e * Math.sin(o),
            a = this.y0 + this.rh - e * Math.cos(o);
        return t.x = s, t.y = a, t
    },
    inverse: function(t) {
        var e,
            n,
            r,
            i;
        t.x -= this.x0,
        t.y = this.rh - t.y + this.y0,
        this.ns >= 0 ? (n = Math.sqrt(t.x * t.x + t.y * t.y), e = 1) : (n = -Math.sqrt(t.x * t.x + t.y * t.y), e = -1);
        var o = 0;
        return 0 !== n && (o = Math.atan2(e * t.x, e * t.y)), this.sphere ? (i = Xp(this.long0 + o / this.ns), r = bd(this.g - n / this.a), t.x = i, t.y = r, t) : (r = Cd(this.g - n / this.a, this.e0, this.e1, this.e2, this.e3), i = Xp(this.long0 + o / this.ns), t.x = i, t.y = r, t)
    },
    names: ["Equidistant_Conic", "eqdc"]
};
var Bd = {
    init: function() {
        this.R = this.a
    },
    forward: function(t) {
        var e,
            n,
            r = t.x,
            i = t.y,
            o = Xp(r - this.long0);
        Math.abs(i) <= 1e-10 && (e = this.x0 + this.R * o, n = this.y0);
        var s = Td(2 * Math.abs(i / Math.PI));
        (Math.abs(o) <= 1e-10 || Math.abs(Math.abs(i) - mp) <= 1e-10) && (e = this.x0, n = i >= 0 ? this.y0 + Math.PI * this.R * Math.tan(.5 * s) : this.y0 + Math.PI * this.R * -Math.tan(.5 * s));
        var a = .5 * Math.abs(Math.PI / o - o / Math.PI),
            u = a * a,
            l = Math.sin(s),
            h = Math.cos(s),
            c = h / (l + h - 1),
            p = c * c,
            f = c * (2 / l - 1),
            d = f * f,
            g = Math.PI * this.R * (a * (c - d) + Math.sqrt(u * (c - d) * (c - d) - (d + u) * (p - d))) / (d + u);
        o < 0 && (g = -g),
        e = this.x0 + g;
        var y = u + c;
        return g = Math.PI * this.R * (f * y - a * Math.sqrt((d + u) * (u + 1) - y * y)) / (d + u), n = i >= 0 ? this.y0 + g : this.y0 - g, t.x = e, t.y = n, t
    },
    inverse: function(t) {
        var e,
            n,
            r,
            i,
            o,
            s,
            a,
            u,
            l,
            h,
            c,
            p;
        return t.x -= this.x0, t.y -= this.y0, c = Math.PI * this.R, o = (r = t.x / c) * r + (i = t.y / c) * i, c = 3 * (i * i / (u = -2 * (s = -Math.abs(i) * (1 + o)) + 1 + 2 * i * i + o * o) + (2 * (a = s - 2 * i * i + r * r) * a * a / u / u / u - 9 * s * a / u / u) / 27) / (l = (s - a * a / 3 / u) / u) / (h = 2 * Math.sqrt(-l / 3)), Math.abs(c) > 1 && (c = c >= 0 ? 1 : -1), p = Math.acos(c) / 3, n = t.y >= 0 ? (-h * Math.cos(p + Math.PI / 3) - a / 3 / u) * Math.PI : -(-h * Math.cos(p + Math.PI / 3) - a / 3 / u) * Math.PI, e = Math.abs(r) < 1e-10 ? this.long0 : Xp(this.long0 + Math.PI * (o - 1 + Math.sqrt(1 + 2 * (r * r - i * i) + o * o)) / 2 / r), t.x = e, t.y = n, t
    },
    names: ["Van_der_Grinten_I", "VanDerGrinten", "vandg"]
};
var qd = {
    init: function() {
        this.sin_p12 = Math.sin(this.lat0),
        this.cos_p12 = Math.cos(this.lat0)
    },
    forward: function(t) {
        var e,
            n,
            r,
            i,
            o,
            s,
            a,
            u,
            l,
            h,
            c,
            p,
            f,
            d,
            g,
            y,
            v,
            m,
            _,
            x,
            E,
            w,
            b = t.x,
            C = t.y,
            M = Math.sin(t.y),
            S = Math.cos(t.y),
            I = Xp(b - this.long0);
        return this.sphere ? Math.abs(this.sin_p12 - 1) <= 1e-10 ? (t.x = this.x0 + this.a * (mp - C) * Math.sin(I), t.y = this.y0 - this.a * (mp - C) * Math.cos(I), t) : Math.abs(this.sin_p12 + 1) <= 1e-10 ? (t.x = this.x0 + this.a * (mp + C) * Math.sin(I), t.y = this.y0 + this.a * (mp + C) * Math.cos(I), t) : (m = this.sin_p12 * M + this.cos_p12 * S * Math.cos(I), v = (y = Math.acos(m)) ? y / Math.sin(y) : 1, t.x = this.x0 + this.a * v * S * Math.sin(I), t.y = this.y0 + this.a * v * (this.cos_p12 * M - this.sin_p12 * S * Math.cos(I)), t) : (e = md(this.es), n = _d(this.es), r = xd(this.es), i = Ed(this.es), Math.abs(this.sin_p12 - 1) <= 1e-10 ? (o = this.a * vd(e, n, r, i, mp), s = this.a * vd(e, n, r, i, C), t.x = this.x0 + (o - s) * Math.sin(I), t.y = this.y0 - (o - s) * Math.cos(I), t) : Math.abs(this.sin_p12 + 1) <= 1e-10 ? (o = this.a * vd(e, n, r, i, mp), s = this.a * vd(e, n, r, i, C), t.x = this.x0 + (o + s) * Math.sin(I), t.y = this.y0 + (o + s) * Math.cos(I), t) : (a = M / S, u = wd(this.a, this.e, this.sin_p12), l = wd(this.a, this.e, M), h = Math.atan((1 - this.es) * a + this.es * u * this.sin_p12 / (l * S)), _ = 0 === (c = Math.atan2(Math.sin(I), this.cos_p12 * Math.tan(h) - this.sin_p12 * Math.cos(I))) ? Math.asin(this.cos_p12 * Math.sin(h) - this.sin_p12 * Math.cos(h)) : Math.abs(Math.abs(c) - Math.PI) <= 1e-10 ? -Math.asin(this.cos_p12 * Math.sin(h) - this.sin_p12 * Math.cos(h)) : Math.asin(Math.sin(I) * Math.cos(h) / Math.sin(c)), p = this.e * this.sin_p12 / Math.sqrt(1 - this.es), y = u * _ * (1 - (x = _ * _) * (g = (f = this.e * this.cos_p12 * Math.cos(c) / Math.sqrt(1 - this.es)) * f) * (1 - g) / 6 + (E = x * _) / 8 * (d = p * f) * (1 - 2 * g) + (w = E * _) / 120 * (g * (4 - 7 * g) - 3 * p * p * (1 - 7 * g)) - w * _ / 48 * d), t.x = this.x0 + y * Math.sin(c), t.y = this.y0 + y * Math.cos(c), t))
    },
    inverse: function(t) {
        var e,
            n,
            r,
            i,
            o,
            s,
            a,
            u,
            l,
            h,
            c,
            p,
            f,
            d,
            g,
            y,
            v,
            m,
            _,
            x,
            E,
            w,
            b;
        if (t.x -= this.x0, t.y -= this.y0, this.sphere) {
            if ((e = Math.sqrt(t.x * t.x + t.y * t.y)) > 2 * mp * this.a)
                return;
            return n = e / this.a, r = Math.sin(n), i = Math.cos(n), o = this.long0, Math.abs(e) <= 1e-10 ? s = this.lat0 : (s = Td(i * this.sin_p12 + t.y * r * this.cos_p12 / e), a = Math.abs(this.lat0) - mp, o = Math.abs(a) <= 1e-10 ? this.lat0 >= 0 ? Xp(this.long0 + Math.atan2(t.x, -t.y)) : Xp(this.long0 - Math.atan2(-t.x, t.y)) : Xp(this.long0 + Math.atan2(t.x * r, e * this.cos_p12 * i - t.y * this.sin_p12 * r))), t.x = o, t.y = s, t
        }
        return u = md(this.es), l = _d(this.es), h = xd(this.es), c = Ed(this.es), Math.abs(this.sin_p12 - 1) <= 1e-10 ? (s = Cd(((p = this.a * vd(u, l, h, c, mp)) - (e = Math.sqrt(t.x * t.x + t.y * t.y))) / this.a, u, l, h, c), o = Xp(this.long0 + Math.atan2(t.x, -1 * t.y)), t.x = o, t.y = s, t) : Math.abs(this.sin_p12 + 1) <= 1e-10 ? (p = this.a * vd(u, l, h, c, mp), s = Cd(((e = Math.sqrt(t.x * t.x + t.y * t.y)) - p) / this.a, u, l, h, c), o = Xp(this.long0 + Math.atan2(t.x, t.y)), t.x = o, t.y = s, t) : (e = Math.sqrt(t.x * t.x + t.y * t.y), g = Math.atan2(t.x, t.y), f = wd(this.a, this.e, this.sin_p12), y = Math.cos(g), m = -(v = this.e * this.cos_p12 * y) * v / (1 - this.es), _ = 3 * this.es * (1 - m) * this.sin_p12 * this.cos_p12 * y / (1 - this.es), w = 1 - m * (E = (x = e / f) - m * (1 + m) * Math.pow(x, 3) / 6 - _ * (1 + 3 * m) * Math.pow(x, 4) / 24) * E / 2 - x * E * E * E / 6, d = Math.asin(this.sin_p12 * Math.cos(E) + this.cos_p12 * Math.sin(E) * y), o = Xp(this.long0 + Math.asin(Math.sin(g) * Math.sin(E) / Math.cos(d))), b = Math.sin(d), s = Math.atan2((b - this.es * w * this.sin_p12) * Math.tan(d), b * (1 - this.es)), t.x = o, t.y = s, t)
    },
    names: ["Azimuthal_Equidistant", "aeqd"]
};
var zd = {
        init: function() {
            this.sin_p14 = Math.sin(this.lat0),
            this.cos_p14 = Math.cos(this.lat0)
        },
        forward: function(t) {
            var e,
                n,
                r,
                i,
                o,
                s,
                a,
                u = t.x,
                l = t.y;
            return r = Xp(u - this.long0), e = Math.sin(l), n = Math.cos(l), i = Math.cos(r), 1, ((o = this.sin_p14 * e + this.cos_p14 * n * i) > 0 || Math.abs(o) <= 1e-10) && (s = 1 * this.a * n * Math.sin(r), a = this.y0 + 1 * this.a * (this.cos_p14 * e - this.sin_p14 * n * i)), t.x = s, t.y = a, t
        },
        inverse: function(t) {
            var e,
                n,
                r,
                i,
                o,
                s,
                a;
            return t.x -= this.x0, t.y -= this.y0, n = Td((e = Math.sqrt(t.x * t.x + t.y * t.y)) / this.a), r = Math.sin(n), i = Math.cos(n), s = this.long0, Math.abs(e) <= 1e-10 ? (a = this.lat0, t.x = s, t.y = a, t) : (a = Td(i * this.sin_p14 + t.y * r * this.cos_p14 / e), o = Math.abs(this.lat0) - mp, Math.abs(o) <= 1e-10 ? (s = this.lat0 >= 0 ? Xp(this.long0 + Math.atan2(t.x, -t.y)) : Xp(this.long0 - Math.atan2(-t.x, t.y)), t.x = s, t.y = a, t) : (s = Xp(this.long0 + Math.atan2(t.x * r, e * this.cos_p14 * i - t.y * this.sin_p14 * r)), t.x = s, t.y = a, t))
        },
        names: ["ortho"]
    },
    Ud = 1,
    Vd = 2,
    Xd = 3,
    Hd = 4,
    Yd = 5,
    Wd = 6,
    $d = 1,
    Kd = 2,
    Zd = 3,
    Jd = 4;
function Qd(t, e, n, r) {
    var i;
    return t < 1e-10 ? (r.value = $d, i = 0) : (i = Math.atan2(e, n), Math.abs(i) <= _p ? r.value = $d : i > _p && i <= mp + _p ? (r.value = Kd, i -= mp) : i > mp + _p || i <= -(mp + _p) ? (r.value = Zd, i = i >= 0 ? i - 3.14159265359 : i + 3.14159265359) : (r.value = Jd, i += mp)), i
}
function tg(t, e) {
    var n = t + e;
    return n < -3.14159265359 ? n += xp : n > 3.14159265359 && (n -= xp), n
}
var eg = {
        init: function() {
            this.x0 = this.x0 || 0,
            this.y0 = this.y0 || 0,
            this.lat0 = this.lat0 || 0,
            this.long0 = this.long0 || 0,
            this.lat_ts = this.lat_ts || 0,
            this.title = this.title || "Quadrilateralized Spherical Cube",
            this.lat0 >= mp - _p / 2 ? this.face = Yd : this.lat0 <= -(mp - _p / 2) ? this.face = Wd : Math.abs(this.long0) <= _p ? this.face = Ud : Math.abs(this.long0) <= mp + _p ? this.face = this.long0 > 0 ? Vd : Hd : this.face = Xd,
            0 !== this.es && (this.one_minus_f = 1 - (this.a - this.b) / this.a, this.one_minus_f_squared = this.one_minus_f * this.one_minus_f)
        },
        forward: function(t) {
            var e,
                n,
                r,
                i,
                o,
                s,
                a = {
                    x: 0,
                    y: 0
                },
                u = {
                    value: 0
                };
            if (t.x -= this.long0, e = 0 !== this.es ? Math.atan(this.one_minus_f_squared * Math.tan(t.y)) : t.y, n = t.x, this.face === Yd)
                i = mp - e,
                n >= _p && n <= mp + _p ? (u.value = $d, r = n - mp) : n > mp + _p || n <= -(mp + _p) ? (u.value = Kd, r = n > 0 ? n - 3.14159265359 : n + 3.14159265359) : n > -(mp + _p) && n <= -_p ? (u.value = Zd, r = n + mp) : (u.value = Jd, r = n);
            else if (this.face === Wd)
                i = mp + e,
                n >= _p && n <= mp + _p ? (u.value = $d, r = -n + mp) : n < _p && n >= -_p ? (u.value = Kd, r = -n) : n < -_p && n >= -(mp + _p) ? (u.value = Zd, r = -n - mp) : (u.value = Jd, r = n > 0 ? 3.14159265359 - n : -n - 3.14159265359);
            else {
                var l,
                    h,
                    c,
                    p,
                    f,
                    d;
                this.face === Vd ? n = tg(n, +mp) : this.face === Xd ? n = tg(n, 3.14159265359) : this.face === Hd && (n = tg(n, -mp)),
                p = Math.sin(e),
                f = Math.cos(e),
                d = Math.sin(n),
                l = f * Math.cos(n),
                h = f * d,
                c = p,
                this.face === Ud ? r = Qd(i = Math.acos(l), c, h, u) : this.face === Vd ? r = Qd(i = Math.acos(h), c, -l, u) : this.face === Xd ? r = Qd(i = Math.acos(-l), c, -h, u) : this.face === Hd ? r = Qd(i = Math.acos(-h), c, l, u) : (i = r = 0, u.value = $d)
            }
            return s = Math.atan(12 / 3.14159265359 * (r + Math.acos(Math.sin(r) * Math.cos(_p)) - mp)), o = Math.sqrt((1 - Math.cos(i)) / (Math.cos(s) * Math.cos(s)) / (1 - Math.cos(Math.atan(1 / Math.cos(r))))), u.value === Kd ? s += mp : u.value === Zd ? s += 3.14159265359 : u.value === Jd && (s += 1.5 * 3.14159265359), a.x = o * Math.cos(s), a.y = o * Math.sin(s), a.x = a.x * this.a + this.x0, a.y = a.y * this.a + this.y0, t.x = a.x, t.y = a.y, t
        },
        inverse: function(t) {
            var e,
                n,
                r,
                i,
                o,
                s,
                a,
                u,
                l,
                h,
                c,
                p,
                f = {
                    lam: 0,
                    phi: 0
                },
                d = {
                    value: 0
                };
            if (t.x = (t.x - this.x0) / this.a, t.y = (t.y - this.y0) / this.a, n = Math.atan(Math.sqrt(t.x * t.x + t.y * t.y)), e = Math.atan2(t.y, t.x), t.x >= 0 && t.x >= Math.abs(t.y) ? d.value = $d : t.y >= 0 && t.y >= Math.abs(t.x) ? (d.value = Kd, e -= mp) : t.x < 0 && -t.x >= Math.abs(t.y) ? (d.value = Zd, e = e < 0 ? e + 3.14159265359 : e - 3.14159265359) : (d.value = Jd, e += mp), l = 3.14159265359 / 12 * Math.tan(e), o = Math.sin(l) / (Math.cos(l) - 1 / Math.sqrt(2)), s = Math.atan(o), (a = 1 - (r = Math.cos(e)) * r * (i = Math.tan(n)) * i * (1 - Math.cos(Math.atan(1 / Math.cos(s))))) < -1 ? a = -1 : a > 1 && (a = 1), this.face === Yd)
                u = Math.acos(a),
                f.phi = mp - u,
                d.value === $d ? f.lam = s + mp : d.value === Kd ? f.lam = s < 0 ? s + 3.14159265359 : s - 3.14159265359 : d.value === Zd ? f.lam = s - mp : f.lam = s;
            else if (this.face === Wd)
                u = Math.acos(a),
                f.phi = u - mp,
                d.value === $d ? f.lam = -s + mp : d.value === Kd ? f.lam = -s : d.value === Zd ? f.lam = -s - mp : f.lam = s < 0 ? -s - 3.14159265359 : 3.14159265359 - s;
            else {
                var g,
                    y,
                    v;
                l = (g = a) * g,
                y = (l += (v = l >= 1 ? 0 : Math.sqrt(1 - l) * Math.sin(s)) * v) >= 1 ? 0 : Math.sqrt(1 - l),
                d.value === Kd ? (l = y, y = -v, v = l) : d.value === Zd ? (y = -y, v = -v) : d.value === Jd && (l = y, y = v, v = -l),
                this.face === Vd ? (l = g, g = -y, y = l) : this.face === Xd ? (g = -g, y = -y) : this.face === Hd && (l = g, g = y, y = -l),
                f.phi = Math.acos(-v) - mp,
                f.lam = Math.atan2(y, g),
                this.face === Vd ? f.lam = tg(f.lam, -mp) : this.face === Xd ? f.lam = tg(f.lam, -3.14159265359) : this.face === Hd && (f.lam = tg(f.lam, +mp))
            }
            return 0 !== this.es && (h = f.phi < 0 ? 1 : 0, c = Math.tan(f.phi), p = this.b / Math.sqrt(c * c + this.one_minus_f_squared), f.phi = Math.atan(Math.sqrt(this.a * this.a - p * p) / (this.one_minus_f * p)), h && (f.phi = -f.phi)), f.lam += this.long0, t.x = f.lam, t.y = f.phi, t
        },
        names: ["Quadrilateralized Spherical Cube", "Quadrilateralized_Spherical_Cube", "qsc"]
    },
    ng = [[1, 22199e-21, -715515e-10, 31103e-10], [.9986, -482243e-9, -24897e-9, -13309e-10], [.9954, -83103e-8, -448605e-10, -9.86701e-7], [.99, -.00135364, -59661e-9, 36777e-10], [.9822, -.00167442, -449547e-11, -572411e-11], [.973, -.00214868, -903571e-10, 1.8736e-8], [.96, -.00305085, -900761e-10, 164917e-11], [.9427, -.00382792, -653386e-10, -26154e-10], [.9216, -.00467746, -10457e-8, 481243e-11], [.8962, -.00536223, -323831e-10, -543432e-11], [.8679, -.00609363, -113898e-9, 332484e-11], [.835, -.00698325, -640253e-10, 9.34959e-7], [.7986, -.00755338, -500009e-10, 9.35324e-7], [.7597, -.00798324, -35971e-9, -227626e-11], [.7186, -.00851367, -701149e-10, -86303e-10], [.6732, -.00986209, -199569e-9, 191974e-10], [.6213, -.010418, 883923e-10, 624051e-11], [.5722, -.00906601, 182e-6, 624051e-11], [.5322, -.00677797, 275608e-9, 624051e-11]],
    rg = [[-520417e-23, .0124, 121431e-23, -845284e-16], [.062, .0124, -1.26793e-9, 4.22642e-10], [.124, .0124, 5.07171e-9, -1.60604e-9], [.186, .0123999, -1.90189e-8, 6.00152e-9], [.248, .0124002, 7.10039e-8, -2.24e-8], [.31, .0123992, -2.64997e-7, 8.35986e-8], [.372, .0124029, 9.88983e-7, -3.11994e-7], [.434, .0123893, -369093e-11, -4.35621e-7], [.4958, .0123198, -102252e-10, -3.45523e-7], [.5571, .0121916, -154081e-10, -5.82288e-7], [.6176, .0119938, -241424e-10, -5.25327e-7], [.6769, .011713, -320223e-10, -5.16405e-7], [.7346, .0113541, -397684e-10, -6.09052e-7], [.7903, .0109107, -489042e-10, -104739e-11], [.8435, .0103431, -64615e-9, -1.40374e-9], [.8936, .00969686, -64636e-9, -8547e-9], [.9394, .00840947, -192841e-9, -42106e-10], [.9761, .00616527, -256e-6, -42106e-10], [1, .00328947, -319159e-9, -42106e-10]],
    ig = function(t, e) {
        return t[0] + e * (t[1] + e * (t[2] + e * t[3]))
    };
var og = {
    init: function() {
        this.x0 = this.x0 || 0,
        this.y0 = this.y0 || 0,
        this.long0 = this.long0 || 0,
        this.es = 0,
        this.title = this.title || "Robinson"
    },
    forward: function(t) {
        var e = Xp(t.x - this.long0),
            n = Math.abs(t.y),
            r = Math.floor(11.459155902616464 * n);
        r < 0 ? r = 0 : r >= 18 && (r = 17);
        var i = {
            x: ig(ng[r], n = 57.29577951308232 * (n - .08726646259971647 * r)) * e,
            y: ig(rg[r], n)
        };
        return t.y < 0 && (i.y = -i.y), i.x = i.x * this.a * .8487 + this.x0, i.y = i.y * this.a * 1.3523 + this.y0, i
    },
    inverse: function(t) {
        var e = {
            x: (t.x - this.x0) / (.8487 * this.a),
            y: Math.abs(t.y - this.y0) / (1.3523 * this.a)
        };
        if (e.y >= 1)
            e.x /= ng[18][0],
            e.y = t.y < 0 ? -mp : mp;
        else {
            var n = Math.floor(18 * e.y);
            for (n < 0 ? n = 0 : n >= 18 && (n = 17);;)
                if (rg[n][0] > e.y)
                    --n;
                else {
                    if (!(rg[n + 1][0] <= e.y))
                        break;
                    ++n
                }
            var r = rg[n],
                i = 5 * (e.y - r[0]) / (rg[n + 1][0] - r[0]);
            i = function(t, e, n, r) {
                for (var i = e; r; --r) {
                    var o = t(i);
                    if (i -= o, Math.abs(o) < n)
                        break
                }
                return i
            }((function(t) {
                return (ig(r, t) - e.y) / function(t, e) {
                    return t[1] + e * (2 * t[2] + 3 * e * t[3])
                }(r, t)
            }), i, 1e-10, 100),
            e.x /= ig(ng[n], i),
            e.y = .017453292519943295 * (5 * n + i),
            t.y < 0 && (e.y = -e.y)
        }
        return e.x = Xp(e.x + this.long0), e
    },
    names: ["Robinson", "robin"]
};
var sg = {
        init: function() {
            this.name = "geocent"
        },
        forward: function(t) {
            return mf(t, this.es, this.a)
        },
        inverse: function(t) {
            return _f(t, this.es, this.a, this.b)
        },
        names: ["Geocentric", "geocentric", "geocent", "Geocent"]
    },
    ag = 0,
    ug = 1,
    lg = 2,
    hg = 3,
    cg = {
        h: {
            def: 1e5,
            num: !0
        },
        azi: {
            def: 0,
            num: !0,
            degrees: !0
        },
        tilt: {
            def: 0,
            num: !0,
            degrees: !0
        },
        long0: {
            def: 0,
            num: !0
        },
        lat0: {
            def: 0,
            num: !0
        }
    };
var pg = {
    init: function() {
        if (Object.keys(cg).forEach(function(t) {
            if (void 0 === this[t])
                this[t] = cg[t].def;
            else {
                if (cg[t].num && isNaN(this[t]))
                    throw new Error("Invalid parameter value, must be numeric " + t + " = " + this[t]);
                cg[t].num && (this[t] = parseFloat(this[t]))
            }
            cg[t].degrees && (this[t] = .017453292519943295 * this[t])
        }.bind(this)), Math.abs(Math.abs(this.lat0) - mp) < 1e-10 ? this.mode = this.lat0 < 0 ? ug : ag : Math.abs(this.lat0) < 1e-10 ? this.mode = lg : (this.mode = hg, this.sinph0 = Math.sin(this.lat0), this.cosph0 = Math.cos(this.lat0)), this.pn1 = this.h / this.a, this.pn1 <= 0 || this.pn1 > 1e10)
            throw new Error("Invalid height");
        this.p = 1 + this.pn1,
        this.rp = 1 / this.p,
        this.h1 = 1 / this.pn1,
        this.pfact = (this.p + 1) * this.h1,
        this.es = 0;
        var t = this.tilt,
            e = this.azi;
        this.cg = Math.cos(e),
        this.sg = Math.sin(e),
        this.cw = Math.cos(t),
        this.sw = Math.sin(t)
    },
    forward: function(t) {
        t.x -= this.long0;
        var e,
            n,
            r,
            i,
            o = Math.sin(t.y),
            s = Math.cos(t.y),
            a = Math.cos(t.x);
        switch (this.mode) {
        case hg:
            n = this.sinph0 * o + this.cosph0 * s * a;
            break;
        case lg:
            n = s * a;
            break;
        case ug:
            n = -o;
            break;
        case ag:
            n = o
        }
        switch (e = (n = this.pn1 / (this.p - n)) * s * Math.sin(t.x), this.mode) {
        case hg:
            n *= this.cosph0 * o - this.sinph0 * s * a;
            break;
        case lg:
            n *= o;
            break;
        case ag:
            n *= -s * a;
            break;
        case ug:
            n *= s * a
        }
        return i = 1 / ((r = n * this.cg + e * this.sg) * this.sw * this.h1 + this.cw), e = (e * this.cg - n * this.sg) * this.cw * i, n = r * i, t.x = e * this.a, t.y = n * this.a, t
    },
    inverse: function(t) {
        t.x /= this.a,
        t.y /= this.a;
        var e,
            n,
            r,
            i = {
                x: t.x,
                y: t.y
            };
        r = 1 / (this.pn1 - t.y * this.sw),
        e = this.pn1 * t.x * r,
        n = this.pn1 * t.y * this.cw * r,
        t.x = e * this.cg + n * this.sg,
        t.y = n * this.cg - e * this.sg;
        var o = Qf(t.x, t.y);
        if (Math.abs(o) < 1e-10)
            i.x = 0,
            i.y = t.y;
        else {
            var s,
                a;
            switch (a = 1 - o * o * this.pfact, a = (this.p - Math.sqrt(a)) / (this.pn1 / o + o / this.pn1), s = Math.sqrt(1 - a * a), this.mode) {
            case hg:
                i.y = Math.asin(s * this.sinph0 + t.y * a * this.cosph0 / o),
                t.y = (s - this.sinph0 * Math.sin(i.y)) * o,
                t.x *= a * this.cosph0;
                break;
            case lg:
                i.y = Math.asin(t.y * a / o),
                t.y = s * o,
                t.x *= a;
                break;
            case ag:
                i.y = Math.asin(s),
                t.y = -t.y;
                break;
            case ug:
                i.y = -Math.asin(s)
            }
            i.x = Math.atan2(t.x, t.y)
        }
        return t.x = i.x + this.long0, t.y = i.y, t
    },
    names: ["Tilted_Perspective", "tpers"]
};
var fg,
    dg = {
        init: function() {
            if (this.flip_axis = "x" === this.sweep ? 1 : 0, this.h = Number(this.h), this.radius_g_1 = this.h / this.a, this.radius_g_1 <= 0 || this.radius_g_1 > 1e10)
                throw new Error;
            if (this.radius_g = 1 + this.radius_g_1, this.C = this.radius_g * this.radius_g - 1, 0 !== this.es) {
                var t = 1 - this.es,
                    e = 1 / t;
                this.radius_p = Math.sqrt(t),
                this.radius_p2 = t,
                this.radius_p_inv2 = e,
                this.shape = "ellipse"
            } else
                this.radius_p = 1,
                this.radius_p2 = 1,
                this.radius_p_inv2 = 1,
                this.shape = "sphere";
            this.title || (this.title = "Geostationary Satellite View")
        },
        forward: function(t) {
            var e,
                n,
                r,
                i,
                o = t.x,
                s = t.y;
            if (o -= this.long0, "ellipse" === this.shape) {
                s = Math.atan(this.radius_p2 * Math.tan(s));
                var a = this.radius_p / Qf(this.radius_p * Math.cos(s), Math.sin(s));
                if (n = a * Math.cos(o) * Math.cos(s), r = a * Math.sin(o) * Math.cos(s), i = a * Math.sin(s), (this.radius_g - n) * n - r * r - i * i * this.radius_p_inv2 < 0)
                    return t.x = Number.NaN, t.y = Number.NaN, t;
                e = this.radius_g - n,
                this.flip_axis ? (t.x = this.radius_g_1 * Math.atan(r / Qf(i, e)), t.y = this.radius_g_1 * Math.atan(i / e)) : (t.x = this.radius_g_1 * Math.atan(r / e), t.y = this.radius_g_1 * Math.atan(i / Qf(r, e)))
            } else
                "sphere" === this.shape && (e = Math.cos(s), n = Math.cos(o) * e, r = Math.sin(o) * e, i = Math.sin(s), e = this.radius_g - n, this.flip_axis ? (t.x = this.radius_g_1 * Math.atan(r / Qf(i, e)), t.y = this.radius_g_1 * Math.atan(i / e)) : (t.x = this.radius_g_1 * Math.atan(r / e), t.y = this.radius_g_1 * Math.atan(i / Qf(r, e))));
            return t.x = t.x * this.a, t.y = t.y * this.a, t
        },
        inverse: function(t) {
            var e,
                n,
                r,
                i,
                o = -1,
                s = 0,
                a = 0;
            if (t.x = t.x / this.a, t.y = t.y / this.a, "ellipse" === this.shape) {
                this.flip_axis ? (a = Math.tan(t.y / this.radius_g_1), s = Math.tan(t.x / this.radius_g_1) * Qf(1, a)) : (s = Math.tan(t.x / this.radius_g_1), a = Math.tan(t.y / this.radius_g_1) * Qf(1, s));
                var u = a / this.radius_p;
                if (e = s * s + u * u + o * o, (r = (n = 2 * this.radius_g * o) * n - 4 * e * this.C) < 0)
                    return t.x = Number.NaN, t.y = Number.NaN, t;
                i = (-n - Math.sqrt(r)) / (2 * e),
                o = this.radius_g + i * o,
                s *= i,
                a *= i,
                t.x = Math.atan2(s, o),
                t.y = Math.atan(a * Math.cos(t.x) / o),
                t.y = Math.atan(this.radius_p_inv2 * Math.tan(t.y))
            } else if ("sphere" === this.shape) {
                if (this.flip_axis ? (a = Math.tan(t.y / this.radius_g_1), s = Math.tan(t.x / this.radius_g_1) * Math.sqrt(1 + a * a)) : (s = Math.tan(t.x / this.radius_g_1), a = Math.tan(t.y / this.radius_g_1) * Math.sqrt(1 + s * s)), e = s * s + a * a + o * o, (r = (n = 2 * this.radius_g * o) * n - 4 * e * this.C) < 0)
                    return t.x = Number.NaN, t.y = Number.NaN, t;
                i = (-n - Math.sqrt(r)) / (2 * e),
                o = this.radius_g + i * o,
                s *= i,
                a *= i,
                t.x = Math.atan2(s, o),
                t.y = Math.atan(a * Math.cos(t.x) / o)
            }
            return t.x = t.x + this.long0, t
        },
        names: ["Geostationary Satellite View", "Geostationary_Satellite", "geos"]
    };
Df.defaultDatum = "WGS84",
Df.Proj = yf,
Df.WGS84 = new Df.Proj("WGS84"),
Df.Point = Yf,
Df.toPoint = Tf,
Df.defs = jp,
Df.nadgrid = function(t, e) {
    var n = new DataView(e),
        r = function(t) {
            var e = t.getInt32(8, !1);
            if (11 === e)
                return !1;
            11 !== (e = t.getInt32(8, !0)) && console.warn("Failed to detect nadgrid endian-ness, defaulting to little-endian");
            return !0
        }(n),
        i = function(t, e) {
            return {
                nFields: t.getInt32(8, e),
                nSubgridFields: t.getInt32(24, e),
                nSubgrids: t.getInt32(40, e),
                shiftType: cf(t, 56, 64).trim(),
                fromSemiMajorAxis: t.getFloat64(120, e),
                fromSemiMinorAxis: t.getFloat64(136, e),
                toSemiMajorAxis: t.getFloat64(152, e),
                toSemiMinorAxis: t.getFloat64(168, e)
            }
        }(n, r);
    i.nSubgrids > 1 && console.log("Only single NTv2 subgrids are currently supported, subsequent sub grids are ignored");
    var o = function(t, e, n) {
            for (var r = 176, i = [], o = 0; o < e.nSubgrids; o++) {
                var s = ff(t, r, n),
                    a = df(t, r, s, n),
                    u = Math.round(1 + (s.upperLongitude - s.lowerLongitude) / s.longitudeInterval),
                    l = Math.round(1 + (s.upperLatitude - s.lowerLatitude) / s.latitudeInterval);
                i.push({
                    ll: [hf(s.lowerLongitude), hf(s.lowerLatitude)],
                    del: [hf(s.longitudeInterval), hf(s.latitudeInterval)],
                    lim: [u, l],
                    count: s.gridNodeCount,
                    cvs: pf(a)
                })
            }
            return i
        }(n, i, r),
        s = {
            header: i,
            subgrids: o
        };
    return af[t] = s, s
},
Df.transform = Of,
Df.mgrs = Ff,
Df.version = "__VERSION__",
(fg = Df).Proj.projections.add(Zf),
fg.Proj.projections.add(sd),
fg.Proj.projections.add(ud),
fg.Proj.projections.add(cd),
fg.Proj.projections.add(pd),
fg.Proj.projections.add(fd),
fg.Proj.projections.add(dd),
fg.Proj.projections.add(gd),
fg.Proj.projections.add(yd),
fg.Proj.projections.add(Md),
fg.Proj.projections.add(Id),
fg.Proj.projections.add(Pd),
fg.Proj.projections.add(Ld),
fg.Proj.projections.add(Nd),
fg.Proj.projections.add(Rd),
fg.Proj.projections.add(Ad),
fg.Proj.projections.add(Dd),
fg.Proj.projections.add(Fd),
fg.Proj.projections.add(kd),
fg.Proj.projections.add(jd),
fg.Proj.projections.add(Gd),
fg.Proj.projections.add(Bd),
fg.Proj.projections.add(qd),
fg.Proj.projections.add(zd),
fg.Proj.projections.add(eg),
fg.Proj.projections.add(og),
fg.Proj.projections.add(sg),
fg.Proj.projections.add(pg),
fg.Proj.projections.add(dg);
var gg = {};
t(gg, "default", (() => Mg), (t => Mg = t));
var yg = {};
t(yg, "default", (() => Eg), (t => Eg = t));
var vg = function() {
    function t() {
        this.dataProjection = void 0,
        this.defaultFeatureProjection = void 0,
        this.supportedMediaTypes = null
    }
    return t.prototype.getReadOptions = function(t, e) {
        var n;
        if (e) {
            var r = e.dataProjection ? ln(e.dataProjection) : this.readProjection(t);
            e.extent && r && r.getUnits() === ct.TILE_PIXELS && (r = ln(r)).setWorldExtent(e.extent),
            n = {
                dataProjection: r,
                featureProjection: e.featureProjection
            }
        }
        return this.adaptOptions(n)
    }, t.prototype.adaptOptions = function(t) {
        return P({
            dataProjection: this.dataProjection,
            featureProjection: this.defaultFeatureProjection
        }, t)
    }, t.prototype.getType = function() {
        return u()
    }, t.prototype.readFeature = function(t, e) {
        return u()
    }, t.prototype.readFeatures = function(t, e) {
        return u()
    }, t.prototype.readGeometry = function(t, e) {
        return u()
    }, t.prototype.readProjection = function(t) {
        return u()
    }, t.prototype.writeFeature = function(t, e) {
        return u()
    }, t.prototype.writeFeatures = function(t, e) {
        return u()
    }, t.prototype.writeGeometry = function(t, e) {
        return u()
    }, t
}();
function mg(t, e, n) {
    var r,
        i = n ? ln(n.featureProjection) : null,
        o = n ? ln(n.dataProjection) : null;
    if (r = i && o && !fn(i, o) ? (e ? t.clone() : t).transform(e ? i : o, e ? o : i) : t, e && n && void 0 !== n.decimals) {
        var s = Math.pow(10, n.decimals);
        r === t && (r = t.clone()),
        r.applyTransform((function(t) {
            for (var e = 0, n = t.length; e < n; ++e)
                t[e] = Math.round(t[e] * s) / s;
            return t
        }))
    }
    return r
}
var _g = function() {
    var t = function(e, n) {
        return t = Object.setPrototypeOf || {
            __proto__: []
        } instanceof Array && function(t, e) {
            t.__proto__ = e
        } || function(t, e) {
            for (var n in e)
                Object.prototype.hasOwnProperty.call(e, n) && (t[n] = e[n])
        }, t(e, n)
    };
    return function(e, n) {
        if ("function" != typeof n && null !== n)
            throw new TypeError("Class extends value " + String(n) + " is not a constructor or null");
        function r() {
            this.constructor = e
        }
        t(e, n),
        e.prototype = null === n ? Object.create(n) : (r.prototype = n.prototype, new r)
    }
}();
function xg(t) {
    if ("string" == typeof t) {
        var e = JSON.parse(t);
        return e || null
    }
    return null !== t ? t : null
}
var Eg = function(t) {
        function e() {
            return t.call(this) || this
        }
        return _g(e, t), e.prototype.getType = function() {
            return "json"
        }, e.prototype.readFeature = function(t, e) {
            return this.readFeatureFromObject(xg(t), this.getReadOptions(t, e))
        }, e.prototype.readFeatures = function(t, e) {
            return this.readFeaturesFromObject(xg(t), this.getReadOptions(t, e))
        }, e.prototype.readFeatureFromObject = function(t, e) {
            return u()
        }, e.prototype.readFeaturesFromObject = function(t, e) {
            return u()
        }, e.prototype.readGeometry = function(t, e) {
            return this.readGeometryFromObject(xg(t), this.getReadOptions(t, e))
        }, e.prototype.readGeometryFromObject = function(t, e) {
            return u()
        }, e.prototype.readProjection = function(t) {
            return this.readProjectionFromObject(xg(t))
        }, e.prototype.readProjectionFromObject = function(t) {
            return u()
        }, e.prototype.writeFeature = function(t, e) {
            return JSON.stringify(this.writeFeatureObject(t, e))
        }, e.prototype.writeFeatureObject = function(t, e) {
            return u()
        }, e.prototype.writeFeatures = function(t, e) {
            return JSON.stringify(this.writeFeaturesObject(t, e))
        }, e.prototype.writeFeaturesObject = function(t, e) {
            return u()
        }, e.prototype.writeGeometry = function(t, e) {
            return JSON.stringify(this.writeGeometryObject(t, e))
        }, e.prototype.writeGeometryObject = function(t, e) {
            return u()
        }, e
    }(vg),
    wg = function() {
        var t = function(e, n) {
            return t = Object.setPrototypeOf || {
                __proto__: []
            } instanceof Array && function(t, e) {
                t.__proto__ = e
            } || function(t, e) {
                for (var n in e)
                    Object.prototype.hasOwnProperty.call(e, n) && (t[n] = e[n])
            }, t(e, n)
        };
        return function(e, n) {
            if ("function" != typeof n && null !== n)
                throw new TypeError("Class extends value " + String(n) + " is not a constructor or null");
            function r() {
                this.constructor = e
            }
            t(e, n),
            e.prototype = null === n ? Object.create(n) : (r.prototype = n.prototype, new r)
        }
    }();
function bg(t, e) {
    if (!t)
        return null;
    var n;
    switch (t.type) {
    case "Point":
        n = function(t) {
            return new (0, hr.default)(t.coordinates)
        }(t);
        break;
    case "LineString":
        n = function(t) {
            return new (0, Na.default)(t.coordinates)
        }(t);
        break;
    case "Polygon":
        n = function(t) {
            return new (0, rt.default)(t.coordinates)
        }(t);
        break;
    case "MultiPoint":
        n = function(t) {
            return new (0, Ua.default)(t.coordinates)
        }(t);
        break;
    case "MultiLineString":
        n = function(t) {
            return new (0, Ba.default)(t.coordinates)
        }(t);
        break;
    case "MultiPolygon":
        n = function(t) {
            return new (0, Ha.default)(t.coordinates)
        }(t);
        break;
    case "GeometryCollection":
        n = function(t, e) {
            var n = t.geometries.map((function(t) {
                return bg(t, e)
            }));
            return new (0, pp.default)(n)
        }(t);
        break;
    default:
        throw new Error("Unsupported GeoJSON type: " + t.type)
    }
    return mg(n, !1, e)
}
function Cg(t, e) {
    var n,
        r = (t = mg(t, !0, e)).getType();
    switch (r) {
    case "Point":
        n = function(t, e) {
            return {
                type: "Point",
                coordinates: t.getCoordinates()
            }
        }(t);
        break;
    case "LineString":
        n = function(t, e) {
            return {
                type: "LineString",
                coordinates: t.getCoordinates()
            }
        }(t);
        break;
    case "Polygon":
        n = function(t, e) {
            var n;
            e && (n = e.rightHanded);
            return {
                type: "Polygon",
                coordinates: t.getCoordinates(n)
            }
        }(t, e);
        break;
    case "MultiPoint":
        n = function(t, e) {
            return {
                type: "MultiPoint",
                coordinates: t.getCoordinates()
            }
        }(t);
        break;
    case "MultiLineString":
        n = function(t, e) {
            return {
                type: "MultiLineString",
                coordinates: t.getCoordinates()
            }
        }(t);
        break;
    case "MultiPolygon":
        n = function(t, e) {
            var n;
            e && (n = e.rightHanded);
            return {
                type: "MultiPolygon",
                coordinates: t.getCoordinates(n)
            }
        }(t, e);
        break;
    case "GeometryCollection":
        n = function(t, e) {
            return {
                type: "GeometryCollection",
                geometries: t.getGeometriesArray().map((function(t) {
                    var n = P({}, e);
                    return delete n.featureProjection, Cg(t, n)
                }))
            }
        }(t, e);
        break;
    case "Circle":
        n = {
            type: "GeometryCollection",
            geometries: []
        };
        break;
    default:
        throw new Error("Unsupported geometry type: " + r)
    }
    return n
}
var Mg = function(t) {
        function e(e) {
            var n = this,
                r = e || {};
            return (n = t.call(this) || this).dataProjection = ln(r.dataProjection ? r.dataProjection : "EPSG:4326"), r.featureProjection && (n.defaultFeatureProjection = ln(r.featureProjection)), n.geometryName_ = r.geometryName, n.extractGeometryName_ = r.extractGeometryName, n.supportedMediaTypes = ["application/geo+json", "application/vnd.geo+json"], n
        }
        return wg(e, t), e.prototype.readFeatureFromObject = function(t, e) {
            var n = null,
                r = bg((n = "Feature" === t.type ? t : {
                    type: "Feature",
                    geometry: t,
                    properties: null
                }).geometry, e),
                i = new (0, Z.default);
            return this.geometryName_ ? i.setGeometryName(this.geometryName_) : this.extractGeometryName_ && i.setGeometryName(n.geometry_name), i.setGeometry(r), "id" in n && i.setId(n.id), n.properties && i.setProperties(n.properties, !0), i
        }, e.prototype.readFeaturesFromObject = function(t, e) {
            var n = null;
            if ("FeatureCollection" === t.type) {
                n = [];
                for (var r = t.features, i = 0, o = r.length; i < o; ++i)
                    n.push(this.readFeatureFromObject(r[i], e))
            } else
                n = [this.readFeatureFromObject(t, e)];
            return n
        }, e.prototype.readGeometryFromObject = function(t, e) {
            return bg(t, e)
        }, e.prototype.readProjectionFromObject = function(t) {
            var e,
                n = t.crs;
            return n ? "name" == n.type ? e = ln(n.properties.name) : "EPSG" === n.type ? e = ln("EPSG:" + n.properties.code) : J(!1, 36) : e = this.dataProjection, e
        }, e.prototype.writeFeatureObject = function(t, e) {
            e = this.adaptOptions(e);
            var n = {
                    type: "Feature",
                    geometry: null,
                    properties: null
                },
                r = t.getId();
            if (void 0 !== r && (n.id = r), !t.hasProperties())
                return n;
            var i = t.getProperties(),
                o = t.getGeometry();
            return o && (n.geometry = Cg(o, e), delete i[t.getGeometryName()]), N(i) || (n.properties = i), n
        }, e.prototype.writeFeaturesObject = function(t, e) {
            e = this.adaptOptions(e);
            for (var n = [], r = 0, i = t.length; r < i; ++r)
                n.push(this.writeFeatureObject(t[r], e));
            return {
                type: "FeatureCollection",
                features: n
            }
        }, e.prototype.writeGeometryObject = function(t, e) {
            return Cg(t, this.adaptOptions(e))
        }, e
    }(yg.default),
    Sg = {};
(Sg = function(t, e, n) {
    return e in t ? Object.defineProperty(t, e, {
        value: n,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : t[e] = n, t
}).__esModule = !0,
Sg.default = Sg;
var Ig = {};
function Tg(t) {
    return Ig = Tg = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t) {
        return typeof t
    } : function(t) {
        return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
    }, Ig.__esModule = !0, Ig.default = Ig, Tg(t)
}
(Ig = Tg).__esModule = !0,
Ig.default = Ig;
var Pg = {};
(Pg = function(t, e) {
    if (!(t instanceof e))
        throw new TypeError("Cannot call a class as a function")
}).__esModule = !0,
Pg.default = Pg;
var Lg = {};
function Og(t, e) {
    for (var n = 0; n < e.length; n++) {
        var r = e[n];
        r.enumerable = r.enumerable || !1,
        r.configurable = !0,
        "value" in r && (r.writable = !0),
        Object.defineProperty(t, r.key, r)
    }
}
(Lg = function(t, e, n) {
    return e && Og(t.prototype, e), n && Og(t, n), Object.defineProperty(t, "prototype", {
        writable: !1
    }), t
}).__esModule = !0,
Lg.default = Lg;
var Ng = {},
    Rg = {},
    Ag = {};
function Dg(t) {
    return Ag = Dg = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t) {
        return t.__proto__ || Object.getPrototypeOf(t)
    }, Ag.__esModule = !0, Ag.default = Ag, Dg(t)
}
function Fg() {
    return "undefined" != typeof Reflect && Reflect.get ? ((Ng = Fg = Reflect.get.bind()).__esModule = !0, Ng.default = Ng) : (Ng = Fg = function(t, e, n) {
        var r = Rg(t, e);
        if (r) {
            var i = Object.getOwnPropertyDescriptor(r, e);
            return i.get ? i.get.call(arguments.length < 3 ? t : n) : i.value
        }
    }, Ng.__esModule = !0, Ng.default = Ng), Fg.apply(this, arguments)
}
(Ag = Dg).__esModule = !0,
Ag.default = Ag,
(Rg = function(t, e) {
    for (; !Object.prototype.hasOwnProperty.call(t, e) && null !== (t = Ag(t));)
        ;
    return t
}).__esModule = !0,
Rg.default = Rg,
(Ng = Fg).__esModule = !0,
Ng.default = Ng;
var kg = {},
    jg = {};
function Gg(t, e) {
    return jg = Gg = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t, e) {
        return t.__proto__ = e, t
    }, jg.__esModule = !0, jg.default = jg, Gg(t, e)
}
(jg = Gg).__esModule = !0,
jg.default = jg,
(kg = function(t, e) {
    if ("function" != typeof e && null !== e)
        throw new TypeError("Super expression must either be null or a function");
    t.prototype = Object.create(e && e.prototype, {
        constructor: {
            value: t,
            writable: !0,
            configurable: !0
        }
    }),
    Object.defineProperty(t, "prototype", {
        writable: !1
    }),
    e && jg(t, e)
}).__esModule = !0,
kg.default = kg;
var Bg = {},
    qg = Ig.default,
    zg = {};
/**
 * This file is part of ol-rotate-feature package.
 * @module ol-rotate-feature
 * @license MIT
 * @author Vladimir Vershinin
 */
function Ug(t) {
    var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "";
    if (e = ["Assertion failed", e].join(": "), !t)
        throw new Error(e)
}
function Vg(t) {
    return t
}
function Xg(t, e) {
    return -1 !== t.indexOf(e)
}
function Hg(t) {
    return "[object Array]" === Object.prototype.toString.call(t)
}
/**
 * This file is part of ol-rotate-feature package.
 * @module ol-rotate-feature
 * @license MIT
 * @author Vladimir Vershinin
 */
(zg = function(t) {
    if (void 0 === t)
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return t
}).__esModule = !0,
zg.default = zg,
(Bg = function(t, e) {
    if (e && ("object" === qg(e) || "function" == typeof e))
        return e;
    if (void 0 !== e)
        throw new TypeError("Derived constructors may only return object or undefined");
    return zg(t)
}).__esModule = !0,
Bg.default = Bg;
var Yg = "rotatestart",
    Wg = "rotating",
    $g = "rotateend",
    Kg = function() {
        function t(n, r, i, o) {
            e(Pg)(this, t),
            this.propagationStopped_ = !1,
            this.type_ = n,
            this.features_ = r,
            this.angle_ = i,
            this.anchor_ = o
        }
        return e(Lg)(t, [{
            key: "preventDefault",
            value: function() {
                this.propagationStopped_ = !0
            }
        }, {
            key: "stopPropagation",
            value: function() {
                this.propagationStopped_ = !0
            }
        }, {
            key: "propagationStopped",
            get: function() {
                return this.propagationStopped_
            }
        }, {
            key: "type",
            get: function() {
                return this.type_
            }
        }, {
            key: "features",
            get: function() {
                return this.features_
            }
        }, {
            key: "angle",
            get: function() {
                return this.angle_
            }
        }, {
            key: "anchor",
            get: function() {
                return this.anchor_
            }
        }]), t
    }(),
    Zg = "undefined" != typeof navigator ? navigator.userAgent.toLowerCase() : "",
    Jg = -1 !== Zg.indexOf("macintosh"),
    Qg = -1 !== Zg.indexOf("webkit") && -1 == Zg.indexOf("edge");
function ty(t) {
    var n = function() {
        if ("undefined" == typeof Reflect || !Reflect.construct)
            return !1;
        if (Reflect.construct.sham)
            return !1;
        if ("function" == typeof Proxy)
            return !0;
        try {
            return Date.prototype.toString.call(Reflect.construct(Date, [], (function() {}))), !0
        } catch (t) {
            return !1
        }
    }();
    return function() {
        var r,
            i = e(Ag)(t);
        if (n) {
            var o = e(Ag)(this).constructor;
            r = Reflect.construct(i, arguments, o)
        } else
            r = i.apply(this, arguments);
        return e(Bg)(this, r)
    }
}
var ey = function(t) {
    e(kg)(r, t);
    var n = ty(r);
    function r() {
        var t,
            i,
            o = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
        if (e(Pg)(this, r), (i = n.call(this, {
            handleDownEvent: ny,
            handleUpEvent: ry,
            handleDragEvent: iy,
            handleMoveEvent: oy
        })).previousCursor_ = void 0, i.anchorFeature_ = void 0, i.arrowFeature_ = void 0, i.lastCoordinate_ = void 0, i.anchorMoving_ = !1, i.overlay_ = new (0, Ka.default)({
            style: o.style || sy(),
            source: new (0, Jl.default)({
                features: new (0, s.default)
            })
        }), i.condition_ = o.condition ? o.condition : Fs, i.features_ = void 0, o.features)
            if (Hg(o.features))
                i.features_ = new (0, s.default)(o.features);
            else {
                if (!(o.features instanceof s.default))
                    throw new Error("Features option should be an array or collection of features, got " + e(Ig)(o.features));
                i.features_ = o.features
            }
        else
            i.features_ = new (0, s.default);
        return i.allowAnchorMovement = void 0 === o.allowAnchorMovement || o.allowAnchorMovement, i.setAnchor(o.anchor || ay(i.features_)), i.setAngle(o.angle || 0), i.features_.on("add", (t = i).onFeatureAdd_.bind(t)), i.features_.on("remove", (t = i).onFeatureRemove_.bind(t)), i.on("change:angle", (t = i).onAngleChange_.bind(t)), i.on("change:anchor", (t = i).onAnchorChange_.bind(t)), i.createOrUpdateAnchorFeature_(), i.createOrUpdateArrowFeature_(), i
    }
    return e(Lg)(r, [{
        key: "setMap",
        value: function(t) {
            this.overlay_.setMap(t),
            e(Ng)(e(Ag)(r.prototype), "setMap", this).call(this, t)
        }
    }, {
        key: "setActive",
        value: function(t) {
            this.overlay_ && this.overlay_.setMap(t ? this.map : void 0),
            e(Ng)(e(Ag)(r.prototype), "setActive", this).call(this, t)
        }
    }, {
        key: "setAngle",
        value: function(t) {
            Ug(!isNaN(parseFloat(t)), "Numeric value passed"),
            this.set("angle", parseFloat(t))
        }
    }, {
        key: "getAngle",
        value: function() {
            return this.get("angle")
        }
    }, {
        key: "setAnchor",
        value: function(t) {
            Ug(null == t || Hg(t) && 2 === t.length, "Array of two elements passed"),
            this.set("anchor", null != t ? t.map(parseFloat) : ay(this.features_))
        }
    }, {
        key: "getAnchor",
        value: function() {
            return this.get("anchor")
        }
    }, {
        key: "createOrUpdateAnchorFeature_",
        value: function() {
            var t,
                n = this.getAngle(),
                r = this.getAnchor();
            r && (this.anchorFeature_ ? (this.anchorFeature_.getGeometry().setCoordinates(r), this.anchorFeature_.set("angle", n)) : (this.anchorFeature_ = new (0, Z.default)((t = {
                geometry: new (0, hr.default)(r)
            }, e(Sg)(t, "angle", n), e(Sg)(t, "rotate-anchor", !0), t)), this.overlay_.getSource().addFeature(this.anchorFeature_)))
        }
    }, {
        key: "createOrUpdateArrowFeature_",
        value: function() {
            var t,
                n = this.getAngle(),
                r = this.getAnchor();
            r && (this.arrowFeature_ ? (this.arrowFeature_.getGeometry().setCoordinates(r), this.arrowFeature_.set("angle", n)) : (this.arrowFeature_ = new (0, Z.default)((t = {
                geometry: new (0, hr.default)(r)
            }, e(Sg)(t, "angle", n), e(Sg)(t, "rotate-arrow", !0), t)), this.overlay_.getSource().addFeature(this.arrowFeature_)))
        }
    }, {
        key: "resetAngleAndAnchor_",
        value: function() {
            this.resetAngle_(),
            this.resetAnchor_()
        }
    }, {
        key: "resetAngle_",
        value: function() {
            this.set("angle", 0, !0),
            this.arrowFeature_ && this.arrowFeature_.set("angle", this.getAngle()),
            this.anchorFeature_ && this.anchorFeature_.set("angle", this.getAngle())
        }
    }, {
        key: "resetAnchor_",
        value: function() {
            this.set("anchor", ay(this.features_), !0),
            this.getAnchor() && (this.arrowFeature_ && this.arrowFeature_.getGeometry().setCoordinates(this.getAnchor()), this.anchorFeature_ && this.anchorFeature_.getGeometry().setCoordinates(this.getAnchor()))
        }
    }, {
        key: "onFeatureAdd_",
        value: function() {
            this.resetAngleAndAnchor_(),
            this.createOrUpdateAnchorFeature_(),
            this.createOrUpdateArrowFeature_()
        }
    }, {
        key: "onFeatureRemove_",
        value: function() {
            this.resetAngleAndAnchor_(),
            this.features_.getLength() ? (this.createOrUpdateAnchorFeature_(), this.createOrUpdateArrowFeature_()) : (this.overlay_.getSource().clear(), this.anchorFeature_ = this.arrowFeature_ = void 0)
        }
    }, {
        key: "onAngleChange_",
        value: function(t) {
            var e = this,
                n = t.oldValue;
            this.features_.forEach((function(t) {
                return t.getGeometry().rotate(e.getAngle() - n, e.getAnchor())
            })),
            this.arrowFeature_ && this.arrowFeature_.set("angle", this.getAngle()),
            this.anchorFeature_ && this.anchorFeature_.set("angle", this.getAngle())
        }
    }, {
        key: "onAnchorChange_",
        value: function() {
            var t = this.getAnchor();
            t && (this.anchorFeature_ && this.anchorFeature_.getGeometry().setCoordinates(t), this.arrowFeature_ && this.arrowFeature_.getGeometry().setCoordinates(t))
        }
    }, {
        key: "dispatchRotateStartEvent_",
        value: function(t) {
            this.dispatchEvent(new Kg(Yg, t, this.getAngle(), this.getAnchor()))
        }
    }, {
        key: "dispatchRotatingEvent_",
        value: function(t) {
            this.dispatchEvent(new Kg(Wg, t, this.getAngle(), this.getAnchor()))
        }
    }, {
        key: "dispatchRotateEndEvent_",
        value: function(t) {
            this.dispatchEvent(new Kg($g, t, this.getAngle(), this.getAnchor()))
        }
    }, {
        key: "features",
        get: function() {
            return this.features_
        }
    }, {
        key: "angle",
        get: function() {
            return this.getAngle()
        },
        set: function(t) {
            this.setAngle(t)
        }
    }, {
        key: "anchor",
        get: function() {
            return this.getAnchor()
        },
        set: function(t) {
            this.setAnchor(t)
        }
    }, {
        key: "map",
        set: function(t) {
            this.setMap(t)
        },
        get: function() {
            return this.getMap()
        }
    }, {
        key: "active",
        set: function(t) {
            this.setActive(t)
        },
        get: function() {
            return this.getActive()
        }
    }]), r
}(Ts.default);
function ny(t) {
    if (!zs(t))
        return !1;
    if (0 == (n = t.originalEvent).button && !(Qg && Jg && n.ctrlKey) && this.condition_(t)) {
        var e = t.map.forEachFeatureAtPixel(t.pixel, Vg);
        if (Xg(["click", "singleclick", "dblclick"], t.type) && Xg([this.anchorFeature_, this.arrowFeature_], e))
            return !1;
        if (e && !this.lastCoordinate_ && (Xg(this.features_.getArray(), e) || e === this.arrowFeature_))
            return this.lastCoordinate_ = t.coordinate, oy.call(this, t), this.dispatchRotateStartEvent_(this.features_), !0;
        if (e && e === this.anchorFeature_ && this.allowAnchorMovement)
            return this.anchorMoving_ = !0, oy.call(this, t), !0
    }
    var n;
    return !1
}
function ry(t) {
    return this.lastCoordinate_ ? (this.lastCoordinate_ = void 0, oy.call(this, t), this.dispatchRotateEndEvent_(this.features_), !0) : !!this.anchorMoving_ && (this.anchorMoving_ = !1, oy.call(this, t), !0)
}
function iy(t) {
    var e = t.coordinate,
        n = this.anchorFeature_.getGeometry().getCoordinates();
    if (this.lastCoordinate_) {
        var r = [this.lastCoordinate_[0] - n[0], this.lastCoordinate_[1] - n[1]],
            i = [e[0] - n[0], e[1] - n[1]],
            o = Math.atan2(r[0] * i[1] - i[0] * r[1], r[0] * i[0] + r[1] * i[1]);
        this.setAngle(this.getAngle() + o),
        this.dispatchRotatingEvent_(this.features_),
        this.lastCoordinate_ = e
    } else
        this.anchorMoving_ && this.setAnchor(e)
}
function oy(t) {
    var e = t.map,
        n = t.pixel,
        r = e.getTargetElement(),
        i = e.forEachFeatureAtPixel(n, Vg),
        o = function(t) {
            var e = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
            e && (r.style.cursor = "-webkit-" + t, r.style.cursor = "-moz-" + t),
            r.style.cursor = t
        };
    this.lastCoordinate_ ? (this.previousCursor_ = r.style.cursor, o("grabbing", !0)) : i && (Xg(this.features_.getArray(), i) || i === this.arrowFeature_) ? (this.previousCursor_ = r.style.cursor, o("grab", !0)) : i && i === this.anchorFeature_ && this.allowAnchorMovement || this.anchorMoving_ ? (this.previousCursor_ = r.style.cursor, o("crosshair")) : (o(this.previousCursor_ || ""), this.previousCursor_ = void 0)
}
function sy() {
    var t,
        n = [255, 255, 255, .8],
        r = [0, 153, 255, .8],
        i = [255, 255, 255, .01],
        o = (t = {}, e(Sg)(t, "rotate-anchor", [new yu({
            image: new (0, tu.default)({
                fill: new uu({
                    color: [0, 153, 255, .8]
                }),
                stroke: new lu({
                    color: r,
                    width: 1
                }),
                radius: 4,
                points: 6
            }),
            zIndex: 1 / 0
        })]), e(Sg)(t, "rotate-arrow", [new yu({
            fill: new uu({
                color: i
            }),
            stroke: new lu({
                color: n,
                width: 4
            }),
            text: new jl({
                font: "12px sans-serif",
                offsetX: 20,
                offsetY: -20,
                fill: new uu({
                    color: "blue"
                }),
                stroke: new lu({
                    color: n,
                    width: 3
                })
            }),
            zIndex: 1 / 0
        }), new yu({
            fill: new uu({
                color: i
            }),
            stroke: new lu({
                color: r,
                width: 2
            }),
            zIndex: 1 / 0
        })]), t);
    return function(t, e) {
        var n,
            r = t.get("angle") || 0;
        switch (!0) {
        case t.get("rotate-anchor"):
            return (n = o["rotate-anchor"])[0].getImage().setRotation(-r), n;
        case t.get("rotate-arrow"):
            n = o["rotate-arrow"];
            var i = t.getGeometry().getCoordinates(),
                s = new (0, rt.default)([[[i[0], i[1] - 6 * e], [i[0] + 8 * e, i[1] - 12 * e], [i[0], i[1] + 30 * e], [i[0] - 8 * e, i[1] - 12 * e], [i[0], i[1] - 6 * e]]]);
            return s.rotate(r, i), n[0].setGeometry(s), n[1].setGeometry(s), n[0].getText().setText(Math.round(180 * -r / Math.PI) + "°"), n
        }
    }
}
function ay(t) {
    if ((t = t instanceof s.default ? t.getArray() : t).length)
        return $t(function(t) {
            if ((t = t instanceof s.default ? t.getArray() : t).length)
                return new (0, pp.default)(t.map((function(t) {
                    return t.getGeometry()
                }))).getExtent()
        }(t))
}
/**
 * This file is part of ol-rotate-feature package.
 * @module ol-rotate-feature
 * @license MIT
 * @author Vladimir Vershinin
 */
"undefined" != typeof window && window.ol && window.ol.interaction && (window.ol.interaction.RotateFeature = ey);
var uy = {};
/*!
 * jQuery JavaScript Library v3.6.1
 * https://jquery.com/
 *
 * Includes Sizzle.js
 * https://sizzlejs.com/
 *
 * Copyright OpenJS Foundation and other contributors
 * Released under the MIT license
 * https://jquery.org/license
 *
 * Date: 2022-08-26T17:52Z
 */
!function(t, e) {
    "object" == typeof uy ? uy = t.document ? e(t, !0) : function(t) {
        if (!t.document)
            throw new Error("jQuery requires a window with a document");
        return e(t)
    } : e(t)
}("undefined" != typeof window ? window : uy, (function(t, e) {
    var n = [],
        r = Object.getPrototypeOf,
        i = n.slice,
        o = n.flat ? function(t) {
            return n.flat.call(t)
        } : function(t) {
            return n.concat.apply([], t)
        },
        s = n.push,
        a = n.indexOf,
        u = {},
        l = u.toString,
        h = u.hasOwnProperty,
        c = h.toString,
        p = c.call(Object),
        f = {},
        d = function(t) {
            return "function" == typeof t && "number" != typeof t.nodeType && "function" != typeof t.item
        },
        g = function(t) {
            return null != t && t === t.window
        },
        y = t.document,
        v = {
            type: !0,
            src: !0,
            nonce: !0,
            noModule: !0
        };
    function m(t, e, n) {
        var r,
            i,
            o = (n = n || y).createElement("script");
        if (o.text = t, e)
            for (r in v)
                (i = e[r] || e.getAttribute && e.getAttribute(r)) && o.setAttribute(r, i);
        n.head.appendChild(o).parentNode.removeChild(o)
    }
    function _(t) {
        return null == t ? t + "" : "object" == typeof t || "function" == typeof t ? u[l.call(t)] || "object" : typeof t
    }
    var x = "3.6.1",
        E = function(t, e) {
            return new E.fn.init(t, e)
        };
    function w(t) {
        var e = !!t && "length" in t && t.length,
            n = _(t);
        return !d(t) && !g(t) && ("array" === n || 0 === e || "number" == typeof e && e > 0 && e - 1 in t)
    }
    E.fn = E.prototype = {
        jquery: x,
        constructor: E,
        length: 0,
        toArray: function() {
            return i.call(this)
        },
        get: function(t) {
            return null == t ? i.call(this) : t < 0 ? this[t + this.length] : this[t]
        },
        pushStack: function(t) {
            var e = E.merge(this.constructor(), t);
            return e.prevObject = this, e
        },
        each: function(t) {
            return E.each(this, t)
        },
        map: function(t) {
            return this.pushStack(E.map(this, (function(e, n) {
                return t.call(e, n, e)
            })))
        },
        slice: function() {
            return this.pushStack(i.apply(this, arguments))
        },
        first: function() {
            return this.eq(0)
        },
        last: function() {
            return this.eq(-1)
        },
        even: function() {
            return this.pushStack(E.grep(this, (function(t, e) {
                return (e + 1) % 2
            })))
        },
        odd: function() {
            return this.pushStack(E.grep(this, (function(t, e) {
                return e % 2
            })))
        },
        eq: function(t) {
            var e = this.length,
                n = +t + (t < 0 ? e : 0);
            return this.pushStack(n >= 0 && n < e ? [this[n]] : [])
        },
        end: function() {
            return this.prevObject || this.constructor()
        },
        push: s,
        sort: n.sort,
        splice: n.splice
    },
    E.extend = E.fn.extend = function() {
        var t,
            e,
            n,
            r,
            i,
            o,
            s = arguments[0] || {},
            a = 1,
            u = arguments.length,
            l = !1;
        for ("boolean" == typeof s && (l = s, s = arguments[a] || {}, a++), "object" == typeof s || d(s) || (s = {}), a === u && (s = this, a--); a < u; a++)
            if (null != (t = arguments[a]))
                for (e in t)
                    r = t[e],
                    "__proto__" !== e && s !== r && (l && r && (E.isPlainObject(r) || (i = Array.isArray(r))) ? (n = s[e], o = i && !Array.isArray(n) ? [] : i || E.isPlainObject(n) ? n : {}, i = !1, s[e] = E.extend(l, o, r)) : void 0 !== r && (s[e] = r));
        return s
    },
    E.extend({
        expando: "jQuery" + (x + Math.random()).replace(/\D/g, ""),
        isReady: !0,
        error: function(t) {
            throw new Error(t)
        },
        noop: function() {},
        isPlainObject: function(t) {
            var e,
                n;
            return !(!t || "[object Object]" !== l.call(t)) && (!(e = r(t)) || "function" == typeof (n = h.call(e, "constructor") && e.constructor) && c.call(n) === p)
        },
        isEmptyObject: function(t) {
            var e;
            for (e in t)
                return !1;
            return !0
        },
        globalEval: function(t, e, n) {
            m(t, {
                nonce: e && e.nonce
            }, n)
        },
        each: function(t, e) {
            var n,
                r = 0;
            if (w(t))
                for (n = t.length; r < n && !1 !== e.call(t[r], r, t[r]); r++)
                    ;
            else
                for (r in t)
                    if (!1 === e.call(t[r], r, t[r]))
                        break;
            return t
        },
        makeArray: function(t, e) {
            var n = e || [];
            return null != t && (w(Object(t)) ? E.merge(n, "string" == typeof t ? [t] : t) : s.call(n, t)), n
        },
        inArray: function(t, e, n) {
            return null == e ? -1 : a.call(e, t, n)
        },
        merge: function(t, e) {
            for (var n = +e.length, r = 0, i = t.length; r < n; r++)
                t[i++] = e[r];
            return t.length = i, t
        },
        grep: function(t, e, n) {
            for (var r = [], i = 0, o = t.length, s = !n; i < o; i++)
                !e(t[i], i) !== s && r.push(t[i]);
            return r
        },
        map: function(t, e, n) {
            var r,
                i,
                s = 0,
                a = [];
            if (w(t))
                for (r = t.length; s < r; s++)
                    null != (i = e(t[s], s, n)) && a.push(i);
            else
                for (s in t)
                    null != (i = e(t[s], s, n)) && a.push(i);
            return o(a)
        },
        guid: 1,
        support: f
    }),
    "function" == typeof Symbol && (E.fn[Symbol.iterator] = n[Symbol.iterator]),
    E.each("Boolean Number String Function Array Date RegExp Object Error Symbol".split(" "), (function(t, e) {
        u["[object " + e + "]"] = e.toLowerCase()
    }));
    var b = /*!
     * Sizzle CSS Selector Engine v2.3.6
     * https://sizzlejs.com/
     *
     * Copyright JS Foundation and other contributors
     * Released under the MIT license
     * https://js.foundation/
     *
     * Date: 2021-02-16
     */
    function(t) {
        var e,
            n,
            r,
            i,
            o,
            s,
            a,
            u,
            l,
            h,
            c,
            p,
            f,
            d,
            g,
            y,
            v,
            m,
            _,
            x = "sizzle" + 1 * new Date,
            E = t.document,
            w = 0,
            b = 0,
            C = ut(),
            M = ut(),
            S = ut(),
            I = ut(),
            T = function(t, e) {
                return t === e && (c = !0), 0
            },
            P = {}.hasOwnProperty,
            L = [],
            O = L.pop,
            N = L.push,
            R = L.push,
            A = L.slice,
            D = function(t, e) {
                for (var n = 0, r = t.length; n < r; n++)
                    if (t[n] === e)
                        return n;
                return -1
            },
            F = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",
            k = "[\\x20\\t\\r\\n\\f]",
            j = "(?:\\\\[\\da-fA-F]{1,6}[\\x20\\t\\r\\n\\f]?|\\\\[^\\r\\n\\f]|[\\w-]|[^\0-\\x7f])+",
            G = "\\[[\\x20\\t\\r\\n\\f]*(" + j + ")(?:" + k + "*([*^$|!~]?=)" + k + "*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + j + "))|)" + k + "*\\]",
            B = ":(" + j + ")(?:\\((('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|((?:\\\\.|[^\\\\()[\\]]|" + G + ")*)|.*)\\)|)",
            q = new RegExp(k + "+", "g"),
            z = new RegExp("^[\\x20\\t\\r\\n\\f]+|((?:^|[^\\\\])(?:\\\\.)*)[\\x20\\t\\r\\n\\f]+$", "g"),
            U = new RegExp("^[\\x20\\t\\r\\n\\f]*,[\\x20\\t\\r\\n\\f]*"),
            V = new RegExp("^[\\x20\\t\\r\\n\\f]*([>+~]|[\\x20\\t\\r\\n\\f])[\\x20\\t\\r\\n\\f]*"),
            X = new RegExp(k + "|>"),
            H = new RegExp(B),
            Y = new RegExp("^" + j + "$"),
            W = {
                ID: new RegExp("^#(" + j + ")"),
                CLASS: new RegExp("^\\.(" + j + ")"),
                TAG: new RegExp("^(" + j + "|[*])"),
                ATTR: new RegExp("^" + G),
                PSEUDO: new RegExp("^" + B),
                CHILD: new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\([\\x20\\t\\r\\n\\f]*(even|odd|(([+-]|)(\\d*)n|)[\\x20\\t\\r\\n\\f]*(?:([+-]|)[\\x20\\t\\r\\n\\f]*(\\d+)|))[\\x20\\t\\r\\n\\f]*\\)|)", "i"),
                bool: new RegExp("^(?:" + F + ")$", "i"),
                needsContext: new RegExp("^[\\x20\\t\\r\\n\\f]*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\([\\x20\\t\\r\\n\\f]*((?:-\\d)?\\d*)[\\x20\\t\\r\\n\\f]*\\)|)(?=[^-]|$)", "i")
            },
            $ = /HTML$/i,
            K = /^(?:input|select|textarea|button)$/i,
            Z = /^h\d$/i,
            J = /^[^{]+\{\s*\[native \w/,
            Q = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,
            tt = /[+~]/,
            et = new RegExp("\\\\[\\da-fA-F]{1,6}[\\x20\\t\\r\\n\\f]?|\\\\([^\\r\\n\\f])", "g"),
            nt = function(t, e) {
                var n = "0x" + t.slice(1) - 65536;
                return e || (n < 0 ? String.fromCharCode(n + 65536) : String.fromCharCode(n >> 10 | 55296, 1023 & n | 56320))
            },
            rt = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g,
            it = function(t, e) {
                return e ? "\0" === t ? "�" : t.slice(0, -1) + "\\" + t.charCodeAt(t.length - 1).toString(16) + " " : "\\" + t
            },
            ot = function() {
                p()
            },
            st = xt((function(t) {
                return !0 === t.disabled && "fieldset" === t.nodeName.toLowerCase()
            }), {
                dir: "parentNode",
                next: "legend"
            });
        try {
            R.apply(L = A.call(E.childNodes), E.childNodes),
            L[E.childNodes.length].nodeType
        } catch (t) {
            R = {
                apply: L.length ? function(t, e) {
                    N.apply(t, A.call(e))
                } : function(t, e) {
                    for (var n = t.length, r = 0; t[n++] = e[r++];)
                        ;
                    t.length = n - 1
                }
            }
        }
        function at(t, e, r, i) {
            var o,
                a,
                l,
                h,
                c,
                d,
                v,
                m = e && e.ownerDocument,
                E = e ? e.nodeType : 9;
            if (r = r || [], "string" != typeof t || !t || 1 !== E && 9 !== E && 11 !== E)
                return r;
            if (!i && (p(e), e = e || f, g)) {
                if (11 !== E && (c = Q.exec(t)))
                    if (o = c[1]) {
                        if (9 === E) {
                            if (!(l = e.getElementById(o)))
                                return r;
                            if (l.id === o)
                                return r.push(l), r
                        } else if (m && (l = m.getElementById(o)) && _(e, l) && l.id === o)
                            return r.push(l), r
                    } else {
                        if (c[2])
                            return R.apply(r, e.getElementsByTagName(t)), r;
                        if ((o = c[3]) && n.getElementsByClassName && e.getElementsByClassName)
                            return R.apply(r, e.getElementsByClassName(o)), r
                    }
                if (n.qsa && !I[t + " "] && (!y || !y.test(t)) && (1 !== E || "object" !== e.nodeName.toLowerCase())) {
                    if (v = t, m = e, 1 === E && (X.test(t) || V.test(t))) {
                        for ((m = tt.test(t) && vt(e.parentNode) || e) === e && n.scope || ((h = e.getAttribute("id")) ? h = h.replace(rt, it) : e.setAttribute("id", h = x)), a = (d = s(t)).length; a--;)
                            d[a] = (h ? "#" + h : ":scope") + " " + _t(d[a]);
                        v = d.join(",")
                    }
                    try {
                        return R.apply(r, m.querySelectorAll(v)), r
                    } catch (e) {
                        I(t, !0)
                    } finally {
                        h === x && e.removeAttribute("id")
                    }
                }
            }
            return u(t.replace(z, "$1"), e, r, i)
        }
        function ut() {
            var t = [];
            return function e(n, i) {
                return t.push(n + " ") > r.cacheLength && delete e[t.shift()], e[n + " "] = i
            }
        }
        function lt(t) {
            return t[x] = !0, t
        }
        function ht(t) {
            var e = f.createElement("fieldset");
            try {
                return !!t(e)
            } catch (t) {
                return !1
            } finally {
                e.parentNode && e.parentNode.removeChild(e),
                e = null
            }
        }
        function ct(t, e) {
            for (var n = t.split("|"), i = n.length; i--;)
                r.attrHandle[n[i]] = e
        }
        function pt(t, e) {
            var n = e && t,
                r = n && 1 === t.nodeType && 1 === e.nodeType && t.sourceIndex - e.sourceIndex;
            if (r)
                return r;
            if (n)
                for (; n = n.nextSibling;)
                    if (n === e)
                        return -1;
            return t ? 1 : -1
        }
        function ft(t) {
            return function(e) {
                return "input" === e.nodeName.toLowerCase() && e.type === t
            }
        }
        function dt(t) {
            return function(e) {
                var n = e.nodeName.toLowerCase();
                return ("input" === n || "button" === n) && e.type === t
            }
        }
        function gt(t) {
            return function(e) {
                return "form" in e ? e.parentNode && !1 === e.disabled ? "label" in e ? "label" in e.parentNode ? e.parentNode.disabled === t : e.disabled === t : e.isDisabled === t || e.isDisabled !== !t && st(e) === t : e.disabled === t : "label" in e && e.disabled === t
            }
        }
        function yt(t) {
            return lt((function(e) {
                return e = +e, lt((function(n, r) {
                    for (var i, o = t([], n.length, e), s = o.length; s--;)
                        n[i = o[s]] && (n[i] = !(r[i] = n[i]))
                }))
            }))
        }
        function vt(t) {
            return t && void 0 !== t.getElementsByTagName && t
        }
        for (e in n = at.support = {}, o = at.isXML = function(t) {
            var e = t && t.namespaceURI,
                n = t && (t.ownerDocument || t).documentElement;
            return !$.test(e || n && n.nodeName || "HTML")
        }, p = at.setDocument = function(t) {
            var e,
                i,
                s = t ? t.ownerDocument || t : E;
            return s != f && 9 === s.nodeType && s.documentElement ? (d = (f = s).documentElement, g = !o(f), E != f && (i = f.defaultView) && i.top !== i && (i.addEventListener ? i.addEventListener("unload", ot, !1) : i.attachEvent && i.attachEvent("onunload", ot)), n.scope = ht((function(t) {
                return d.appendChild(t).appendChild(f.createElement("div")), void 0 !== t.querySelectorAll && !t.querySelectorAll(":scope fieldset div").length
            })), n.attributes = ht((function(t) {
                return t.className = "i", !t.getAttribute("className")
            })), n.getElementsByTagName = ht((function(t) {
                return t.appendChild(f.createComment("")), !t.getElementsByTagName("*").length
            })), n.getElementsByClassName = J.test(f.getElementsByClassName), n.getById = ht((function(t) {
                return d.appendChild(t).id = x, !f.getElementsByName || !f.getElementsByName(x).length
            })), n.getById ? (r.filter.ID = function(t) {
                var e = t.replace(et, nt);
                return function(t) {
                    return t.getAttribute("id") === e
                }
            }, r.find.ID = function(t, e) {
                if (void 0 !== e.getElementById && g) {
                    var n = e.getElementById(t);
                    return n ? [n] : []
                }
            }) : (r.filter.ID = function(t) {
                var e = t.replace(et, nt);
                return function(t) {
                    var n = void 0 !== t.getAttributeNode && t.getAttributeNode("id");
                    return n && n.value === e
                }
            }, r.find.ID = function(t, e) {
                if (void 0 !== e.getElementById && g) {
                    var n,
                        r,
                        i,
                        o = e.getElementById(t);
                    if (o) {
                        if ((n = o.getAttributeNode("id")) && n.value === t)
                            return [o];
                        for (i = e.getElementsByName(t), r = 0; o = i[r++];)
                            if ((n = o.getAttributeNode("id")) && n.value === t)
                                return [o]
                    }
                    return []
                }
            }), r.find.TAG = n.getElementsByTagName ? function(t, e) {
                return void 0 !== e.getElementsByTagName ? e.getElementsByTagName(t) : n.qsa ? e.querySelectorAll(t) : void 0
            } : function(t, e) {
                var n,
                    r = [],
                    i = 0,
                    o = e.getElementsByTagName(t);
                if ("*" === t) {
                    for (; n = o[i++];)
                        1 === n.nodeType && r.push(n);
                    return r
                }
                return o
            }, r.find.CLASS = n.getElementsByClassName && function(t, e) {
                if (void 0 !== e.getElementsByClassName && g)
                    return e.getElementsByClassName(t)
            }, v = [], y = [], (n.qsa = J.test(f.querySelectorAll)) && (ht((function(t) {
                var e;
                d.appendChild(t).innerHTML = "<a id='" + x + "'></a><select id='" + x + "-\r\\' msallowcapture=''><option selected=''></option></select>",
                t.querySelectorAll("[msallowcapture^='']").length && y.push("[*^$]=[\\x20\\t\\r\\n\\f]*(?:''|\"\")"),
                t.querySelectorAll("[selected]").length || y.push("\\[[\\x20\\t\\r\\n\\f]*(?:value|" + F + ")"),
                t.querySelectorAll("[id~=" + x + "-]").length || y.push("~="),
                (e = f.createElement("input")).setAttribute("name", ""),
                t.appendChild(e),
                t.querySelectorAll("[name='']").length || y.push("\\[[\\x20\\t\\r\\n\\f]*name[\\x20\\t\\r\\n\\f]*=[\\x20\\t\\r\\n\\f]*(?:''|\"\")"),
                t.querySelectorAll(":checked").length || y.push(":checked"),
                t.querySelectorAll("a#" + x + "+*").length || y.push(".#.+[+~]"),
                t.querySelectorAll("\\\f"),
                y.push("[\\r\\n\\f]")
            })), ht((function(t) {
                t.innerHTML = "<a href='' disabled='disabled'></a><select disabled='disabled'><option/></select>";
                var e = f.createElement("input");
                e.setAttribute("type", "hidden"),
                t.appendChild(e).setAttribute("name", "D"),
                t.querySelectorAll("[name=d]").length && y.push("name[\\x20\\t\\r\\n\\f]*[*^$|!~]?="),
                2 !== t.querySelectorAll(":enabled").length && y.push(":enabled", ":disabled"),
                d.appendChild(t).disabled = !0,
                2 !== t.querySelectorAll(":disabled").length && y.push(":enabled", ":disabled"),
                t.querySelectorAll("*,:x"),
                y.push(",.*:")
            }))), (n.matchesSelector = J.test(m = d.matches || d.webkitMatchesSelector || d.mozMatchesSelector || d.oMatchesSelector || d.msMatchesSelector)) && ht((function(t) {
                n.disconnectedMatch = m.call(t, "*"),
                m.call(t, "[s!='']:x"),
                v.push("!=", B)
            })), y = y.length && new RegExp(y.join("|")), v = v.length && new RegExp(v.join("|")), e = J.test(d.compareDocumentPosition), _ = e || J.test(d.contains) ? function(t, e) {
                var n = 9 === t.nodeType ? t.documentElement : t,
                    r = e && e.parentNode;
                return t === r || !(!r || 1 !== r.nodeType || !(n.contains ? n.contains(r) : t.compareDocumentPosition && 16 & t.compareDocumentPosition(r)))
            } : function(t, e) {
                if (e)
                    for (; e = e.parentNode;)
                        if (e === t)
                            return !0;
                return !1
            }, T = e ? function(t, e) {
                if (t === e)
                    return c = !0, 0;
                var r = !t.compareDocumentPosition - !e.compareDocumentPosition;
                return r || (1 & (r = (t.ownerDocument || t) == (e.ownerDocument || e) ? t.compareDocumentPosition(e) : 1) || !n.sortDetached && e.compareDocumentPosition(t) === r ? t == f || t.ownerDocument == E && _(E, t) ? -1 : e == f || e.ownerDocument == E && _(E, e) ? 1 : h ? D(h, t) - D(h, e) : 0 : 4 & r ? -1 : 1)
            } : function(t, e) {
                if (t === e)
                    return c = !0, 0;
                var n,
                    r = 0,
                    i = t.parentNode,
                    o = e.parentNode,
                    s = [t],
                    a = [e];
                if (!i || !o)
                    return t == f ? -1 : e == f ? 1 : i ? -1 : o ? 1 : h ? D(h, t) - D(h, e) : 0;
                if (i === o)
                    return pt(t, e);
                for (n = t; n = n.parentNode;)
                    s.unshift(n);
                for (n = e; n = n.parentNode;)
                    a.unshift(n);
                for (; s[r] === a[r];)
                    r++;
                return r ? pt(s[r], a[r]) : s[r] == E ? -1 : a[r] == E ? 1 : 0
            }, f) : f
        }, at.matches = function(t, e) {
            return at(t, null, null, e)
        }, at.matchesSelector = function(t, e) {
            if (p(t), n.matchesSelector && g && !I[e + " "] && (!v || !v.test(e)) && (!y || !y.test(e)))
                try {
                    var r = m.call(t, e);
                    if (r || n.disconnectedMatch || t.document && 11 !== t.document.nodeType)
                        return r
                } catch (t) {
                    I(e, !0)
                }
            return at(e, f, null, [t]).length > 0
        }, at.contains = function(t, e) {
            return (t.ownerDocument || t) != f && p(t), _(t, e)
        }, at.attr = function(t, e) {
            (t.ownerDocument || t) != f && p(t);
            var i = r.attrHandle[e.toLowerCase()],
                o = i && P.call(r.attrHandle, e.toLowerCase()) ? i(t, e, !g) : void 0;
            return void 0 !== o ? o : n.attributes || !g ? t.getAttribute(e) : (o = t.getAttributeNode(e)) && o.specified ? o.value : null
        }, at.escape = function(t) {
            return (t + "").replace(rt, it)
        }, at.error = function(t) {
            throw new Error("Syntax error, unrecognized expression: " + t)
        }, at.uniqueSort = function(t) {
            var e,
                r = [],
                i = 0,
                o = 0;
            if (c = !n.detectDuplicates, h = !n.sortStable && t.slice(0), t.sort(T), c) {
                for (; e = t[o++];)
                    e === t[o] && (i = r.push(o));
                for (; i--;)
                    t.splice(r[i], 1)
            }
            return h = null, t
        }, i = at.getText = function(t) {
            var e,
                n = "",
                r = 0,
                o = t.nodeType;
            if (o) {
                if (1 === o || 9 === o || 11 === o) {
                    if ("string" == typeof t.textContent)
                        return t.textContent;
                    for (t = t.firstChild; t; t = t.nextSibling)
                        n += i(t)
                } else if (3 === o || 4 === o)
                    return t.nodeValue
            } else
                for (; e = t[r++];)
                    n += i(e);
            return n
        }, r = at.selectors = {
            cacheLength: 50,
            createPseudo: lt,
            match: W,
            attrHandle: {},
            find: {},
            relative: {
                ">": {
                    dir: "parentNode",
                    first: !0
                },
                " ": {
                    dir: "parentNode"
                },
                "+": {
                    dir: "previousSibling",
                    first: !0
                },
                "~": {
                    dir: "previousSibling"
                }
            },
            preFilter: {
                ATTR: function(t) {
                    return t[1] = t[1].replace(et, nt), t[3] = (t[3] || t[4] || t[5] || "").replace(et, nt), "~=" === t[2] && (t[3] = " " + t[3] + " "), t.slice(0, 4)
                },
                CHILD: function(t) {
                    return t[1] = t[1].toLowerCase(), "nth" === t[1].slice(0, 3) ? (t[3] || at.error(t[0]), t[4] = +(t[4] ? t[5] + (t[6] || 1) : 2 * ("even" === t[3] || "odd" === t[3])), t[5] = +(t[7] + t[8] || "odd" === t[3])) : t[3] && at.error(t[0]), t
                },
                PSEUDO: function(t) {
                    var e,
                        n = !t[6] && t[2];
                    return W.CHILD.test(t[0]) ? null : (t[3] ? t[2] = t[4] || t[5] || "" : n && H.test(n) && (e = s(n, !0)) && (e = n.indexOf(")", n.length - e) - n.length) && (t[0] = t[0].slice(0, e), t[2] = n.slice(0, e)), t.slice(0, 3))
                }
            },
            filter: {
                TAG: function(t) {
                    var e = t.replace(et, nt).toLowerCase();
                    return "*" === t ? function() {
                        return !0
                    } : function(t) {
                        return t.nodeName && t.nodeName.toLowerCase() === e
                    }
                },
                CLASS: function(t) {
                    var e = C[t + " "];
                    return e || (e = new RegExp("(^|[\\x20\\t\\r\\n\\f])" + t + "(" + k + "|$)"), C(t, (function(t) {
                            return e.test("string" == typeof t.className && t.className || void 0 !== t.getAttribute && t.getAttribute("class") || "")
                        })))
                },
                ATTR: function(t, e, n) {
                    return function(r) {
                        var i = at.attr(r, t);
                        return null == i ? "!=" === e : !e || (i += "", "=" === e ? i === n : "!=" === e ? i !== n : "^=" === e ? n && 0 === i.indexOf(n) : "*=" === e ? n && i.indexOf(n) > -1 : "$=" === e ? n && i.slice(-n.length) === n : "~=" === e ? (" " + i.replace(q, " ") + " ").indexOf(n) > -1 : "|=" === e && (i === n || i.slice(0, n.length + 1) === n + "-"))
                    }
                },
                CHILD: function(t, e, n, r, i) {
                    var o = "nth" !== t.slice(0, 3),
                        s = "last" !== t.slice(-4),
                        a = "of-type" === e;
                    return 1 === r && 0 === i ? function(t) {
                        return !!t.parentNode
                    } : function(e, n, u) {
                        var l,
                            h,
                            c,
                            p,
                            f,
                            d,
                            g = o !== s ? "nextSibling" : "previousSibling",
                            y = e.parentNode,
                            v = a && e.nodeName.toLowerCase(),
                            m = !u && !a,
                            _ = !1;
                        if (y) {
                            if (o) {
                                for (; g;) {
                                    for (p = e; p = p[g];)
                                        if (a ? p.nodeName.toLowerCase() === v : 1 === p.nodeType)
                                            return !1;
                                    d = g = "only" === t && !d && "nextSibling"
                                }
                                return !0
                            }
                            if (d = [s ? y.firstChild : y.lastChild], s && m) {
                                for (_ = (f = (l = (h = (c = (p = y)[x] || (p[x] = {}))[p.uniqueID] || (c[p.uniqueID] = {}))[t] || [])[0] === w && l[1]) && l[2], p = f && y.childNodes[f]; p = ++f && p && p[g] || (_ = f = 0) || d.pop();)
                                    if (1 === p.nodeType && ++_ && p === e) {
                                        h[t] = [w, f, _];
                                        break
                                    }
                            } else if (m && (_ = f = (l = (h = (c = (p = e)[x] || (p[x] = {}))[p.uniqueID] || (c[p.uniqueID] = {}))[t] || [])[0] === w && l[1]), !1 === _)
                                for (; (p = ++f && p && p[g] || (_ = f = 0) || d.pop()) && ((a ? p.nodeName.toLowerCase() !== v : 1 !== p.nodeType) || !++_ || (m && ((h = (c = p[x] || (p[x] = {}))[p.uniqueID] || (c[p.uniqueID] = {}))[t] = [w, _]), p !== e));)
                                    ;
                            return (_ -= i) === r || _ % r == 0 && _ / r >= 0
                        }
                    }
                },
                PSEUDO: function(t, e) {
                    var n,
                        i = r.pseudos[t] || r.setFilters[t.toLowerCase()] || at.error("unsupported pseudo: " + t);
                    return i[x] ? i(e) : i.length > 1 ? (n = [t, t, "", e], r.setFilters.hasOwnProperty(t.toLowerCase()) ? lt((function(t, n) {
                        for (var r, o = i(t, e), s = o.length; s--;)
                            t[r = D(t, o[s])] = !(n[r] = o[s])
                    })) : function(t) {
                        return i(t, 0, n)
                    }) : i
                }
            },
            pseudos: {
                not: lt((function(t) {
                    var e = [],
                        n = [],
                        r = a(t.replace(z, "$1"));
                    return r[x] ? lt((function(t, e, n, i) {
                        for (var o, s = r(t, null, i, []), a = t.length; a--;)
                            (o = s[a]) && (t[a] = !(e[a] = o))
                    })) : function(t, i, o) {
                        return e[0] = t, r(e, null, o, n), e[0] = null, !n.pop()
                    }
                })),
                has: lt((function(t) {
                    return function(e) {
                        return at(t, e).length > 0
                    }
                })),
                contains: lt((function(t) {
                    return t = t.replace(et, nt), function(e) {
                        return (e.textContent || i(e)).indexOf(t) > -1
                    }
                })),
                lang: lt((function(t) {
                    return Y.test(t || "") || at.error("unsupported lang: " + t), t = t.replace(et, nt).toLowerCase(), function(e) {
                        var n;
                        do {
                            if (n = g ? e.lang : e.getAttribute("xml:lang") || e.getAttribute("lang"))
                                return (n = n.toLowerCase()) === t || 0 === n.indexOf(t + "-")
                        } while ((e = e.parentNode) && 1 === e.nodeType);
                        return !1
                    }
                })),
                target: function(e) {
                    var n = t.location && t.location.hash;
                    return n && n.slice(1) === e.id
                },
                root: function(t) {
                    return t === d
                },
                focus: function(t) {
                    return t === f.activeElement && (!f.hasFocus || f.hasFocus()) && !!(t.type || t.href || ~t.tabIndex)
                },
                enabled: gt(!1),
                disabled: gt(!0),
                checked: function(t) {
                    var e = t.nodeName.toLowerCase();
                    return "input" === e && !!t.checked || "option" === e && !!t.selected
                },
                selected: function(t) {
                    return t.parentNode && t.parentNode.selectedIndex, !0 === t.selected
                },
                empty: function(t) {
                    for (t = t.firstChild; t; t = t.nextSibling)
                        if (t.nodeType < 6)
                            return !1;
                    return !0
                },
                parent: function(t) {
                    return !r.pseudos.empty(t)
                },
                header: function(t) {
                    return Z.test(t.nodeName)
                },
                input: function(t) {
                    return K.test(t.nodeName)
                },
                button: function(t) {
                    var e = t.nodeName.toLowerCase();
                    return "input" === e && "button" === t.type || "button" === e
                },
                text: function(t) {
                    var e;
                    return "input" === t.nodeName.toLowerCase() && "text" === t.type && (null == (e = t.getAttribute("type")) || "text" === e.toLowerCase())
                },
                first: yt((function() {
                    return [0]
                })),
                last: yt((function(t, e) {
                    return [e - 1]
                })),
                eq: yt((function(t, e, n) {
                    return [n < 0 ? n + e : n]
                })),
                even: yt((function(t, e) {
                    for (var n = 0; n < e; n += 2)
                        t.push(n);
                    return t
                })),
                odd: yt((function(t, e) {
                    for (var n = 1; n < e; n += 2)
                        t.push(n);
                    return t
                })),
                lt: yt((function(t, e, n) {
                    for (var r = n < 0 ? n + e : n > e ? e : n; --r >= 0;)
                        t.push(r);
                    return t
                })),
                gt: yt((function(t, e, n) {
                    for (var r = n < 0 ? n + e : n; ++r < e;)
                        t.push(r);
                    return t
                }))
            }
        }, r.pseudos.nth = r.pseudos.eq, {
            radio: !0,
            checkbox: !0,
            file: !0,
            password: !0,
            image: !0
        })
            r.pseudos[e] = ft(e);
        for (e in {
            submit: !0,
            reset: !0
        })
            r.pseudos[e] = dt(e);
        function mt() {}
        function _t(t) {
            for (var e = 0, n = t.length, r = ""; e < n; e++)
                r += t[e].value;
            return r
        }
        function xt(t, e, n) {
            var r = e.dir,
                i = e.next,
                o = i || r,
                s = n && "parentNode" === o,
                a = b++;
            return e.first ? function(e, n, i) {
                for (; e = e[r];)
                    if (1 === e.nodeType || s)
                        return t(e, n, i);
                return !1
            } : function(e, n, u) {
                var l,
                    h,
                    c,
                    p = [w, a];
                if (u) {
                    for (; e = e[r];)
                        if ((1 === e.nodeType || s) && t(e, n, u))
                            return !0
                } else
                    for (; e = e[r];)
                        if (1 === e.nodeType || s)
                            if (h = (c = e[x] || (e[x] = {}))[e.uniqueID] || (c[e.uniqueID] = {}), i && i === e.nodeName.toLowerCase())
                                e = e[r] || e;
                            else {
                                if ((l = h[o]) && l[0] === w && l[1] === a)
                                    return p[2] = l[2];
                                if (h[o] = p, p[2] = t(e, n, u))
                                    return !0
                            }
                return !1
            }
        }
        function Et(t) {
            return t.length > 1 ? function(e, n, r) {
                for (var i = t.length; i--;)
                    if (!t[i](e, n, r))
                        return !1;
                return !0
            } : t[0]
        }
        function wt(t, e, n, r, i) {
            for (var o, s = [], a = 0, u = t.length, l = null != e; a < u; a++)
                (o = t[a]) && (n && !n(o, r, i) || (s.push(o), l && e.push(a)));
            return s
        }
        function bt(t, e, n, r, i, o) {
            return r && !r[x] && (r = bt(r)), i && !i[x] && (i = bt(i, o)), lt((function(o, s, a, u) {
                var l,
                    h,
                    c,
                    p = [],
                    f = [],
                    d = s.length,
                    g = o || function(t, e, n) {
                        for (var r = 0, i = e.length; r < i; r++)
                            at(t, e[r], n);
                        return n
                    }(e || "*", a.nodeType ? [a] : a, []),
                    y = !t || !o && e ? g : wt(g, p, t, a, u),
                    v = n ? i || (o ? t : d || r) ? [] : s : y;
                if (n && n(y, v, a, u), r)
                    for (l = wt(v, f), r(l, [], a, u), h = l.length; h--;)
                        (c = l[h]) && (v[f[h]] = !(y[f[h]] = c));
                if (o) {
                    if (i || t) {
                        if (i) {
                            for (l = [], h = v.length; h--;)
                                (c = v[h]) && l.push(y[h] = c);
                            i(null, v = [], l, u)
                        }
                        for (h = v.length; h--;)
                            (c = v[h]) && (l = i ? D(o, c) : p[h]) > -1 && (o[l] = !(s[l] = c))
                    }
                } else
                    v = wt(v === s ? v.splice(d, v.length) : v),
                    i ? i(null, s, v, u) : R.apply(s, v)
            }))
        }
        function Ct(t) {
            for (var e, n, i, o = t.length, s = r.relative[t[0].type], a = s || r.relative[" "], u = s ? 1 : 0, h = xt((function(t) {
                    return t === e
                }), a, !0), c = xt((function(t) {
                    return D(e, t) > -1
                }), a, !0), p = [function(t, n, r) {
                    var i = !s && (r || n !== l) || ((e = n).nodeType ? h(t, n, r) : c(t, n, r));
                    return e = null, i
                }]; u < o; u++)
                if (n = r.relative[t[u].type])
                    p = [xt(Et(p), n)];
                else {
                    if ((n = r.filter[t[u].type].apply(null, t[u].matches))[x]) {
                        for (i = ++u; i < o && !r.relative[t[i].type]; i++)
                            ;
                        return bt(u > 1 && Et(p), u > 1 && _t(t.slice(0, u - 1).concat({
                            value: " " === t[u - 2].type ? "*" : ""
                        })).replace(z, "$1"), n, u < i && Ct(t.slice(u, i)), i < o && Ct(t = t.slice(i)), i < o && _t(t))
                    }
                    p.push(n)
                }
            return Et(p)
        }
        return mt.prototype = r.filters = r.pseudos, r.setFilters = new mt, s = at.tokenize = function(t, e) {
            var n,
                i,
                o,
                s,
                a,
                u,
                l,
                h = M[t + " "];
            if (h)
                return e ? 0 : h.slice(0);
            for (a = t, u = [], l = r.preFilter; a;) {
                for (s in n && !(i = U.exec(a)) || (i && (a = a.slice(i[0].length) || a), u.push(o = [])), n = !1, (i = V.exec(a)) && (n = i.shift(), o.push({
                    value: n,
                    type: i[0].replace(z, " ")
                }), a = a.slice(n.length)), r.filter)
                    !(i = W[s].exec(a)) || l[s] && !(i = l[s](i)) || (n = i.shift(), o.push({
                        value: n,
                        type: s,
                        matches: i
                    }), a = a.slice(n.length));
                if (!n)
                    break
            }
            return e ? a.length : a ? at.error(t) : M(t, u).slice(0)
        }, a = at.compile = function(t, e) {
            var n,
                i = [],
                o = [],
                a = S[t + " "];
            if (!a) {
                for (e || (e = s(t)), n = e.length; n--;)
                    (a = Ct(e[n]))[x] ? i.push(a) : o.push(a);
                a = S(t, function(t, e) {
                    var n = e.length > 0,
                        i = t.length > 0,
                        o = function(o, s, a, u, h) {
                            var c,
                                d,
                                y,
                                v = 0,
                                m = "0",
                                _ = o && [],
                                x = [],
                                E = l,
                                b = o || i && r.find.TAG("*", h),
                                C = w += null == E ? 1 : Math.random() || .1,
                                M = b.length;
                            for (h && (l = s == f || s || h); m !== M && null != (c = b[m]); m++) {
                                if (i && c) {
                                    for (d = 0, s || c.ownerDocument == f || (p(c), a = !g); y = t[d++];)
                                        if (y(c, s || f, a)) {
                                            u.push(c);
                                            break
                                        }
                                    h && (w = C)
                                }
                                n && ((c = !y && c) && v--, o && _.push(c))
                            }
                            if (v += m, n && m !== v) {
                                for (d = 0; y = e[d++];)
                                    y(_, x, s, a);
                                if (o) {
                                    if (v > 0)
                                        for (; m--;)
                                            _[m] || x[m] || (x[m] = O.call(u));
                                    x = wt(x)
                                }
                                R.apply(u, x),
                                h && !o && x.length > 0 && v + e.length > 1 && at.uniqueSort(u)
                            }
                            return h && (w = C, l = E), _
                        };
                    return n ? lt(o) : o
                }(o, i)),
                a.selector = t
            }
            return a
        }, u = at.select = function(t, e, n, i) {
            var o,
                u,
                l,
                h,
                c,
                p = "function" == typeof t && t,
                f = !i && s(t = p.selector || t);
            if (n = n || [], 1 === f.length) {
                if ((u = f[0] = f[0].slice(0)).length > 2 && "ID" === (l = u[0]).type && 9 === e.nodeType && g && r.relative[u[1].type]) {
                    if (!(e = (r.find.ID(l.matches[0].replace(et, nt), e) || [])[0]))
                        return n;
                    p && (e = e.parentNode),
                    t = t.slice(u.shift().value.length)
                }
                for (o = W.needsContext.test(t) ? 0 : u.length; o-- && (l = u[o], !r.relative[h = l.type]);)
                    if ((c = r.find[h]) && (i = c(l.matches[0].replace(et, nt), tt.test(u[0].type) && vt(e.parentNode) || e))) {
                        if (u.splice(o, 1), !(t = i.length && _t(u)))
                            return R.apply(n, i), n;
                        break
                    }
            }
            return (p || a(t, f))(i, e, !g, n, !e || tt.test(t) && vt(e.parentNode) || e), n
        }, n.sortStable = x.split("").sort(T).join("") === x, n.detectDuplicates = !!c, p(), n.sortDetached = ht((function(t) {
            return 1 & t.compareDocumentPosition(f.createElement("fieldset"))
        })), ht((function(t) {
            return t.innerHTML = "<a href='#'></a>", "#" === t.firstChild.getAttribute("href")
        })) || ct("type|href|height|width", (function(t, e, n) {
            if (!n)
                return t.getAttribute(e, "type" === e.toLowerCase() ? 1 : 2)
        })), n.attributes && ht((function(t) {
            return t.innerHTML = "<input/>", t.firstChild.setAttribute("value", ""), "" === t.firstChild.getAttribute("value")
        })) || ct("value", (function(t, e, n) {
            if (!n && "input" === t.nodeName.toLowerCase())
                return t.defaultValue
        })), ht((function(t) {
            return null == t.getAttribute("disabled")
        })) || ct(F, (function(t, e, n) {
            var r;
            if (!n)
                return !0 === t[e] ? e.toLowerCase() : (r = t.getAttributeNode(e)) && r.specified ? r.value : null
        })), at
    }(t);
    E.find = b,
    E.expr = b.selectors,
    E.expr[":"] = E.expr.pseudos,
    E.uniqueSort = E.unique = b.uniqueSort,
    E.text = b.getText,
    E.isXMLDoc = b.isXML,
    E.contains = b.contains,
    E.escapeSelector = b.escape;
    var C = function(t, e, n) {
            for (var r = [], i = void 0 !== n; (t = t[e]) && 9 !== t.nodeType;)
                if (1 === t.nodeType) {
                    if (i && E(t).is(n))
                        break;
                    r.push(t)
                }
            return r
        },
        M = function(t, e) {
            for (var n = []; t; t = t.nextSibling)
                1 === t.nodeType && t !== e && n.push(t);
            return n
        },
        S = E.expr.match.needsContext;
    function I(t, e) {
        return t.nodeName && t.nodeName.toLowerCase() === e.toLowerCase()
    }
    var T = /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i;
    function P(t, e, n) {
        return d(e) ? E.grep(t, (function(t, r) {
            return !!e.call(t, r, t) !== n
        })) : e.nodeType ? E.grep(t, (function(t) {
            return t === e !== n
        })) : "string" != typeof e ? E.grep(t, (function(t) {
            return a.call(e, t) > -1 !== n
        })) : E.filter(e, t, n)
    }
    E.filter = function(t, e, n) {
        var r = e[0];
        return n && (t = ":not(" + t + ")"), 1 === e.length && 1 === r.nodeType ? E.find.matchesSelector(r, t) ? [r] : [] : E.find.matches(t, E.grep(e, (function(t) {
            return 1 === t.nodeType
        })))
    },
    E.fn.extend({
        find: function(t) {
            var e,
                n,
                r = this.length,
                i = this;
            if ("string" != typeof t)
                return this.pushStack(E(t).filter((function() {
                    for (e = 0; e < r; e++)
                        if (E.contains(i[e], this))
                            return !0
                })));
            for (n = this.pushStack([]), e = 0; e < r; e++)
                E.find(t, i[e], n);
            return r > 1 ? E.uniqueSort(n) : n
        },
        filter: function(t) {
            return this.pushStack(P(this, t || [], !1))
        },
        not: function(t) {
            return this.pushStack(P(this, t || [], !0))
        },
        is: function(t) {
            return !!P(this, "string" == typeof t && S.test(t) ? E(t) : t || [], !1).length
        }
    });
    var L,
        O = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/;
    (E.fn.init = function(t, e, n) {
        var r,
            i;
        if (!t)
            return this;
        if (n = n || L, "string" == typeof t) {
            if (!(r = "<" === t[0] && ">" === t[t.length - 1] && t.length >= 3 ? [null, t, null] : O.exec(t)) || !r[1] && e)
                return !e || e.jquery ? (e || n).find(t) : this.constructor(e).find(t);
            if (r[1]) {
                if (e = e instanceof E ? e[0] : e, E.merge(this, E.parseHTML(r[1], e && e.nodeType ? e.ownerDocument || e : y, !0)), T.test(r[1]) && E.isPlainObject(e))
                    for (r in e)
                        d(this[r]) ? this[r](e[r]) : this.attr(r, e[r]);
                return this
            }
            return (i = y.getElementById(r[2])) && (this[0] = i, this.length = 1), this
        }
        return t.nodeType ? (this[0] = t, this.length = 1, this) : d(t) ? void 0 !== n.ready ? n.ready(t) : t(E) : E.makeArray(t, this)
    }).prototype = E.fn,
    L = E(y);
    var N = /^(?:parents|prev(?:Until|All))/,
        R = {
            children: !0,
            contents: !0,
            next: !0,
            prev: !0
        };
    function A(t, e) {
        for (; (t = t[e]) && 1 !== t.nodeType;)
            ;
        return t
    }
    E.fn.extend({
        has: function(t) {
            var e = E(t, this),
                n = e.length;
            return this.filter((function() {
                for (var t = 0; t < n; t++)
                    if (E.contains(this, e[t]))
                        return !0
            }))
        },
        closest: function(t, e) {
            var n,
                r = 0,
                i = this.length,
                o = [],
                s = "string" != typeof t && E(t);
            if (!S.test(t))
                for (; r < i; r++)
                    for (n = this[r]; n && n !== e; n = n.parentNode)
                        if (n.nodeType < 11 && (s ? s.index(n) > -1 : 1 === n.nodeType && E.find.matchesSelector(n, t))) {
                            o.push(n);
                            break
                        }
            return this.pushStack(o.length > 1 ? E.uniqueSort(o) : o)
        },
        index: function(t) {
            return t ? "string" == typeof t ? a.call(E(t), this[0]) : a.call(this, t.jquery ? t[0] : t) : this[0] && this[0].parentNode ? this.first().prevAll().length : -1
        },
        add: function(t, e) {
            return this.pushStack(E.uniqueSort(E.merge(this.get(), E(t, e))))
        },
        addBack: function(t) {
            return this.add(null == t ? this.prevObject : this.prevObject.filter(t))
        }
    }),
    E.each({
        parent: function(t) {
            var e = t.parentNode;
            return e && 11 !== e.nodeType ? e : null
        },
        parents: function(t) {
            return C(t, "parentNode")
        },
        parentsUntil: function(t, e, n) {
            return C(t, "parentNode", n)
        },
        next: function(t) {
            return A(t, "nextSibling")
        },
        prev: function(t) {
            return A(t, "previousSibling")
        },
        nextAll: function(t) {
            return C(t, "nextSibling")
        },
        prevAll: function(t) {
            return C(t, "previousSibling")
        },
        nextUntil: function(t, e, n) {
            return C(t, "nextSibling", n)
        },
        prevUntil: function(t, e, n) {
            return C(t, "previousSibling", n)
        },
        siblings: function(t) {
            return M((t.parentNode || {}).firstChild, t)
        },
        children: function(t) {
            return M(t.firstChild)
        },
        contents: function(t) {
            return null != t.contentDocument && r(t.contentDocument) ? t.contentDocument : (I(t, "template") && (t = t.content || t), E.merge([], t.childNodes))
        }
    }, (function(t, e) {
        E.fn[t] = function(n, r) {
            var i = E.map(this, e, n);
            return "Until" !== t.slice(-5) && (r = n), r && "string" == typeof r && (i = E.filter(r, i)), this.length > 1 && (R[t] || E.uniqueSort(i), N.test(t) && i.reverse()), this.pushStack(i)
        }
    }));
    var D = /[^\x20\t\r\n\f]+/g;
    function F(t) {
        return t
    }
    function k(t) {
        throw t
    }
    function j(t, e, n, r) {
        var i;
        try {
            t && d(i = t.promise) ? i.call(t).done(e).fail(n) : t && d(i = t.then) ? i.call(t, e, n) : e.apply(void 0, [t].slice(r))
        } catch (t) {
            n.apply(void 0, [t])
        }
    }
    E.Callbacks = function(t) {
        t = "string" == typeof t ? function(t) {
            var e = {};
            return E.each(t.match(D) || [], (function(t, n) {
                e[n] = !0
            })), e
        }(t) : E.extend({}, t);
        var e,
            n,
            r,
            i,
            o = [],
            s = [],
            a = -1,
            u = function() {
                for (i = i || t.once, r = e = !0; s.length; a = -1)
                    for (n = s.shift(); ++a < o.length;)
                        !1 === o[a].apply(n[0], n[1]) && t.stopOnFalse && (a = o.length, n = !1);
                t.memory || (n = !1),
                e = !1,
                i && (o = n ? [] : "")
            },
            l = {
                add: function() {
                    return o && (n && !e && (a = o.length - 1, s.push(n)), function e(n) {
                        E.each(n, (function(n, r) {
                            d(r) ? t.unique && l.has(r) || o.push(r) : r && r.length && "string" !== _(r) && e(r)
                        }))
                    }(arguments), n && !e && u()), this
                },
                remove: function() {
                    return E.each(arguments, (function(t, e) {
                        for (var n; (n = E.inArray(e, o, n)) > -1;)
                            o.splice(n, 1),
                            n <= a && a--
                    })), this
                },
                has: function(t) {
                    return t ? E.inArray(t, o) > -1 : o.length > 0
                },
                empty: function() {
                    return o && (o = []), this
                },
                disable: function() {
                    return i = s = [], o = n = "", this
                },
                disabled: function() {
                    return !o
                },
                lock: function() {
                    return i = s = [], n || e || (o = n = ""), this
                },
                locked: function() {
                    return !!i
                },
                fireWith: function(t, n) {
                    return i || (n = [t, (n = n || []).slice ? n.slice() : n], s.push(n), e || u()), this
                },
                fire: function() {
                    return l.fireWith(this, arguments), this
                },
                fired: function() {
                    return !!r
                }
            };
        return l
    },
    E.extend({
        Deferred: function(e) {
            var n = [["notify", "progress", E.Callbacks("memory"), E.Callbacks("memory"), 2], ["resolve", "done", E.Callbacks("once memory"), E.Callbacks("once memory"), 0, "resolved"], ["reject", "fail", E.Callbacks("once memory"), E.Callbacks("once memory"), 1, "rejected"]],
                r = "pending",
                i = {
                    state: function() {
                        return r
                    },
                    always: function() {
                        return o.done(arguments).fail(arguments), this
                    },
                    catch: function(t) {
                        return i.then(null, t)
                    },
                    pipe: function() {
                        var t = arguments;
                        return E.Deferred((function(e) {
                            E.each(n, (function(n, r) {
                                var i = d(t[r[4]]) && t[r[4]];
                                o[r[1]]((function() {
                                    var t = i && i.apply(this, arguments);
                                    t && d(t.promise) ? t.promise().progress(e.notify).done(e.resolve).fail(e.reject) : e[r[0] + "With"](this, i ? [t] : arguments)
                                }))
                            })),
                            t = null
                        })).promise()
                    },
                    then: function(e, r, i) {
                        var o = 0;
                        function s(e, n, r, i) {
                            return function() {
                                var a = this,
                                    u = arguments,
                                    l = function() {
                                        var t,
                                            l;
                                        if (!(e < o)) {
                                            if ((t = r.apply(a, u)) === n.promise())
                                                throw new TypeError("Thenable self-resolution");
                                            l = t && ("object" == typeof t || "function" == typeof t) && t.then,
                                            d(l) ? i ? l.call(t, s(o, n, F, i), s(o, n, k, i)) : (o++, l.call(t, s(o, n, F, i), s(o, n, k, i), s(o, n, F, n.notifyWith))) : (r !== F && (a = void 0, u = [t]), (i || n.resolveWith)(a, u))
                                        }
                                    },
                                    h = i ? l : function() {
                                        try {
                                            l()
                                        } catch (t) {
                                            E.Deferred.exceptionHook && E.Deferred.exceptionHook(t, h.stackTrace),
                                            e + 1 >= o && (r !== k && (a = void 0, u = [t]), n.rejectWith(a, u))
                                        }
                                    };
                                e ? h() : (E.Deferred.getStackHook && (h.stackTrace = E.Deferred.getStackHook()), t.setTimeout(h))
                            }
                        }
                        return E.Deferred((function(t) {
                            n[0][3].add(s(0, t, d(i) ? i : F, t.notifyWith)),
                            n[1][3].add(s(0, t, d(e) ? e : F)),
                            n[2][3].add(s(0, t, d(r) ? r : k))
                        })).promise()
                    },
                    promise: function(t) {
                        return null != t ? E.extend(t, i) : i
                    }
                },
                o = {};
            return E.each(n, (function(t, e) {
                var s = e[2],
                    a = e[5];
                i[e[1]] = s.add,
                a && s.add((function() {
                    r = a
                }), n[3 - t][2].disable, n[3 - t][3].disable, n[0][2].lock, n[0][3].lock),
                s.add(e[3].fire),
                o[e[0]] = function() {
                    return o[e[0] + "With"](this === o ? void 0 : this, arguments), this
                },
                o[e[0] + "With"] = s.fireWith
            })), i.promise(o), e && e.call(o, o), o
        },
        when: function(t) {
            var e = arguments.length,
                n = e,
                r = Array(n),
                o = i.call(arguments),
                s = E.Deferred(),
                a = function(t) {
                    return function(n) {
                        r[t] = this,
                        o[t] = arguments.length > 1 ? i.call(arguments) : n,
                        --e || s.resolveWith(r, o)
                    }
                };
            if (e <= 1 && (j(t, s.done(a(n)).resolve, s.reject, !e), "pending" === s.state() || d(o[n] && o[n].then)))
                return s.then();
            for (; n--;)
                j(o[n], a(n), s.reject);
            return s.promise()
        }
    });
    var G = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;
    E.Deferred.exceptionHook = function(e, n) {
        t.console && t.console.warn && e && G.test(e.name) && t.console.warn("jQuery.Deferred exception: " + e.message, e.stack, n)
    },
    E.readyException = function(e) {
        t.setTimeout((function() {
            throw e
        }))
    };
    var B = E.Deferred();
    function q() {
        y.removeEventListener("DOMContentLoaded", q),
        t.removeEventListener("load", q),
        E.ready()
    }
    E.fn.ready = function(t) {
        return B.then(t).catch((function(t) {
            E.readyException(t)
        })), this
    },
    E.extend({
        isReady: !1,
        readyWait: 1,
        ready: function(t) {
            (!0 === t ? --E.readyWait : E.isReady) || (E.isReady = !0, !0 !== t && --E.readyWait > 0 || B.resolveWith(y, [E]))
        }
    }),
    E.ready.then = B.then,
    "complete" === y.readyState || "loading" !== y.readyState && !y.documentElement.doScroll ? t.setTimeout(E.ready) : (y.addEventListener("DOMContentLoaded", q), t.addEventListener("load", q));
    var z = function(t, e, n, r, i, o, s) {
            var a = 0,
                u = t.length,
                l = null == n;
            if ("object" === _(n))
                for (a in i = !0, n)
                    z(t, e, a, n[a], !0, o, s);
            else if (void 0 !== r && (i = !0, d(r) || (s = !0), l && (s ? (e.call(t, r), e = null) : (l = e, e = function(t, e, n) {
                return l.call(E(t), n)
            })), e))
                for (; a < u; a++)
                    e(t[a], n, s ? r : r.call(t[a], a, e(t[a], n)));
            return i ? t : l ? e.call(t) : u ? e(t[0], n) : o
        },
        U = /^-ms-/,
        V = /-([a-z])/g;
    function X(t, e) {
        return e.toUpperCase()
    }
    function H(t) {
        return t.replace(U, "ms-").replace(V, X)
    }
    var Y = function(t) {
        return 1 === t.nodeType || 9 === t.nodeType || !+t.nodeType
    };
    function W() {
        this.expando = E.expando + W.uid++
    }
    W.uid = 1,
    W.prototype = {
        cache: function(t) {
            var e = t[this.expando];
            return e || (e = {}, Y(t) && (t.nodeType ? t[this.expando] = e : Object.defineProperty(t, this.expando, {
                value: e,
                configurable: !0
            }))), e
        },
        set: function(t, e, n) {
            var r,
                i = this.cache(t);
            if ("string" == typeof e)
                i[H(e)] = n;
            else
                for (r in e)
                    i[H(r)] = e[r];
            return i
        },
        get: function(t, e) {
            return void 0 === e ? this.cache(t) : t[this.expando] && t[this.expando][H(e)]
        },
        access: function(t, e, n) {
            return void 0 === e || e && "string" == typeof e && void 0 === n ? this.get(t, e) : (this.set(t, e, n), void 0 !== n ? n : e)
        },
        remove: function(t, e) {
            var n,
                r = t[this.expando];
            if (void 0 !== r) {
                if (void 0 !== e) {
                    n = (e = Array.isArray(e) ? e.map(H) : (e = H(e)) in r ? [e] : e.match(D) || []).length;
                    for (; n--;)
                        delete r[e[n]]
                }
                (void 0 === e || E.isEmptyObject(r)) && (t.nodeType ? t[this.expando] = void 0 : delete t[this.expando])
            }
        },
        hasData: function(t) {
            var e = t[this.expando];
            return void 0 !== e && !E.isEmptyObject(e)
        }
    };
    var $ = new W,
        K = new W,
        Z = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
        J = /[A-Z]/g;
    function Q(t, e, n) {
        var r;
        if (void 0 === n && 1 === t.nodeType)
            if (r = "data-" + e.replace(J, "-$&").toLowerCase(), "string" == typeof (n = t.getAttribute(r))) {
                try {
                    n = function(t) {
                        return "true" === t || "false" !== t && ("null" === t ? null : t === +t + "" ? +t : Z.test(t) ? JSON.parse(t) : t)
                    }(n)
                } catch (t) {}
                K.set(t, e, n)
            } else
                n = void 0;
        return n
    }
    E.extend({
        hasData: function(t) {
            return K.hasData(t) || $.hasData(t)
        },
        data: function(t, e, n) {
            return K.access(t, e, n)
        },
        removeData: function(t, e) {
            K.remove(t, e)
        },
        _data: function(t, e, n) {
            return $.access(t, e, n)
        },
        _removeData: function(t, e) {
            $.remove(t, e)
        }
    }),
    E.fn.extend({
        data: function(t, e) {
            var n,
                r,
                i,
                o = this[0],
                s = o && o.attributes;
            if (void 0 === t) {
                if (this.length && (i = K.get(o), 1 === o.nodeType && !$.get(o, "hasDataAttrs"))) {
                    for (n = s.length; n--;)
                        s[n] && 0 === (r = s[n].name).indexOf("data-") && (r = H(r.slice(5)), Q(o, r, i[r]));
                    $.set(o, "hasDataAttrs", !0)
                }
                return i
            }
            return "object" == typeof t ? this.each((function() {
                K.set(this, t)
            })) : z(this, (function(e) {
                var n;
                if (o && void 0 === e)
                    return void 0 !== (n = K.get(o, t)) || void 0 !== (n = Q(o, t)) ? n : void 0;
                this.each((function() {
                    K.set(this, t, e)
                }))
            }), null, e, arguments.length > 1, null, !0)
        },
        removeData: function(t) {
            return this.each((function() {
                K.remove(this, t)
            }))
        }
    }),
    E.extend({
        queue: function(t, e, n) {
            var r;
            if (t)
                return e = (e || "fx") + "queue", r = $.get(t, e), n && (!r || Array.isArray(n) ? r = $.access(t, e, E.makeArray(n)) : r.push(n)), r || []
        },
        dequeue: function(t, e) {
            e = e || "fx";
            var n = E.queue(t, e),
                r = n.length,
                i = n.shift(),
                o = E._queueHooks(t, e);
            "inprogress" === i && (i = n.shift(), r--),
            i && ("fx" === e && n.unshift("inprogress"), delete o.stop, i.call(t, (function() {
                E.dequeue(t, e)
            }), o)),
            !r && o && o.empty.fire()
        },
        _queueHooks: function(t, e) {
            var n = e + "queueHooks";
            return $.get(t, n) || $.access(t, n, {
                    empty: E.Callbacks("once memory").add((function() {
                        $.remove(t, [e + "queue", n])
                    }))
                })
        }
    }),
    E.fn.extend({
        queue: function(t, e) {
            var n = 2;
            return "string" != typeof t && (e = t, t = "fx", n--), arguments.length < n ? E.queue(this[0], t) : void 0 === e ? this : this.each((function() {
                var n = E.queue(this, t, e);
                E._queueHooks(this, t),
                "fx" === t && "inprogress" !== n[0] && E.dequeue(this, t)
            }))
        },
        dequeue: function(t) {
            return this.each((function() {
                E.dequeue(this, t)
            }))
        },
        clearQueue: function(t) {
            return this.queue(t || "fx", [])
        },
        promise: function(t, e) {
            var n,
                r = 1,
                i = E.Deferred(),
                o = this,
                s = this.length,
                a = function() {
                    --r || i.resolveWith(o, [o])
                };
            for ("string" != typeof t && (e = t, t = void 0), t = t || "fx"; s--;)
                (n = $.get(o[s], t + "queueHooks")) && n.empty && (r++, n.empty.add(a));
            return a(), i.promise(e)
        }
    });
    var tt = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source,
        et = new RegExp("^(?:([+-])=|)(" + tt + ")([a-z%]*)$", "i"),
        nt = ["Top", "Right", "Bottom", "Left"],
        rt = y.documentElement,
        it = function(t) {
            return E.contains(t.ownerDocument, t)
        },
        ot = {
            composed: !0
        };
    rt.getRootNode && (it = function(t) {
        return E.contains(t.ownerDocument, t) || t.getRootNode(ot) === t.ownerDocument
    });
    var st = function(t, e) {
        return "none" === (t = e || t).style.display || "" === t.style.display && it(t) && "none" === E.css(t, "display")
    };
    function at(t, e, n, r) {
        var i,
            o,
            s = 20,
            a = r ? function() {
                return r.cur()
            } : function() {
                return E.css(t, e, "")
            },
            u = a(),
            l = n && n[3] || (E.cssNumber[e] ? "" : "px"),
            h = t.nodeType && (E.cssNumber[e] || "px" !== l && +u) && et.exec(E.css(t, e));
        if (h && h[3] !== l) {
            for (u /= 2, l = l || h[3], h = +u || 1; s--;)
                E.style(t, e, h + l),
                (1 - o) * (1 - (o = a() / u || .5)) <= 0 && (s = 0),
                h /= o;
            h *= 2,
            E.style(t, e, h + l),
            n = n || []
        }
        return n && (h = +h || +u || 0, i = n[1] ? h + (n[1] + 1) * n[2] : +n[2], r && (r.unit = l, r.start = h, r.end = i)), i
    }
    var ut = {};
    function lt(t) {
        var e,
            n = t.ownerDocument,
            r = t.nodeName,
            i = ut[r];
        return i || (e = n.body.appendChild(n.createElement(r)), i = E.css(e, "display"), e.parentNode.removeChild(e), "none" === i && (i = "block"), ut[r] = i, i)
    }
    function ht(t, e) {
        for (var n, r, i = [], o = 0, s = t.length; o < s; o++)
            (r = t[o]).style && (n = r.style.display, e ? ("none" === n && (i[o] = $.get(r, "display") || null, i[o] || (r.style.display = "")), "" === r.style.display && st(r) && (i[o] = lt(r))) : "none" !== n && (i[o] = "none", $.set(r, "display", n)));
        for (o = 0; o < s; o++)
            null != i[o] && (t[o].style.display = i[o]);
        return t
    }
    E.fn.extend({
        show: function() {
            return ht(this, !0)
        },
        hide: function() {
            return ht(this)
        },
        toggle: function(t) {
            return "boolean" == typeof t ? t ? this.show() : this.hide() : this.each((function() {
                st(this) ? E(this).show() : E(this).hide()
            }))
        }
    });
    var ct,
        pt,
        ft = /^(?:checkbox|radio)$/i,
        dt = /<([a-z][^\/\0>\x20\t\r\n\f]*)/i,
        gt = /^$|^module$|\/(?:java|ecma)script/i;
    ct = y.createDocumentFragment().appendChild(y.createElement("div")),
    (pt = y.createElement("input")).setAttribute("type", "radio"),
    pt.setAttribute("checked", "checked"),
    pt.setAttribute("name", "t"),
    ct.appendChild(pt),
    f.checkClone = ct.cloneNode(!0).cloneNode(!0).lastChild.checked,
    ct.innerHTML = "<textarea>x</textarea>",
    f.noCloneChecked = !!ct.cloneNode(!0).lastChild.defaultValue,
    ct.innerHTML = "<option></option>",
    f.option = !!ct.lastChild;
    var yt = {
        thead: [1, "<table>", "</table>"],
        col: [2, "<table><colgroup>", "</colgroup></table>"],
        tr: [2, "<table><tbody>", "</tbody></table>"],
        td: [3, "<table><tbody><tr>", "</tr></tbody></table>"],
        _default: [0, "", ""]
    };
    function vt(t, e) {
        var n;
        return n = void 0 !== t.getElementsByTagName ? t.getElementsByTagName(e || "*") : void 0 !== t.querySelectorAll ? t.querySelectorAll(e || "*") : [], void 0 === e || e && I(t, e) ? E.merge([t], n) : n
    }
    function mt(t, e) {
        for (var n = 0, r = t.length; n < r; n++)
            $.set(t[n], "globalEval", !e || $.get(e[n], "globalEval"))
    }
    yt.tbody = yt.tfoot = yt.colgroup = yt.caption = yt.thead,
    yt.th = yt.td,
    f.option || (yt.optgroup = yt.option = [1, "<select multiple='multiple'>", "</select>"]);
    var _t = /<|&#?\w+;/;
    function xt(t, e, n, r, i) {
        for (var o, s, a, u, l, h, c = e.createDocumentFragment(), p = [], f = 0, d = t.length; f < d; f++)
            if ((o = t[f]) || 0 === o)
                if ("object" === _(o))
                    E.merge(p, o.nodeType ? [o] : o);
                else if (_t.test(o)) {
                    for (s = s || c.appendChild(e.createElement("div")), a = (dt.exec(o) || ["", ""])[1].toLowerCase(), u = yt[a] || yt._default, s.innerHTML = u[1] + E.htmlPrefilter(o) + u[2], h = u[0]; h--;)
                        s = s.lastChild;
                    E.merge(p, s.childNodes),
                    (s = c.firstChild).textContent = ""
                } else
                    p.push(e.createTextNode(o));
        for (c.textContent = "", f = 0; o = p[f++];)
            if (r && E.inArray(o, r) > -1)
                i && i.push(o);
            else if (l = it(o), s = vt(c.appendChild(o), "script"), l && mt(s), n)
                for (h = 0; o = s[h++];)
                    gt.test(o.type || "") && n.push(o);
        return c
    }
    var Et = /^([^.]*)(?:\.(.+)|)/;
    function wt() {
        return !0
    }
    function bt() {
        return !1
    }
    function Ct(t, e) {
        return t === function() {
            try {
                return y.activeElement
            } catch (t) {}
        }() == ("focus" === e)
    }
    function Mt(t, e, n, r, i, o) {
        var s,
            a;
        if ("object" == typeof e) {
            for (a in "string" != typeof n && (r = r || n, n = void 0), e)
                Mt(t, a, n, r, e[a], o);
            return t
        }
        if (null == r && null == i ? (i = n, r = n = void 0) : null == i && ("string" == typeof n ? (i = r, r = void 0) : (i = r, r = n, n = void 0)), !1 === i)
            i = bt;
        else if (!i)
            return t;
        return 1 === o && (s = i, i = function(t) {
            return E().off(t), s.apply(this, arguments)
        }, i.guid = s.guid || (s.guid = E.guid++)), t.each((function() {
            E.event.add(this, e, i, r, n)
        }))
    }
    function St(t, e, n) {
        n ? ($.set(t, e, !1), E.event.add(t, e, {
            namespace: !1,
            handler: function(t) {
                var r,
                    o,
                    s = $.get(this, e);
                if (1 & t.isTrigger && this[e]) {
                    if (s.length)
                        (E.event.special[e] || {}).delegateType && t.stopPropagation();
                    else if (s = i.call(arguments), $.set(this, e, s), r = n(this, e), this[e](), s !== (o = $.get(this, e)) || r ? $.set(this, e, !1) : o = {}, s !== o)
                        return t.stopImmediatePropagation(), t.preventDefault(), o && o.value
                } else
                    s.length && ($.set(this, e, {
                        value: E.event.trigger(E.extend(s[0], E.Event.prototype), s.slice(1), this)
                    }), t.stopImmediatePropagation())
            }
        })) : void 0 === $.get(t, e) && E.event.add(t, e, wt)
    }
    E.event = {
        global: {},
        add: function(t, e, n, r, i) {
            var o,
                s,
                a,
                u,
                l,
                h,
                c,
                p,
                f,
                d,
                g,
                y = $.get(t);
            if (Y(t))
                for (n.handler && (n = (o = n).handler, i = o.selector), i && E.find.matchesSelector(rt, i), n.guid || (n.guid = E.guid++), (u = y.events) || (u = y.events = Object.create(null)), (s = y.handle) || (s = y.handle = function(e) {
                    return void 0 !== E && E.event.triggered !== e.type ? E.event.dispatch.apply(t, arguments) : void 0
                }), l = (e = (e || "").match(D) || [""]).length; l--;)
                    f = g = (a = Et.exec(e[l]) || [])[1],
                    d = (a[2] || "").split(".").sort(),
                    f && (c = E.event.special[f] || {}, f = (i ? c.delegateType : c.bindType) || f, c = E.event.special[f] || {}, h = E.extend({
                        type: f,
                        origType: g,
                        data: r,
                        handler: n,
                        guid: n.guid,
                        selector: i,
                        needsContext: i && E.expr.match.needsContext.test(i),
                        namespace: d.join(".")
                    }, o), (p = u[f]) || ((p = u[f] = []).delegateCount = 0, c.setup && !1 !== c.setup.call(t, r, d, s) || t.addEventListener && t.addEventListener(f, s)), c.add && (c.add.call(t, h), h.handler.guid || (h.handler.guid = n.guid)), i ? p.splice(p.delegateCount++, 0, h) : p.push(h), E.event.global[f] = !0)
        },
        remove: function(t, e, n, r, i) {
            var o,
                s,
                a,
                u,
                l,
                h,
                c,
                p,
                f,
                d,
                g,
                y = $.hasData(t) && $.get(t);
            if (y && (u = y.events)) {
                for (l = (e = (e || "").match(D) || [""]).length; l--;)
                    if (f = g = (a = Et.exec(e[l]) || [])[1], d = (a[2] || "").split(".").sort(), f) {
                        for (c = E.event.special[f] || {}, p = u[f = (r ? c.delegateType : c.bindType) || f] || [], a = a[2] && new RegExp("(^|\\.)" + d.join("\\.(?:.*\\.|)") + "(\\.|$)"), s = o = p.length; o--;)
                            h = p[o],
                            !i && g !== h.origType || n && n.guid !== h.guid || a && !a.test(h.namespace) || r && r !== h.selector && ("**" !== r || !h.selector) || (p.splice(o, 1), h.selector && p.delegateCount--, c.remove && c.remove.call(t, h));
                        s && !p.length && (c.teardown && !1 !== c.teardown.call(t, d, y.handle) || E.removeEvent(t, f, y.handle), delete u[f])
                    } else
                        for (f in u)
                            E.event.remove(t, f + e[l], n, r, !0);
                E.isEmptyObject(u) && $.remove(t, "handle events")
            }
        },
        dispatch: function(t) {
            var e,
                n,
                r,
                i,
                o,
                s,
                a = new Array(arguments.length),
                u = E.event.fix(t),
                l = ($.get(this, "events") || Object.create(null))[u.type] || [],
                h = E.event.special[u.type] || {};
            for (a[0] = u, e = 1; e < arguments.length; e++)
                a[e] = arguments[e];
            if (u.delegateTarget = this, !h.preDispatch || !1 !== h.preDispatch.call(this, u)) {
                for (s = E.event.handlers.call(this, u, l), e = 0; (i = s[e++]) && !u.isPropagationStopped();)
                    for (u.currentTarget = i.elem, n = 0; (o = i.handlers[n++]) && !u.isImmediatePropagationStopped();)
                        u.rnamespace && !1 !== o.namespace && !u.rnamespace.test(o.namespace) || (u.handleObj = o, u.data = o.data, void 0 !== (r = ((E.event.special[o.origType] || {}).handle || o.handler).apply(i.elem, a)) && !1 === (u.result = r) && (u.preventDefault(), u.stopPropagation()));
                return h.postDispatch && h.postDispatch.call(this, u), u.result
            }
        },
        handlers: function(t, e) {
            var n,
                r,
                i,
                o,
                s,
                a = [],
                u = e.delegateCount,
                l = t.target;
            if (u && l.nodeType && !("click" === t.type && t.button >= 1))
                for (; l !== this; l = l.parentNode || this)
                    if (1 === l.nodeType && ("click" !== t.type || !0 !== l.disabled)) {
                        for (o = [], s = {}, n = 0; n < u; n++)
                            void 0 === s[i = (r = e[n]).selector + " "] && (s[i] = r.needsContext ? E(i, this).index(l) > -1 : E.find(i, this, null, [l]).length),
                            s[i] && o.push(r);
                        o.length && a.push({
                            elem: l,
                            handlers: o
                        })
                    }
            return l = this, u < e.length && a.push({
                elem: l,
                handlers: e.slice(u)
            }), a
        },
        addProp: function(t, e) {
            Object.defineProperty(E.Event.prototype, t, {
                enumerable: !0,
                configurable: !0,
                get: d(e) ? function() {
                    if (this.originalEvent)
                        return e(this.originalEvent)
                } : function() {
                    if (this.originalEvent)
                        return this.originalEvent[t]
                },
                set: function(e) {
                    Object.defineProperty(this, t, {
                        enumerable: !0,
                        configurable: !0,
                        writable: !0,
                        value: e
                    })
                }
            })
        },
        fix: function(t) {
            return t[E.expando] ? t : new E.Event(t)
        },
        special: {
            load: {
                noBubble: !0
            },
            click: {
                setup: function(t) {
                    var e = this || t;
                    return ft.test(e.type) && e.click && I(e, "input") && St(e, "click", wt), !1
                },
                trigger: function(t) {
                    var e = this || t;
                    return ft.test(e.type) && e.click && I(e, "input") && St(e, "click"), !0
                },
                _default: function(t) {
                    var e = t.target;
                    return ft.test(e.type) && e.click && I(e, "input") && $.get(e, "click") || I(e, "a")
                }
            },
            beforeunload: {
                postDispatch: function(t) {
                    void 0 !== t.result && t.originalEvent && (t.originalEvent.returnValue = t.result)
                }
            }
        }
    },
    E.removeEvent = function(t, e, n) {
        t.removeEventListener && t.removeEventListener(e, n)
    },
    E.Event = function(t, e) {
        if (!(this instanceof E.Event))
            return new E.Event(t, e);
        t && t.type ? (this.originalEvent = t, this.type = t.type, this.isDefaultPrevented = t.defaultPrevented || void 0 === t.defaultPrevented && !1 === t.returnValue ? wt : bt, this.target = t.target && 3 === t.target.nodeType ? t.target.parentNode : t.target, this.currentTarget = t.currentTarget, this.relatedTarget = t.relatedTarget) : this.type = t,
        e && E.extend(this, e),
        this.timeStamp = t && t.timeStamp || Date.now(),
        this[E.expando] = !0
    },
    E.Event.prototype = {
        constructor: E.Event,
        isDefaultPrevented: bt,
        isPropagationStopped: bt,
        isImmediatePropagationStopped: bt,
        isSimulated: !1,
        preventDefault: function() {
            var t = this.originalEvent;
            this.isDefaultPrevented = wt,
            t && !this.isSimulated && t.preventDefault()
        },
        stopPropagation: function() {
            var t = this.originalEvent;
            this.isPropagationStopped = wt,
            t && !this.isSimulated && t.stopPropagation()
        },
        stopImmediatePropagation: function() {
            var t = this.originalEvent;
            this.isImmediatePropagationStopped = wt,
            t && !this.isSimulated && t.stopImmediatePropagation(),
            this.stopPropagation()
        }
    },
    E.each({
        altKey: !0,
        bubbles: !0,
        cancelable: !0,
        changedTouches: !0,
        ctrlKey: !0,
        detail: !0,
        eventPhase: !0,
        metaKey: !0,
        pageX: !0,
        pageY: !0,
        shiftKey: !0,
        view: !0,
        char: !0,
        code: !0,
        charCode: !0,
        key: !0,
        keyCode: !0,
        button: !0,
        buttons: !0,
        clientX: !0,
        clientY: !0,
        offsetX: !0,
        offsetY: !0,
        pointerId: !0,
        pointerType: !0,
        screenX: !0,
        screenY: !0,
        targetTouches: !0,
        toElement: !0,
        touches: !0,
        which: !0
    }, E.event.addProp),
    E.each({
        focus: "focusin",
        blur: "focusout"
    }, (function(t, e) {
        E.event.special[t] = {
            setup: function() {
                return St(this, t, Ct), !1
            },
            trigger: function() {
                return St(this, t), !0
            },
            _default: function(e) {
                return $.get(e.target, t)
            },
            delegateType: e
        }
    })),
    E.each({
        mouseenter: "mouseover",
        mouseleave: "mouseout",
        pointerenter: "pointerover",
        pointerleave: "pointerout"
    }, (function(t, e) {
        E.event.special[t] = {
            delegateType: e,
            bindType: e,
            handle: function(t) {
                var n,
                    r = this,
                    i = t.relatedTarget,
                    o = t.handleObj;
                return i && (i === r || E.contains(r, i)) || (t.type = o.origType, n = o.handler.apply(this, arguments), t.type = e), n
            }
        }
    })),
    E.fn.extend({
        on: function(t, e, n, r) {
            return Mt(this, t, e, n, r)
        },
        one: function(t, e, n, r) {
            return Mt(this, t, e, n, r, 1)
        },
        off: function(t, e, n) {
            var r,
                i;
            if (t && t.preventDefault && t.handleObj)
                return r = t.handleObj, E(t.delegateTarget).off(r.namespace ? r.origType + "." + r.namespace : r.origType, r.selector, r.handler), this;
            if ("object" == typeof t) {
                for (i in t)
                    this.off(i, e, t[i]);
                return this
            }
            return !1 !== e && "function" != typeof e || (n = e, e = void 0), !1 === n && (n = bt), this.each((function() {
                E.event.remove(this, t, n, e)
            }))
        }
    });
    var It = /<script|<style|<link/i,
        Tt = /checked\s*(?:[^=]|=\s*.checked.)/i,
        Pt = /^\s*<!\[CDATA\[|\]\]>\s*$/g;
    function Lt(t, e) {
        return I(t, "table") && I(11 !== e.nodeType ? e : e.firstChild, "tr") && E(t).children("tbody")[0] || t
    }
    function Ot(t) {
        return t.type = (null !== t.getAttribute("type")) + "/" + t.type, t
    }
    function Nt(t) {
        return "true/" === (t.type || "").slice(0, 5) ? t.type = t.type.slice(5) : t.removeAttribute("type"), t
    }
    function Rt(t, e) {
        var n,
            r,
            i,
            o,
            s,
            a;
        if (1 === e.nodeType) {
            if ($.hasData(t) && (a = $.get(t).events))
                for (i in $.remove(e, "handle events"), a)
                    for (n = 0, r = a[i].length; n < r; n++)
                        E.event.add(e, i, a[i][n]);
            K.hasData(t) && (o = K.access(t), s = E.extend({}, o), K.set(e, s))
        }
    }
    function At(t, e) {
        var n = e.nodeName.toLowerCase();
        "input" === n && ft.test(t.type) ? e.checked = t.checked : "input" !== n && "textarea" !== n || (e.defaultValue = t.defaultValue)
    }
    function Dt(t, e, n, r) {
        e = o(e);
        var i,
            s,
            a,
            u,
            l,
            h,
            c = 0,
            p = t.length,
            g = p - 1,
            y = e[0],
            v = d(y);
        if (v || p > 1 && "string" == typeof y && !f.checkClone && Tt.test(y))
            return t.each((function(i) {
                var o = t.eq(i);
                v && (e[0] = y.call(this, i, o.html())),
                Dt(o, e, n, r)
            }));
        if (p && (s = (i = xt(e, t[0].ownerDocument, !1, t, r)).firstChild, 1 === i.childNodes.length && (i = s), s || r)) {
            for (u = (a = E.map(vt(i, "script"), Ot)).length; c < p; c++)
                l = i,
                c !== g && (l = E.clone(l, !0, !0), u && E.merge(a, vt(l, "script"))),
                n.call(t[c], l, c);
            if (u)
                for (h = a[a.length - 1].ownerDocument, E.map(a, Nt), c = 0; c < u; c++)
                    l = a[c],
                    gt.test(l.type || "") && !$.access(l, "globalEval") && E.contains(h, l) && (l.src && "module" !== (l.type || "").toLowerCase() ? E._evalUrl && !l.noModule && E._evalUrl(l.src, {
                        nonce: l.nonce || l.getAttribute("nonce")
                    }, h) : m(l.textContent.replace(Pt, ""), l, h))
        }
        return t
    }
    function Ft(t, e, n) {
        for (var r, i = e ? E.filter(e, t) : t, o = 0; null != (r = i[o]); o++)
            n || 1 !== r.nodeType || E.cleanData(vt(r)),
            r.parentNode && (n && it(r) && mt(vt(r, "script")), r.parentNode.removeChild(r));
        return t
    }
    E.extend({
        htmlPrefilter: function(t) {
            return t
        },
        clone: function(t, e, n) {
            var r,
                i,
                o,
                s,
                a = t.cloneNode(!0),
                u = it(t);
            if (!(f.noCloneChecked || 1 !== t.nodeType && 11 !== t.nodeType || E.isXMLDoc(t)))
                for (s = vt(a), r = 0, i = (o = vt(t)).length; r < i; r++)
                    At(o[r], s[r]);
            if (e)
                if (n)
                    for (o = o || vt(t), s = s || vt(a), r = 0, i = o.length; r < i; r++)
                        Rt(o[r], s[r]);
                else
                    Rt(t, a);
            return (s = vt(a, "script")).length > 0 && mt(s, !u && vt(t, "script")), a
        },
        cleanData: function(t) {
            for (var e, n, r, i = E.event.special, o = 0; void 0 !== (n = t[o]); o++)
                if (Y(n)) {
                    if (e = n[$.expando]) {
                        if (e.events)
                            for (r in e.events)
                                i[r] ? E.event.remove(n, r) : E.removeEvent(n, r, e.handle);
                        n[$.expando] = void 0
                    }
                    n[K.expando] && (n[K.expando] = void 0)
                }
        }
    }),
    E.fn.extend({
        detach: function(t) {
            return Ft(this, t, !0)
        },
        remove: function(t) {
            return Ft(this, t)
        },
        text: function(t) {
            return z(this, (function(t) {
                return void 0 === t ? E.text(this) : this.empty().each((function() {
                    1 !== this.nodeType && 11 !== this.nodeType && 9 !== this.nodeType || (this.textContent = t)
                }))
            }), null, t, arguments.length)
        },
        append: function() {
            return Dt(this, arguments, (function(t) {
                1 !== this.nodeType && 11 !== this.nodeType && 9 !== this.nodeType || Lt(this, t).appendChild(t)
            }))
        },
        prepend: function() {
            return Dt(this, arguments, (function(t) {
                if (1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) {
                    var e = Lt(this, t);
                    e.insertBefore(t, e.firstChild)
                }
            }))
        },
        before: function() {
            return Dt(this, arguments, (function(t) {
                this.parentNode && this.parentNode.insertBefore(t, this)
            }))
        },
        after: function() {
            return Dt(this, arguments, (function(t) {
                this.parentNode && this.parentNode.insertBefore(t, this.nextSibling)
            }))
        },
        empty: function() {
            for (var t, e = 0; null != (t = this[e]); e++)
                1 === t.nodeType && (E.cleanData(vt(t, !1)), t.textContent = "");
            return this
        },
        clone: function(t, e) {
            return t = null != t && t, e = null == e ? t : e, this.map((function() {
                return E.clone(this, t, e)
            }))
        },
        html: function(t) {
            return z(this, (function(t) {
                var e = this[0] || {},
                    n = 0,
                    r = this.length;
                if (void 0 === t && 1 === e.nodeType)
                    return e.innerHTML;
                if ("string" == typeof t && !It.test(t) && !yt[(dt.exec(t) || ["", ""])[1].toLowerCase()]) {
                    t = E.htmlPrefilter(t);
                    try {
                        for (; n < r; n++)
                            1 === (e = this[n] || {}).nodeType && (E.cleanData(vt(e, !1)), e.innerHTML = t);
                        e = 0
                    } catch (t) {}
                }
                e && this.empty().append(t)
            }), null, t, arguments.length)
        },
        replaceWith: function() {
            var t = [];
            return Dt(this, arguments, (function(e) {
                var n = this.parentNode;
                E.inArray(this, t) < 0 && (E.cleanData(vt(this)), n && n.replaceChild(e, this))
            }), t)
        }
    }),
    E.each({
        appendTo: "append",
        prependTo: "prepend",
        insertBefore: "before",
        insertAfter: "after",
        replaceAll: "replaceWith"
    }, (function(t, e) {
        E.fn[t] = function(t) {
            for (var n, r = [], i = E(t), o = i.length - 1, a = 0; a <= o; a++)
                n = a === o ? this : this.clone(!0),
                E(i[a])[e](n),
                s.apply(r, n.get());
            return this.pushStack(r)
        }
    }));
    var kt = new RegExp("^(" + tt + ")(?!px)[a-z%]+$", "i"),
        jt = /^--/,
        Gt = function(e) {
            var n = e.ownerDocument.defaultView;
            return n && n.opener || (n = t), n.getComputedStyle(e)
        },
        Bt = function(t, e, n) {
            var r,
                i,
                o = {};
            for (i in e)
                o[i] = t.style[i],
                t.style[i] = e[i];
            for (i in r = n.call(t), e)
                t.style[i] = o[i];
            return r
        },
        qt = new RegExp(nt.join("|"), "i"),
        zt = new RegExp("^[\\x20\\t\\r\\n\\f]+|((?:^|[^\\\\])(?:\\\\.)*)[\\x20\\t\\r\\n\\f]+$", "g");
    function Ut(t, e, n) {
        var r,
            i,
            o,
            s,
            a = jt.test(e),
            u = t.style;
        return (n = n || Gt(t)) && (s = n.getPropertyValue(e) || n[e], a && (s = s.replace(zt, "$1")), "" !== s || it(t) || (s = E.style(t, e)), !f.pixelBoxStyles() && kt.test(s) && qt.test(e) && (r = u.width, i = u.minWidth, o = u.maxWidth, u.minWidth = u.maxWidth = u.width = s, s = n.width, u.width = r, u.minWidth = i, u.maxWidth = o)), void 0 !== s ? s + "" : s
    }
    function Vt(t, e) {
        return {
            get: function() {
                if (!t())
                    return (this.get = e).apply(this, arguments);
                delete this.get
            }
        }
    }
    !function() {
        function e() {
            if (h) {
                l.style.cssText = "position:absolute;left:-11111px;width:60px;margin-top:1px;padding:0;border:0",
                h.style.cssText = "position:relative;display:block;box-sizing:border-box;overflow:scroll;margin:auto;border:1px;padding:1px;width:60%;top:1%",
                rt.appendChild(l).appendChild(h);
                var e = t.getComputedStyle(h);
                r = "1%" !== e.top,
                u = 12 === n(e.marginLeft),
                h.style.right = "60%",
                s = 36 === n(e.right),
                i = 36 === n(e.width),
                h.style.position = "absolute",
                o = 12 === n(h.offsetWidth / 3),
                rt.removeChild(l),
                h = null
            }
        }
        function n(t) {
            return Math.round(parseFloat(t))
        }
        var r,
            i,
            o,
            s,
            a,
            u,
            l = y.createElement("div"),
            h = y.createElement("div");
        h.style && (h.style.backgroundClip = "content-box", h.cloneNode(!0).style.backgroundClip = "", f.clearCloneStyle = "content-box" === h.style.backgroundClip, E.extend(f, {
            boxSizingReliable: function() {
                return e(), i
            },
            pixelBoxStyles: function() {
                return e(), s
            },
            pixelPosition: function() {
                return e(), r
            },
            reliableMarginLeft: function() {
                return e(), u
            },
            scrollboxSize: function() {
                return e(), o
            },
            reliableTrDimensions: function() {
                var e,
                    n,
                    r,
                    i;
                return null == a && (e = y.createElement("table"), n = y.createElement("tr"), r = y.createElement("div"), e.style.cssText = "position:absolute;left:-11111px;border-collapse:separate", n.style.cssText = "border:1px solid", n.style.height = "1px", r.style.height = "9px", r.style.display = "block", rt.appendChild(e).appendChild(n).appendChild(r), i = t.getComputedStyle(n), a = parseInt(i.height, 10) + parseInt(i.borderTopWidth, 10) + parseInt(i.borderBottomWidth, 10) === n.offsetHeight, rt.removeChild(e)), a
            }
        }))
    }();
    var Xt = ["Webkit", "Moz", "ms"],
        Ht = y.createElement("div").style,
        Yt = {};
    function Wt(t) {
        var e = E.cssProps[t] || Yt[t];
        return e || (t in Ht ? t : Yt[t] = function(t) {
                for (var e = t[0].toUpperCase() + t.slice(1), n = Xt.length; n--;)
                    if ((t = Xt[n] + e) in Ht)
                        return t
            }(t) || t)
    }
    var $t = /^(none|table(?!-c[ea]).+)/,
        Kt = {
            position: "absolute",
            visibility: "hidden",
            display: "block"
        },
        Zt = {
            letterSpacing: "0",
            fontWeight: "400"
        };
    function Jt(t, e, n) {
        var r = et.exec(e);
        return r ? Math.max(0, r[2] - (n || 0)) + (r[3] || "px") : e
    }
    function Qt(t, e, n, r, i, o) {
        var s = "width" === e ? 1 : 0,
            a = 0,
            u = 0;
        if (n === (r ? "border" : "content"))
            return 0;
        for (; s < 4; s += 2)
            "margin" === n && (u += E.css(t, n + nt[s], !0, i)),
            r ? ("content" === n && (u -= E.css(t, "padding" + nt[s], !0, i)), "margin" !== n && (u -= E.css(t, "border" + nt[s] + "Width", !0, i))) : (u += E.css(t, "padding" + nt[s], !0, i), "padding" !== n ? u += E.css(t, "border" + nt[s] + "Width", !0, i) : a += E.css(t, "border" + nt[s] + "Width", !0, i));
        return !r && o >= 0 && (u += Math.max(0, Math.ceil(t["offset" + e[0].toUpperCase() + e.slice(1)] - o - u - a - .5)) || 0), u
    }
    function te(t, e, n) {
        var r = Gt(t),
            i = (!f.boxSizingReliable() || n) && "border-box" === E.css(t, "boxSizing", !1, r),
            o = i,
            s = Ut(t, e, r),
            a = "offset" + e[0].toUpperCase() + e.slice(1);
        if (kt.test(s)) {
            if (!n)
                return s;
            s = "auto"
        }
        return (!f.boxSizingReliable() && i || !f.reliableTrDimensions() && I(t, "tr") || "auto" === s || !parseFloat(s) && "inline" === E.css(t, "display", !1, r)) && t.getClientRects().length && (i = "border-box" === E.css(t, "boxSizing", !1, r), (o = a in t) && (s = t[a])), (s = parseFloat(s) || 0) + Qt(t, e, n || (i ? "border" : "content"), o, r, s) + "px"
    }
    function ee(t, e, n, r, i) {
        return new ee.prototype.init(t, e, n, r, i)
    }
    E.extend({
        cssHooks: {
            opacity: {
                get: function(t, e) {
                    if (e) {
                        var n = Ut(t, "opacity");
                        return "" === n ? "1" : n
                    }
                }
            }
        },
        cssNumber: {
            animationIterationCount: !0,
            columnCount: !0,
            fillOpacity: !0,
            flexGrow: !0,
            flexShrink: !0,
            fontWeight: !0,
            gridArea: !0,
            gridColumn: !0,
            gridColumnEnd: !0,
            gridColumnStart: !0,
            gridRow: !0,
            gridRowEnd: !0,
            gridRowStart: !0,
            lineHeight: !0,
            opacity: !0,
            order: !0,
            orphans: !0,
            widows: !0,
            zIndex: !0,
            zoom: !0
        },
        cssProps: {},
        style: function(t, e, n, r) {
            if (t && 3 !== t.nodeType && 8 !== t.nodeType && t.style) {
                var i,
                    o,
                    s,
                    a = H(e),
                    u = jt.test(e),
                    l = t.style;
                if (u || (e = Wt(a)), s = E.cssHooks[e] || E.cssHooks[a], void 0 === n)
                    return s && "get" in s && void 0 !== (i = s.get(t, !1, r)) ? i : l[e];
                "string" === (o = typeof n) && (i = et.exec(n)) && i[1] && (n = at(t, e, i), o = "number"),
                null != n && n == n && ("number" !== o || u || (n += i && i[3] || (E.cssNumber[a] ? "" : "px")), f.clearCloneStyle || "" !== n || 0 !== e.indexOf("background") || (l[e] = "inherit"), s && "set" in s && void 0 === (n = s.set(t, n, r)) || (u ? l.setProperty(e, n) : l[e] = n))
            }
        },
        css: function(t, e, n, r) {
            var i,
                o,
                s,
                a = H(e);
            return jt.test(e) || (e = Wt(a)), (s = E.cssHooks[e] || E.cssHooks[a]) && "get" in s && (i = s.get(t, !0, n)), void 0 === i && (i = Ut(t, e, r)), "normal" === i && e in Zt && (i = Zt[e]), "" === n || n ? (o = parseFloat(i), !0 === n || isFinite(o) ? o || 0 : i) : i
        }
    }),
    E.each(["height", "width"], (function(t, e) {
        E.cssHooks[e] = {
            get: function(t, n, r) {
                if (n)
                    return !$t.test(E.css(t, "display")) || t.getClientRects().length && t.getBoundingClientRect().width ? te(t, e, r) : Bt(t, Kt, (function() {
                        return te(t, e, r)
                    }))
            },
            set: function(t, n, r) {
                var i,
                    o = Gt(t),
                    s = !f.scrollboxSize() && "absolute" === o.position,
                    a = (s || r) && "border-box" === E.css(t, "boxSizing", !1, o),
                    u = r ? Qt(t, e, r, a, o) : 0;
                return a && s && (u -= Math.ceil(t["offset" + e[0].toUpperCase() + e.slice(1)] - parseFloat(o[e]) - Qt(t, e, "border", !1, o) - .5)), u && (i = et.exec(n)) && "px" !== (i[3] || "px") && (t.style[e] = n, n = E.css(t, e)), Jt(0, n, u)
            }
        }
    })),
    E.cssHooks.marginLeft = Vt(f.reliableMarginLeft, (function(t, e) {
        if (e)
            return (parseFloat(Ut(t, "marginLeft")) || t.getBoundingClientRect().left - Bt(t, {
                marginLeft: 0
            }, (function() {
                return t.getBoundingClientRect().left
            }))) + "px"
    })),
    E.each({
        margin: "",
        padding: "",
        border: "Width"
    }, (function(t, e) {
        E.cssHooks[t + e] = {
            expand: function(n) {
                for (var r = 0, i = {}, o = "string" == typeof n ? n.split(" ") : [n]; r < 4; r++)
                    i[t + nt[r] + e] = o[r] || o[r - 2] || o[0];
                return i
            }
        },
        "margin" !== t && (E.cssHooks[t + e].set = Jt)
    })),
    E.fn.extend({
        css: function(t, e) {
            return z(this, (function(t, e, n) {
                var r,
                    i,
                    o = {},
                    s = 0;
                if (Array.isArray(e)) {
                    for (r = Gt(t), i = e.length; s < i; s++)
                        o[e[s]] = E.css(t, e[s], !1, r);
                    return o
                }
                return void 0 !== n ? E.style(t, e, n) : E.css(t, e)
            }), t, e, arguments.length > 1)
        }
    }),
    E.Tween = ee,
    ee.prototype = {
        constructor: ee,
        init: function(t, e, n, r, i, o) {
            this.elem = t,
            this.prop = n,
            this.easing = i || E.easing._default,
            this.options = e,
            this.start = this.now = this.cur(),
            this.end = r,
            this.unit = o || (E.cssNumber[n] ? "" : "px")
        },
        cur: function() {
            var t = ee.propHooks[this.prop];
            return t && t.get ? t.get(this) : ee.propHooks._default.get(this)
        },
        run: function(t) {
            var e,
                n = ee.propHooks[this.prop];
            return this.options.duration ? this.pos = e = E.easing[this.easing](t, this.options.duration * t, 0, 1, this.options.duration) : this.pos = e = t, this.now = (this.end - this.start) * e + this.start, this.options.step && this.options.step.call(this.elem, this.now, this), n && n.set ? n.set(this) : ee.propHooks._default.set(this), this
        }
    },
    ee.prototype.init.prototype = ee.prototype,
    ee.propHooks = {
        _default: {
            get: function(t) {
                var e;
                return 1 !== t.elem.nodeType || null != t.elem[t.prop] && null == t.elem.style[t.prop] ? t.elem[t.prop] : (e = E.css(t.elem, t.prop, "")) && "auto" !== e ? e : 0
            },
            set: function(t) {
                E.fx.step[t.prop] ? E.fx.step[t.prop](t) : 1 !== t.elem.nodeType || !E.cssHooks[t.prop] && null == t.elem.style[Wt(t.prop)] ? t.elem[t.prop] = t.now : E.style(t.elem, t.prop, t.now + t.unit)
            }
        }
    },
    ee.propHooks.scrollTop = ee.propHooks.scrollLeft = {
        set: function(t) {
            t.elem.nodeType && t.elem.parentNode && (t.elem[t.prop] = t.now)
        }
    },
    E.easing = {
        linear: function(t) {
            return t
        },
        swing: function(t) {
            return .5 - Math.cos(t * Math.PI) / 2
        },
        _default: "swing"
    },
    E.fx = ee.prototype.init,
    E.fx.step = {};
    var ne,
        re,
        ie = /^(?:toggle|show|hide)$/,
        oe = /queueHooks$/;
    function se() {
        re && (!1 === y.hidden && t.requestAnimationFrame ? t.requestAnimationFrame(se) : t.setTimeout(se, E.fx.interval), E.fx.tick())
    }
    function ae() {
        return t.setTimeout((function() {
            ne = void 0
        })), ne = Date.now()
    }
    function ue(t, e) {
        var n,
            r = 0,
            i = {
                height: t
            };
        for (e = e ? 1 : 0; r < 4; r += 2 - e)
            i["margin" + (n = nt[r])] = i["padding" + n] = t;
        return e && (i.opacity = i.width = t), i
    }
    function le(t, e, n) {
        for (var r, i = (he.tweeners[e] || []).concat(he.tweeners["*"]), o = 0, s = i.length; o < s; o++)
            if (r = i[o].call(n, e, t))
                return r
    }
    function he(t, e, n) {
        var r,
            i,
            o = 0,
            s = he.prefilters.length,
            a = E.Deferred().always((function() {
                delete u.elem
            })),
            u = function() {
                if (i)
                    return !1;
                for (var e = ne || ae(), n = Math.max(0, l.startTime + l.duration - e), r = 1 - (n / l.duration || 0), o = 0, s = l.tweens.length; o < s; o++)
                    l.tweens[o].run(r);
                return a.notifyWith(t, [l, r, n]), r < 1 && s ? n : (s || a.notifyWith(t, [l, 1, 0]), a.resolveWith(t, [l]), !1)
            },
            l = a.promise({
                elem: t,
                props: E.extend({}, e),
                opts: E.extend(!0, {
                    specialEasing: {},
                    easing: E.easing._default
                }, n),
                originalProperties: e,
                originalOptions: n,
                startTime: ne || ae(),
                duration: n.duration,
                tweens: [],
                createTween: function(e, n) {
                    var r = E.Tween(t, l.opts, e, n, l.opts.specialEasing[e] || l.opts.easing);
                    return l.tweens.push(r), r
                },
                stop: function(e) {
                    var n = 0,
                        r = e ? l.tweens.length : 0;
                    if (i)
                        return this;
                    for (i = !0; n < r; n++)
                        l.tweens[n].run(1);
                    return e ? (a.notifyWith(t, [l, 1, 0]), a.resolveWith(t, [l, e])) : a.rejectWith(t, [l, e]), this
                }
            }),
            h = l.props;
        for (!function(t, e) {
            var n,
                r,
                i,
                o,
                s;
            for (n in t)
                if (i = e[r = H(n)], o = t[n], Array.isArray(o) && (i = o[1], o = t[n] = o[0]), n !== r && (t[r] = o, delete t[n]), (s = E.cssHooks[r]) && "expand" in s)
                    for (n in o = s.expand(o), delete t[r], o)
                        n in t || (t[n] = o[n], e[n] = i);
                else
                    e[r] = i
        }(h, l.opts.specialEasing); o < s; o++)
            if (r = he.prefilters[o].call(l, t, h, l.opts))
                return d(r.stop) && (E._queueHooks(l.elem, l.opts.queue).stop = r.stop.bind(r)), r;
        return E.map(h, le, l), d(l.opts.start) && l.opts.start.call(t, l), l.progress(l.opts.progress).done(l.opts.done, l.opts.complete).fail(l.opts.fail).always(l.opts.always), E.fx.timer(E.extend(u, {
            elem: t,
            anim: l,
            queue: l.opts.queue
        })), l
    }
    E.Animation = E.extend(he, {
        tweeners: {
            "*": [function(t, e) {
                var n = this.createTween(t, e);
                return at(n.elem, t, et.exec(e), n), n
            }]
        },
        tweener: function(t, e) {
            d(t) ? (e = t, t = ["*"]) : t = t.match(D);
            for (var n, r = 0, i = t.length; r < i; r++)
                n = t[r],
                he.tweeners[n] = he.tweeners[n] || [],
                he.tweeners[n].unshift(e)
        },
        prefilters: [function(t, e, n) {
            var r,
                i,
                o,
                s,
                a,
                u,
                l,
                h,
                c = "width" in e || "height" in e,
                p = this,
                f = {},
                d = t.style,
                g = t.nodeType && st(t),
                y = $.get(t, "fxshow");
            for (r in n.queue || (null == (s = E._queueHooks(t, "fx")).unqueued && (s.unqueued = 0, a = s.empty.fire, s.empty.fire = function() {
                s.unqueued || a()
            }), s.unqueued++, p.always((function() {
                p.always((function() {
                    s.unqueued--,
                    E.queue(t, "fx").length || s.empty.fire()
                }))
            }))), e)
                if (i = e[r], ie.test(i)) {
                    if (delete e[r], o = o || "toggle" === i, i === (g ? "hide" : "show")) {
                        if ("show" !== i || !y || void 0 === y[r])
                            continue;
                        g = !0
                    }
                    f[r] = y && y[r] || E.style(t, r)
                }
            if ((u = !E.isEmptyObject(e)) || !E.isEmptyObject(f))
                for (r in c && 1 === t.nodeType && (n.overflow = [d.overflow, d.overflowX, d.overflowY], null == (l = y && y.display) && (l = $.get(t, "display")), "none" === (h = E.css(t, "display")) && (l ? h = l : (ht([t], !0), l = t.style.display || l, h = E.css(t, "display"), ht([t]))), ("inline" === h || "inline-block" === h && null != l) && "none" === E.css(t, "float") && (u || (p.done((function() {
                    d.display = l
                })), null == l && (h = d.display, l = "none" === h ? "" : h)), d.display = "inline-block")), n.overflow && (d.overflow = "hidden", p.always((function() {
                    d.overflow = n.overflow[0],
                    d.overflowX = n.overflow[1],
                    d.overflowY = n.overflow[2]
                }))), u = !1, f)
                    u || (y ? "hidden" in y && (g = y.hidden) : y = $.access(t, "fxshow", {
                        display: l
                    }), o && (y.hidden = !g), g && ht([t], !0), p.done((function() {
                        for (r in g || ht([t]), $.remove(t, "fxshow"), f)
                            E.style(t, r, f[r])
                    }))),
                    u = le(g ? y[r] : 0, r, p),
                    r in y || (y[r] = u.start, g && (u.end = u.start, u.start = 0))
        }],
        prefilter: function(t, e) {
            e ? he.prefilters.unshift(t) : he.prefilters.push(t)
        }
    }),
    E.speed = function(t, e, n) {
        var r = t && "object" == typeof t ? E.extend({}, t) : {
            complete: n || !n && e || d(t) && t,
            duration: t,
            easing: n && e || e && !d(e) && e
        };
        return E.fx.off ? r.duration = 0 : "number" != typeof r.duration && (r.duration in E.fx.speeds ? r.duration = E.fx.speeds[r.duration] : r.duration = E.fx.speeds._default), null != r.queue && !0 !== r.queue || (r.queue = "fx"), r.old = r.complete, r.complete = function() {
            d(r.old) && r.old.call(this),
            r.queue && E.dequeue(this, r.queue)
        }, r
    },
    E.fn.extend({
        fadeTo: function(t, e, n, r) {
            return this.filter(st).css("opacity", 0).show().end().animate({
                opacity: e
            }, t, n, r)
        },
        animate: function(t, e, n, r) {
            var i = E.isEmptyObject(t),
                o = E.speed(e, n, r),
                s = function() {
                    var e = he(this, E.extend({}, t), o);
                    (i || $.get(this, "finish")) && e.stop(!0)
                };
            return s.finish = s, i || !1 === o.queue ? this.each(s) : this.queue(o.queue, s)
        },
        stop: function(t, e, n) {
            var r = function(t) {
                var e = t.stop;
                delete t.stop,
                e(n)
            };
            return "string" != typeof t && (n = e, e = t, t = void 0), e && this.queue(t || "fx", []), this.each((function() {
                var e = !0,
                    i = null != t && t + "queueHooks",
                    o = E.timers,
                    s = $.get(this);
                if (i)
                    s[i] && s[i].stop && r(s[i]);
                else
                    for (i in s)
                        s[i] && s[i].stop && oe.test(i) && r(s[i]);
                for (i = o.length; i--;)
                    o[i].elem !== this || null != t && o[i].queue !== t || (o[i].anim.stop(n), e = !1, o.splice(i, 1));
                !e && n || E.dequeue(this, t)
            }))
        },
        finish: function(t) {
            return !1 !== t && (t = t || "fx"), this.each((function() {
                var e,
                    n = $.get(this),
                    r = n[t + "queue"],
                    i = n[t + "queueHooks"],
                    o = E.timers,
                    s = r ? r.length : 0;
                for (n.finish = !0, E.queue(this, t, []), i && i.stop && i.stop.call(this, !0), e = o.length; e--;)
                    o[e].elem === this && o[e].queue === t && (o[e].anim.stop(!0), o.splice(e, 1));
                for (e = 0; e < s; e++)
                    r[e] && r[e].finish && r[e].finish.call(this);
                delete n.finish
            }))
        }
    }),
    E.each(["toggle", "show", "hide"], (function(t, e) {
        var n = E.fn[e];
        E.fn[e] = function(t, r, i) {
            return null == t || "boolean" == typeof t ? n.apply(this, arguments) : this.animate(ue(e, !0), t, r, i)
        }
    })),
    E.each({
        slideDown: ue("show"),
        slideUp: ue("hide"),
        slideToggle: ue("toggle"),
        fadeIn: {
            opacity: "show"
        },
        fadeOut: {
            opacity: "hide"
        },
        fadeToggle: {
            opacity: "toggle"
        }
    }, (function(t, e) {
        E.fn[t] = function(t, n, r) {
            return this.animate(e, t, n, r)
        }
    })),
    E.timers = [],
    E.fx.tick = function() {
        var t,
            e = 0,
            n = E.timers;
        for (ne = Date.now(); e < n.length; e++)
            (t = n[e])() || n[e] !== t || n.splice(e--, 1);
        n.length || E.fx.stop(),
        ne = void 0
    },
    E.fx.timer = function(t) {
        E.timers.push(t),
        E.fx.start()
    },
    E.fx.interval = 13,
    E.fx.start = function() {
        re || (re = !0, se())
    },
    E.fx.stop = function() {
        re = null
    },
    E.fx.speeds = {
        slow: 600,
        fast: 200,
        _default: 400
    },
    E.fn.delay = function(e, n) {
        return e = E.fx && E.fx.speeds[e] || e, n = n || "fx", this.queue(n, (function(n, r) {
            var i = t.setTimeout(n, e);
            r.stop = function() {
                t.clearTimeout(i)
            }
        }))
    },
    function() {
        var t = y.createElement("input"),
            e = y.createElement("select").appendChild(y.createElement("option"));
        t.type = "checkbox",
        f.checkOn = "" !== t.value,
        f.optSelected = e.selected,
        (t = y.createElement("input")).value = "t",
        t.type = "radio",
        f.radioValue = "t" === t.value
    }();
    var ce,
        pe = E.expr.attrHandle;
    E.fn.extend({
        attr: function(t, e) {
            return z(this, E.attr, t, e, arguments.length > 1)
        },
        removeAttr: function(t) {
            return this.each((function() {
                E.removeAttr(this, t)
            }))
        }
    }),
    E.extend({
        attr: function(t, e, n) {
            var r,
                i,
                o = t.nodeType;
            if (3 !== o && 8 !== o && 2 !== o)
                return void 0 === t.getAttribute ? E.prop(t, e, n) : (1 === o && E.isXMLDoc(t) || (i = E.attrHooks[e.toLowerCase()] || (E.expr.match.bool.test(e) ? ce : void 0)), void 0 !== n ? null === n ? void E.removeAttr(t, e) : i && "set" in i && void 0 !== (r = i.set(t, n, e)) ? r : (t.setAttribute(e, n + ""), n) : i && "get" in i && null !== (r = i.get(t, e)) ? r : null == (r = E.find.attr(t, e)) ? void 0 : r)
        },
        attrHooks: {
            type: {
                set: function(t, e) {
                    if (!f.radioValue && "radio" === e && I(t, "input")) {
                        var n = t.value;
                        return t.setAttribute("type", e), n && (t.value = n), e
                    }
                }
            }
        },
        removeAttr: function(t, e) {
            var n,
                r = 0,
                i = e && e.match(D);
            if (i && 1 === t.nodeType)
                for (; n = i[r++];)
                    t.removeAttribute(n)
        }
    }),
    ce = {
        set: function(t, e, n) {
            return !1 === e ? E.removeAttr(t, n) : t.setAttribute(n, n), n
        }
    },
    E.each(E.expr.match.bool.source.match(/\w+/g), (function(t, e) {
        var n = pe[e] || E.find.attr;
        pe[e] = function(t, e, r) {
            var i,
                o,
                s = e.toLowerCase();
            return r || (o = pe[s], pe[s] = i, i = null != n(t, e, r) ? s : null, pe[s] = o), i
        }
    }));
    var fe = /^(?:input|select|textarea|button)$/i,
        de = /^(?:a|area)$/i;
    function ge(t) {
        return (t.match(D) || []).join(" ")
    }
    function ye(t) {
        return t.getAttribute && t.getAttribute("class") || ""
    }
    function ve(t) {
        return Array.isArray(t) ? t : "string" == typeof t && t.match(D) || []
    }
    E.fn.extend({
        prop: function(t, e) {
            return z(this, E.prop, t, e, arguments.length > 1)
        },
        removeProp: function(t) {
            return this.each((function() {
                delete this[E.propFix[t] || t]
            }))
        }
    }),
    E.extend({
        prop: function(t, e, n) {
            var r,
                i,
                o = t.nodeType;
            if (3 !== o && 8 !== o && 2 !== o)
                return 1 === o && E.isXMLDoc(t) || (e = E.propFix[e] || e, i = E.propHooks[e]), void 0 !== n ? i && "set" in i && void 0 !== (r = i.set(t, n, e)) ? r : t[e] = n : i && "get" in i && null !== (r = i.get(t, e)) ? r : t[e]
        },
        propHooks: {
            tabIndex: {
                get: function(t) {
                    var e = E.find.attr(t, "tabindex");
                    return e ? parseInt(e, 10) : fe.test(t.nodeName) || de.test(t.nodeName) && t.href ? 0 : -1
                }
            }
        },
        propFix: {
            for: "htmlFor",
            class: "className"
        }
    }),
    f.optSelected || (E.propHooks.selected = {
        get: function(t) {
            var e = t.parentNode;
            return e && e.parentNode && e.parentNode.selectedIndex, null
        },
        set: function(t) {
            var e = t.parentNode;
            e && (e.selectedIndex, e.parentNode && e.parentNode.selectedIndex)
        }
    }),
    E.each(["tabIndex", "readOnly", "maxLength", "cellSpacing", "cellPadding", "rowSpan", "colSpan", "useMap", "frameBorder", "contentEditable"], (function() {
        E.propFix[this.toLowerCase()] = this
    })),
    E.fn.extend({
        addClass: function(t) {
            var e,
                n,
                r,
                i,
                o,
                s;
            return d(t) ? this.each((function(e) {
                E(this).addClass(t.call(this, e, ye(this)))
            })) : (e = ve(t)).length ? this.each((function() {
                if (r = ye(this), n = 1 === this.nodeType && " " + ge(r) + " ") {
                    for (o = 0; o < e.length; o++)
                        i = e[o],
                        n.indexOf(" " + i + " ") < 0 && (n += i + " ");
                    s = ge(n),
                    r !== s && this.setAttribute("class", s)
                }
            })) : this
        },
        removeClass: function(t) {
            var e,
                n,
                r,
                i,
                o,
                s;
            return d(t) ? this.each((function(e) {
                E(this).removeClass(t.call(this, e, ye(this)))
            })) : arguments.length ? (e = ve(t)).length ? this.each((function() {
                if (r = ye(this), n = 1 === this.nodeType && " " + ge(r) + " ") {
                    for (o = 0; o < e.length; o++)
                        for (i = e[o]; n.indexOf(" " + i + " ") > -1;)
                            n = n.replace(" " + i + " ", " ");
                    s = ge(n),
                    r !== s && this.setAttribute("class", s)
                }
            })) : this : this.attr("class", "")
        },
        toggleClass: function(t, e) {
            var n,
                r,
                i,
                o,
                s = typeof t,
                a = "string" === s || Array.isArray(t);
            return d(t) ? this.each((function(n) {
                E(this).toggleClass(t.call(this, n, ye(this), e), e)
            })) : "boolean" == typeof e && a ? e ? this.addClass(t) : this.removeClass(t) : (n = ve(t), this.each((function() {
                if (a)
                    for (o = E(this), i = 0; i < n.length; i++)
                        r = n[i],
                        o.hasClass(r) ? o.removeClass(r) : o.addClass(r);
                else
                    void 0 !== t && "boolean" !== s || ((r = ye(this)) && $.set(this, "__className__", r), this.setAttribute && this.setAttribute("class", r || !1 === t ? "" : $.get(this, "__className__") || ""))
            })))
        },
        hasClass: function(t) {
            var e,
                n,
                r = 0;
            for (e = " " + t + " "; n = this[r++];)
                if (1 === n.nodeType && (" " + ge(ye(n)) + " ").indexOf(e) > -1)
                    return !0;
            return !1
        }
    });
    var me = /\r/g;
    E.fn.extend({
        val: function(t) {
            var e,
                n,
                r,
                i = this[0];
            return arguments.length ? (r = d(t), this.each((function(n) {
                var i;
                1 === this.nodeType && (null == (i = r ? t.call(this, n, E(this).val()) : t) ? i = "" : "number" == typeof i ? i += "" : Array.isArray(i) && (i = E.map(i, (function(t) {
                    return null == t ? "" : t + ""
                }))), (e = E.valHooks[this.type] || E.valHooks[this.nodeName.toLowerCase()]) && "set" in e && void 0 !== e.set(this, i, "value") || (this.value = i))
            }))) : i ? (e = E.valHooks[i.type] || E.valHooks[i.nodeName.toLowerCase()]) && "get" in e && void 0 !== (n = e.get(i, "value")) ? n : "string" == typeof (n = i.value) ? n.replace(me, "") : null == n ? "" : n : void 0
        }
    }),
    E.extend({
        valHooks: {
            option: {
                get: function(t) {
                    var e = E.find.attr(t, "value");
                    return null != e ? e : ge(E.text(t))
                }
            },
            select: {
                get: function(t) {
                    var e,
                        n,
                        r,
                        i = t.options,
                        o = t.selectedIndex,
                        s = "select-one" === t.type,
                        a = s ? null : [],
                        u = s ? o + 1 : i.length;
                    for (r = o < 0 ? u : s ? o : 0; r < u; r++)
                        if (((n = i[r]).selected || r === o) && !n.disabled && (!n.parentNode.disabled || !I(n.parentNode, "optgroup"))) {
                            if (e = E(n).val(), s)
                                return e;
                            a.push(e)
                        }
                    return a
                },
                set: function(t, e) {
                    for (var n, r, i = t.options, o = E.makeArray(e), s = i.length; s--;)
                        ((r = i[s]).selected = E.inArray(E.valHooks.option.get(r), o) > -1) && (n = !0);
                    return n || (t.selectedIndex = -1), o
                }
            }
        }
    }),
    E.each(["radio", "checkbox"], (function() {
        E.valHooks[this] = {
            set: function(t, e) {
                if (Array.isArray(e))
                    return t.checked = E.inArray(E(t).val(), e) > -1
            }
        },
        f.checkOn || (E.valHooks[this].get = function(t) {
            return null === t.getAttribute("value") ? "on" : t.value
        })
    })),
    f.focusin = "onfocusin" in t;
    var _e = /^(?:focusinfocus|focusoutblur)$/,
        xe = function(t) {
            t.stopPropagation()
        };
    E.extend(E.event, {
        trigger: function(e, n, r, i) {
            var o,
                s,
                a,
                u,
                l,
                c,
                p,
                f,
                v = [r || y],
                m = h.call(e, "type") ? e.type : e,
                _ = h.call(e, "namespace") ? e.namespace.split(".") : [];
            if (s = f = a = r = r || y, 3 !== r.nodeType && 8 !== r.nodeType && !_e.test(m + E.event.triggered) && (m.indexOf(".") > -1 && (_ = m.split("."), m = _.shift(), _.sort()), l = m.indexOf(":") < 0 && "on" + m, (e = e[E.expando] ? e : new E.Event(m, "object" == typeof e && e)).isTrigger = i ? 2 : 3, e.namespace = _.join("."), e.rnamespace = e.namespace ? new RegExp("(^|\\.)" + _.join("\\.(?:.*\\.|)") + "(\\.|$)") : null, e.result = void 0, e.target || (e.target = r), n = null == n ? [e] : E.makeArray(n, [e]), p = E.event.special[m] || {}, i || !p.trigger || !1 !== p.trigger.apply(r, n))) {
                if (!i && !p.noBubble && !g(r)) {
                    for (u = p.delegateType || m, _e.test(u + m) || (s = s.parentNode); s; s = s.parentNode)
                        v.push(s),
                        a = s;
                    a === (r.ownerDocument || y) && v.push(a.defaultView || a.parentWindow || t)
                }
                for (o = 0; (s = v[o++]) && !e.isPropagationStopped();)
                    f = s,
                    e.type = o > 1 ? u : p.bindType || m,
                    (c = ($.get(s, "events") || Object.create(null))[e.type] && $.get(s, "handle")) && c.apply(s, n),
                    (c = l && s[l]) && c.apply && Y(s) && (e.result = c.apply(s, n), !1 === e.result && e.preventDefault());
                return e.type = m, i || e.isDefaultPrevented() || p._default && !1 !== p._default.apply(v.pop(), n) || !Y(r) || l && d(r[m]) && !g(r) && ((a = r[l]) && (r[l] = null), E.event.triggered = m, e.isPropagationStopped() && f.addEventListener(m, xe), r[m](), e.isPropagationStopped() && f.removeEventListener(m, xe), E.event.triggered = void 0, a && (r[l] = a)), e.result
            }
        },
        simulate: function(t, e, n) {
            var r = E.extend(new E.Event, n, {
                type: t,
                isSimulated: !0
            });
            E.event.trigger(r, null, e)
        }
    }),
    E.fn.extend({
        trigger: function(t, e) {
            return this.each((function() {
                E.event.trigger(t, e, this)
            }))
        },
        triggerHandler: function(t, e) {
            var n = this[0];
            if (n)
                return E.event.trigger(t, e, n, !0)
        }
    }),
    f.focusin || E.each({
        focus: "focusin",
        blur: "focusout"
    }, (function(t, e) {
        var n = function(t) {
            E.event.simulate(e, t.target, E.event.fix(t))
        };
        E.event.special[e] = {
            setup: function() {
                var r = this.ownerDocument || this.document || this,
                    i = $.access(r, e);
                i || r.addEventListener(t, n, !0),
                $.access(r, e, (i || 0) + 1)
            },
            teardown: function() {
                var r = this.ownerDocument || this.document || this,
                    i = $.access(r, e) - 1;
                i ? $.access(r, e, i) : (r.removeEventListener(t, n, !0), $.remove(r, e))
            }
        }
    }));
    var Ee = t.location,
        we = {
            guid: Date.now()
        },
        be = /\?/;
    E.parseXML = function(e) {
        var n,
            r;
        if (!e || "string" != typeof e)
            return null;
        try {
            n = (new t.DOMParser).parseFromString(e, "text/xml")
        } catch (t) {}
        return r = n && n.getElementsByTagName("parsererror")[0], n && !r || E.error("Invalid XML: " + (r ? E.map(r.childNodes, (function(t) {
            return t.textContent
        })).join("\n") : e)), n
    };
    var Ce = /\[\]$/,
        Me = /\r?\n/g,
        Se = /^(?:submit|button|image|reset|file)$/i,
        Ie = /^(?:input|select|textarea|keygen)/i;
    function Te(t, e, n, r) {
        var i;
        if (Array.isArray(e))
            E.each(e, (function(e, i) {
                n || Ce.test(t) ? r(t, i) : Te(t + "[" + ("object" == typeof i && null != i ? e : "") + "]", i, n, r)
            }));
        else if (n || "object" !== _(e))
            r(t, e);
        else
            for (i in e)
                Te(t + "[" + i + "]", e[i], n, r)
    }
    E.param = function(t, e) {
        var n,
            r = [],
            i = function(t, e) {
                var n = d(e) ? e() : e;
                r[r.length] = encodeURIComponent(t) + "=" + encodeURIComponent(null == n ? "" : n)
            };
        if (null == t)
            return "";
        if (Array.isArray(t) || t.jquery && !E.isPlainObject(t))
            E.each(t, (function() {
                i(this.name, this.value)
            }));
        else
            for (n in t)
                Te(n, t[n], e, i);
        return r.join("&")
    },
    E.fn.extend({
        serialize: function() {
            return E.param(this.serializeArray())
        },
        serializeArray: function() {
            return this.map((function() {
                var t = E.prop(this, "elements");
                return t ? E.makeArray(t) : this
            })).filter((function() {
                var t = this.type;
                return this.name && !E(this).is(":disabled") && Ie.test(this.nodeName) && !Se.test(t) && (this.checked || !ft.test(t))
            })).map((function(t, e) {
                var n = E(this).val();
                return null == n ? null : Array.isArray(n) ? E.map(n, (function(t) {
                    return {
                        name: e.name,
                        value: t.replace(Me, "\r\n")
                    }
                })) : {
                    name: e.name,
                    value: n.replace(Me, "\r\n")
                }
            })).get()
        }
    });
    var Pe = /%20/g,
        Le = /#.*$/,
        Oe = /([?&])_=[^&]*/,
        Ne = /^(.*?):[ \t]*([^\r\n]*)$/gm,
        Re = /^(?:GET|HEAD)$/,
        Ae = /^\/\//,
        De = {},
        Fe = {},
        ke = "*/".concat("*"),
        je = y.createElement("a");
    function Ge(t) {
        return function(e, n) {
            "string" != typeof e && (n = e, e = "*");
            var r,
                i = 0,
                o = e.toLowerCase().match(D) || [];
            if (d(n))
                for (; r = o[i++];)
                    "+" === r[0] ? (r = r.slice(1) || "*", (t[r] = t[r] || []).unshift(n)) : (t[r] = t[r] || []).push(n)
        }
    }
    function Be(t, e, n, r) {
        var i = {},
            o = t === Fe;
        function s(a) {
            var u;
            return i[a] = !0, E.each(t[a] || [], (function(t, a) {
                var l = a(e, n, r);
                return "string" != typeof l || o || i[l] ? o ? !(u = l) : void 0 : (e.dataTypes.unshift(l), s(l), !1)
            })), u
        }
        return s(e.dataTypes[0]) || !i["*"] && s("*")
    }
    function qe(t, e) {
        var n,
            r,
            i = E.ajaxSettings.flatOptions || {};
        for (n in e)
            void 0 !== e[n] && ((i[n] ? t : r || (r = {}))[n] = e[n]);
        return r && E.extend(!0, t, r), t
    }
    je.href = Ee.href,
    E.extend({
        active: 0,
        lastModified: {},
        etag: {},
        ajaxSettings: {
            url: Ee.href,
            type: "GET",
            isLocal: /^(?:about|app|app-storage|.+-extension|file|res|widget):$/.test(Ee.protocol),
            global: !0,
            processData: !0,
            async: !0,
            contentType: "application/x-www-form-urlencoded; charset=UTF-8",
            accepts: {
                "*": ke,
                text: "text/plain",
                html: "text/html",
                xml: "application/xml, text/xml",
                json: "application/json, text/javascript"
            },
            contents: {
                xml: /\bxml\b/,
                html: /\bhtml/,
                json: /\bjson\b/
            },
            responseFields: {
                xml: "responseXML",
                text: "responseText",
                json: "responseJSON"
            },
            converters: {
                "* text": String,
                "text html": !0,
                "text json": JSON.parse,
                "text xml": E.parseXML
            },
            flatOptions: {
                url: !0,
                context: !0
            }
        },
        ajaxSetup: function(t, e) {
            return e ? qe(qe(t, E.ajaxSettings), e) : qe(E.ajaxSettings, t)
        },
        ajaxPrefilter: Ge(De),
        ajaxTransport: Ge(Fe),
        ajax: function(e, n) {
            "object" == typeof e && (n = e, e = void 0),
            n = n || {};
            var r,
                i,
                o,
                s,
                a,
                u,
                l,
                h,
                c,
                p,
                f = E.ajaxSetup({}, n),
                d = f.context || f,
                g = f.context && (d.nodeType || d.jquery) ? E(d) : E.event,
                v = E.Deferred(),
                m = E.Callbacks("once memory"),
                _ = f.statusCode || {},
                x = {},
                w = {},
                b = "canceled",
                C = {
                    readyState: 0,
                    getResponseHeader: function(t) {
                        var e;
                        if (l) {
                            if (!s)
                                for (s = {}; e = Ne.exec(o);)
                                    s[e[1].toLowerCase() + " "] = (s[e[1].toLowerCase() + " "] || []).concat(e[2]);
                            e = s[t.toLowerCase() + " "]
                        }
                        return null == e ? null : e.join(", ")
                    },
                    getAllResponseHeaders: function() {
                        return l ? o : null
                    },
                    setRequestHeader: function(t, e) {
                        return null == l && (t = w[t.toLowerCase()] = w[t.toLowerCase()] || t, x[t] = e), this
                    },
                    overrideMimeType: function(t) {
                        return null == l && (f.mimeType = t), this
                    },
                    statusCode: function(t) {
                        var e;
                        if (t)
                            if (l)
                                C.always(t[C.status]);
                            else
                                for (e in t)
                                    _[e] = [_[e], t[e]];
                        return this
                    },
                    abort: function(t) {
                        var e = t || b;
                        return r && r.abort(e), M(0, e), this
                    }
                };
            if (v.promise(C), f.url = ((e || f.url || Ee.href) + "").replace(Ae, Ee.protocol + "//"), f.type = n.method || n.type || f.method || f.type, f.dataTypes = (f.dataType || "*").toLowerCase().match(D) || [""], null == f.crossDomain) {
                u = y.createElement("a");
                try {
                    u.href = f.url,
                    u.href = u.href,
                    f.crossDomain = je.protocol + "//" + je.host != u.protocol + "//" + u.host
                } catch (t) {
                    f.crossDomain = !0
                }
            }
            if (f.data && f.processData && "string" != typeof f.data && (f.data = E.param(f.data, f.traditional)), Be(De, f, n, C), l)
                return C;
            for (c in (h = E.event && f.global) && 0 == E.active++ && E.event.trigger("ajaxStart"), f.type = f.type.toUpperCase(), f.hasContent = !Re.test(f.type), i = f.url.replace(Le, ""), f.hasContent ? f.data && f.processData && 0 === (f.contentType || "").indexOf("application/x-www-form-urlencoded") && (f.data = f.data.replace(Pe, "+")) : (p = f.url.slice(i.length), f.data && (f.processData || "string" == typeof f.data) && (i += (be.test(i) ? "&" : "?") + f.data, delete f.data), !1 === f.cache && (i = i.replace(Oe, "$1"), p = (be.test(i) ? "&" : "?") + "_=" + we.guid++ + p), f.url = i + p), f.ifModified && (E.lastModified[i] && C.setRequestHeader("If-Modified-Since", E.lastModified[i]), E.etag[i] && C.setRequestHeader("If-None-Match", E.etag[i])), (f.data && f.hasContent && !1 !== f.contentType || n.contentType) && C.setRequestHeader("Content-Type", f.contentType), C.setRequestHeader("Accept", f.dataTypes[0] && f.accepts[f.dataTypes[0]] ? f.accepts[f.dataTypes[0]] + ("*" !== f.dataTypes[0] ? ", " + ke + "; q=0.01" : "") : f.accepts["*"]), f.headers)
                C.setRequestHeader(c, f.headers[c]);
            if (f.beforeSend && (!1 === f.beforeSend.call(d, C, f) || l))
                return C.abort();
            if (b = "abort", m.add(f.complete), C.done(f.success), C.fail(f.error), r = Be(Fe, f, n, C)) {
                if (C.readyState = 1, h && g.trigger("ajaxSend", [C, f]), l)
                    return C;
                f.async && f.timeout > 0 && (a = t.setTimeout((function() {
                    C.abort("timeout")
                }), f.timeout));
                try {
                    l = !1,
                    r.send(x, M)
                } catch (t) {
                    if (l)
                        throw t;
                    M(-1, t)
                }
            } else
                M(-1, "No Transport");
            function M(e, n, s, u) {
                var c,
                    p,
                    y,
                    x,
                    w,
                    b = n;
                l || (l = !0, a && t.clearTimeout(a), r = void 0, o = u || "", C.readyState = e > 0 ? 4 : 0, c = e >= 200 && e < 300 || 304 === e, s && (x = function(t, e, n) {
                    for (var r, i, o, s, a = t.contents, u = t.dataTypes; "*" === u[0];)
                        u.shift(),
                        void 0 === r && (r = t.mimeType || e.getResponseHeader("Content-Type"));
                    if (r)
                        for (i in a)
                            if (a[i] && a[i].test(r)) {
                                u.unshift(i);
                                break
                            }
                    if (u[0] in n)
                        o = u[0];
                    else {
                        for (i in n) {
                            if (!u[0] || t.converters[i + " " + u[0]]) {
                                o = i;
                                break
                            }
                            s || (s = i)
                        }
                        o = o || s
                    }
                    if (o)
                        return o !== u[0] && u.unshift(o), n[o]
                }(f, C, s)), !c && E.inArray("script", f.dataTypes) > -1 && E.inArray("json", f.dataTypes) < 0 && (f.converters["text script"] = function() {}), x = function(t, e, n, r) {
                    var i,
                        o,
                        s,
                        a,
                        u,
                        l = {},
                        h = t.dataTypes.slice();
                    if (h[1])
                        for (s in t.converters)
                            l[s.toLowerCase()] = t.converters[s];
                    for (o = h.shift(); o;)
                        if (t.responseFields[o] && (n[t.responseFields[o]] = e), !u && r && t.dataFilter && (e = t.dataFilter(e, t.dataType)), u = o, o = h.shift())
                            if ("*" === o)
                                o = u;
                            else if ("*" !== u && u !== o) {
                                if (!(s = l[u + " " + o] || l["* " + o]))
                                    for (i in l)
                                        if ((a = i.split(" "))[1] === o && (s = l[u + " " + a[0]] || l["* " + a[0]])) {
                                            !0 === s ? s = l[i] : !0 !== l[i] && (o = a[0], h.unshift(a[1]));
                                            break
                                        }
                                if (!0 !== s)
                                    if (s && t.throws)
                                        e = s(e);
                                    else
                                        try {
                                            e = s(e)
                                        } catch (t) {
                                            return {
                                                state: "parsererror",
                                                error: s ? t : "No conversion from " + u + " to " + o
                                            }
                                        }
                            }
                    return {
                        state: "success",
                        data: e
                    }
                }(f, x, C, c), c ? (f.ifModified && ((w = C.getResponseHeader("Last-Modified")) && (E.lastModified[i] = w), (w = C.getResponseHeader("etag")) && (E.etag[i] = w)), 204 === e || "HEAD" === f.type ? b = "nocontent" : 304 === e ? b = "notmodified" : (b = x.state, p = x.data, c = !(y = x.error))) : (y = b, !e && b || (b = "error", e < 0 && (e = 0))), C.status = e, C.statusText = (n || b) + "", c ? v.resolveWith(d, [p, b, C]) : v.rejectWith(d, [C, b, y]), C.statusCode(_), _ = void 0, h && g.trigger(c ? "ajaxSuccess" : "ajaxError", [C, f, c ? p : y]), m.fireWith(d, [C, b]), h && (g.trigger("ajaxComplete", [C, f]), --E.active || E.event.trigger("ajaxStop")))
            }
            return C
        },
        getJSON: function(t, e, n) {
            return E.get(t, e, n, "json")
        },
        getScript: function(t, e) {
            return E.get(t, void 0, e, "script")
        }
    }),
    E.each(["get", "post"], (function(t, e) {
        E[e] = function(t, n, r, i) {
            return d(n) && (i = i || r, r = n, n = void 0), E.ajax(E.extend({
                url: t,
                type: e,
                dataType: i,
                data: n,
                success: r
            }, E.isPlainObject(t) && t))
        }
    })),
    E.ajaxPrefilter((function(t) {
        var e;
        for (e in t.headers)
            "content-type" === e.toLowerCase() && (t.contentType = t.headers[e] || "")
    })),
    E._evalUrl = function(t, e, n) {
        return E.ajax({
            url: t,
            type: "GET",
            dataType: "script",
            cache: !0,
            async: !1,
            global: !1,
            converters: {
                "text script": function() {}
            },
            dataFilter: function(t) {
                E.globalEval(t, e, n)
            }
        })
    },
    E.fn.extend({
        wrapAll: function(t) {
            var e;
            return this[0] && (d(t) && (t = t.call(this[0])), e = E(t, this[0].ownerDocument).eq(0).clone(!0), this[0].parentNode && e.insertBefore(this[0]), e.map((function() {
                for (var t = this; t.firstElementChild;)
                    t = t.firstElementChild;
                return t
            })).append(this)), this
        },
        wrapInner: function(t) {
            return d(t) ? this.each((function(e) {
                E(this).wrapInner(t.call(this, e))
            })) : this.each((function() {
                var e = E(this),
                    n = e.contents();
                n.length ? n.wrapAll(t) : e.append(t)
            }))
        },
        wrap: function(t) {
            var e = d(t);
            return this.each((function(n) {
                E(this).wrapAll(e ? t.call(this, n) : t)
            }))
        },
        unwrap: function(t) {
            return this.parent(t).not("body").each((function() {
                E(this).replaceWith(this.childNodes)
            })), this
        }
    }),
    E.expr.pseudos.hidden = function(t) {
        return !E.expr.pseudos.visible(t)
    },
    E.expr.pseudos.visible = function(t) {
        return !!(t.offsetWidth || t.offsetHeight || t.getClientRects().length)
    },
    E.ajaxSettings.xhr = function() {
        try {
            return new t.XMLHttpRequest
        } catch (t) {}
    };
    var ze = {
            0: 200,
            1223: 204
        },
        Ue = E.ajaxSettings.xhr();
    f.cors = !!Ue && "withCredentials" in Ue,
    f.ajax = Ue = !!Ue,
    E.ajaxTransport((function(e) {
        var n,
            r;
        if (f.cors || Ue && !e.crossDomain)
            return {
                send: function(i, o) {
                    var s,
                        a = e.xhr();
                    if (a.open(e.type, e.url, e.async, e.username, e.password), e.xhrFields)
                        for (s in e.xhrFields)
                            a[s] = e.xhrFields[s];
                    for (s in e.mimeType && a.overrideMimeType && a.overrideMimeType(e.mimeType), e.crossDomain || i["X-Requested-With"] || (i["X-Requested-With"] = "XMLHttpRequest"), i)
                        a.setRequestHeader(s, i[s]);
                    n = function(t) {
                        return function() {
                            n && (n = r = a.onload = a.onerror = a.onabort = a.ontimeout = a.onreadystatechange = null, "abort" === t ? a.abort() : "error" === t ? "number" != typeof a.status ? o(0, "error") : o(a.status, a.statusText) : o(ze[a.status] || a.status, a.statusText, "text" !== (a.responseType || "text") || "string" != typeof a.responseText ? {
                                binary: a.response
                            } : {
                                text: a.responseText
                            }, a.getAllResponseHeaders()))
                        }
                    },
                    a.onload = n(),
                    r = a.onerror = a.ontimeout = n("error"),
                    void 0 !== a.onabort ? a.onabort = r : a.onreadystatechange = function() {
                        4 === a.readyState && t.setTimeout((function() {
                            n && r()
                        }))
                    },
                    n = n("abort");
                    try {
                        a.send(e.hasContent && e.data || null)
                    } catch (t) {
                        if (n)
                            throw t
                    }
                },
                abort: function() {
                    n && n()
                }
            }
    })),
    E.ajaxPrefilter((function(t) {
        t.crossDomain && (t.contents.script = !1)
    })),
    E.ajaxSetup({
        accepts: {
            script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"
        },
        contents: {
            script: /\b(?:java|ecma)script\b/
        },
        converters: {
            "text script": function(t) {
                return E.globalEval(t), t
            }
        }
    }),
    E.ajaxPrefilter("script", (function(t) {
        void 0 === t.cache && (t.cache = !1),
        t.crossDomain && (t.type = "GET")
    })),
    E.ajaxTransport("script", (function(t) {
        var e,
            n;
        if (t.crossDomain || t.scriptAttrs)
            return {
                send: function(r, i) {
                    e = E("<script>").attr(t.scriptAttrs || {}).prop({
                        charset: t.scriptCharset,
                        src: t.url
                    }).on("load error", n = function(t) {
                        e.remove(),
                        n = null,
                        t && i("error" === t.type ? 404 : 200, t.type)
                    }),
                    y.head.appendChild(e[0])
                },
                abort: function() {
                    n && n()
                }
            }
    }));
    var Ve,
        Xe = [],
        He = /(=)\?(?=&|$)|\?\?/;
    E.ajaxSetup({
        jsonp: "callback",
        jsonpCallback: function() {
            var t = Xe.pop() || E.expando + "_" + we.guid++;
            return this[t] = !0, t
        }
    }),
    E.ajaxPrefilter("json jsonp", (function(e, n, r) {
        var i,
            o,
            s,
            a = !1 !== e.jsonp && (He.test(e.url) ? "url" : "string" == typeof e.data && 0 === (e.contentType || "").indexOf("application/x-www-form-urlencoded") && He.test(e.data) && "data");
        if (a || "jsonp" === e.dataTypes[0])
            return i = e.jsonpCallback = d(e.jsonpCallback) ? e.jsonpCallback() : e.jsonpCallback, a ? e[a] = e[a].replace(He, "$1" + i) : !1 !== e.jsonp && (e.url += (be.test(e.url) ? "&" : "?") + e.jsonp + "=" + i), e.converters["script json"] = function() {
                return s || E.error(i + " was not called"), s[0]
            }, e.dataTypes[0] = "json", o = t[i], t[i] = function() {
                s = arguments
            }, r.always((function() {
                void 0 === o ? E(t).removeProp(i) : t[i] = o,
                e[i] && (e.jsonpCallback = n.jsonpCallback, Xe.push(i)),
                s && d(o) && o(s[0]),
                s = o = void 0
            })), "script"
    })),
    f.createHTMLDocument = ((Ve = y.implementation.createHTMLDocument("").body).innerHTML = "<form></form><form></form>", 2 === Ve.childNodes.length),
    E.parseHTML = function(t, e, n) {
        return "string" != typeof t ? [] : ("boolean" == typeof e && (n = e, e = !1), e || (f.createHTMLDocument ? ((r = (e = y.implementation.createHTMLDocument("")).createElement("base")).href = y.location.href, e.head.appendChild(r)) : e = y), o = !n && [], (i = T.exec(t)) ? [e.createElement(i[1])] : (i = xt([t], e, o), o && o.length && E(o).remove(), E.merge([], i.childNodes)));
        var r,
            i,
            o
    },
    E.fn.load = function(t, e, n) {
        var r,
            i,
            o,
            s = this,
            a = t.indexOf(" ");
        return a > -1 && (r = ge(t.slice(a)), t = t.slice(0, a)), d(e) ? (n = e, e = void 0) : e && "object" == typeof e && (i = "POST"), s.length > 0 && E.ajax({
            url: t,
            type: i || "GET",
            dataType: "html",
            data: e
        }).done((function(t) {
            o = arguments,
            s.html(r ? E("<div>").append(E.parseHTML(t)).find(r) : t)
        })).always(n && function(t, e) {
            s.each((function() {
                n.apply(this, o || [t.responseText, e, t])
            }))
        }), this
    },
    E.expr.pseudos.animated = function(t) {
        return E.grep(E.timers, (function(e) {
            return t === e.elem
        })).length
    },
    E.offset = {
        setOffset: function(t, e, n) {
            var r,
                i,
                o,
                s,
                a,
                u,
                l = E.css(t, "position"),
                h = E(t),
                c = {};
            "static" === l && (t.style.position = "relative"),
            a = h.offset(),
            o = E.css(t, "top"),
            u = E.css(t, "left"),
            ("absolute" === l || "fixed" === l) && (o + u).indexOf("auto") > -1 ? (s = (r = h.position()).top, i = r.left) : (s = parseFloat(o) || 0, i = parseFloat(u) || 0),
            d(e) && (e = e.call(t, n, E.extend({}, a))),
            null != e.top && (c.top = e.top - a.top + s),
            null != e.left && (c.left = e.left - a.left + i),
            "using" in e ? e.using.call(t, c) : h.css(c)
        }
    },
    E.fn.extend({
        offset: function(t) {
            if (arguments.length)
                return void 0 === t ? this : this.each((function(e) {
                    E.offset.setOffset(this, t, e)
                }));
            var e,
                n,
                r = this[0];
            return r ? r.getClientRects().length ? (e = r.getBoundingClientRect(), n = r.ownerDocument.defaultView, {
                top: e.top + n.pageYOffset,
                left: e.left + n.pageXOffset
            }) : {
                top: 0,
                left: 0
            } : void 0
        },
        position: function() {
            if (this[0]) {
                var t,
                    e,
                    n,
                    r = this[0],
                    i = {
                        top: 0,
                        left: 0
                    };
                if ("fixed" === E.css(r, "position"))
                    e = r.getBoundingClientRect();
                else {
                    for (e = this.offset(), n = r.ownerDocument, t = r.offsetParent || n.documentElement; t && (t === n.body || t === n.documentElement) && "static" === E.css(t, "position");)
                        t = t.parentNode;
                    t && t !== r && 1 === t.nodeType && ((i = E(t).offset()).top += E.css(t, "borderTopWidth", !0), i.left += E.css(t, "borderLeftWidth", !0))
                }
                return {
                    top: e.top - i.top - E.css(r, "marginTop", !0),
                    left: e.left - i.left - E.css(r, "marginLeft", !0)
                }
            }
        },
        offsetParent: function() {
            return this.map((function() {
                for (var t = this.offsetParent; t && "static" === E.css(t, "position");)
                    t = t.offsetParent;
                return t || rt
            }))
        }
    }),
    E.each({
        scrollLeft: "pageXOffset",
        scrollTop: "pageYOffset"
    }, (function(t, e) {
        var n = "pageYOffset" === e;
        E.fn[t] = function(r) {
            return z(this, (function(t, r, i) {
                var o;
                if (g(t) ? o = t : 9 === t.nodeType && (o = t.defaultView), void 0 === i)
                    return o ? o[e] : t[r];
                o ? o.scrollTo(n ? o.pageXOffset : i, n ? i : o.pageYOffset) : t[r] = i
            }), t, r, arguments.length)
        }
    })),
    E.each(["top", "left"], (function(t, e) {
        E.cssHooks[e] = Vt(f.pixelPosition, (function(t, n) {
            if (n)
                return n = Ut(t, e), kt.test(n) ? E(t).position()[e] + "px" : n
        }))
    })),
    E.each({
        Height: "height",
        Width: "width"
    }, (function(t, e) {
        E.each({
            padding: "inner" + t,
            content: e,
            "": "outer" + t
        }, (function(n, r) {
            E.fn[r] = function(i, o) {
                var s = arguments.length && (n || "boolean" != typeof i),
                    a = n || (!0 === i || !0 === o ? "margin" : "border");
                return z(this, (function(e, n, i) {
                    var o;
                    return g(e) ? 0 === r.indexOf("outer") ? e["inner" + t] : e.document.documentElement["client" + t] : 9 === e.nodeType ? (o = e.documentElement, Math.max(e.body["scroll" + t], o["scroll" + t], e.body["offset" + t], o["offset" + t], o["client" + t])) : void 0 === i ? E.css(e, n, a) : E.style(e, n, i, a)
                }), e, s ? i : void 0, s)
            }
        }))
    })),
    E.each(["ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend"], (function(t, e) {
        E.fn[e] = function(t) {
            return this.on(e, t)
        }
    })),
    E.fn.extend({
        bind: function(t, e, n) {
            return this.on(t, null, e, n)
        },
        unbind: function(t, e) {
            return this.off(t, null, e)
        },
        delegate: function(t, e, n, r) {
            return this.on(e, t, n, r)
        },
        undelegate: function(t, e, n) {
            return 1 === arguments.length ? this.off(t, "**") : this.off(e, t || "**", n)
        },
        hover: function(t, e) {
            return this.mouseenter(t).mouseleave(e || t)
        }
    }),
    E.each("blur focus focusin focusout resize scroll click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup contextmenu".split(" "), (function(t, e) {
        E.fn[e] = function(t, n) {
            return arguments.length > 0 ? this.on(e, null, t, n) : this.trigger(e)
        }
    }));
    var Ye = /^[\s\uFEFF\xA0]+|([^\s\uFEFF\xA0])[\s\uFEFF\xA0]+$/g;
    E.proxy = function(t, e) {
        var n,
            r,
            o;
        if ("string" == typeof e && (n = t[e], e = t, t = n), d(t))
            return r = i.call(arguments, 2), o = function() {
                return t.apply(e || this, r.concat(i.call(arguments)))
            }, o.guid = t.guid = t.guid || E.guid++, o
    },
    E.holdReady = function(t) {
        t ? E.readyWait++ : E.ready(!0)
    },
    E.isArray = Array.isArray,
    E.parseJSON = JSON.parse,
    E.nodeName = I,
    E.isFunction = d,
    E.isWindow = g,
    E.camelCase = H,
    E.type = _,
    E.now = Date.now,
    E.isNumeric = function(t) {
        var e = E.type(t);
        return ("number" === e || "string" === e) && !isNaN(t - parseFloat(t))
    },
    E.trim = function(t) {
        return null == t ? "" : (t + "").replace(Ye, "$1")
    },
    "function" == typeof define && define.amd && define("jquery", [], (function() {
        return E
    }));
    var We = t.jQuery,
        $e = t.$;
    return E.noConflict = function(e) {
        return t.$ === E && (t.$ = $e), e && t.jQuery === E && (t.jQuery = We), E
    }, void 0 === e && (t.jQuery = t.$ = E), E
})),
window.ol && !ol.ext && (ol.ext = {});
var ly = function(t, e) {
    t.prototype = Object.create(e.prototype),
    t.prototype.constructor = t
};
window.ol && (ol.inherits || (ol.inherits = ly)),
window.NodeList && !NodeList.prototype.forEach && (NodeList.prototype.forEach = Array.prototype.forEach),
window.Element && !Element.prototype.remove && (Element.prototype.remove = function() {
    this.parentNode && this.parentNode.removeChild(this)
});
var hy = ly;
window.ol && (ol.ext.input = {});
var cy = function(t) {
    t = t || {},
    d.default.call(this);
    var e,
        n = this.input = t.input;
    n || (n = this.input = document.createElement("INPUT"), t.type && n.setAttribute("type", t.type), void 0 !== t.min && n.setAttribute("min", t.min), void 0 !== t.max && n.setAttribute("max", t.max), void 0 !== t.step && n.setAttribute("step", t.step), t.parent && t.parent.appendChild(n)),
    t.disabled && (n.disabled = !0),
    void 0 !== t.checked && (n.checked = !!t.checked),
    void 0 !== t.val && (n.value = t.val),
    t.hidden && (n.style.display = "none"),
    n.addEventListener("focus", function() {
        this.element && this.element.classList.add("ol-focus")
    }.bind(this)),
    n.addEventListener("focusout", function() {
        this.element && (e && clearTimeout(e), e = setTimeout(function() {
            this.element.classList.remove("ol-focus")
        }.bind(this), 0))
    }.bind(this))
};
hy(cy, d.default),
cy.prototype._listenDrag = function(t, e) {
    var n = function(n) {
        this.moving = !0,
        this.element.classList.add("ol-moving");
        var r = function(n) {
            "pointerup" === n.type && (document.removeEventListener("pointermove", r), document.removeEventListener("pointerup", r), document.removeEventListener("pointercancel", r), setTimeout(function() {
                this.moving = !1,
                this.element.classList.remove("ol-moving")
            }.bind(this))),
            n.target === t && e(n),
            n.stopPropagation(),
            n.preventDefault()
        }.bind(this);
        document.addEventListener("pointermove", r, !1),
        document.addEventListener("pointerup", r, !1),
        document.addEventListener("pointercancel", r, !1),
        n.stopPropagation(),
        n.preventDefault()
    }.bind(this);
    t.addEventListener("mousedown", n, !1),
    t.addEventListener("touchstart", n, !1)
},
cy.prototype.setValue = function(t) {
    void 0 !== t && (this.input.value = t),
    this.input.dispatchEvent(new Event("change"))
},
cy.prototype.getValue = function() {
    return this.input.value
},
cy.prototype.getInputElement = function() {
    return this.input
};
var py = cy,
    fy = function(t) {
        py.call(this, t = t || {});
        var e = this.element = document.createElement("LABEL");
        t.html instanceof Element ? e.appendChild(t.html) : void 0 !== t.html && (e.innerHTML = t.html),
        e.className = ("ol-ext-check ol-ext-checkbox " + (t.className || "")).trim(),
        this.input.parentNode && this.input.parentNode.insertBefore(e, this.input),
        e.appendChild(this.input),
        e.appendChild(document.createElement("SPAN")),
        t.after && e.appendChild(document.createTextNode(t.after)),
        this.input.addEventListener("change", function() {
            this.dispatchEvent({
                type: "check",
                checked: this.input.checked,
                value: this.input.value
            })
        }.bind(this))
    };
hy(fy, py),
fy.prototype.isChecked = function() {
    return this.input.checked
};
var dy = fy,
    gy = function(t) {
        dy.call(this, t = t || {}),
        this.element.className = ("ol-ext-toggle-switch " + (t.className || "")).trim()
    };
hy(gy, dy);
var yy = gy,
    vy = function(t) {
        dy.call(this, t = t || {}),
        this.element.className = ("ol-ext-check ol-ext-radio " + (t.className || "")).trim()
    };
hy(vy, dy);
var my = vy,
    _y = {
        create: function(t, e) {
            var n;
            if (e = e || {}, "TEXT" === t)
                n = document.createTextNode(e.html || ""),
                e.parent && e.parent.appendChild(n);
            else
                for (var r in n = document.createElement(t), /button/i.test(t) && n.setAttribute("type", "button"), e)
                    switch (r) {
                    case "className":
                        e.className && e.className.trim && n.setAttribute("class", e.className.trim());
                        break;
                    case "text":
                        n.innerText = e.text;
                        break;
                    case "html":
                        e.html instanceof Element ? n.appendChild(e.html) : void 0 !== e.html && (n.innerHTML = e.html);
                        break;
                    case "parent":
                        e.parent && e.parent.appendChild(n);
                        break;
                    case "options":
                        if (/select/i.test(t))
                            for (var i in e.options)
                                _y.create("OPTION", {
                                    html: i,
                                    value: e.options[i],
                                    parent: n
                                });
                        break;
                    case "style":
                        _y.setStyle(n, e.style);
                        break;
                    case "change":
                    case "click":
                        _y.addListener(n, r, e[r]);
                        break;
                    case "on":
                        for (var o in e.on)
                            _y.addListener(n, o, e.on[o]);
                        break;
                    case "checked":
                        n.checked = !!e.checked;
                        break;
                    default:
                        n.setAttribute(r, e[r])
                    }
            return n
        },
        createSwitch: function(t) {
            var e = _y.create("INPUT", {
                    type: "checkbox",
                    on: t.on,
                    click: t.click,
                    change: t.change,
                    parent: t.parent
                }),
                n = Object.assign({
                    input: e
                }, t || {});
            return new yy(n), e
        },
        createCheck: function(t) {
            var e = _y.create("INPUT", {
                    name: t.name,
                    type: "radio" === t.type ? "radio" : "checkbox",
                    on: t.on,
                    parent: t.parent
                }),
                n = Object.assign({
                    input: e
                }, t || {});
            return "radio" === t.type ? new my(n) : new dy(n), e
        },
        setHTML: function(t, e) {
            e instanceof Element ? t.appendChild(e) : void 0 !== e && (t.innerHTML = e)
        },
        appendText: function(t, e) {
            t.appendChild(document.createTextNode(e || ""))
        },
        addListener: function(t, e, n, r) {
            "string" == typeof e && (e = e.split(" ")),
            e.forEach((function(e) {
                t.addEventListener(e, n, r)
            }))
        },
        removeListener: function(t, e, n) {
            "string" == typeof e && (e = e.split(" ")),
            e.forEach((function(e) {
                t.removeEventListener(e, n)
            }))
        },
        show: function(t) {
            t.style.display = ""
        },
        hide: function(t) {
            t.style.display = "none"
        },
        hidden: function(t) {
            return "none" === _y.getStyle(t, "display")
        },
        toggle: function(t) {
            t.style.display = "none" === t.style.display ? "" : "none"
        },
        setStyle: function(t, e) {
            for (var n in e)
                switch (n) {
                case "top":
                case "left":
                case "bottom":
                case "right":
                case "minWidth":
                case "maxWidth":
                case "width":
                case "height":
                    "number" == typeof e[n] ? t.style[n] = e[n] + "px" : t.style[n] = e[n];
                    break;
                default:
                    t.style[n] = e[n]
                }
        },
        getStyle: function(t, e) {
            var n,
                r = (t.ownerDocument || document).defaultView;
            if (r && r.getComputedStyle)
                e = e.replace(/([A-Z])/g, "-$1").toLowerCase(),
                n = r.getComputedStyle(t, null).getPropertyValue(e);
            else if (t.currentStyle && (e = e.replace(/-(\w)/g, (function(t, e) {
                return e.toUpperCase()
            })), n = t.currentStyle[e], /^\d+(em|pt|%|ex)?$/i.test(n)))
                return function(e) {
                    var n = t.style.left,
                        r = t.runtimeStyle.left;
                    return t.runtimeStyle.left = t.currentStyle.left, t.style.left = e || 0, e = t.style.pixelLeft + "px", t.style.left = n, t.runtimeStyle.left = r, e
                }(n);
            return /px$/.test(n) ? parseInt(n) : n
        },
        outerHeight: function(t) {
            return t.offsetHeight + _y.getStyle(t, "marginBottom")
        },
        outerWidth: function(t) {
            return t.offsetWidth + _y.getStyle(t, "marginLeft")
        },
        offsetRect: function(t) {
            var e = t.getBoundingClientRect();
            return {
                top: e.top + (window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop || 0),
                left: e.left + (window.pageXOffset || document.documentElement.scrollLeft || document.body.scrollLeft || 0),
                height: e.height || e.bottom - e.top,
                width: e.width || e.right - e.left
            }
        },
        getFixedOffset: function(t) {
            var e = {
                    left: 0,
                    top: 0
                },
                n = function(t) {
                    if (!t)
                        return e;
                    if ("absolute" === _y.getStyle(t, "position") && "none" !== _y.getStyle(t, "transform")) {
                        var r = t.getBoundingClientRect();
                        return e.left += r.left, e.top += r.top, e
                    }
                    return n(t.offsetParent)
                };
            return n(t.offsetParent)
        },
        positionRect: function(t, e) {
            var n = 0,
                r = 0,
                i = function(o) {
                    if (o)
                        return n += o.offsetLeft, r += o.offsetTop, i(o.offsetParent);
                    var s = {
                        top: t.offsetTop + r,
                        left: t.offsetLeft + n
                    };
                    return e && (s.top -= window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop || 0, s.left -= window.pageXOffset || document.documentElement.scrollLeft || document.body.scrollLeft || 0), s.bottom = s.top + t.offsetHeight, s.right = s.top + t.offsetWidth, s
                };
            return i(t.offsetParent)
        },
        scrollDiv: function(t, e) {
            var n,
                r,
                i,
                o,
                s,
                a = !1,
                u = 0,
                l = 0,
                h = "function" == typeof (e = e || {}).onmove ? e.onmove : function() {},
                c = e.vertical ? "screenY" : "screenX",
                p = e.vertical ? "scrollTop" : "scrollLeft",
                f = !1,
                d = 0,
                g = function() {
                    s && (d++, setTimeout(y))
                },
                y = function() {
                    if (s) {
                        if (--d)
                            return;
                        var e = t.clientHeight,
                            n = t.scrollHeight;
                        r = e / n,
                        s.style.height = 100 * r + "%",
                        s.style.top = t.scrollTop / n * 100 + "%",
                        o.style.height = e + "px",
                        e > n - .5 ? o.classList.add("ol-100pc") : o.classList.remove("ol-100pc")
                    }
                },
                v = function(e) {
                    e.target.classList.contains("ol-noscroll") || (f = !1, a = e[c], l = new Date, t.classList.add("ol-move"), e.preventDefault(), window.addEventListener("pointermove", m), _y.addListener(window, ["pointerup", "pointercancel"], E))
                },
                m = function(e) {
                    if (f = !0, !1 !== a) {
                        var o = (i ? -1 / r : 1) * (a - e[c]);
                        t[p] += o,
                        (n = new Date) - l && (u = (u + o / (n - l)) / 2),
                        a = e[c],
                        l = n,
                        o && h(!0)
                    }
                },
                _ = function(e) {
                    var n = e > 0 ? Math.min(100, e / 2) : Math.max(-100, e / 2);
                    e -= n,
                    t[p] += n,
                    -1 < e && e < 1 ? (f ? setTimeout((function() {
                        t.classList.remove("ol-move")
                    })) : t.classList.remove("ol-move"), f = !1, h(!1)) : setTimeout((function() {
                        _(e)
                    }), 40)
                };
            if (e.vertical && e.minibar) {
                var x = function(n) {
                    t.removeEventListener("pointermove", x),
                    t.parentNode.classList.add("ol-miniscroll"),
                    s = _y.create("DIV"),
                    o = _y.create("DIV", {
                        className: "ol-scroll",
                        html: s
                    }),
                    t.parentNode.insertBefore(o, t),
                    s.addEventListener("pointerdown", (function(t) {
                        i = !0,
                        v(t)
                    })),
                    e.mousewheel && (_y.addListener(o, ["mousewheel", "DOMMouseScroll", "onmousewheel"], (function(t) {
                        w(t)
                    })), _y.addListener(s, ["mousewheel", "DOMMouseScroll", "onmousewheel"], (function(t) {
                        w(t)
                    }))),
                    t.parentNode.addEventListener("pointerenter", g),
                    window.addEventListener("resize", g),
                    !1 !== n && g()
                };
                t.parentNode ? x(!1) : t.addEventListener("pointermove", x),
                t.addEventListener("scroll", (function() {
                    g()
                }))
            }
            t.style["touch-action"] = "none",
            t.style.overflow = "hidden",
            t.classList.add("ol-scrolldiv"),
            _y.addListener(t, ["pointerdown"], (function(t) {
                i = !1,
                v(t)
            })),
            t.addEventListener("click", (function(e) {
                t.classList.contains("ol-move") && (e.preventDefault(), e.stopPropagation())
            }), !0);
            var E = function(n) {
                    (l = new Date - l) > 100 || i ? u = 0 : l > 0 && (u = ((u || 0) + (a - n[c]) / l) / 2),
                    _(!1 === e.animate ? 0 : 200 * u),
                    a = !1,
                    u = 0,
                    l = 0,
                    t.classList.contains("ol-move") ? t.classList.remove("ol-hasClick") : (t.classList.add("ol-hasClick"), setTimeout((function() {
                        t.classList.remove("ol-hasClick")
                    }), 500)),
                    i = !1,
                    window.removeEventListener("pointermove", m),
                    _y.removeListener(window, ["pointerup", "pointercancel"], E)
                },
                w = function(e) {
                    var n = Math.max(-1, Math.min(1, e.wheelDelta || -e.detail));
                    return t.classList.add("ol-move"), t[p] -= 30 * n, t.classList.remove("ol-move"), !1
                };
            return e.mousewheel && _y.addListener(t, ["mousewheel", "DOMMouseScroll", "onmousewheel"], w), {
                refresh: g
            }
        },
        dispatchEvent: function(t, e) {
            var n;
            try {
                n = new CustomEvent(t)
            } catch (e) {
                (n = document.createEvent("CustomEvent")).initCustomEvent(t, !0, !0, {})
            }
            e.dispatchEvent(n)
        }
    },
    xy = _y,
    Ey = function(t) {
        t || (t = {});
        var e = xy.create("DIV", {
            className: "ol-unselectable ol-overlay " + (t.className || ""),
            html: t.content
        });
        ss.default.call(this, {
            element: e,
            target: t.target
        });
        var n = this;
        t.hideOnClick && e.addEventListener("click", (function() {
            n.hide()
        })),
        this.set("closeBox", t.closeBox),
        this.setContent(t.content)
    };
hy(Ey, ss.default),
Ey.prototype.setContent = function(t) {
    var e = this;
    if (t) {
        var n = this.element;
        if (t instanceof Element ? (n.innerHTML = "", n.appendChild(t)) : void 0 !== t && (n.innerHTML = t), this.get("closeBox")) {
            var r = document.createElement("div");
            r.classList.add("ol-closebox"),
            r.addEventListener("click", (function() {
                e.hide()
            })),
            n.insertBefore(r, n.firstChild)
        }
    }
},
Ey.prototype.show = function(t, e) {
    var n = this.element;
    n.style.display = "block",
    e ? (this.center_ = this.getMap().getPixelFromCoordinate(e), n.style.top = this.center_[1] + "px", n.style.left = this.center_[0] + "px") : (this.center_ = !1, n.style.top = "", n.style.left = ""),
    t && this.setContent(t),
    n.classList.add("ol-visible"),
    n.style.top = "",
    n.style.left = "",
    this.dispatchEvent({
        type: "change:visible",
        visible: !0,
        element: this.element
    })
},
Ey.prototype.showImage = function(t, e) {
    e = e || {};
    var n = xy.create("DIV", {
        className: "ol-fullscreen-image"
    });
    xy.create("IMG", {
        src: t,
        parent: n
    }),
    e.title && (n.classList.add("ol-has-title"), xy.create("P", {
        html: e.title,
        parent: n
    })),
    this.show(n, e.coordinate)
},
Ey.prototype.hide = function() {
    var t = this.element;
    this.element.classList.remove("ol-visible"),
    this.center_ && (t.style.top = this.center_[1] + "px", t.style.left = this.center_[0] + "px", this.center_ = !1),
    t.style.display = "none",
    this.dispatchEvent({
        type: "change:visible",
        visible: !1,
        element: this.element
    })
},
Ey.prototype.toggle = function() {
    this.getVisible() ? this.hide() : this.show()
},
Ey.prototype.getVisible = function() {
    return "none" !== xy.getStyle(this.element, "display")
},
Ey.prototype.setClass = function(t) {
    var e = this.element.classList.contains("ol-visible");
    this.element.className = ("ol-unselectable ol-overlay " + (e ? "ol-visible " : "") + t).trim()
};
var wy = Ey,
    by = function(t) {
        t = t || {};
        var e = document.createElement("div");
        e.className = (t.className || "") + " ol-button ol-unselectable ol-control";
        var n = this,
            r = this.button_ = document.createElement(/ol-text-button/.test(t.className) ? "div" : "button");
        r.type = "button",
        t.title && (r.title = t.title),
        t.name && (r.name = t.name),
        t.html instanceof Element ? r.appendChild(t.html) : r.innerHTML = t.html || "";
        r.addEventListener("click", (function(e) {
            e && e.preventDefault && (e.preventDefault(), e.stopPropagation()),
            t.handleClick && t.handleClick.call(n, e)
        })),
        e.appendChild(r),
        !t.title && r.firstElementChild && (r.title = r.firstElementChild.title),
        ss.default.call(this, {
            element: e,
            target: t.target
        }),
        t.title && this.set("title", t.title),
        t.title && this.set("title", t.title),
        t.name && this.set("name", t.name)
    };
hy(by, ss.default),
by.prototype.setVisible = function(t) {
    t ? xy.show(this.element) : xy.hide(this.element)
},
by.prototype.setTitle = function(t) {
    this.button_.setAttribute("title", t)
},
by.prototype.setHtml = function(t) {
    xy.setHTML(this.button_, t)
},
by.prototype.getButtonElement = function() {
    return this.button_
};
var Cy = by,
    My = function(t) {
        t = t || {};
        var e = this;
        this.interaction_ = t.interaction,
        this.interaction_ && (this.interaction_.setActive(t.active), this.interaction_.on("change:active", (function() {
            e.setActive(e.interaction_.getActive())
        }))),
        t.toggleFn && (t.onToggle = t.toggleFn),
        t.handleClick = function() {
            e.toggle(),
            t.onToggle && t.onToggle.call(e, e.getActive())
        },
        t.className = (t.className || "") + " ol-toggle",
        Cy.call(this, t),
        this.set("title", t.title),
        this.set("autoActivate", t.autoActivate),
        t.bar && this.setSubBar(t.bar),
        this.setActive(t.active),
        this.setDisable(t.disable)
    };
hy(My, Cy),
My.prototype.setMap = function(t) {
    !t && this.getMap() && (this.interaction_ && this.getMap().removeInteraction(this.interaction_), this.subbar_ && this.getMap().removeControl(this.subbar_)),
    Cy.prototype.setMap.call(this, t),
    t && (this.interaction_ && t.addInteraction(this.interaction_), this.subbar_ && t.addControl(this.subbar_))
},
My.prototype.getSubBar = function() {
    return this.subbar_
},
My.prototype.setSubBar = function(t) {
    var e = this.getMap();
    e && this.subbar_ && e.removeControl(this.subbar_),
    this.subbar_ = t,
    t && (this.subbar_.setTarget(this.element), this.subbar_.element.classList.add("ol-option-bar"), e && e.addControl(this.subbar_))
},
My.prototype.getDisable = function() {
    var t = this.element.querySelector("button");
    return t && t.disabled
},
My.prototype.setDisable = function(t) {
    this.getDisable() != t && (this.element.querySelector("button").disabled = t, t && this.getActive() && this.setActive(!1), this.dispatchEvent({
        type: "change:disable",
        key: "disable",
        oldValue: !t,
        disable: t
    }))
},
My.prototype.getActive = function() {
    return this.element.classList.contains("ol-active")
},
My.prototype.toggle = function() {
    this.getActive() ? this.setActive(!1) : this.setActive(!0)
},
My.prototype.setActive = function(t) {
    this.interaction_ && this.interaction_.setActive(t),
    this.subbar_ && this.subbar_.setActive(t),
    this.getActive() !== t && (t ? this.element.classList.add("ol-active") : this.element.classList.remove("ol-active"), this.dispatchEvent({
        type: "change:active",
        key: "active",
        oldValue: !t,
        active: t
    }))
},
My.prototype.setInteraction = function(t) {
    this.interaction_ = t
},
My.prototype.getInteraction = function() {
    return this.interaction_
};
var Sy = My;
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const Iy = function(t) {
        const e = [];
        let n = 0;
        for (let r = 0; r < t.length; r++) {
            let i = t.charCodeAt(r);
            i < 128 ? e[n++] = i : i < 2048 ? (e[n++] = i >> 6 | 192, e[n++] = 63 & i | 128) : 55296 == (64512 & i) && r + 1 < t.length && 56320 == (64512 & t.charCodeAt(r + 1)) ? (i = 65536 + ((1023 & i) << 10) + (1023 & t.charCodeAt(++r)), e[n++] = i >> 18 | 240, e[n++] = i >> 12 & 63 | 128, e[n++] = i >> 6 & 63 | 128, e[n++] = 63 & i | 128) : (e[n++] = i >> 12 | 224, e[n++] = i >> 6 & 63 | 128, e[n++] = 63 & i | 128)
        }
        return e
    },
    Ty = {
        byteToCharMap_: null,
        charToByteMap_: null,
        byteToCharMapWebSafe_: null,
        charToByteMapWebSafe_: null,
        ENCODED_VALS_BASE: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789",
        get ENCODED_VALS() {
            return this.ENCODED_VALS_BASE + "+/="
        },
        get ENCODED_VALS_WEBSAFE() {
            return this.ENCODED_VALS_BASE + "-_."
        },
        HAS_NATIVE_SUPPORT: "function" == typeof atob,
        encodeByteArray(t, e) {
            if (!Array.isArray(t))
                throw Error("encodeByteArray takes an array as a parameter");
            this.init_();
            const n = e ? this.byteToCharMapWebSafe_ : this.byteToCharMap_,
                r = [];
            for (let e = 0; e < t.length; e += 3) {
                const i = t[e],
                    o = e + 1 < t.length,
                    s = o ? t[e + 1] : 0,
                    a = e + 2 < t.length,
                    u = a ? t[e + 2] : 0,
                    l = i >> 2,
                    h = (3 & i) << 4 | s >> 4;
                let c = (15 & s) << 2 | u >> 6,
                    p = 63 & u;
                a || (p = 64, o || (c = 64)),
                r.push(n[l], n[h], n[c], n[p])
            }
            return r.join("")
        },
        encodeString(t, e) {
            return this.HAS_NATIVE_SUPPORT && !e ? btoa(t) : this.encodeByteArray(Iy(t), e)
        },
        decodeString(t, e) {
            return this.HAS_NATIVE_SUPPORT && !e ? atob(t) : function(t) {
                const e = [];
                let n = 0,
                    r = 0;
                for (; n < t.length;) {
                    const i = t[n++];
                    if (i < 128)
                        e[r++] = String.fromCharCode(i);
                    else if (i > 191 && i < 224) {
                        const o = t[n++];
                        e[r++] = String.fromCharCode((31 & i) << 6 | 63 & o)
                    } else if (i > 239 && i < 365) {
                        const o = ((7 & i) << 18 | (63 & t[n++]) << 12 | (63 & t[n++]) << 6 | 63 & t[n++]) - 65536;
                        e[r++] = String.fromCharCode(55296 + (o >> 10)),
                        e[r++] = String.fromCharCode(56320 + (1023 & o))
                    } else {
                        const o = t[n++],
                            s = t[n++];
                        e[r++] = String.fromCharCode((15 & i) << 12 | (63 & o) << 6 | 63 & s)
                    }
                }
                return e.join("")
            }(this.decodeStringToByteArray(t, e))
        },
        decodeStringToByteArray(t, e) {
            this.init_();
            const n = e ? this.charToByteMapWebSafe_ : this.charToByteMap_,
                r = [];
            for (let e = 0; e < t.length;) {
                const i = n[t.charAt(e++)],
                    o = e < t.length ? n[t.charAt(e)] : 0;
                ++e;
                const s = e < t.length ? n[t.charAt(e)] : 64;
                ++e;
                const a = e < t.length ? n[t.charAt(e)] : 64;
                if (++e, null == i || null == o || null == s || null == a)
                    throw Error();
                const u = i << 2 | o >> 4;
                if (r.push(u), 64 !== s) {
                    const t = o << 4 & 240 | s >> 2;
                    if (r.push(t), 64 !== a) {
                        const t = s << 6 & 192 | a;
                        r.push(t)
                    }
                }
            }
            return r
        },
        init_() {
            if (!this.byteToCharMap_) {
                this.byteToCharMap_ = {},
                this.charToByteMap_ = {},
                this.byteToCharMapWebSafe_ = {},
                this.charToByteMapWebSafe_ = {};
                for (let t = 0; t < this.ENCODED_VALS.length; t++)
                    this.byteToCharMap_[t] = this.ENCODED_VALS.charAt(t),
                    this.charToByteMap_[this.byteToCharMap_[t]] = t,
                    this.byteToCharMapWebSafe_[t] = this.ENCODED_VALS_WEBSAFE.charAt(t),
                    this.charToByteMapWebSafe_[this.byteToCharMapWebSafe_[t]] = t,
                    t >= this.ENCODED_VALS_BASE.length && (this.charToByteMap_[this.ENCODED_VALS_WEBSAFE.charAt(t)] = t, this.charToByteMapWebSafe_[this.ENCODED_VALS.charAt(t)] = t)
            }
        }
    },
    Py = function(t) {
        return function(t) {
            const e = Iy(t);
            return Ty.encodeByteArray(e, !0)
        }(t).replace(/\./g, "")
    };
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Ly {
    constructor()
    {
        this.reject = () => {},
        this.resolve = () => {},
        this.promise = new Promise(((t, e) => {
            this.resolve = t,
            this.reject = e
        }))
    }
    wrapCallback(t)
    {
        return (e, n) => {
            e ? this.reject(e) : this.resolve(n),
            "function" == typeof t && (this.promise.catch((() => {})), 1 === t.length ? t(e) : t(e, n))
        }
    }
}
/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function Oy() {
    const t = "object" == typeof chrome ? chrome.runtime : "object" == typeof browser ? browser.runtime : void 0;
    return "object" == typeof t && void 0 !== t.id
}
function Ny() {
    return "object" == typeof indexedDB
}
function Ry() {
    return new Promise(((t, e) => {
        try {
            let n = !0;
            const r = "validate-browser-context-for-indexeddb-analytics-module",
                i = self.indexedDB.open(r);
            i.onsuccess = () => {
                i.result.close(),
                n || self.indexedDB.deleteDatabase(r),
                t(!0)
            },
            i.onupgradeneeded = () => {
                n = !1
            },
            i.onerror = () => {
                var t;
                e((null === (t = i.error) || void 0 === t ? void 0 : t.message) || "")
            }
        } catch (t) {
            e(t)
        }
    }))
}
function Ay() {
    return !("undefined" == typeof navigator || !navigator.cookieEnabled)
}
class Fy {
    constructor(t, e, n)
    {
        this.service = t,
        this.serviceName = e,
        this.errors = n
    }
    create(t, ...e)
    {
        const n = e[0] || {},
            r = `${this.service}/${t}`,
            i = this.errors[t],
            o = i ? function(t, e) {
                return t.replace(ky, ((t, n) => {
                    const r = e[n];
                    return null != r ? String(r) : `<${n}?>`
                }))
            }(i, n) : "Error",
            s = `${this.serviceName}: ${o} (${r}).`;
        return new Dy(r, s, n)
    }
}
const ky = /\{\$([^}]+)}/g;
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function jy(t, e) {
    if (t === e)
        return !0;
    const n = Object.keys(t),
        r = Object.keys(e);
    for (const i of n) {
        if (!r.includes(i))
            return !1;
        const n = t[i],
            o = e[i];
        if (Gy(n) && Gy(o)) {
            if (!jy(n, o))
                return !1
        } else if (n !== o)
            return !1
    }
    for (const t of r)
        if (!n.includes(t))
            return !1;
    return !0
}
function Gy(t) {
    return null !== t && "object" == typeof t
}
/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function By(t, e=1e3, n=2) {
    const r = e * Math.pow(n, t),
        i = Math.round(.5 * r * (Math.random() - .5) * 2);
    return Math.min(144e5, r + i)
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function qy(t) {
    return t && t._delegate ? t._delegate : t
}
class zy {
    constructor(t, e, n)
    {
        this.name = t,
        this.instanceFactory = e,
        this.type = n,
        this.multipleInstances = !1,
        this.serviceProps = {},
        this.instantiationMode = "LAZY",
        this.onInstanceCreated = null
    }
    setInstantiationMode(t)
    {
        return this.instantiationMode = t, this
    }
    setMultipleInstances(t)
    {
        return this.multipleInstances = t, this
    }
    setServiceProps(t)
    {
        return this.serviceProps = t, this
    }
    setInstanceCreatedCallback(t)
    {
        return this.onInstanceCreated = t, this
    }
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Uy {
    constructor(t, e)
    {
        this.name = t,
        this.container = e,
        this.component = null,
        this.instances = new Map,
        this.instancesDeferred = new Map,
        this.instancesOptions = new Map,
        this.onInitCallbacks = new Map
    }
    get(t)
    {
        const e = this.normalizeInstanceIdentifier(t);
        if (!this.instancesDeferred.has(e)) {
            const t = new Ly;
            if (this.instancesDeferred.set(e, t), this.isInitialized(e) || this.shouldAutoInitialize())
                try {
                    const n = this.getOrInitializeService({
                        instanceIdentifier: e
                    });
                    n && t.resolve(n)
                } catch (t) {}
        }
        return this.instancesDeferred.get(e).promise
    }
    getImmediate(t)
    {
        var e;
        const n = this.normalizeInstanceIdentifier(null == t ? void 0 : t.identifier),
            r = null !== (e = null == t ? void 0 : t.optional) && void 0 !== e && e;
        if (!this.isInitialized(n) && !this.shouldAutoInitialize()) {
            if (r)
                return null;
            throw Error(`Service ${this.name} is not available`)
        }
        try {
            return this.getOrInitializeService({
                instanceIdentifier: n
            })
        } catch (t) {
            if (r)
                return null;
            throw t
        }
    }
    getComponent()
    {
        return this.component
    }
    setComponent(t)
    {
        if (t.name !== this.name)
            throw Error(`Mismatching Component ${t.name} for Provider ${this.name}.`);
        if (this.component)
            throw Error(`Component for ${this.name} has already been provided`);
        if (this.component = t, this.shouldAutoInitialize()) {
            if (function(t) {
                return "EAGER" === t.instantiationMode
            }















            (/**
             * @license
             * Copyright 2019 Google LLC
             *
             * Licensed under the Apache License, Version 2.0 (the "License");
             * you may not use this file except in compliance with the License.
             * You may obtain a copy of the License at
             *
             *   http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an "AS IS" BASIS,
             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
             * See the License for the specific language governing permissions and
             * limitations under the License.
             */
            t))
                try {
                    this.getOrInitializeService({
                        instanceIdentifier: "[DEFAULT]"
                    })
                } catch (t) {}
            for (const [t, e] of this.instancesDeferred.entries()) {
                const n = this.normalizeInstanceIdentifier(t);
                try {
                    const t = this.getOrInitializeService({
                        instanceIdentifier: n
                    });
                    e.resolve(t)
                } catch (t) {}
            }
        }
    }
    clearInstance(t="[DEFAULT]")
    {
        this.instancesDeferred.delete(t),
        this.instancesOptions.delete(t),
        this.instances.delete(t)
    }
    async delete()
    {
        const t = Array.from(this.instances.values());
        await Promise.all([...t.filter((t => "INTERNAL" in t)).map((t => t.INTERNAL.delete())), ...t.filter((t => "_delete" in t)).map((t => t._delete()))])
    }
    isComponentSet()
    {
        return null != this.component
    }
    isInitialized(t="[DEFAULT]")
    {
        return this.instances.has(t)
    }
    getOptions(t="[DEFAULT]")
    {
        return this.instancesOptions.get(t) || {}
    }
    initialize(t={})
    {
        const {options: e={}} = t,
            n = this.normalizeInstanceIdentifier(t.instanceIdentifier);
        if (this.isInitialized(n))
            throw Error(`${this.name}(${n}) has already been initialized`);
        if (!this.isComponentSet())
            throw Error(`Component ${this.name} has not been registered yet`);
        const r = this.getOrInitializeService({
            instanceIdentifier: n,
            options: e
        });
        for (const [t, e] of this.instancesDeferred.entries()) {
            n === this.normalizeInstanceIdentifier(t) && e.resolve(r)
        }
        return r
    }
    onInit(t, e)
    {
        var n;
        const r = this.normalizeInstanceIdentifier(e),
            i = null !== (n = this.onInitCallbacks.get(r)) && void 0 !== n ? n : new Set;
        i.add(t),
        this.onInitCallbacks.set(r, i);
        const o = this.instances.get(r);
        return o && t(o, r), () => {
            i.delete(t)
        }
    }
    invokeOnInitCallbacks(t, e)
    {
        const n = this.onInitCallbacks.get(e);
        if (n)
            for (const r of n)
                try {
                    r(t, e)
                } catch (t) {}
    }
    getOrInitializeService({instanceIdentifier: t, options: e={}})
    {
        let n = this.instances.get(t);
        if (!n && this.component && (n = this.component.instanceFactory(this.container, {
            instanceIdentifier: (r = t, "[DEFAULT]" === r ? void 0 : r),
            options: e
        }), this.instances.set(t, n), this.instancesOptions.set(t, e), this.invokeOnInitCallbacks(n, t), this.component.onInstanceCreated))
            try {
                this.component.onInstanceCreated(this.container, t, n)
            } catch (t) {}
        var r;
        return n || null
    }
    normalizeInstanceIdentifier(t="[DEFAULT]")
    {
        return this.component ? this.component.multipleInstances ? t : "[DEFAULT]" : t
    }
    shouldAutoInitialize()
    {
        return !!this.component && "EXPLICIT" !== this.component.instantiationMode
    }
}
class Vy {
    constructor(t)
    {
        this.name = t,
        this.providers = new Map
    }
    addComponent(t)
    {
        const e = this.getProvider(t.name);
        if (e.isComponentSet())
            throw new Error(`Component ${t.name} has already been registered with ${this.name}`);
        e.setComponent(t)
    }
    addOrOverwriteComponent(t)
    {
        this.getProvider(t.name).isComponentSet() && this.providers.delete(t.name),
        this.addComponent(t)
    }
    getProvider(t)
    {
        if (this.providers.has(t))
            return this.providers.get(t);
        const e = new Uy(t, this);
        return this.providers.set(t, e), e
    }
    getProviders()
    {
        return Array.from(this.providers.values())
    }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const Xy = [];
var Hy,
    Yy;
(Yy = Hy || (Hy = {}))[Yy.DEBUG = 0] = "DEBUG",
Yy[Yy.VERBOSE = 1] = "VERBOSE",
Yy[Yy.INFO = 2] = "INFO",
Yy[Yy.WARN = 3] = "WARN",
Yy[Yy.ERROR = 4] = "ERROR",
Yy[Yy.SILENT = 5] = "SILENT";
const Wy = {
        debug: Hy.DEBUG,
        verbose: Hy.VERBOSE,
        info: Hy.INFO,
        warn: Hy.WARN,
        error: Hy.ERROR,
        silent: Hy.SILENT
    },
    $y = Hy.INFO,
    Ky = {
        [Hy.DEBUG]: "log",
        [Hy.VERBOSE]: "log",
        [Hy.INFO]: "info",
        [Hy.WARN]: "warn",
        [Hy.ERROR]: "error"
    },
    Zy = (t, e, ...n) => {
        if (e < t.logLevel)
            return;
        const r = (new Date).toISOString(),
            i = Ky[e];
        if (!i)
            throw new Error(`Attempted to log a message with an invalid logType (value: ${e})`);
        console[i](`[${r}]  ${t.name}:`, ...n)
    };
class Jy {
    constructor(t)
    {
        this.name = t,
        this._logLevel = $y,
        this._logHandler = Zy,
        this._userLogHandler = null,
        Xy.push(this)
    }
    get logLevel()
    {
        return this._logLevel
    }
    set logLevel(t)
    {
        if (!(t in Hy))
            throw new TypeError(`Invalid value "${t}" assigned to \`logLevel\``);
        this._logLevel = t
    }
    setLogLevel(t)
    {
        this._logLevel = "string" == typeof t ? Wy[t] : t
    }
    get logHandler()
    {
        return this._logHandler
    }
    set logHandler(t)
    {
        if ("function" != typeof t)
            throw new TypeError("Value assigned to `logHandler` must be a function");
        this._logHandler = t
    }
    get userLogHandler()
    {
        return this._userLogHandler
    }
    set userLogHandler(t)
    {
        this._userLogHandler = t
    }
    debug(...t)
    {
        this._userLogHandler && this._userLogHandler(this, Hy.DEBUG, ...t),
        this._logHandler(this, Hy.DEBUG, ...t)
    }
    log(...t)
    {
        this._userLogHandler && this._userLogHandler(this, Hy.VERBOSE, ...t),
        this._logHandler(this, Hy.VERBOSE, ...t)
    }
    info(...t)
    {
        this._userLogHandler && this._userLogHandler(this, Hy.INFO, ...t),
        this._logHandler(this, Hy.INFO, ...t)
    }
    warn(...t)
    {
        this._userLogHandler && this._userLogHandler(this, Hy.WARN, ...t),
        this._logHandler(this, Hy.WARN, ...t)
    }
    error(...t)
    {
        this._userLogHandler && this._userLogHandler(this, Hy.ERROR, ...t),
        this._logHandler(this, Hy.ERROR, ...t)
    }
}
let Qy,
    tv;
const ev = new WeakMap,
    nv = new WeakMap,
    rv = new WeakMap,
    iv = new WeakMap,
    ov = new WeakMap;
let sv = {
    get(t, e, n) {
        if (t instanceof IDBTransaction) {
            if ("done" === e)
                return nv.get(t);
            if ("objectStoreNames" === e)
                return t.objectStoreNames || rv.get(t);
            if ("store" === e)
                return n.objectStoreNames[1] ? void 0 : n.objectStore(n.objectStoreNames[0])
        }
        return lv(t[e])
    },
    set: (t, e, n) => (t[e] = n, !0),
    has: (t, e) => t instanceof IDBTransaction && ("done" === e || "store" === e) || e in t
};
function av(t) {
    return t !== IDBDatabase.prototype.transaction || "objectStoreNames" in IDBTransaction.prototype ? (tv || (tv = [IDBCursor.prototype.advance, IDBCursor.prototype.continue, IDBCursor.prototype.continuePrimaryKey])).includes(t) ? function(...e) {
        return t.apply(hv(this), e), lv(ev.get(this))
    } : function(...e) {
        return lv(t.apply(hv(this), e))
    } : function(e, ...n) {
        const r = t.call(hv(this), e, ...n);
        return rv.set(r, e.sort ? e.sort() : [e]), lv(r)
    }
}
function uv(t) {
    return "function" == typeof t ? av(t) : (t instanceof IDBTransaction && function(t) {
        if (nv.has(t))
            return;
        const e = new Promise(((e, n) => {
            const r = () => {
                    t.removeEventListener("complete", i),
                    t.removeEventListener("error", o),
                    t.removeEventListener("abort", o)
                },
                i = () => {
                    e(),
                    r()
                },
                o = () => {
                    n(t.error || new DOMException("AbortError", "AbortError")),
                    r()
                };
            t.addEventListener("complete", i),
            t.addEventListener("error", o),
            t.addEventListener("abort", o)
        }));
        nv.set(t, e)
    }(t), e = t, (Qy || (Qy = [IDBDatabase, IDBObjectStore, IDBIndex, IDBCursor, IDBTransaction])).some((t => e instanceof t)) ? new Proxy(t, sv) : t);
    var e
}
function lv(t) {
    if (t instanceof IDBRequest)
        return function(t) {
            const e = new Promise(((e, n) => {
                const r = () => {
                        t.removeEventListener("success", i),
                        t.removeEventListener("error", o)
                    },
                    i = () => {
                        e(lv(t.result)),
                        r()
                    },
                    o = () => {
                        n(t.error),
                        r()
                    };
                t.addEventListener("success", i),
                t.addEventListener("error", o)
            }));
            return e.then((e => {
                e instanceof IDBCursor && ev.set(e, t)
            })).catch((() => {})), ov.set(e, t), e
        }(t);
    if (iv.has(t))
        return iv.get(t);
    const e = uv(t);
    return e !== t && (iv.set(t, e), ov.set(e, t)), e
}
const hv = t => ov.get(t);
function cv(t, e, {blocked: n, upgrade: r, blocking: i, terminated: o}={}) {
    const s = indexedDB.open(t, e),
        a = lv(s);
    return r && s.addEventListener("upgradeneeded", (t => {
        r(lv(s.result), t.oldVersion, t.newVersion, lv(s.transaction))
    })), n && s.addEventListener("blocked", (() => n())), a.then((t => {
        o && t.addEventListener("close", (() => o())),
        i && t.addEventListener("versionchange", (() => i()))
    })).catch((() => {})), a
}
const pv = ["get", "getKey", "getAll", "getAllKeys", "count"],
    fv = ["put", "add", "delete", "clear"],
    dv = new Map;
function gv(t, e) {
    if (!(t instanceof IDBDatabase) || e in t || "string" != typeof e)
        return;
    if (dv.get(e))
        return dv.get(e);
    const n = e.replace(/FromIndex$/, ""),
        r = e !== n,
        i = fv.includes(n);
    if (!(n in (r ? IDBIndex : IDBObjectStore).prototype) || !i && !pv.includes(n))
        return;
    const o = async function(t, ...e) {
        const o = this.transaction(t, i ? "readwrite" : "readonly");
        let s = o.store;
        return r && (s = s.index(e.shift())), (await Promise.all([s[n](...e), i && o.done]))[0]
    };
    return dv.set(e, o), o
}
sv = (t => ({
    ...t,
    get: (e, n, r) => gv(e, n) || t.get(e, n, r),
    has: (e, n) => !!gv(e, n) || t.has(e, n)
}))(sv);


onload = async function() {
    function t(t, e, n, r) {
        this.sensorWidth = t,
        this.focalLength = e,
        this.imageWidth = n,
        this.imageHeight = r
    }
    let n,
        r,
        i,
        s,
        a,
        u,
        l = new t(6.17, 4.49, 4e3, 3e3),
        h = 0,
        c = 1,
        p = !1,
        f = "DJI Mini 2",
        d = null,
        g = null,
        y = 0,
        v = 3e3,
        m = 0,
        _ = 700,
        x = 400,
        E = 30,
        w = l.sensorWidth,
        b = l.focalLength,
        C = l.imageWidth,
        M = l.imageHeight,
        S = v / 1e3 * M / 100,
        I = S * (1 - x / 1e3),
        T = -90,
        P = 0,
        L = 1;
    const O = o("hEixu"),
        N = o("9eDez").default;
    let R = !1;
    function A() {
        R ? (R = !1, Dt.removeLayer(Et), Dt.addLayer(wt)) : (R = !0, Dt.removeLayer(wt), Dt.addLayer(Et))
    }
    function D(t, e, n) {
        let r = t / 1e3 * (e / 100) * (1 - n / 1e3);
        return O.lengthToDegrees(r, "metres")
    }
    function F(t) {
        let e = t.features.length,
            n = O.featureCollection([]),
            r = O.featureCollection([]);
        S = v / 1e3 * M / 100,
        I = S * (1 - x / 1e3);
        for (let i = 0; i < t.features.length; i++) {
            let o = 0,
                s = O.length(t.features[i], {
                    units: "metres"
                });
            if (s > I) {
                for (let a = 0; a < s - .6; a += I) {
                    let s = O.along(t.features[i], a, {
                        units: "metres"
                    });
                    if (n.features.push(s), o % c == 0 && 0 !== c) {
                        let e = O.along(t.features[i], a, {
                            units: "metres"
                        });
                        r.features.push(e)
                    }
                    o++,
                    e++
                }
                let a = O.along(t.features[i], s, {
                    units: "metres"
                });
                r.features.push(a),
                n.features.push(a)
            } else {
                let e = O.along(t.features[i], 0, {
                    units: "metres"
                });
                n.features.push(e),
                r.features.push(e);
                let o = O.along(t.features[i], s, {
                    units: "metres"
                });
                r.features.push(o),
                n.features.push(o)
            }
        }
        return le.innerHTML = `📷: ~${e}, (${parseFloat(I).toFixed(2)}m/${parseFloat(3.28084 * I).toFixed(2)}ft)`, [n, r]
    }
    let k = D(v, C, _);
    function j(t, e, n, r) {
        return t / 1e3 / (e / (n * r)) / 100
    }
    let G = j(v, l.sensorWidth, l.focalLength, l.imageWidth);
    function B() {
        let t;
        if (d && i) {
            t = 0 != c ? F(i)[1] : F(i)[0];
            let n = function(t, e) {
                    if (gt && d) {
                        let n = `latitude;longitude;altitude(m);heading(deg);curvesize(m);rotationdir;gimbalmode;gimbalpitchangle;actiontype1;actionparam1;actiontype2;actionparam2;actiontype3;actionparam3;actiontype4;actionparam4;actiontype5;actionparam5;actiontype6;actionparam6;actiontype7;actionparam7;actiontype8;actionparam8;actiontype9;actionparam9;actiontype10;actionparam10;actiontype11;actionparam11;actiontype12;actionparam12;actiontype13;actionparam13;actiontype14;actionparam14;actiontype15;actionparam15;altitudemode;speed(m/s);poi_latitude;poi_longitude;poi_altitude(m);poi_altitudemode;photo_timeinterval;photo_distinterval\n${t.geometry.coordinates[1]};${t.geometry.coordinates[0]};${G.toFixed(4)};${r};0.2;0;0;${T};5;${T};-1;0;-1;0;-1;0;-1;0;-1;0;-1;0;-1;0;-1;0;-1;0;-1;0;-1;0;-1;0;-1;0;-1;0;1;0;0;0;0;0;-1;-1\n`,
                            i = Math.round(O.bearing([e.features[0].geometry.coordinates[0], e.features[0].geometry.coordinates[1]], [e.features[1].geometry.coordinates[0], e.features[1].geometry.coordinates[1]]) + 360) % 360,
                            o = Math.round(O.bearing([e.features[e.features.length - 2].geometry.coordinates[0], e.features[e.features.length - 2].geometry.coordinates[1]], [e.features[e.features.length - 1].geometry.coordinates[0], e.features[e.features.length - 1].geometry.coordinates[1]]) + 360) % 360;
                        for (let t = 0; t < e.features.length; t++) {
                            let r = O.point(e.features[t].geometry.coordinates);
                            if (t + 1 < e.features.length) {
                                let o = parseInt(Math.round(O.bearing([e.features[t].geometry.coordinates[0], e.features[t].geometry.coordinates[1]], [e.features[t + 1].geometry.coordinates[0], e.features[t + 1].geometry.coordinates[1]]) + 360) % 360);
                                if (o % 360 == i)
                                    1 == c ? n += `${r.geometry.coordinates[1]};${r.geometry.coordinates[0]};${G.toFixed(4)};${o};0.2;0;0;${T};5;${T};1;0;-1;0;-1;0;-1;0;-1;0;-1;0;-1;0;-1;0;-1;0;-1;0;-1;0;-1;0;-1;0;-1;0;1;${E / 10};0;0;0;0;-1;-1\n` : f.indexOf("Phantom") > -1 ? n += `${r.geometry.coordinates[1]};${r.geometry.coordinates[0]};${G.toFixed(4)};${o};0.2;0;0;${T};5;${T};1;0;-1;0;-1;0;-1;0;-1;0;-1;0;-1;0;-1;0;-1;0;-1;0;-1;0;-1;0;-1;0;-1;0;1;${E / 10};0;0;0;0;${parseFloat((I / (E / 10)).toFixed(2))};-1\n` : n += `${r.geometry.coordinates[1]};${r.geometry.coordinates[0]};${G.toFixed(4)};${o};0.2;0;0;${T};5;${T};1;0;-1;0;-1;0;-1;0;-1;0;-1;0;-1;0;-1;0;-1;0;-1;0;-1;0;-1;0;-1;0;-1;0;1;${E / 10};0;0;0;0;-1;${I}\n`;
                                else {
                                    let s = parseInt(Math.round(O.bearing([e.features[t - 1].geometry.coordinates[0], e.features[t - 1].geometry.coordinates[1]], [e.features[t].geometry.coordinates[0], e.features[t].geometry.coordinates[1]]) + 360) % 360),
                                        a = parseInt(Math.round(O.bearing([e.features[0].geometry.coordinates[0], e.features[0].geometry.coordinates[1]], [e.features[1].geometry.coordinates[0], e.features[1].geometry.coordinates[1]]) + 180) % 360);
                                    s == i ? n += `${r.geometry.coordinates[1]};${r.geometry.coordinates[0]};${G.toFixed(4)};${i};0.2;0;0;${T};5;${T};1;0;-1;0;-1;0;-1;0;-1;0;-1;0;-1;0;-1;0;-1;0;-1;0;-1;0;-1;0;-1;0;-1;0;1;${E / 10};0;0;0;0;-1;-1\n` : 1 == c ? n += 1 == L ? `${r.geometry.coordinates[1]};${r.geometry.coordinates[0]};${G.toFixed(4)};${a};0.2;0;0;${T};5;${T};1;0;-1;0;-1;0;-1;0;-1;0;-1;0;-1;0;-1;0;-1;0;-1;0;-1;0;-1;0;-1;0;-1;0;1;${E / 10};0;0;0;0;-1;-1\n` : `${r.geometry.coordinates[1]};${r.geometry.coordinates[0]};${G.toFixed(4)};${i};0.2;0;0;${T};5;${T};1;0;-1;0;-1;0;-1;0;-1;0;-1;0;-1;0;-1;0;-1;0;-1;0;-1;0;-1;0;-1;0;-1;0;1;${E / 10};0;0;0;0;-1;-1\n` : f.indexOf("Phantom") > -1 ? n += o != a ? 1 == L ? `${r.geometry.coordinates[1]};${r.geometry.coordinates[0]};${G.toFixed(4)};${a};0.2;0;0;${T};5;${T};1;0;-1;0;-1;0;-1;0;-1;0;-1;0;-1;0;-1;0;-1;0;-1;0;-1;0;-1;0;-1;0;-1;0;1;${E / 10};0;0;0;0;-1;-1\n` : `${r.geometry.coordinates[1]};${r.geometry.coordinates[0]};${G.toFixed(4)};${i};0.2;0;0;${T};5;${T};1;0;-1;0;-1;0;-1;0;-1;0;-1;0;-1;0;-1;0;-1;0;-1;0;-1;0;-1;0;-1;0;-1;0;1;${E / 10};0;0;0;0;-1;-1\n` : 1 == L ? `${r.geometry.coordinates[1]};${r.geometry.coordinates[0]};${G.toFixed(4)};${a};0.2;0;0;${T};5;${T};1;0;-1;0;-1;0;-1;0;-1;0;-1;0;-1;0;-1;0;-1;0;-1;0;-1;0;-1;0;-1;0;-1;0;1;${E / 10};0;0;0;0;${parseFloat((I / (E / 10)).toFixed(2))};-1\n` : `${r.geometry.coordinates[1]};${r.geometry.coordinates[0]};${G.toFixed(4)};${i};0.2;0;0;${T};5;${T};1;0;-1;0;-1;0;-1;0;-1;0;-1;0;-1;0;-1;0;-1;0;-1;0;-1;0;-1;0;-1;0;-1;0;1;${E / 10};0;0;0;0;${parseFloat((I / (E / 10)).toFixed(2))};-1\n` : n += o != a ? 1 == L ? `${r.geometry.coordinates[1]};${r.geometry.coordinates[0]};${G.toFixed(4)};${a};0.2;0;0;${T};5;${T};1;0;-1;0;-1;0;-1;0;-1;0;-1;0;-1;0;-1;0;-1;0;-1;0;-1;0;-1;0;-1;0;-1;0;1;${E / 10};0;0;0;0;-1;-1\n` : `${r.geometry.coordinates[1]};${r.geometry.coordinates[0]};${G.toFixed(4)};${i};0.2;0;0;${T};5;${T};1;0;-1;0;-1;0;-1;0;-1;0;-1;0;-1;0;-1;0;-1;0;-1;0;-1;0;-1;0;-1;0;-1;0;1;${E / 10};0;0;0;0;-1;-1\n` : 1 == L ? `${r.geometry.coordinates[1]};${r.geometry.coordinates[0]};${G.toFixed(4)};${a};0.2;0;0;${T};5;${T};1;0;-1;0;-1;0;-1;0;-1;0;-1;0;-1;0;-1;0;-1;0;-1;0;-1;0;-1;0;-1;0;-1;0;1;${E / 10};0;0;0;0;-1;${I}\n` : `${r.geometry.coordinates[1]};${r.geometry.coordinates[0]};${G.toFixed(4)};${i};0.2;0;0;${T};5;${T};1;0;-1;0;-1;0;-1;0;-1;0;-1;0;-1;0;-1;0;-1;0;-1;0;-1;0;-1;0;-1;0;-1;0;1;${E / 10};0;0;0;0;-1;${I}\n`
                                }
                            } else
                                n += 1 == L ? `${r.geometry.coordinates[1]};${r.geometry.coordinates[0]};${G.toFixed(4)};${o};0.2;0;0;${T};5;${T};1;0;5;0;-1;0;-1;0;-1;0;-1;0;-1;0;-1;0;-1;0;-1;0;-1;0;-1;0;-1;0;-1;0;1;0;0;0;0;0;-1;-1\n` : `${r.geometry.coordinates[1]};${r.geometry.coordinates[0]};${G.toFixed(4)};${i};0.2;0;0;${T};5;${T};1;0;5;0;-1;0;-1;0;-1;0;-1;0;-1;0;-1;0;-1;0;-1;0;-1;0;-1;0;-1;0;-1;0;1;0;0;0;0;0;-1;-1\n`
                        }
                        return n
                    }
                }(g, t),
                o = new Date,
                s = `LitchiMission${["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"][o.getMonth()] + o.getDate()}.csv`,
                a = new Blob([n], {
                    type: "text/plain;charset=utf-8"
                });
            e(vp)(a, s)
        } else
            alert("Please draw a home point and an area of interest")
    }
    const q = new (0, Jl.default)({
            features: [],
            useSpatialIndex: !1
        }),
        z = new (0, Ka.default)({
            source: null,
            style: new yu({
                image: new (0, Qa.default)({
                    radius: 4,
                    fill: new uu({
                        color: "rgba(255, 128, 0, 1)"
                    }),
                    stroke: new lu({
                        color: "rgba(0, 0, 0, 0.5)",
                        width: 2
                    })
                })
            }),
            zIndex: 115
        }),
        U = new (0, Jl.default)({
            features: [],
            useSpatialIndex: !1
        }),
        V = new (0, Ka.default)({
            source: null,
            style: new yu({
                image: new (0, Qa.default)({
                    radius: 2.5,
                    fill: new uu({
                        color: "rgba(255, 255, 0, 0.8)"
                    })
                })
            }),
            zIndex: 100
        }),
        X = new (0, Jl.default)({
            features: [],
            useSpatialIndex: !1
        }),
        H = new (0, Ka.default)({
            source: null,
            style: new yu({
                stroke: new lu({
                    color: "rgba(0, 200, 0, 0.8)",
                    width: 3
                })
            }),
            zIndex: 115
        }),
        Y = new (0, Jl.default)({
            features: [],
            useSpatialIndex: !1
        }),
        W = new (0, Ka.default)({
            source: null,
            style: new yu({
                stroke: new lu({
                    color: "rgba(255, 255, 0, 0.8)",
                    width: 2
                })
            }),
            zIndex: 109
        }),
        $ = new (0, Ka.default)({
            source: null,
            style: new yu({
                image: new (0, Qa.default)({
                    radius: 3,
                    fill: new uu({
                        color: "rgba(255, 255, 255, 0.8)"
                    })
                }),
                fill: new uu({
                    color: "rgba(0, 0, 0, 0.15)"
                }),
                stroke: new lu({
                    color: "rgba(255, 0, 255, 0.3)",
                    width: 3
                })
            }),
            zIndex: 110
        }),
        K = new (0, Ka.default)({
            source: null,
            style: new yu({
                image: new (0, Qa.default)({
                    radius: 7,
                    fill: new uu({
                        color: "rgba(0, 255, 0, 0.7)"
                    }),
                    stroke: new lu({
                        color: "rgba(0, 0, 0, 0.7)",
                        width: 2
                    })
                })
            }),
            zIndex: 120
        }),
        J = new (0, Jl.default)({
            features: [],
            useSpatialIndex: !1
        }),
        Q = new (0, Jl.default)({
            features: [],
            useSpatialIndex: !1
        }),
        tt = new (0, Ka.default)({
            source: null,
            zIndex: 103,
            style: new yu({
                image: new (0, Qa.default)({
                    radius: 5.5,
                    fill: new uu({
                        color: "rgba(255, 0, 255, 0.50)"
                    }),
                    stroke: new lu({
                        color: "rgba(255, 0, 255, 1)"
                    })
                })
            })
        }),
        et = new (0, Jl.default)({
            features: [],
            useSpatialIndex: !1
        }),
        rt = new (0, Ka.default)({
            source: null,
            style: new yu({
                image: new (0, Qa.default)({
                    radius: 9,
                    fill: new uu({
                        color: "rgba(255, 128, 0, 1)"
                    }),
                    stroke: new lu({
                        color: "rgba(0, 0, 0, 1)",
                        width: 2
                    })
                })
            }),
            zIndex: 120
        }),
        it = new (0, Jl.default)({
            features: [],
            useSpatialIndex: !1
        }),
        ot = new (0, Ka.default)({
            source: null,
            style: new yu({
                image: new (0, Qa.default)({
                    radius: 9,
                    fill: new uu({
                        color: "rgba(255, 0, 0, 0.8)"
                    }),
                    stroke: new lu({
                        color: "rgba(0, 0, 0, 1)",
                        width: 2
                    })
                })
            }),
            zIndex: 117
        }),
        st = new (0, Jl.default)({
            features: [],
            useSpatialIndex: !1
        }),
        at = (new (0, Ka.default)({
            source: null,
            style: new yu({
                stroke: new lu({
                    color: "rgba(255, 0, 0, 0.7)",
                    width: 2
                }),
                fill: new uu({
                    color: "rgba(0, 0, 0, 0.2)"
                })
            })
        }), new (0, Jl.default)({
            features: [],
            useSpatialIndex: !1
        }), new (0, Ka.default)({
            source: null,
            style: new yu({
                stroke: new lu({
                    color: "rgba(0, 80, 0, 0.4)",
                    width: 2
                }),
                fill: new uu({
                    color: "rgba(0, 80, 0, 0.15)"
                })
            })
        })),
        ut = new (0, Jl.default)({
            features: [],
            projection: "EPSG:4326",
            useSpatialIndex: !1
        }),
        lt = new (0, Ka.default)({
            source: null,
            fill: new uu({
                color: "rgba(0, 0, 0, 0.2)"
            }),
            style: new yu({
                image: new (0, Qa.default)({
                    radius: 4,
                    fill: new uu({
                        color: "rgba(0, 0, 0, 0.6)"
                    })
                }),
                stroke: new lu({
                    color: "rgba(0, 0, 0, 0.7)",
                    width: 1
                })
            }),
            zIndex: 118
        }),
        ht = new (0, Jl.default)({
            features: null,
            useSpatialIndex: !1
        }),
        ct = new (0, Ka.default)({
            source: null,
            style: new yu({
                stroke: new lu({
                    color: "rgba(255, 255, 0, 0.7)",
                    width: 2
                })
            }),
            zIndex: 6
        }),
        pt = new (0, Jl.default)({
            features: null,
            useSpatialIndex: !1
        }),
        ft = new (0, Ka.default)({
            source: null,
            zIndex: 108
        }),
        dt = new (0, Jl.default)({
            features: null,
            useSpatialIndex: !1
        });
    let gt;
    function yt() {
        Dt.removeLayer($),
        Dt.removeLayer(tt),
        Q.clear(),
        et.clear();
        let t = O.toMercator(gt),
            e = (O.explode(gt), O.explode(O.toMercator(gt)));
        Q.addFeatures((new (0, gg.default)).readFeatures(t)),
        $.setSource(Q),
        et.addFeatures((new (0, gg.default)).readFeatures(e)),
        tt.setSource(et),
        Dt.addLayer($),
        Dt.addLayer(tt),
        ge(y, l)
    }
    function vt() {
        Dt.removeLayer(K),
        J.clear(),
        J.addFeature((new (0, gg.default)).readFeature(d)),
        K.setSource(J),
        Dt.addLayer(K)
    }
    function mt(t) {
        let e = [];
        return e.push(t[0] - 2 * (t[2] - t[0])), e.push(t[1] - 2 * (t[3] - t[1])), e.push(t[2] + 2 * (t[2] - t[0])), e.push(t[3] + 2 * (t[3] - t[1])), e
    }
    function _t() {
        bt.clear(),
        Dt.removeLayer($),
        Dt.removeLayer(tt),
        Q.clear(),
        et.clear(),
        gt = [];
        let t = [];
        bt.clear();
        let e = new (0, Ia.default)({
                source: bt,
                type: "Polygon",
                geometryName: "poly"
            }),
            n = new (0, kh.default)({
                source: bt,
                vertex: !0,
                edge: !1,
                pixelTolerance: 20
            });
        e.on("drawend", (function(t) {
            bt.clear(),
            Dt.removeInteraction(e),
            Dt.removeInteraction(n),
            p = !1
        })),
        St.on("modifyend", (function(t) {
            const e = t.features.getArray()[0].getGeometry().getCoordinates()[0];
            gt = O.toWgs84(O.polygon([e])),
            s = O.toMercator(gt),
            O.area(gt) > 5e6 ? (alert("Area too large. Please draw a smaller area."), bt.clear(), gt = []) : (yt(), ge(y, l), u = parseFloat(O.area(gt) / 1e4), a = parseFloat(2.47105 * u), he.innerHTML = `🔳: ${a.toFixed(1)}ac | ${u.toFixed(1)}ha`),
            p = !1
        })),
        e.on("drawend", (function(e) {
            for (let n = 0; n < e.feature.getGeometry().getCoordinates()[0].length; n++)
                t.push(e.feature.getGeometry().getCoordinates()[0][n]);
            if (gt = O.toWgs84(O.polygon([t])), !(O.area(gt) > 5e6))
                return yt(), p = !1, u = parseFloat(O.area(gt) / 1e4), a = parseFloat(2.47105 * u), he.innerHTML = `🔳: ${a.toFixed(1)}ac | ${u.toFixed(1)}ha`, t;
            alert("Area too large. Please draw a smaller area."),
            gt = [],
            t = [],
            bt.clear(),
            p = !1
        })),
        !1 === p && (Dt.addInteraction(e), Dt.addInteraction(n))
    }
    function xt() {
        J.clear();
        let t = new (0, Ia.default)({
                source: J,
                type: "Point",
                geometryName: "homePoint"
            }),
            e = new (0, kh.default)({
                source: J,
                vertex: !0,
                pixelTolerance: 20
            });
        t.on("drawend", (function(n) {
            d = O.point(n.feature.getGeometry().getCoordinates()),
            g = O.toWgs84(d),
            Dt.removeInteraction(t),
            Dt.removeInteraction(e),
            vt(),
            gt && ge(y, l)
        })),
        Dt.addInteraction(t),
        Dt.addInteraction(e),
        It.on("modifyend", (function(t) {
            const e = t.features.getArray()[0].getGeometry().getCoordinates();
            d = O.point(e),
            g = O.toWgs84(d),
            vt(),
            null != gt && (ge(y, l), ae.innerHTML = `📐: ${((h + n) / 1e3).toPrecision(3)}km | ${(.00062137141096 * (h + n)).toPrecision(3)}mi`, ue.innerHTML = `🕓 > ${Math.ceil((h + n) / (E / 10) / 60 * 1.5) + 2}min`)
        })),
        Dt.addInteraction(t),
        Dt.addInteraction(e)
    }
    const Et = new (0, np.default)({
            source: new (0, Yh.default)({
                tileSize: [512, 512],
                url: "https://api.mapbox.com/v4/mapbox.satellite/{z}/{x}/{y}@2x.jpg90?access_token=pk.eyJ1IjoiZmxvcGFzZW4iLCJhIjoiY2twYzdxOTl6MHdmdzJwcDlxNDh6YW0zcCJ9.BF89YFRpuaCEbbTkijdu0w",
                transition: 0
            }),
            zIndex: 0
        }),
        wt = new (0, np.default)({
            source: new (0, Hh.default),
            zIndex: 0,
            transition: 0
        }),
        bt = new (0, Jl.default),
        Ct = new (0, Ka.default)({
            source: bt,
            style: new yu({
                fill: new uu({
                    color: "rgba(0, 180, 0, 0.0)"
                }),
                stroke: new lu({
                    color: "rgba(255, 255, 255, 0.4)",
                    width: 2
                })
            }),
            zIndex: 100
        }),
        Mt = ln("EPSG:3857").getExtent().slice();
    Mt[0] = -21039383.757,
    Mt[2] = 21039383.757;
    const St = new (0, Mh.default)({
            source: bt,
            insertVertexCondition: function() {
                return !1
            }
        }),
        It = new (0, Mh.default)({
            source: J,
            insertVertexCondition: function() {
                return !1
            }
        }),
        Tt = new class  extends ss.default{
            constructor(t)
            {
                const e = t || {},
                    n = document.createElement("button");
                n.innerHTML = "&#127919",
                n.title = "Draw Polygon";
                const r = document.createElement("div");
                r.className = "draw ol-selectable ol-control",
                r.appendChild(n),
                super({
                    element: r,
                    target: e.target
                }),
                n.addEventListener("click", (() => {
                    p = !1
                }), !1),
                n.addEventListener("click", _t, !0)
            }
        }
        ,
        Pt = new class  extends ss.default{
            constructor(t)
            {
                const e = t || {},
                    n = document.createElement("button");
                n.innerHTML = "🗺️",
                n.title = "Satellite Imagery";
                const r = document.createElement("div");
                r.className = "satellite ol-selectable ol-control",
                r.appendChild(n),
                super({
                    element: r,
                    target: e.target
                }),
                n.addEventListener("click", A, !1)
            }
        }
        ,
        Lt = new class  extends ss.default{
            constructor(t)
            {
                const e = t || {},
                    n = document.createElement("button");
                n.innerHTML = "&#127968",
                n.title = "Set Home Point";
                const r = document.createElement("div");
                r.className = "set-home-point ol-selectable ol-control",
                r.appendChild(n),
                super({
                    element: r,
                    target: e.target
                }),
                n.addEventListener("click", xt, !0)
            }
        }
        ,
        Ot = new class  extends ss.default{
            constructor(t)
            {
                const e = t || {},
                    n = document.createElement("button");
                n.innerHTML = "&#128190",
                n.title = "Export to Litchi";
                const r = document.createElement("div");
                r.className = "export-to-litchi ol-selectable ol-control",
                r.appendChild(n),
                super({
                    element: r,
                    target: e.target
                }),
                n.addEventListener("click", B, !0)
            }
        }
        ,
        Nt = new class  extends ss.default{
            constructor(t)
            {
                const e = t || {},
                    n = document.createElement("button");
                n.innerHTML = "🛰️",
                n.title = "Geolocate";
                const r = document.createElement("div");
                r.className = "geolocate ol-selectable ol-control",
                r.appendChild(n),
                super({
                    element: r,
                    target: e.target
                }),
                n.addEventListener("click", (function() {
                    !function() {
                        const t = new (0, nt.default)({
                            tracking: !0,
                            trackingOptions: {
                                enableHighAccuracy: !0
                            },
                            projection: Dt.getView().getProjection()
                        });
                        t.on("change", (async function(e) {
                            const n = t.getPosition();
                            Dt.getView().animate({
                                center: n,
                                zoom: 18,
                                duration: 1e3
                            }),
                            t.setTracking(!1)
                        }))
                    }()
                }), !0)
            }
        }
        ,
        Rt = new class  extends ss.default{
            constructor(t)
            {
                const e = t || {},
                    n = document.createElement("button");
                n.innerHTML = "🌚",
                n.title = "See Photo Footprints";
                const r = document.createElement("div");
                r.className = "photo-layer ol-selectable ol-control",
                r.appendChild(n),
                super({
                    element: r,
                    target: e.target
                }),
                n.addEventListener("click", (function() {
                    1 == P ? (P = 0, Dt.removeLayer(ft), document.querySelector("#map > div > div.ol-overlaycontainer-stopevent > div.photo-layer.ol-selectable.ol-control > button").innerHTML = "🌚") : (P = 1, Dt.removeLayer(ft), Dt.addLayer(ft), document.querySelector("#map > div > div.ol-overlaycontainer-stopevent > div.photo-layer.ol-selectable.ol-control > button").innerHTML = "🌝")
                }), !0)
            }
        }
        ,
        At = new class  extends ss.default{
            constructor(t)
            {
                const e = t || {},
                    n = document.createElement("button");
                n.innerHTML = "🔃",
                n.title = "Alternate Directions";
                const r = document.createElement("div");
                r.className = "direction ol-selectable ol-control",
                r.appendChild(n),
                super({
                    element: r,
                    target: e.target
                }),
                n.addEventListener("click", (function() {
                    1 == L ? (L = 0, document.querySelector("#map > div > div.ol-overlaycontainer-stopevent > div.direction.ol-selectable.ol-control > button").innerHTML = "⬆️", gt && ge(y, l)) : (L = 1, document.querySelector("#map > div > div.ol-overlaycontainer-stopevent > div.direction.ol-selectable.ol-control > button").innerHTML = "🔃", gt && ge(y, l))
                }), !0)
            }
        }
        ,
        Dt = new (0, Zr.default)({
            layers: [wt, Ct],
            target: "map",
            theme: null,
            view: new (0, Io.default)({
                zoom: 1,
                center: [0, 0],
                extent: Mt,
                maxZoom: 22
            })
        });
    let Ft = document.createElement("input");
    Ft.setAttribute("type", "text"),
    Ft.setAttribute("placeholder", "Search for a location"),
    Ft.setAttribute("id", "searchBox");
    let kt = document.createElement("button");
    kt.setAttribute("id", "searchButton"),
    kt.innerHTML = "🔍",
    Dt.getViewport().appendChild(Ft),
    Dt.getViewport().appendChild(kt);
    let jt = new (0, Jl.default),
        Gt = new (0, Ka.default)({
            source: jt,
            style: new yu({
                image: new (0, Qa.default)({
                    radius: 10,
                    fill: new uu({
                        color: "rgba(255, 255, 255, 0.5)"
                    }),
                    stroke: new lu({
                        color: "rgba(0, 0, 0, 0.5)"
                    })
                })
            }),
            zIndex: 90
        });
    kt.addEventListener("click", (function() {
        ce.getVisible() && ce.toggle(),
        jt.clear(),
        Dt.removeLayer(Gt);
        let t = Ft.value;
        fetch("https://api.mapbox.com/geocoding/v5/mapbox.places/" + t + ".json?access_token=pk.eyJ1IjoiZmxvcGFzZW4iLCJhIjoiY2twYzdxeTVvMDFsYzJvdDZ5dG0zb3ZmbSJ9.dxikkLvuG7e-0F-wfET_Yg").then((t => t.json())).then((t => {
            let e = t.features,
                n = document.createElement("ul");
            n.setAttribute("id", "resultsList"),
            Dt.getViewport().appendChild(n);
            for (let t = 0; t < e.length; t++) {
                let r = e[t],
                    i = document.createElement("li");
                i.setAttribute("class", "resultItem"),
                i.innerHTML = r.place_name,
                n.appendChild(i),
                i.addEventListener("click", (function() {
                    let t = O.toMercator(r.center);
                    Dt.getView().setCenter(t),
                    Dt.getView().setZoom(20);
                    let e = new (0, Z.default)({
                        geometry: new (0, hr.default)(t)
                    });
                    jt.addFeature(e),
                    Dt.addLayer(Gt),
                    n.remove()
                }))
            }
        }))
    })),
    document.addEventListener("click", (function(t) {
        let e = document.getElementById("resultsList");
        e && (e.contains(t.target) || e.remove())
    }));
    const Bt = new class  extends ss.default{
            constructor(t)
            {
                const e = t || {},
                    n = document.createElement("input");
                n.type = "range",
                n.min = "0",
                n.max = "359",
                n.value = "0",
                n.step = "1",
                n.className = "slider",
                super({
                    element: n,
                    target: e.target
                }),
                n.addEventListener("input", (async function() {
                    gt && await ge(parseInt(n.value, 10))
                }), !0),
                n.addEventListener("input", (function() {
                    y = parseInt(n.value, 10)
                }), !0),
                n.addEventListener("input", (function() {
                    $t.innerHTML = `<span>Direction: ${n.value}°</span>`
                }), !0)
            }
        }
        ,
        qt = new class  extends ss.default{
            constructor(t)
            {
                const e = t || {},
                    n = document.createElement("input");
                n.type = "range",
                n.min = "100",
                n.max = "15000",
                n.value = "3000",
                n.step = "100",
                n.className = "gsdslider",
                super({
                    element: n,
                    target: e.target
                }),
                n.addEventListener("input", (function() {
                    v = parseInt(n.value)
                }), !0),
                n.addEventListener("input", (function() {
                    G = j(v, l.sensorWidth, l.focalLength, l.imageWidth)
                }), !0),
                n.addEventListener("input", (async function() {
                    gt && (k = D(v, C, _))
                }), !0),
                n.addEventListener("input", (function() {
                    I = O.convertLength(D(v, M, x), "degrees", "meters")
                }), !0),
                n.addEventListener("input", (async function() {
                    gt && await ge(y, l)
                }), !0),
                n.addEventListener("input", (function() {
                    Kt.innerHTML = `<span>GSD: ${v / 1e3} : ${G.toPrecision(3)}m : ${(3.28084 * G).toPrecision(3)}ft</span>`
                }), !0)
            }
        }
        ,
        zt = new class  extends ss.default{
            constructor(t)
            {
                const e = t || {},
                    n = document.createElement("input");
                n.type = "range",
                n.min = "0",
                n.max = "200",
                n.value = "0",
                n.step = "1",
                n.className = "nudgeslider",
                super({
                    element: n,
                    target: e.target
                }),
                n.addEventListener("input", (function() {
                    m = parseInt(n.value)
                }), !0),
                n.addEventListener("input", (async function() {
                    gt && await ge(y, l)
                }), !0),
                n.addEventListener("input", (function() {
                    Zt.innerHTML = `<span>Nudged: ${n.value}</span>`
                }), !0)
            }
        }
        ,
        Ut = new class  extends ss.default{
            constructor(t)
            {
                const e = t || {},
                    n = document.createElement("input");
                n.type = "range",
                n.min = "100",
                n.max = "950",
                n.value = "700",
                n.step = "10",
                n.className = "sidelapslider",
                super({
                    element: n,
                    target: e.target
                }),
                n.addEventListener("input", (function() {
                    _ = parseInt(n.value)
                }), !0),
                n.addEventListener("input", (async function() {
                    gt && (k = D(v, C, _))
                }), !0),
                n.addEventListener("input", (async function() {
                    gt && await ge(y, l)
                }), !0),
                n.addEventListener("input", (function() {
                    Jt.innerHTML = `<span>Sidelap: ${n.value / 10}%</span>`
                }), !0)
            }
        }
        ,
        Vt = new class  extends ss.default{
            constructor(t)
            {
                const e = t || {},
                    n = document.createElement("input");
                n.type = "range",
                n.min = "100",
                n.max = "950",
                n.value = "400",
                n.step = "10",
                n.className = "frontlapslider",
                super({
                    element: n,
                    target: e.target
                }),
                n.addEventListener("input", (function() {
                    x = parseInt(n.value)
                }), !0),
                n.addEventListener("input", (async function() {
                    gt && (I = D(v, M, x))
                }), !0),
                n.addEventListener("input", (async function() {
                    gt && await ge(y, l)
                }), !0),
                n.addEventListener("input", (function() {
                    Qt.innerHTML = `<span>Frontlap: ${n.value / 10}%</span>`
                }), !0),
                n.addEventListener("input", (function() {
                    I = O.convertLength(D(v, M, x), "degrees", "meters")
                }), !0)
            }
        }
        ,
        Xt = new class  extends ss.default{
            constructor(t)
            {
                const e = t || {},
                    r = document.createElement("input");
                r.type = "range",
                r.min = "1",
                r.max = "150",
                r.value = "30",
                r.step = "1",
                r.className = "speedslider",
                super({
                    element: r,
                    target: e.target
                }),
                r.addEventListener("input", (function() {
                    E = parseInt(r.value)
                }), !0),
                r.addEventListener("input", (function() {
                    te.innerHTML = `<span>Speed:${E / 10}m (${(E / 10 * 3.28084).toPrecision(3)}ft)/s</span>`
                }), !0),
                r.addEventListener("input", (function() {
                    ue.innerHTML = `🕓 > ${Math.ceil((h + n) / (E / 10) / 60 * 1.5) + 2}min`
                }), !0)
            }
        }
        ,
        Ht = new class  extends ss.default{
            constructor(t)
            {
                const e = t || {},
                    n = document.createElement("input");
                n.type = "range",
                n.min = "1",
                n.max = "50",
                n.value = "1",
                n.step = "1",
                n.className = "densifyslider",
                super({
                    element: n,
                    target: e.target
                }),
                n.addEventListener("input", (function() {
                    c = parseInt(n.value)
                }), !0),
                n.addEventListener("input", (function() {
                    oe.innerHTML = `<span>Z Check: ${c}</span>`
                }), !0),
                n.addEventListener("input", (function() {
                    gt && ge(y, l)
                }), !0)
            }
        }
        ,
        Yt = new class  extends ss.default{
            constructor(t)
            {
                const e = t || {},
                    n = document.createElement("input");
                n.type = "range",
                n.min = "-90",
                n.max = "0",
                n.value = "-90",
                n.step = "1",
                n.className = "gimbalslider",
                super({
                    element: n,
                    target: e.target
                }),
                n.addEventListener("input", (function() {
                    T = parseInt(n.value)
                }), !0),
                n.addEventListener("input", (function() {
                    se.innerHTML = `<span>Gimbal: ${T}°</span>`
                }), !0),
                n.addEventListener("input", (function() {
                    gt && ge(y, l)
                }), !0)
            }
        }
        ;
    let Wt,
        $t,
        Kt,
        Zt,
        Jt,
        Qt,
        te,
        ee,
        ne,
        re,
        ie,
        oe,
        se,
        ae = document.createElement("div");
    ae.className = "totalDistance",
    ae.innerHTML = 0 != h ? `📐: ${((h + n) / 1e3).toPrecision(3)}km | ${(.00062137141096 * (h + n)).toPrecision(3)}mi` : "📐:",
    Dt.getViewport().appendChild(ae);
    let ue = document.createElement("div");
    ue.className = "minTime",
    ue.innerHTML = 0 != h ? `🕓 > ${Math.ceil((h + n) / (E / 10) / 60 * 1.5) + 2}min` : "🕓:",
    Dt.getViewport().appendChild(ue);
    let le = document.createElement("div");
    le.className = "photoTally",
    le.innerHTML = 0 != h ? `📷: ~${photoCount}, interval: ${I.toFixed(2)}m` : "📷:",
    Dt.getViewport().appendChild(le);
    let he = document.createElement("div");
    he.className = "aoiArea",
    he.innerHTML = 0 != h ? `🔳: ${a.toFixed(2)}ac | ${u.toFixed(2)}ha` : "🔳:",
    Dt.getViewport().appendChild(he);
    const ce = new wy({
        closeBox: !0,
        className: "slide-left menu",
        content: null
    });
    ce.toggle(),
    Dt.addControl(ce);
    const pe = new Sy({
        html: "&#9776",
        className: "menu",
        title: "Menu",
        onToggle: function() {
            ce.toggle(),
            function() {
                let e = document.createElement("button");
                e.innerHTML = "-",
                e.title = "Rotate Counter Clockwise",
                e.addEventListener("click", (function() {
                    0 == y || y--
                }), !0),
                e.addEventListener("click", (async function() {
                    gt && await ge(y, l)
                }), !0),
                e.addEventListener("click", (function() {
                    Bt.element.value = y
                }), !0),
                e.addEventListener("click", (function() {
                    $t.innerHTML = `<span>Direction: ${y}°</span>`
                }), !0);
                let r = document.createElement("button");
                r.innerHTML = "+",
                r.title = "Rotate Clockwise",
                r.addEventListener("click", (function() {
                    y >= 359 ? y = 359 : y++
                }), !0),
                r.addEventListener("click", (async function() {
                    gt && await ge(y, l)
                }), !0),
                r.addEventListener("click", (function() {
                    Bt.element.value = y
                }), !0),
                r.addEventListener("click", (function() {
                    $t.innerHTML = `<span>Direction: ${y}°</span>`
                }), !0);
                let i = document.createElement("button");
                i.innerHTML = "+",
                i.title = "Speed Up",
                i.addEventListener("click", (function() {
                    E >= 150 ? E = 150 : E += 1
                }), !0),
                i.addEventListener("click", (function() {
                    Xt.element.value = E
                }), !0),
                i.addEventListener("click", (function() {
                    te.innerHTML = `<span>Speed:${E / 10}m (${(E / 10 * 3.28084).toPrecision(3)}ft)/s</span>`
                }), !0),
                i.addEventListener("click", (function() {
                    ue.innerHTML = `🕓 > ${Math.ceil((h + n) / (E / 10) / 60 * 1.5) + 2}min`
                }), !0);
                let o = document.createElement("button");
                o.innerHTML = "-",
                o.title = "Slow Down",
                o.addEventListener("click", (function() {
                    1 == E ? E = 1 : E -= 1
                }), !0),
                o.addEventListener("click", (function() {
                    Xt.element.value = E
                }), !0),
                o.addEventListener("click", (function() {
                    te.innerHTML = `<span>Speed:${E / 10}m (${(E / 10 * 3.28084).toPrecision(3)}ft)/s</span>`
                }), !0),
                o.addEventListener("click", (function() {
                    ue.innerHTML = `🕓 > ${Math.ceil((h + n) / (E / 10) / 60 * 1.5) + 2}min`
                }), !0);
                let s = document.createElement("button");
                s.innerHTML = "+",
                s.title = "Increase GSD",
                s.addEventListener("click", (function() {
                    v >= 15e3 ? v = 15e3 : v += 100
                }), !0),
                s.addEventListener("click", (function() {
                    G = j(v, l.sensorWidth, l.focalLength, l.imageWidth)
                }), !0),
                s.addEventListener("click", (async function() {
                    gt && (k = D(v, C, _))
                }), !0),
                s.addEventListener("click", (function() {
                    I = O.convertLength(D(v, M, x), "degrees", "meters")
                }), !0),
                s.addEventListener("click", (async function() {
                    gt && await ge(y, l)
                }), !0),
                s.addEventListener("click", (function() {
                    qt.element.value = v
                }), !0),
                s.addEventListener("click", (function() {
                    Kt.innerHTML = `<span>GSD: ${v / 1e3} : ${G.toPrecision(3)}m : ${(3.28084 * G).toPrecision(3)}ft</span>`
                }), !0),
                s.addEventListener("click", (function() {
                    U.innerHTML = `<span>${I.toPrecision(3)}m</span>`
                }), !0);
                let a = document.createElement("button");
                a.innerHTML = "-",
                a.title = "Decrease GSD",
                a.addEventListener("click", (function() {
                    v <= 100 ? v = 100 : v -= 100
                }), !0),
                a.addEventListener("click", (function() {
                    G = j(v, l.sensorWidth, l.focalLength, l.imageWidth)
                }), !0),
                a.addEventListener("click", (async function() {
                    gt && (k = D(v, C, _))
                }), !0),
                a.addEventListener("click", (function() {
                    I = O.convertLength(D(v, M, x), "degrees", "meters")
                }), !0),
                a.addEventListener("click", (async function() {
                    gt && await ge(y, l)
                }), !0),
                a.addEventListener("click", (function() {
                    qt.element.value = v
                }), !0),
                a.addEventListener("click", (function() {
                    Kt.innerHTML = `<span>GSD: ${v / 1e3} : ${G.toPrecision(3)}m : ${(3.28084 * G).toPrecision(3)}ft</span>`
                }), !0),
                a.addEventListener("click", (function() {
                    U.innerHTML = `<span>${I.toPrecision(3)}m</span>`
                }), !0);
                let u = document.createElement("button");
                u.innerHTML = "+",
                u.title = "Increase Nudge",
                u.addEventListener("click", (function() {
                    m >= 200 ? m = 200 : m++
                }), !0),
                u.addEventListener("click", (async function() {
                    gt && await ge(y, l)
                }), !0),
                u.addEventListener("click", (function() {
                    zt.element.value = m
                }), !0),
                u.addEventListener("click", (function() {
                    Zt.innerHTML = `<span>Nudged: ${m}</span>`
                }), !0);
                let p = document.createElement("button");
                p.innerHTML = "-",
                p.title = "Decrease Nudge",
                p.addEventListener("click", (function() {
                    m <= 0 ? m = 0 : m--
                }), !0),
                p.addEventListener("click", (async function() {
                    gt && await ge(y, l)
                }), !0),
                p.addEventListener("click", (function() {
                    zt.element.value = m
                }), !0),
                p.addEventListener("click", (function() {
                    Zt.innerHTML = `<span>Nudged: ${m}</span>`
                }), !0);
                let d = document.createElement("button");
                d.innerHTML = "+",
                d.title = "Increase Overlap",
                d.addEventListener("click", (function() {
                    _ >= 950 ? _ = 950 : _ += 10
                }), !0),
                d.addEventListener("click", (async function() {
                    gt && (k = D(v, C, _))
                }), !0),
                d.addEventListener("click", (async function() {
                    gt && await ge(y, l)
                }), !0),
                d.addEventListener("click", (function() {
                    Ut.element.value = _
                }), !0),
                d.addEventListener("click", (function() {
                    Jt.innerHTML = `<span>Sidelap: ${_ / 10}%</span>`
                }), !0);
                let g = document.createElement("button");
                g.innerHTML = "-",
                g.title = "Decrease Overlap",
                g.addEventListener("click", (function() {
                    _ <= 100 ? _ = 100 : _ -= 10
                }), !0),
                g.addEventListener("click", (async function() {
                    gt && (k = D(v, C, _))
                }), !0),
                g.addEventListener("click", (async function() {
                    gt && await ge(y, l)
                }), !0),
                g.addEventListener("click", (function() {
                    Ut.element.value = _
                }), !0),
                g.addEventListener("click", (function() {
                    Jt.innerHTML = `<span>Sidelap: ${_ / 10}%</span>`
                }), !0);
                let S = document.createElement("button");
                S.innerHTML = "+",
                S.title = "Increase Frontlap",
                S.addEventListener("click", (function() {
                    x >= 950 ? x = 950 : x += 10
                }), !0),
                S.addEventListener("click", (async function() {
                    gt && await ge(y, l)
                }), !0),
                S.addEventListener("click", (function() {
                    I = O.convertLength(D(v, M, x), "degrees", "meters")
                }), !0),
                S.addEventListener("click", (function() {
                    Vt.element.value = x
                }), !0),
                S.addEventListener("click", (function() {
                    Qt.innerHTML = `<span>Frontlap: ${x / 10}%</span>`
                }), !0),
                S.addEventListener("click", (function() {
                    U.innerHTML = `<span>${I.toPrecision(3)}m</span>`
                }), !0);
                let P = document.createElement("button");
                P.innerHTML = "-",
                P.title = "Decrease Frontlap",
                P.addEventListener("click", (function() {
                    x <= 100 ? x = 100 : x -= 10
                }), !0),
                P.addEventListener("click", (async function() {
                    gt && await ge(y, l)
                }), !0),
                P.addEventListener("click", (function() {
                    I = O.convertLength(D(v, M, x), "degrees", "meters")
                }), !0),
                P.addEventListener("click", (function() {
                    Vt.element.value = x
                }), !0),
                P.addEventListener("click", (function() {
                    Qt.innerHTML = `<span>Frontlap: ${x / 10}%</span>`
                }), !0),
                P.addEventListener("click", (function() {
                    U.innerHTML = `<span>${I.toPrecision(3)}m</span>`
                }), !0);
                let L = document.createElement("button");
                L.innerHTML = "+",
                L.title = "Adjust Less Often",
                L.addEventListener("click", (function() {
                    c >= 50 ? c = 50 : c += 1
                }), !0),
                L.addEventListener("click", (function() {
                    Ht.element.value = c
                }), !0),
                L.addEventListener("click", (function() {
                    oe.innerHTML = `<span>Z Check: ${c}</span>`
                }), !0),
                L.addEventListener("click", (function() {
                    gt && ge(y, l)
                }), !0);
                let N = document.createElement("button");
                N.innerHTML = "-",
                N.title = "Adjust More Often",
                N.addEventListener("click", (function() {
                    c <= 1 ? c = 1 : c -= 1
                }), !0),
                N.addEventListener("click", (function() {
                    Ht.element.value = c
                }), !0),
                N.addEventListener("click", (function() {
                    oe.innerHTML = `<span>Z Check: ${c}</span>`
                }), !0),
                N.addEventListener("click", (function() {
                    gt && ge(y, l)
                }), !0);
                let R = document.createElement("button");
                R.innerHTML = "+",
                R.title = "Increase Gimbal Angle",
                R.addEventListener("click", (function() {
                    T >= 0 ? T = 0 : T += 1
                }), !0),
                R.addEventListener("click", (function() {
                    Yt.element.value = T
                }), !0),
                R.addEventListener("click", (function() {
                    se.innerHTML = `<span>Gimbal: ${T}°</span>`
                }), !0),
                R.addEventListener("click", (function() {
                    gt && ge(y, l)
                }), !0);
                let A = document.createElement("button");
                A.innerHTML = "-",
                A.title = "Decrease Gimbal Angle",
                A.addEventListener("click", (function() {
                    T <= -90 ? T = -90 : T -= 1
                }), !0),
                A.addEventListener("click", (function() {
                    Yt.element.value = T
                }), !0),
                A.addEventListener("click", (function() {
                    se.innerHTML = `<span>Gimbal: ${T}°</span>`
                }), !0),
                A.addEventListener("click", (function() {
                    gt && ge(y, l)
                }), !0);
                let F = document.createElement("div");
                F.innerHTML = `<span>${C}px</span>`,
                F.className = "imageWidthDisplay";
                let B = document.createElement("div");
                B.innerHTML = `<span>${M}px</span>`,
                B.className = "imageHeightDisplay";
                let q = document.createElement("div");
                q.innerHTML = `<span>${w}mm</span>`,
                q.className = "sensorWidthDisplay";
                let z = document.createElement("div");
                z.innerHTML = `<span>${b}mm</span>`,
                z.className = "focalLengthDisplay";
                let U = document.createElement("div");
                U.innerHTML = `<span>${I.toPrecision(3)}m</span>`,
                U.className = "frontlapDisplay",
                ce.setContent(null),
                Wt = document.createElement("menuStuff"),
                Wt.className = "menuStuff";
                let V = document.createElement("select");
                V.title = "Select Camera",
                V.addEventListener("change", (function() {
                    let e = V.options[V.selectedIndex];
                    M = e.imageHeight,
                    C = e.imageWidth,
                    w = e.sensorWidth,
                    f = e.value,
                    b = e.focalLength,
                    G = j(v, w, b, C),
                    l = new t(w, b, C, M),
                    G = j(v, w, b, C),
                    Kt.innerHTML = `<span>GSD: ${v / 1e3} : ${G.toPrecision(3)}m : ${(3.28084 * G).toPrecision(3)}ft</span>`,
                    B.innerHTML = `<span>${M}px</span>`,
                    F.innerHTML = `<span>${C}px</span>`,
                    q.innerHTML = `<span>${w}mm</span>`,
                    z.innerHTML = `<span>${b}mm</span>`,
                    k = D(v, C, _),
                    gt && ge(y, l)
                }), !0),
                $t = document.createElement("p"),
                $t.innerHTML = `<span>Direction: ${y}°</span>`,
                $t.className = "rotateText",
                te = document.createElement("p"),
                te.innerHTML = `<span>Speed:${E / 10}m (${(E / 10 * 3.28084).toPrecision(3)}ft)/s</span>`,
                te.className = "speedText",
                Kt = document.createElement("p"),
                Kt.innerHTML = `<span>GSD: ${v / 1e3} : ${G.toPrecision(3)}m : ${(3.28084 * G).toPrecision(3)}ft</span>`,
                Kt.className = "gsdText",
                Zt = document.createElement("p"),
                Zt.innerHTML = `<span>Nudged: ${m}</span>`,
                Zt.className = "nudgeText",
                Jt = document.createElement("p"),
                Jt.innerHTML = `<span>Sidelap: ${_ / 10}%</span>`,
                Jt.className = "sidelapText",
                Qt = document.createElement("p"),
                Qt.innerHTML = `<span>Frontlap: ${x / 10}%</span>`,
                Qt.className = "frontlapText",
                ee = document.createElement("p"),
                ee.innerHTML = "<span>Photo Width</span>",
                ee.className = "imageWidthText",
                ne = document.createElement("p"),
                ne.innerHTML = "<span>Photo Height</span>",
                ne.className = "imageHeightText",
                re = document.createElement("p"),
                re.innerHTML = "<span>Sensor Width</span>",
                re.className = "sensorWidthText",
                ie = document.createElement("p"),
                ie.innerHTML = "<span>Focal Length</span>",
                ie.className = "focalLengthText",
                oe = document.createElement("p"),
                oe.innerHTML = `<span>Z Check: ${c}</span>`,
                oe.className = "heightUpdateText",
                se = document.createElement("p"),
                se.innerHTML = `Gimbal: ${T}°`,
                se.className = "gimbalText";
                let X = [{
                    name: "DJI Mini 2",
                    sensorWidth: 6.3,
                    focalLength: 4.49,
                    imageWidth: 4e3,
                    imageHeight: 3e3
                }, {
                    name: "DJI Mavic Mini",
                    sensorWidth: 6.3,
                    focalLength: 4.49,
                    imageWidth: 4e3,
                    imageHeight: 3e3
                }, {
                    name: "DJI Mini SE",
                    sensorWidth: 6.3,
                    focalLength: 4.49,
                    imageWidth: 4e3,
                    imageHeight: 3e3
                }, {
                    name: "DJI Air 2S",
                    sensorWidth: 13.2,
                    focalLength: 8.4,
                    imageWidth: 5472,
                    imageHeight: 3648
                }, {
                    name: "DJI Mavic Air",
                    sensorWidth: 13.2,
                    focalLength: 4.7,
                    imageWidth: 4056,
                    imageHeight: 3040
                }, {
                    name: "DJI Mavic Air 2",
                    sensorWidth: 6.3,
                    focalLength: 4.49,
                    imageWidth: 8e3,
                    imageHeight: 6e3
                }, {
                    name: "DJI Mavic 2 Pro",
                    sensorWidth: 13.2,
                    focalLength: 10.3,
                    imageWidth: 5472,
                    imageHeight: 3648
                }, {
                    name: "DJI Mavic 2 Zoom",
                    sensorWidth: 6.3,
                    focalLength: 8.6,
                    imageWidth: 4e3,
                    imageHeight: 3e3
                }, {
                    name: "DJI Phantom 3",
                    sensorWidth: 6.3,
                    focalLength: 3.61,
                    imageWidth: 4e3,
                    imageHeight: 3e3
                }, {
                    name: "DJI Phantom 4",
                    sensorWidth: 6.3,
                    focalLength: 3.61,
                    imageWidth: 4e3,
                    imageHeight: 3e3
                }, {
                    name: "DJI Phantom 4 Pro / 2.0 / Advanced",
                    sensorWidth: 13.2,
                    focalLength: 8.8,
                    imageWidth: 5472,
                    imageHeight: 3648
                }];
                for (let t = 0; t < X.length; t++) {
                    let e = document.createElement("option");
                    e.value = X[t].name,
                    e.text = X[t].name,
                    e.sensorWidth = X[t].sensorWidth,
                    e.focalLength = X[t].focalLength,
                    e.imageWidth = X[t].imageWidth,
                    e.imageHeight = X[t].imageHeight,
                    V.appendChild(e)
                }
                Wt.appendChild(V),
                Wt.appendChild($t),
                Wt.appendChild(Bt.element),
                Wt.appendChild(e),
                Wt.appendChild(r),
                Wt.appendChild(te),
                Wt.appendChild(Xt.element),
                Wt.appendChild(o),
                Wt.appendChild(i),
                Wt.appendChild(Kt),
                Wt.appendChild(qt.element),
                Wt.appendChild(a),
                Wt.appendChild(s),
                Wt.appendChild(Zt),
                Wt.appendChild(zt.element),
                Wt.appendChild(p),
                Wt.appendChild(u),
                Wt.appendChild(Jt),
                Wt.appendChild(Ut.element),
                Wt.appendChild(g),
                Wt.appendChild(d),
                Wt.appendChild(Qt),
                Wt.appendChild(Vt.element),
                Wt.appendChild(P),
                Wt.appendChild(S),
                Wt.appendChild(oe),
                Wt.appendChild(Ht.element),
                Wt.appendChild(N),
                Wt.appendChild(L),
                Wt.appendChild(se),
                Wt.appendChild(Yt.element),
                Wt.appendChild(A),
                Wt.appendChild(R),
                ce.setContent(Wt)
            }()
        }
    });
    Dt.addControl(pe);
    const fe = new Sy({
        html: "🛠️",
        className: "tools",
        title: "Tools",
        onToggle: function() {
            de ? (Dt.removeControl(Tt), Dt.removeControl(Lt), Dt.removeControl(Ot), Dt.removeControl(Nt), Dt.removeControl(Rt), Dt.removeControl(Pt), Dt.removeControl(At), de = !1) : de || (Dt.controls.extend([Tt]), Dt.controls.extend([Lt]), Dt.controls.extend([Ot]), Dt.controls.extend([Nt]), Dt.controls.extend([Rt]), Dt.controls.extend([Pt]), Dt.controls.extend([At]), de = !0)
        }
    });
    Dt.addControl(fe);
    let de = !1;
    async function ge(t, e) {
        h = 0;
        let o,
            s,
            a,
            u = O.bbox(gt),
            l = (O.transformRotate(gt, 0, {
                mutate: !0
            }), mt(u));
        l[3],
        l[1],
        l[2],
        l[0];
        Dt.removeLayer(at),
        at.setSource(null),
        ut.clear(),
        Dt.removeLayer(lt),
        lt.setSource(null),
        ht.clear(),
        i = O.featureCollection([]),
        Dt.removeLayer(ft),
        ft.setSource(null),
        dt.clear();
        let c = O.featureCollection([]);
        Dt.removeLayer(W),
        W.setSource(null),
        Y.clear();
        O.featureCollection([]);
        Dt.removeLayer(H),
        H.setSource(null),
        X.clear();
        O.featureCollection([]);
        let p = mt(O.bbox(gt)),
            f = p[3] - p[1];
        p[2],
        p[0];
        o = N(p, k, .99 * f, {
            units: "degrees"
        }),
        o.features.length > 0 && (s = O.transformTranslate(O.transformRotate(o, t, {
            mutate: !0
        }), m, 45, {
            units: "metres"
        }));
        for (let t = 0; t < s.features.length; t++)
            t % 1 == 0 && s.features.splice(t, 1);
        s.features.length > 0 && (a = O.lineIntersect(s, gt));
        const _ = function(t) {
            if (t.features.length > 0) {
                let e = t.features[0].geometry.coordinates,
                    n = t.features[1].geometry.coordinates,
                    r = e[1] < n[1],
                    i = e[0] < n[0];
                if (r && i)
                    return "northeast";
                if (!r && i)
                    return "southeast";
                if (r && !i)
                    return "northwest";
                if (!r && !i)
                    return "southwest";
                console.log("error in detecting direction")
            } else
                console.log("error in detecting direction (no polygon)")
        }(a);
        O.featureEach(s, (function(t, e) {
            if (0 === e)
                return;
            let n,
                r;
            n = O.lineString([t.geometry.coordinates[0][0], t.geometry.coordinates[0][1]]),
            r = O.lineString([t.geometry.coordinates[0][2], t.geometry.coordinates[0][3]]);
            let o = O.lineIntersect(n, gt),
                s = O.lineIntersect(r, gt);
            if (o.features.length > 0) {
                let t,
                    e = o.features[0].geometry.coordinates,
                    n = o.features[o.features.length - 1].geometry.coordinates;
                "northeast" === _ ? t = e[0] < n[0] && e[1] < n[1] ? O.lineString([e, n]) : O.lineString([n, e]) : "southeast" === _ ? t = e[0] < n[0] && e[1] > n[1] ? O.lineString([e, n]) : O.lineString([n, e]) : "northwest" === _ ? t = e[0] > n[0] && e[1] < n[1] ? O.lineString([e, n]) : O.lineString([n, e]) : "southwest" === _ ? t = e[0] > n[0] && e[1] > n[1] ? O.lineString([e, n]) : O.lineString([n, e]) : console.log("error in direction"),
                i.features.push(t)
            }
            if (s.features.length > 0) {
                let t,
                    e = s.features[0].geometry.coordinates,
                    n = s.features[s.features.length - 1].geometry.coordinates;
                "northeast" === _ && (t = e[0] < n[0] && e[1] < n[1] ? O.lineString([n, e]) : O.lineString([e, n])),
                "southeast" === _ && (t = e[0] < n[0] && e[1] > n[1] ? O.lineString([n, e]) : O.lineString([e, n])),
                "northwest" === _ && (t = e[0] > n[0] && e[1] < n[1] ? O.lineString([n, e]) : O.lineString([e, n])),
                "southwest" === _ && (t = e[0] > n[0] && e[1] > n[1] ? O.lineString([n, e]) : O.lineString([e, n])),
                i.features.push(t)
            }
        })),
        Dt.removeLayer(ct),
        pt.clear();
        let x = O.toMercator(i);
        if (pt.addFeatures((new (0, gg.default)).readFeatures(x)), ct.setSource(pt), Dt.removeLayer(rt), it.clear(), Dt.removeLayer(ot), st.clear(), i.features.length > 0) {
            const t = O.toMercator(O.point(i.features[0].geometry.coordinates[0])),
                e = O.toMercator(O.point(i.features[i.features.length - 1].geometry.coordinates[1]));
            it.addFeatures((new (0, gg.default)).readFeatures(t)),
            rt.setSource(it),
            st.addFeatures((new (0, gg.default)).readFeatures(e)),
            ot.setSource(st),
            Dt.addLayer(rt),
            Dt.addLayer(ot)
        }
        !function(t) {
            let e = [],
                n = [];
            for (let r = 0; r < t.features.length; r++)
                e.push(t.features[r].geometry.coordinates[0][0]),
                n.push(t.features[r].geometry.coordinates[0][1]),
                e.push(t.features[r].geometry.coordinates[t.features[r].geometry.coordinates.length - 1][0]),
                n.push(t.features[r].geometry.coordinates[t.features[r].geometry.coordinates.length - 1][1])
        }(i);
        let w = O.lineString([i.features[0].geometry.coordinates[0], i.features[1].geometry.coordinates[1]]);
        O.length(w, {
            units: "meters"
        });
        function b(t, e) {
            let n,
                r,
                i,
                o,
                s,
                a,
                u = v / 1e3 * C / 100,
                l = v / 1e3 * M / 100,
                h = O.lengthToDegrees(u, "metres"),
                p = O.lengthToDegrees(l, "metres");
            n = t.geometry.coordinates,
            r = [n[0] - h / 2, n[1] - p / 2 * Math.cos(n[1] * Math.PI / 180)],
            i = [n[0] - h / 2, n[1] + p / 2 * Math.cos(n[1] * Math.PI / 180)],
            o = [n[0] + h / 2, n[1] + p / 2 * Math.cos(n[1] * Math.PI / 180)],
            s = [n[0] + h / 2, n[1] - p / 2 * Math.cos(n[1] * Math.PI / 180)],
            a = O.polygon([[r, i, o, s, r]]);
            let f = O.transformScale(a, 1 / Math.cos(n[1] * Math.PI / 180)),
                d = O.transformRotate(f, y);
            c.features.push(O.toMercator(d))
        }
        function S(t) {
            let e = t.getFeaturesCollection().getArray(),
                n = [],
                r = [],
                i = [];
            for (let t = 0; t < e.length; t++) {
                let r = e[t];
                n.push(r.getGeometry().getCoordinates())
            }
            for (let t = 0; t < n.length; t++) {
                let e = n[t][0][0],
                    i = n[t][1][0];
                r.push(e),
                r.push(i)
            }
            for (let t = 0; t < n.length; t++) {
                let e = n[t][0][1],
                    r = n[t][1][1];
                i.push(e),
                i.push(r)
            }
            return {
                featuresXArray: r,
                featuresYArray: i
            }
        }
        ht.addFeatures((new (0, gg.default)).readFeatures(O.toMercator(a))),
        ut.addFeatures((new (0, gg.default)).readFeatures(O.toMercator(s))),
        at.setSource(ut),
        lt.setSource(ht),
        S(pt),
        await async function() {
            if (d) {
                Dt.removeLayer(H),
                X.clear(),
                n = 0;
                let t = O.point(g.geometry.coordinates),
                    e = O.point(i.features[0].geometry.coordinates[0]),
                    o = O.point(i.features[i.features.length - 1].geometry.coordinates[1]),
                    s = O.lineString([t.geometry.coordinates, e.geometry.coordinates]);
                r = (parseInt(O.bearing(t, e)) + 360) % 360;
                let a = O.lineString([t.geometry.coordinates, o.geometry.coordinates]),
                    u = O.toMercator(O.featureCollection([s, a]));
                X.addFeatures((new (0, gg.default)).readFeatures(u)),
                H.setSource(X),
                Dt.addLayer(H),
                n = O.length(s, {
                    units: "metres"
                }) + O.length(a, {
                    units: "metres"
                }),
                ae.innerHTML = `📐: ${((h + n) / 1e3).toPrecision(3)}km | ${(.00062137141096 * (h + n)).toPrecision(3)}mi`
            }
        }(),
        function() {
            Dt.removeLayer(ft),
            dt.clear(),
            Dt.removeLayer(W),
            Y.clear(),
            Dt.removeLayer(V),
            U.clear(),
            Dt.removeLayer(z),
            q.clear(),
            h = 0;
            let t,
                e = S(pt),
                r = [],
                o = [];
            for (let n = 0; n < e.featuresXArray.length; n++) {
                let i = [e.featuresXArray[n], e.featuresYArray[n]],
                    s = [e.featuresXArray[n + 1], e.featuresYArray[n + 1]];
                if (null == s)
                    break;
                o = O.lineString([i, s]),
                r.push(o),
                t = O.length(O.toWgs84(o), {
                    units: "metres"
                }),
                t > 0 && (h += t)
            }
            let s = O.featureCollection(r);
            Y.addFeatures((new (0, gg.default)).readFeatures(s)),
            W.setSource(Y),
            Dt.addLayer(W);
            let a = F(i)[0];
            U.addFeatures((new (0, gg.default)).readFeatures(O.toMercator(a))),
            V.setSource(U);
            let u = F(i)[1];
            q.addFeatures((new (0, gg.default)).readFeatures(O.toMercator(u))),
            z.setSource(q),
            O.featureEach(a, b);
            let l = (new (0, gg.default)).readFeatures(c);
            l.forEach((t => {
                l.indexOf(t) % 2 == 0 ? t.setStyle(new yu({
                    fill: new uu({
                        color: "rgba(0, 255, 0, 0.1)"
                    }),
                    stroke: new lu({
                        color: "rgba(0, 0, 0, 0.8)",
                        width: 1
                    }),
                    zIndex: 110
                })) : t.setStyle(new yu({
                    fill: new uu({
                        color: "rgba(255, 0, 0, 0.1)"
                    }),
                    stroke: new lu({
                        color: "rgba(0, 0, 0, 0.8)",
                        width: 1
                    }),
                    zIndex: 110
                }))
            })),
            dt.addFeatures(l),
            ft.setSource(dt),
            1 == P && (Dt.removeLayer(ft), Dt.addLayer(ft)),
            Dt.addLayer(V),
            Dt.addLayer(z),
            ue.innerHTML = `🕓 > ${Math.ceil((h + n) / (E / 10) / 60 * 1.5) + 2}min`,
            ae.innerHTML = `📐: ${((h + n) / 1e3).toPrecision(3)}km | ${(.00062137141096 * (h + n)).toPrecision(3)}mi`
        }()
    }
    Dt.addInteraction(St),
    Dt.addInteraction(It)
};
//# sourceMappingURL=index.efe9f8c2.js.map
